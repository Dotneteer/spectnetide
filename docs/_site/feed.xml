<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/spectnetide/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/spectnetide/" rel="alternate" type="text/html" /><updated>2019-02-28T08:13:14+01:00</updated><id>http://localhost:4000/spectnetide/feed.xml</id><title type="html">SpectNet IDE</title><subtitle>Visual Studio 2017/2019 integrated ZX Spectrum IDE for the Community</subtitle><entry><title type="html">Watch Commands</title><link href="http://localhost:4000/spectnetide/documents/watch-commands" rel="alternate" type="text/html" title="Watch Commands" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-commands">&lt;p&gt;With these commands, you can manage the list of items in the &lt;strong&gt;Watch Memory&lt;/strong&gt; tool window:&lt;/p&gt;

&lt;h2 id=&quot;add-a-new-watch-item-command&quot;&gt;Add a New Watch Item Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;&lt;/em&gt; [&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Appends a new watch expression to the watch list.&lt;/p&gt;

&lt;h2 id=&quot;remove-a-watch-item-command&quot;&gt;Remove a Watch Item command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Removes the watch item with the specified index from the list. Automatically renumbers the indexes of
remaining items.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can access this command from the context menu of a watch item (&lt;strong&gt;Remove&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;modify-a-watch-item-command&quot;&gt;Modify a Watch Item command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;&lt;/em&gt; [&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Modifies the watch item with the specified index to the provided &lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt; and optional &lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can access this command from the context menu of a watch item (&lt;strong&gt;Modify&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;exchange-watch-items-command&quot;&gt;Exchange Watch Items command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XW&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index2&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Exchanges the watch items specified by the two indexes in the list.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can move up or down watch items with the commands available from the context menu of an item
(&lt;strong&gt;Move up&lt;/strong&gt;, &lt;strong&gt;Move down&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;erase-the-watch-item-list-command&quot;&gt;Erase the Watch Item List command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EW&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Erases the entire watch item list.&lt;/p&gt;

&lt;h2 id=&quot;set-watch-item-label-width-command&quot;&gt;Set Watch Item Label Width command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sets the width of the label that displays the watch expression to the value specified by &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;. Here index is
used as a width in pixels.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Instead of using the command line, you can use a sizing grip between the watch item’s expression and its displayed
value to change the width with the mouse.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">With these commands, you can manage the list of items in the Watch Memory tool window:</summary></entry><entry><title type="html">Watch Samples</title><link href="http://localhost:4000/spectnetide/documents/watch-samples" rel="alternate" type="text/html" title="Watch Samples" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-samples</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-samples">&lt;p&gt;These samples help you to understand how powerful the watch expressions are:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[XPOS:W]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Displays the two bytes stored in the memory at the address pointed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;XPOS&lt;/code&gt; symbol.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[`Z ? XPOS : YPOS :W]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the Z flag is set, reads the two bytes stored at the &lt;code class=&quot;highlighter-rouge&quot;&gt;XPOS&lt;/code&gt; address; otherwise retrieves
the two bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;YPOS&lt;/code&gt; address.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DE*HL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Displays the value of DE and HL registers multiplied. The result is a double word (32 bits).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[#4000:DW] &amp;amp; [MASK:DW] :%32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Reads the four bytes stored at the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address. Uses the four bytes store at the 
address pointed by &lt;code class=&quot;highlighter-rouge&quot;&gt;MASK&lt;/code&gt; and executes a bitwise AND operation on these two 32-bit values.
Displays the result as a 32-bit binary vector.&lt;/p&gt;</content><author><name></name></author><summary type="html">These samples help you to understand how powerful the watch expressions are:</summary></entry><entry><title type="html">Watch Expressions</title><link href="http://localhost:4000/spectnetide/documents/watch-expressions" rel="alternate" type="text/html" title="Watch Expressions" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-expressions</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-expressions">&lt;p&gt;Although its name suggests that the Watch Memory window can display only values in the memory, the capabilities of this
tool are richer.&lt;/p&gt;

&lt;p&gt;You can define &lt;em&gt;watch expressions&lt;/em&gt; and define their &lt;em&gt;display format&lt;/em&gt;. For example, if you want to display for consecutive
bytes in the memory pointed by the HL register in bitvector format (32 bits), you can do this with this command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [HL :DW] :%32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Later, you need to display the 16-bit value in the memory address pointed by HL plus BC. You can use this command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [HL + BC :W] :W
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Watch expressions are arithmetic expression using C-like expression syntax. The engine behind the Watch Memory window
continuously evalutes these expressions, formats them and displays their values.&lt;/p&gt;

&lt;h2 id=&quot;expression-types&quot;&gt;Expression Types&lt;/h2&gt;

&lt;p&gt;When working with expressions, the engine uses for integral types, and automatically converts them:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Boolean&lt;/strong&gt;: Simple &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;. Any non-zero value is converted to &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;, zero is &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Byte&lt;/strong&gt;: 8-bit unsigned value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Word&lt;/strong&gt;: 16-bit unsigned value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Double word&lt;/strong&gt;: 32-bit unsigned value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When working with values, the expression engine automatically converts operation result to keep all valuable bits.
For example, when you multiply two bytes, the result will be a word. Multiplying a byte and a word results a double word.
Nonetheless, when you multiply two double words, the result will be a double word, so only the last 32 bits are kept.&lt;/p&gt;

&lt;p&gt;Comparisons and other logical operations result in booleans.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You do not need to deal with types, the evaluation engine does it for you. Sometimes you need signed types. With the
help of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:-B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;:-W&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;:-DW&lt;/code&gt; format specifiers, as you will learn later, you can display values in signed form.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;value-sources&quot;&gt;Value Sources&lt;/h2&gt;

&lt;p&gt;You have several value sources that you can use in expressions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Literal values (decimal, hexadecimal, binary, character)&lt;/li&gt;
  &lt;li&gt;Compilation symbols&lt;/li&gt;
  &lt;li&gt;Z80 register values&lt;/li&gt;
  &lt;li&gt;Z80 CPU flag values&lt;/li&gt;
  &lt;li&gt;ZX Spectrum memory contents&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the future you may use ULA-specific values, or memory values of non-paged memory banks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;literals&quot;&gt;Literals&lt;/h2&gt;

&lt;p&gt;The expression syntax provides these types of literals:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Decimal numbers.&lt;/strong&gt; You can use up to 5 digits (0..9) to declare a decimal number. Examples:
16, 32768, 2354.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hexadecimal numbers.&lt;/strong&gt; You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare
a hexadecimal literal. The engine recognizes one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0x&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; prefix, or one of 
the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; suffixes. If you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;
suffixes, the hexadecimal number should start with a decimal digit &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;…&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12AC
0x12ac
$12Ac
12ACh
12acH
0AC34H
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Binary numbers.&lt;/strong&gt; Literal starting with the one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0b&lt;/code&gt; prefix are taken into 
account as binary literals. You can follow the prefix with up to 16 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; digits. To make
them more readable, you can separate adjacent digits with the underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;) character. These 
are all valid binary literals:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%01011111
0b01011111
0b_0101_1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use negative number with the minus sign in front of them. Actually, the sign is not
the part of the numeric literal, it is an operator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Characters&lt;/strong&gt;. You can put a character between single quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;'Q'&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can use escape sequences to define non-visible or control characters:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Escape&lt;/th&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Character&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;INK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x11&lt;/td&gt;
      &lt;td&gt;PAPER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x12&lt;/td&gt;
      &lt;td&gt;FLASH&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x13&lt;/td&gt;
      &lt;td&gt;BRIGHT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x14&lt;/td&gt;
      &lt;td&gt;INVERSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x15&lt;/td&gt;
      &lt;td&gt;OVER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x16&lt;/td&gt;
      &lt;td&gt;AT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x17&lt;/td&gt;
      &lt;td&gt;TAB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x60&lt;/td&gt;
      &lt;td&gt;pound sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x7F&lt;/td&gt;
      &lt;td&gt;copyright sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x5C&lt;/td&gt;
      &lt;td&gt;backslash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\'&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x27&lt;/td&gt;
      &lt;td&gt;single quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x22&lt;/td&gt;
      &lt;td&gt;double quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;binary zero&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To declare a character by its binary code, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;\xH&lt;/code&gt; or&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;\xHH&lt;/code&gt; sequences (&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; is a hexadecimal digit). For example, these
escape sequence pairs are equivalent:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'\i'
'\x10'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;symbols&quot;&gt;Symbols&lt;/h3&gt;

&lt;p&gt;You can use symbols to refer to labels and other constants used in Z80 programs. Identifiers must start with 
a letter (a..z or A..Z) or the underscore character (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;). The subsequent characters 
letters, digits, or underscores. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyCycle
ERR_NO
Cycle_4_Wait  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;There are strings that can be both identifiers or hexadecimal literals with the &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; suffix, like
&lt;code class=&quot;highlighter-rouge&quot;&gt;AC0Fh&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;FADH&lt;/code&gt;. The engine considers such strings as symbols. To use hexadecimal literal, use a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;
prefix: &lt;code class=&quot;highlighter-rouge&quot;&gt;0FADH&lt;/code&gt; is a hexadecimal literal, while &lt;code class=&quot;highlighter-rouge&quot;&gt;FADH&lt;/code&gt; is an identifier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The engine usus the symbols within the Z80 program you compile, inject, run or debug.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The SpecteNetIde Z80 Assembler handles symbols with string values. These symbols retrieve
0 (word) value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;z80-registers&quot;&gt;Z80 Registers&lt;/h3&gt;

&lt;p&gt;The expression engine recognizes the standard 8-bit and 16-bit register names, as specified in the official 
Zilog Z80 documentation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8-bit registers: &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;16-bit registers: &lt;code class=&quot;highlighter-rouge&quot;&gt;AF&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;For the 8-bit halves of the &lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt; index registers, the engine uses these names:
&lt;code class=&quot;highlighter-rouge&quot;&gt;XL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;XH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;YL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;YH&lt;/code&gt;. Alternatively, the compiler accepts these names, too: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;IXL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IXH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYH&lt;/code&gt;. As a kind of exception to general naming conventions, 
these mixed-case names are also accepted: &lt;code class=&quot;highlighter-rouge&quot;&gt;IXl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IXh&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYh&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The engine recognizes the &lt;code class=&quot;highlighter-rouge&quot;&gt;WZ&lt;/code&gt; (internal Z80 register, not accessible programmatically) register, too.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;z80-flags&quot;&gt;Z80 Flags&lt;/h3&gt;

&lt;p&gt;The expression engine can access the Z80 CPU flags individually, and it also has tokens for the inverted flag values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Token&lt;/th&gt;
      &lt;th&gt;Flag&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;P&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;S&lt;/strong&gt; flag (Bit 7) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;M&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;S&lt;/strong&gt; flag (Bit 7) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;Z&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;Z&lt;/strong&gt; flag (Bit 6) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NZ&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;Z&lt;/strong&gt; flag (Bit 6) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R5&lt;/strong&gt; flag (Bit 5) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N5&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R5&lt;/strong&gt; flag (Bit 5) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;H&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;H&lt;/strong&gt; flag (Bit 4) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NH&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;H&lt;/strong&gt; flag (Bit 4) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R3&lt;/strong&gt; flag (Bit 3) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R3&lt;/strong&gt; flag (Bit 3) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;PE&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;PV&lt;/strong&gt; flag (Bit 2) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;PO&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;PV&lt;/strong&gt; flag (Bit 2) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;N&lt;/strong&gt; flag (Bit 1) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NN&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;N&lt;/strong&gt; flag (Bit 1) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;C&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;C&lt;/strong&gt; flag (Bit 0) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NC&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;C&lt;/strong&gt; flag (Bit 0) is reset&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;zx-spectrum-memory-contents&quot;&gt;ZX Spectrum Memory Contents&lt;/h3&gt;

&lt;p&gt;You can query the entire 64K memory available by the Z80 CPU. With a memory indirection expression, 
you can query byte, word, and double word values, respectively:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt; [&lt;code class=&quot;highlighter-rouge&quot;&gt;access specifier&lt;/code&gt;] &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You wrap an &lt;em&gt;expression&lt;/em&gt; and an optional &lt;em&gt;access specifier&lt;/em&gt; between square brackets. 
The expression specifies the memory address, the &lt;em&gt;access specifier&lt;/em&gt; sets the number of bytes to
query from the memory:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt; — A single byte stored in the specified memory address.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt; — Two consequtive bytes stored in the specified address and the next one.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt; — Four consequtive bytes stored in the specified memory address and the next three.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you omit the access specifier, the default is &lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When you query multiple bytes from the memory, the first byte is the LSB (least significant byte), 
the last is the MSB (most significant byte). Lets assume, you store these four bytes at the address #4000:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12, #4A, #C3, #78
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000]&lt;/code&gt; (and &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B]&lt;/code&gt;) expressions retrieve &lt;code class=&quot;highlighter-rouge&quot;&gt;#12&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W]&lt;/code&gt; expression results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#4A12&lt;/code&gt; (16 bits).&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW]&lt;/code&gt; expression results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#78C34A12&lt;/code&gt; (32 bits).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;operators&quot;&gt;Operators&lt;/h2&gt;

&lt;p&gt;You can use about a dozen operators, including unary, binary and ternary ones. In this section
you will learn about them. I will introduce them in descending order of their precendence.&lt;/p&gt;

&lt;h3 id=&quot;conditional-operator&quot;&gt;Conditional Operator&lt;/h3&gt;

&lt;p&gt;The engine supports using only one ternary operator, the conditional operator:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;conditional-expression&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;true-value&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;false-value&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This operation results in -1:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 &amp;gt; 3 ? 2 : -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When &lt;em&gt;conditional-expression&lt;/em&gt; evaluates to true, the operation results 
in &lt;em&gt;true-value&lt;/em&gt;; otherwise in &lt;em&gt;false-value&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Conditional expressions are evaluated from right to left, in contrast to binary operators,
which use left-to-right evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;binary-bitwise-operators&quot;&gt;Binary Bitwise Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Bitwise OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Bitwise XOR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Bitwise AND&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;relational-operators&quot;&gt;Relational Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Non-equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than or equal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;shift-operators&quot;&gt;Shift Operators&lt;/h3&gt;

&lt;p&gt;The bits of the left operand are shifted by the number of bits given by the right operand.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift left&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift right&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;basic-arithmetic-operators&quot;&gt;Basic Arithmetic Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Addition&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Subtraction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Multiplication&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Division&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Modulo calculation&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;unary-operators&quot;&gt;Unary operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary plus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary minus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary bitwise NOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary logical NOT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Do not forget, you can change the default precendence with &lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;, for example:
&lt;code class=&quot;highlighter-rouge&quot;&gt;(4 + 2) * 3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;format-specifiers&quot;&gt;Format Specifiers&lt;/h2&gt;

&lt;p&gt;With format specifiers, you can declare how would you like to display the results of watch expressions.
These are optional, if you do not use them, the engine will select the format according to the type of 
the expressions’s value:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:F&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Byte values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Word values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Double word values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This table lists the format specifiers supported by the watch engine:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Specifier&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:F&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Flag format. When the value is zero, the output is &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;; otherwise, &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Byte format. The engine displays both the hexadecimal value in two hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#7C (124)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-B&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed byte format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:C&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Character format. The value is converted to a byte, and the ASCII character value of the byte is displayed. When the character code is between 32 and 126, the character is displayed, otherwise a hexadecimal character escape is used. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#41&lt;/code&gt; results in &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'A'&lt;/code&gt;&lt;/strong&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;#8D&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;'\0x8D'&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Word format. The engine displays both the hexadecimal value in four hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#317C (12668)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-W&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed word format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Double word format. The engine displays both the hexadecimal value in eight hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#43CA317C (‭1137324412‬)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-DW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed double word format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFFFFFE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;4 hexadecimal digits. The result is converted to a word and displayed in hexadecimal format, bytes in LSB/MSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4F3C&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#3C #4F&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;8 hexadecimal digits. The result is converted to a double word and displayed in hexadecimal format, bytes in LSB/MSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#67D24F3C&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#3C #4F #D2 #67&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%8&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;8 binary digits. The result is converted to a byte and displayed in binary format. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%16&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;16 binary digits. The result is converted to a word and displayed in binary format, bytes in MSB/LSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#324F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;00110010 01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%32&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;32 binary digits. The result is converted to a double word and displayed in binary format, bytes in MSB/LSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#AA55324F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;10101010 01010101 00110010 01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the future, the list of format specifiers may extend.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Please note, while &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt; use LSB/MSB byte order, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%8&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%16&lt;/code&gt;&lt;/strong&gt;,
and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%32&lt;/code&gt;&lt;/strong&gt; apply MSB/LSB order. You may use the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt; formats to display memory
contents in the order of bytes as they are stored in the memory. Lets assume, you store these
four bytes at the address #4000:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12, #4A, #C3, #78
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is how watch expressions display the content:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 (18)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 (18)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B] :H4&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #00&lt;/code&gt; (Do not forget, the expression reads only a single byte from the memory!)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#4A12 (18962)&lt;/code&gt; (This expression reads two bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W] :H4&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #4A&lt;/code&gt; (This expression reads two bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#78C34A12 (‭2026064402‬)&lt;/code&gt; (This expression reads four bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW] :H8&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #4A #C3 #78&lt;/code&gt; (This expression reads four bytes from the memory)&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Although its name suggests that the Watch Memory window can display only values in the memory, the capabilities of this tool are richer.</summary></entry><entry><title type="html">Overview</title><link href="http://localhost:4000/spectnetide/documents/tool-overview" rel="alternate" type="text/html" title="Overview" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/tool-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/tool-overview">&lt;p&gt;&lt;strong&gt;SpectNetIDE&lt;/strong&gt; has several tool windows that provide a prompt to enter commands. Such windows are &lt;strong&gt;ZX Spectrum Memory&lt;/strong&gt;, &lt;strong&gt;Z80 Disassembly&lt;/strong&gt;, and &lt;strong&gt;Watch Memory&lt;/strong&gt;.
Though each of them has different command sets that slightly overlap, they share a common syntax.
Here, you can find an overview of that syntax.&lt;/p&gt;

&lt;h2 id=&quot;syntax-basics&quot;&gt;Syntax Basics&lt;/h2&gt;

&lt;p&gt;Each &lt;em&gt;command&lt;/em&gt; has a name, and zero, one or more &lt;em&gt;arguments&lt;/em&gt;. Command names are one or two characters, you can use both lowercase and uppercase letters. Commands may use literals, which can be hexadecimal numbers, decimal numbers or identifiers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hexadecimal numbers&lt;/em&gt; must use the 0 to 9 digits, or letters from &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;. If a hexadecimal number would start with a letter, you should add a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; prefix so that the parser consider it as a number and not as an identifier.&lt;/p&gt;

&lt;p&gt;Decimal numbers should start with a colon (&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;) and followed by digits.&lt;/p&gt;

&lt;p&gt;Identifiers should start with one a letter or an underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;) and may continue with digits, letters, or underscore characters.&lt;/p&gt;

&lt;p&gt;Here are a few examples of literals:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1234      (hexadecimal number!)
0FA12     (hexadecimal number)
FA12      (identifier: it starts with a letter!)
:123      (decimal number)
MySymbol  (identifier)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the sections providing detailed command reference, you will meet these elements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;number&lt;/em&gt;: hexadecimal or decimal number.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;identifier&lt;/em&gt;: an identifier, as specified earlier.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;literal&lt;/em&gt;: a hexadecimal number, a decimal number, or an identifier.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;text&lt;/em&gt;: a text that contains arbitrary characters, including spaces, punctuations, and so on.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;[optional]&lt;/em&gt;: the argument is optional.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;identifier-resolution&quot;&gt;Identifier Resolution&lt;/h2&gt;

&lt;p&gt;When executing a command, identifiers are translated into addresses. During the resolution process, the command parsing engine resolves identifiers in these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Checks the output of the last compilation. If the identifier is found, its value is taken from the Assembler’s symbol table.&lt;/li&gt;
  &lt;li&gt;Checks the labels and symbols in the user annotations (by default stored in the Annotations.disann file). If the identifier is found, its value is taken from the symbol table of the annotation.&lt;/li&gt;
  &lt;li&gt;Checks the labels and symbols in the current ROM’s annotations. If the identifier is found, its value is taken from the symbol table of the ROM annotation.&lt;/li&gt;
  &lt;li&gt;The identifier cannot be resolved, the command parsing engine signs an error.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">SpectNetIDE has several tool windows that provide a prompt to enter commands. Such windows are ZX Spectrum Memory, Z80 Disassembly, and Watch Memory. Though each of them has different command sets that slightly overlap, they share a common syntax. Here, you can find an overview of that syntax.</summary></entry><entry><title type="html">Disassembly: Miscellaneous</title><link href="http://localhost:4000/spectnetide/documents/miscellaneous-commands" rel="alternate" type="text/html" title="Disassembly: Miscellaneous" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/miscellaneous-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/miscellaneous-commands">&lt;h2 id=&quot;disassembly-type-command&quot;&gt;Disassembly Type Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;48&lt;/code&gt;|&lt;code class=&quot;highlighter-rouge&quot;&gt;128&lt;/code&gt;|&lt;code class=&quot;highlighter-rouge&quot;&gt;P3&lt;/code&gt;|&lt;code class=&quot;highlighter-rouge&quot;&gt;NEXT&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;You can choose the disassembly type for the current view. ZX Spectrum models have their disassembly peculiarities. For example, 
the Spectrum 48K model uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #28&lt;/code&gt; instructions to implement a floating point calculator with bytecode that follows the 
call. Spectrum 128K uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #28&lt;/code&gt; instruction to call into ROM 0 with the 2-byte address that follows the RST call.&lt;/p&gt;

&lt;p&gt;With this command you can select which model type to use for the disassembly displayed in the tool window.&lt;/p&gt;

&lt;h2 id=&quot;re-disassembly-command&quot;&gt;Re-Disassembly Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RD&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can force a re-disassembly of the current view. If the contents of the RAM changes, you might need this command to 
refresh the view so that you can see the latests changes.&lt;/p&gt;

&lt;h2 id=&quot;jump-command&quot;&gt;Jump Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This command works only when the Spectrum VM is paused. It sets the Program Counter (PC) to the
specified address. When the Spectum VM continues running — after the Start command —
it will carry on from the specified address.&lt;/p&gt;</content><author><name></name></author><summary type="html">Disassembly Type Command</summary></entry><entry><title type="html">Disassembly: Memory Sections</title><link href="http://localhost:4000/spectnetide/documents/memory-section-commands" rel="alternate" type="text/html" title="Disassembly: Memory Sections" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/memory-section-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/memory-section-commands">&lt;p&gt;These commands instructs the disassembly tool how to map a certain memory section into disassembly
output. The &lt;em&gt;literal1&lt;/em&gt; and &lt;em&gt;literal2&lt;/em&gt; values specify the memory range. Be aware, &lt;em&gt;literal1&lt;/em&gt; is inclusive, 
but &lt;em&gt;literal2&lt;/em&gt; is exclusive.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MD&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a disassembly section — this section of memory is represented as a flow id Z80 instructions.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MB&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a byte section. The contents of this memory area is displayed as bytes with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defb&lt;/code&gt;&lt;/strong&gt; pragma.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MW&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a word section. The contents of this memory area is displayed as bytes with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defw&lt;/code&gt;&lt;/strong&gt; pragma.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MS&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Skip section — the view displays a simple &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.skip&lt;/code&gt;&lt;/strong&gt; pragma for the section.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MC&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Calculator section. The disassembler takes these bytes into account as the byte code of the ZX Spectrum’s RST #28 calculator.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MG&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt; section. The contents of this memory area is displayed as single bytes with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt;&lt;/strong&gt; pragma.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MG1&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;The same as &lt;code class=&quot;highlighter-rouge&quot;&gt;MG&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MG2&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt; section. The contents of this memory area is displayed with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt;&lt;/strong&gt; pragma as a group of two bytes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MG3&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt; section. The contents of this memory area is displayed with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt;&lt;/strong&gt; pragma as a group of three bytes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MG4&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal2&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt; section. The contents of this memory area is displayed with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.defg&lt;/code&gt;&lt;/strong&gt; pragma as a group of four bytes.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The IDE saves the memory map you set up with these commands into the annotations file of your project. The ZX Spectrum ROMs within SpectNetIDE ship with their memory map set, but you can change them, too.&lt;/p&gt;

&lt;p&gt;If your change regards to ROM addresses, the &lt;code class=&quot;highlighter-rouge&quot;&gt;.disann&lt;/code&gt; file of the specific ROM file is changed; otherwise, memory map modifications go to your default annotation file (&lt;code class=&quot;highlighter-rouge&quot;&gt;Annotations.disann&lt;/code&gt; in a new project).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt;: When you define memory maps, avoid those that overlap the ROM/RAM boundary.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">These commands instructs the disassembly tool how to map a certain memory section into disassembly output. The literal1 and literal2 values specify the memory range. Be aware, literal1 is inclusive, but literal2 is exclusive.</summary></entry><entry><title type="html">Navigation and View Commands</title><link href="http://localhost:4000/spectnetide/documents/memory-commands" rel="alternate" type="text/html" title="Navigation and View Commands" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/memory-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/memory-commands">&lt;p&gt;This section describes the navigation and view commands you can use in the &lt;strong&gt;ZX Spectrum Memory&lt;/strong&gt;, and &lt;strong&gt;Z80 Disassembly&lt;/strong&gt; tool windows.&lt;/p&gt;

&lt;h2 id=&quot;navigation-command&quot;&gt;Navigation Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;G&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sets the top position of the ZX Spectrum tool window to the specified address. &lt;em&gt;Note:&lt;/em&gt; The tool window displays 
the memory contents in 8-byte sections, so the given address is aligned to the closest segment.&lt;/p&gt;

&lt;h2 id=&quot;banking-commands&quot;&gt;Banking Commands&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This commands are available with the Spectrum 128K, Spectrum +3E, and Spectrum Next models only.&lt;/p&gt;

&lt;h3 id=&quot;select-rom-page&quot;&gt;Select ROM Page&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Displays the ROM with the specified index. When showing the memory contents, the addresses between &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt; 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;#3fff&lt;/code&gt; display the contents of this ROM. With a Spectrum 128K, you can use indexes &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, as this model has two ROMs.
With a Spectrum +3E model, you can use indexes from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;, supporting the four ROMs of such a model.&lt;/p&gt;

&lt;p&gt;In this mode, the tool window displays only the contents of the selected ROM, and no other parts of the memory.&lt;/p&gt;

&lt;h3 id=&quot;select-memory-bank&quot;&gt;Select Memory Bank&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Displays the RAM bank with the specified index. When displaying the memory contents, the addresses between &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt; 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;#3fff&lt;/code&gt; display the contents of this RAM bank. Indexes can be between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this mode, the tool window displays only the contents of the selected RAM bank, and no other parts of the memory.&lt;/p&gt;

&lt;h3 id=&quot;select-full-memory-mode&quot;&gt;Select Full Memory Mode&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Displays the entire addressable (64K) memory, exactly as the Z80 CPU sees it. Displays the currently selected RAM
in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt; address range, Bank 5 in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;#7FFF&lt;/code&gt; range, Bank 2 between &lt;code class=&quot;highlighter-rouge&quot;&gt;#8000&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;#BFFF&lt;/code&gt;.
Uses the currently paged bank for the &lt;code class=&quot;highlighter-rouge&quot;&gt;#C000&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Right now, these views cannot handle the special banking modes available in the Spectrum +3E model (through the &lt;code class=&quot;highlighter-rouge&quot;&gt;#1ffd&lt;/code&gt; port).
This feature will be implemented later.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">This section describes the navigation and view commands you can use in the ZX Spectrum Memory, and Z80 Disassembly tool windows.</summary></entry><entry><title type="html">Disassembly: Breakpoints</title><link href="http://localhost:4000/spectnetide/documents/breakpoint-commands" rel="alternate" type="text/html" title="Disassembly: Breakpoints" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/breakpoint-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/breakpoint-commands">&lt;p&gt;With these commands, you can set up breakpoint according to their addresses. These breakpoints are not persisted,
they are removed when you close the solution.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SB&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt; [ &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hit-condition&lt;/code&gt;&lt;/em&gt;] [ &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter-condition&lt;/code&gt;&lt;/em&gt;]&lt;/td&gt;
      &lt;td&gt;Sets a breakpoint at the specified address with the optional &lt;em&gt;hit condition&lt;/em&gt; and/or &lt;em&gt;filter condition&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TB&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Toggles a breakpoint at the specified address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RB&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Removes the breakpoint from the specified address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UB&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Retrieves the breakpoint at the specified address so that you can update it.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EB&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Erases all breakpoints.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;hit-condition&quot;&gt;Hit Condition&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SB&lt;/code&gt;&lt;/strong&gt; command allows you to specify a hit condition to define when the program should stop at the specified breakpoint.
The debugger counts how many times the program code reaches the breakpoint and stops when the hit condition meets:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;condition-type&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;condition-value&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;condition-value&lt;/em&gt; is an integer number. You can apply one of these &lt;em&gt;condition-type&lt;/em&gt; tokens:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is less than &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is less than or equal to &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is equal to &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is greater than &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is greater than or equal to &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops when the current hit counter is a multiple of &lt;em&gt;condition-value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The following example defines a hit condition that stops at the &lt;code class=&quot;highlighter-rouge&quot;&gt;$8010&lt;/code&gt; address when the 
hit counter s greater than 10:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 8010 H&amp;gt;10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These command sets a breakpoint at &lt;code class=&quot;highlighter-rouge&quot;&gt;$6100&lt;/code&gt; to stop at every fifth hit:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6000 H*5*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;filter-condition&quot;&gt;Filter Condition&lt;/h3&gt;

&lt;p&gt;You can apply not only hit conditions, but also &lt;em&gt;filter conditions&lt;/em&gt; to a breakpoint. When
the execution reaches the breakpoint, the debugger evaluates the expression. If it is a &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;
value (non-zero integer), the execution flow pauses; otherwise it goes on without stoping.&lt;/p&gt;

&lt;p&gt;You can use the same syntax for defining a filter condition as for watch items in the 
&lt;strong&gt;Watch Memory tool window&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When the watch expression results an evaluation error, the debug engine pauses as if there
were no filter condition.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s see a few examples. The following command defines a breakpoint at &lt;code class=&quot;highlighter-rouge&quot;&gt;$6800&lt;/code&gt; that stops when
the contents of the &lt;strong&gt;HL&lt;/strong&gt; register is &lt;code class=&quot;highlighter-rouge&quot;&gt;$4020&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6800 C HL==#4020
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This condition breakpoint tests if the value of the memory address &lt;code class=&quot;highlighter-rouge&quot;&gt;$4100&lt;/code&gt; equals to &lt;code class=&quot;highlighter-rouge&quot;&gt;$FF&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 7A00 C [#4100]==#FF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can use the condition to check if there’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;$20&lt;/code&gt; value at the &lt;strong&gt;IX+12&lt;/strong&gt; address:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6500 C [IX+12]==#20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The following condition results in a “Divide by zero” error, so it stops every time the execution
flow reaches the &lt;code class=&quot;highlighter-rouge&quot;&gt;$6200&lt;/code&gt; address:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6200 C HL/0==2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;combining-hit-conditions-and-filter-conditions&quot;&gt;Combining Hit Conditions and Filter Conditions&lt;/h3&gt;

&lt;p&gt;You can apply both hit and filter conditions for the same breakpoint. You have to define the hit
condition first, filter condition next:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6400 H&amp;gt;5 C B&amp;lt;=10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you exchange the condition order, the command prompt will indicate syntax error:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SB 6400 C B&amp;lt;=10 H&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you apply both conditions, they must be both satisfied to pause at that particular breakpoint.&lt;/p&gt;</content><author><name></name></author><summary type="html">With these commands, you can set up breakpoint according to their addresses. These breakpoints are not persisted, they are removed when you close the solution.</summary></entry><entry><title type="html">Disassembly: Annotations</title><link href="http://localhost:4000/spectnetide/documents/annotation-commands" rel="alternate" type="text/html" title="Disassembly: Annotations" /><published>2019-01-02T00:00:00+01:00</published><updated>2019-01-02T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/annotation-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/annotation-commands">&lt;p&gt;Managing annotations is a unique feature of &lt;strong&gt;SpectNetIDE&lt;/strong&gt;. It is very useful when you re-engineer existing code, including a ZX Spectrum ROM. You can define labels, add end-of-instruction comments, prefix comments to disassembly instructions. Moreover, you can define identifiers for literal values and tell the disassembler to use them for particular instructions instead of the less meaningful numbers.&lt;/p&gt;

&lt;p&gt;These commands allow you to edit the code annotation (both for the ROM and the code in the RAM):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;&lt;/em&gt; &lt;em&gt;[&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;]&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Adds a label with the given identifier for the specified address. If the identifier is omitted, removes the label from the address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;&lt;/em&gt; &lt;em&gt;[&lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;]&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Adds a tail comment with the given text to the instruction at the specified addres. If no text is specified, the comment is removed.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;&lt;/em&gt; &lt;em&gt;[&lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;]&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Adds a prefix comment with the given text to the instruction at the specified addres. If no text is specified, the comment is removed.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;With these commands you can create identifiers for literals, and replace literals with their corresponding identifiers.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Replaces the literal value within the instruction that starts at the specified address with the given &lt;em&gt;identifier&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Removes the literal replacements from instruction that starts at the specified address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Replaces the literal value within the instruction that starts at the specified address with the first available identifier in the symbol table that has the value of the literal.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The IDE saves the annotations you add with these commands into the annotations file of your project. The ZX Spectrum ROMs within SpectNetIDE ship with their predefined annotations, but you can change them, too.&lt;/p&gt;

&lt;p&gt;If your change regards to ROM addresses, the &lt;code class=&quot;highlighter-rouge&quot;&gt;.disann&lt;/code&gt; file of the specific ROM file is changed; otherwise, modifications go to your default annotation file (&lt;code class=&quot;highlighter-rouge&quot;&gt;Annotations.disann&lt;/code&gt; in a new project).&lt;/p&gt;

&lt;p&gt;With the following commands, you can retrieve the already placed annotations of a particular address:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RL&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Retrieves the label of the specified address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RC&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Retrieves the comment of the specified address.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RP&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;literal&lt;/code&gt;&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Retrieves the prefix comment of the specified address.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;When the specified address has an annotation, the Disassembly commands above prepare a new command line you can modify and change the label, comment, or prefix comment, respectively. However, if there is no annotation associated with the particular address, the command line remains empty.&lt;/p&gt;</content><author><name></name></author><summary type="html">Managing annotations is a unique feature of SpectNetIDE. It is very useful when you re-engineer existing code, including a ZX Spectrum ROM. You can define labels, add end-of-instruction comments, prefix comments to disassembly instructions. Moreover, you can define identifiers for literal values and tell the disassembler to use them for particular instructions instead of the less meaningful numbers.</summary></entry><entry><title type="html">Statements</title><link href="http://localhost:4000/spectnetide/documents/statements" rel="alternate" type="text/html" title="Statements" /><published>2019-01-01T00:00:00+01:00</published><updated>2019-01-01T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/statements</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/statements">&lt;p&gt;Statements are &lt;strong&gt;SpectNetIDE&lt;/strong&gt; specific control flow constructs — thanks again for the inspiration by
&lt;a href=&quot;http://www.desdes.com/index.htm&quot;&gt;Simon Brattel&lt;/a&gt; — that instruct the compiler about loop-like and
conditional compilation.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;While &lt;em&gt;directives&lt;/em&gt; help you to organize your code and include code files optionally according to the
compilation context, &lt;em&gt;statements&lt;/em&gt; provide you more useful tools to shorten the way you can declare Z80
assembly code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each statement can be written with a leading dot, or without it, and the compiler accepts both lowercase 
and uppercase versions. For example all of these version are valid: &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.IF&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-loop-block&quot;&gt;The LOOP Block&lt;/h2&gt;

&lt;p&gt;With LOOP block, you can organize a cycle to emit code. Here is a sample that tells the gist:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.loop 6
  add hl,hl 
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a shorter way to multiply &lt;strong&gt;HL&lt;/strong&gt; with 64. It is equivalent with the following code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; statement accepts an expression. The compiler repeats the instructions within the 
loop’s body according to the value of the expression. The &lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt; statement marks the end of the loop.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use many flavors for the &lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt; block closing statement. &lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;endl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.lend&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lend&lt;/code&gt;
are all accepted — with fully uppercase letters, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Look at this code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter .equ 2
; do something (code omitted)
.loop counter + 1
  .db #80, #00
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is as if you wrote this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  .db #80, #00
  .db #80, #00
  .db #80, #00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-loop-scope&quot;&gt;The LOOP Scope&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; statement declares a scope for all labels, symbols, and variables declared in the loop’s
body. Every iteration has its separate local scope. When the assembler resolves symbols, it starts 
from the scope of the loop, and tries to resolve the value of a symbol. If it fails, steps out to 
the outer scope, and goes on with the resolution.&lt;/p&gt;

&lt;p&gt;Check this code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value .equ 2
; do something (code omitted)
.loop 2
    value .equ 5
    ld a,value
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The compiler takes it into account as if you wrote this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ld a,5
    ld a,5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; symbol declared within the loop, overrides &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; in the outer scope, and
thus 5 is used instead of 5.&lt;/p&gt;

&lt;p&gt;Nonetheless, you when you utilize a different construct, it seems a bit strange at first:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value .equ 2
; do something (code omitted)
.loop 2
    ld a,value
    value .equ 5
    ld b,value
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The strangeness is that the compiler creates this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ld a,2
    ld b,5
    ld a,2
    ld b,5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the assembler resolves &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ld a,value&lt;/code&gt; instruction, if finds &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 
in the outer scope only, as it is not declared yet within the loop’s scope. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;ld b,value&lt;/code&gt;
instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; gets resolved from the inner scope, so it takes 5.&lt;/p&gt;

&lt;h2 id=&quot;variables-and-scopes&quot;&gt;Variables and Scopes&lt;/h2&gt;

&lt;p&gt;Unlike symbols that work as constant values, variables (declared with the &lt;code class=&quot;highlighter-rouge&quot;&gt;.var&lt;/code&gt; pragma, or its syntactical 
equivalents, the &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; tokens) can change their values.&lt;/p&gt;

&lt;p&gt;Take a look at this code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter = 4
.loop 3
    innercounter = 4
    ld a,counter + innercounter
    counter = counter + 1
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt; variable is defined in the global scope (out of the loop’s scope), while &lt;code class=&quot;highlighter-rouge&quot;&gt;innercounter&lt;/code&gt; in
the local scope of the loop. When evaluating the &lt;code class=&quot;highlighter-rouge&quot;&gt;counter = counter + 1&lt;/code&gt; statement, the compiler finds &lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt; in
the outer scope, so it uses that variable to increment its value. This code emits machine code for this source:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ld a,#08
ld a,#09
ld a,#0A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, add a single line to the loop’s code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter = 4
.loop 3
    innercounter = 4
    ld a,counter + innercounter
    counter = counter + 1
.endl
ld b,innercounter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The compiler will not compile this code, as it cannot find the value for &lt;code class=&quot;highlighter-rouge&quot;&gt;innercounter&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ld b,innercount&lt;/code&gt; 
instruction. Because &lt;code class=&quot;highlighter-rouge&quot;&gt;innercounter&lt;/code&gt; is defined in the local scope of the loop, this scope is immediately disposed as
the loop is completed. When the compiler processes the &lt;code class=&quot;highlighter-rouge&quot;&gt;ld b,innercounter&lt;/code&gt; instruction, the local scope is not 
available.&lt;/p&gt;

&lt;h2 id=&quot;labels-and-scopes&quot;&gt;Labels and Scopes&lt;/h2&gt;

&lt;p&gt;Labels behave like symbols, and they work similarly. When you create a label within a loop, that label is created in
the local scope of the loop. The following code helps you understand which labels are the part of the global scope, and
which are created in the loop’s scope:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.org #8000
MyLoop: .loop 2
    ld bc,MyLoop
Inner: 
    ld de,MyEnd
    ld hl,Inner
    ld ix,Outer
MyEnd: .endl
Outer: nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The label of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; statement is part of the outer (global) scope, just like the label that &lt;em&gt;follows&lt;/em&gt; the 
&lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt; statement. However, all labels declared within the loop’s body, including the label of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt;
statement belongs to the local scope of the loop.&lt;/p&gt;

&lt;p&gt;Thus, the compiler translates the code above into this one:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         (#8000): ld bc,#8000 (MyLoop)
Inner_1  (#8003): ld de,#800D (MyEnd_1)
         (#8006): ld hl,#8003 (Inner_1)
         (#8009): ld ix,#801A (Outer)
MyEnd_1  (#800D): ld bc,#8000 (MyLoop)
Inner_2  (#8010): ld de,#801A (MyEnd_2)
         (#8013): ld hl,#8010 (Inner_2)
         (#8016): ld ix,#801A (Outer)
MyEnd_2
Outer    (#801A): nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, &lt;code class=&quot;highlighter-rouge&quot;&gt;Inner_1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Inner_2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MyEnd_1&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;MyEnd_2&lt;/code&gt; represents the labels created in the local scope of the
loop. The &lt;code class=&quot;highlighter-rouge&quot;&gt;_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;_2&lt;/code&gt; suffixes indicate that each loop iteration has a separate local scope. As you can see,
the last iteration of &lt;code class=&quot;highlighter-rouge&quot;&gt;MyLabel&lt;/code&gt; points to the first outer address (&lt;code class=&quot;highlighter-rouge&quot;&gt;Outer&lt;/code&gt; label).&lt;/p&gt;

&lt;h2 id=&quot;nesting-loops&quot;&gt;Nesting LOOPs&lt;/h2&gt;

&lt;p&gt;Of course, you can nest loops, such as in this code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.loop 3
  nop
  .loop 2
    ld a,b
  .endl
  inc b
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code snippet translates to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nop
ld a,b
ld a,b
inc b
nop
ld a,b
ld a,b
inc b
nop
ld a,b
ld a,b
inc b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you nest loops, each loop has its separate scope.&lt;/p&gt;

&lt;h2 id=&quot;the-cnt-value&quot;&gt;The $CNT value&lt;/h2&gt;

&lt;p&gt;It is very useful to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; value that represents the current loop counter. It starts from 
1 and increments to the maximum number of loops. This sample demonstrates how you can use it:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.loop 2
  outerCount = $cnt
  .loop 3
     .db #10 * outerCount + $cnt
  .endl
.endl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code translates to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #11
.db #12
.db #13
.db #21
.db #22
.db #23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can observe that each loop has its spearate &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; value.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$ctn&lt;/code&gt; value has several syntax versions that the compiler accepts: &lt;code class=&quot;highlighter-rouge&quot;&gt;$CNT&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;.cnt&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;.CNT&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-procendp-block&quot;&gt;The PROC..ENDP Block&lt;/h2&gt;

&lt;p&gt;In the previous section you could understand how labels and scopes work for the &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; statement.
You can utilize this scoping mechanism with the help of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.proc&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;.endp&lt;/code&gt; statement.
This sample code demonstrates the concepts (just as you learned earlier):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.org #8000
MyLabel:
  ld de,Outer
  ld hl,Mylabel
  call MyProc
  halt

MyProc: 
  .proc
    ld bc,MyProc
  MyLabel: 
    ld de,MyEnd
    ld hl,MyLabel
    ld ix,Outer
    ret
MyEnd:
    .endp
Outer: nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first &lt;code class=&quot;highlighter-rouge&quot;&gt;MyLabel&lt;/code&gt; label belongs to the global scope, while the second (within &lt;code class=&quot;highlighter-rouge&quot;&gt;MyProc&lt;/code&gt;)
to the local scope of the procedure wrapped between &lt;code class=&quot;highlighter-rouge&quot;&gt;.proc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;endp&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;MyProc&lt;/code&gt; belongs to the
global scope too, however, &lt;code class=&quot;highlighter-rouge&quot;&gt;MyEnd&lt;/code&gt; is the part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;MyProc&lt;/code&gt; scope, so it is visible only from
within the procedure.&lt;/p&gt;

&lt;p&gt;The assembler emits this code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyLabel  (#8000): ld de,#8018 (Outer)
         (#8003): ld hl,#8000 (MyLabel)
         (#8006): call #800A (MyProc)
         (#8009): halt
MyProc   (#800A): ld bc,#800A (MyProc)
MyLabel_ (#800D): ld de,#8018 (MyEnd)
         (#8010): ld hl,#800D (MyLabel_)
         (#8013): ld ix,#8018 (Outer)
         (#8017): ret
MyEnd
Outer    (#8018): nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can nest &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; bloks just as &lt;code class=&quot;highlighter-rouge&quot;&gt;LOOP&lt;/code&gt; blocks. Each &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; block has its private scope.
When the compiler sees a &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; block, it works just as if you wrote &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop 1&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE: &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; is different than a loop. You cannot use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; value. Similarly, the &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt; 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; instructions are unavailable within a &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; block.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The assembler accepts these aliases for &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ENDP&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;.proc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;proc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.PROC&lt;/code&gt;
, &lt;code class=&quot;highlighter-rouge&quot;&gt;PROC&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.endp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.ENDP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;endp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ENDP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.pend&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.PEND&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pend&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PEND&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-repeatuntil-block&quot;&gt;The REPEAT..UNTIL Block&lt;/h2&gt;

&lt;p&gt;While the &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; statement works with an expression that specified the loop counter,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;.repeat&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;.until&lt;/code&gt; block uses an exit condition to create more flexible loops.
Here is a sample:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter = 0
.repeat 
    .db counter
    counter = counter + 3
.until counter % 7 == 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Observe, the &lt;code class=&quot;highlighter-rouge&quot;&gt;counter % 7 == 0&lt;/code&gt; condition specifies when &lt;em&gt;to exit&lt;/em&gt; the loop. Because the
exit condition is examined only at the end of the loop, the &lt;code class=&quot;highlighter-rouge&quot;&gt;.repeat&lt;/code&gt; blocks executes 
at least once.&lt;/p&gt;

&lt;p&gt;The sample above translates to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db 0
.db 3
.db 6
.db 9
.db 12
.db 15
.db 18
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;.repeat&lt;/code&gt; block uses the same approach to handle its local scope, symbols, labels, and
variables as the &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; block. The block also provides the &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; loop counter that starts 
from 1 and increments in every loop cycle.&lt;/p&gt;

&lt;p&gt;This sample demontrates the &lt;code class=&quot;highlighter-rouge&quot;&gt;.repeat&lt;/code&gt; block in action:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.org #8000
counter = 0
.repeat 
    .db low(EndLabel), high(Endlabel), $cnt
    counter = counter + 3
EndLabel: .until counter % 7 == 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The compiler translates the code to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #03, #80, #01
.db #06, #80, #02
.db #09, #80, #03
.db #0C, #80, #04
.db #0F, #80, #05
.db #12, #80, #06
.db #15, #80, #07
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-whileendw-block&quot;&gt;The WHILE..ENDW Block&lt;/h2&gt;

&lt;p&gt;With &lt;code class=&quot;highlighter-rouge&quot;&gt;.while&lt;/code&gt; loop, you can create another kind of block, which uses entry condition. For example,
the following code snippet generates instructions to create the sum of numbers from 1 to 9:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter = 1
    ld a,0
.while counter &amp;lt; 10
    add a,counter
    counter = counter + 1
.endw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;.while&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;.endw&lt;/code&gt; block uses an entry condition declared in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.while&lt;/code&gt; statement. Provided, this
condition is true, the compiler enters into the body of the loop, and compiles all instructions and statements
until it reaches the &lt;code class=&quot;highlighter-rouge&quot;&gt;.endw&lt;/code&gt; statement. Observe, it may happen that the body of the loop is never reached.&lt;/p&gt;

&lt;p&gt;The compiler translates the code snippet above to the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ld a,0
add a,1
add a,2
add a,3
add a,4
add a,5
add a,6
add a,7
add a,8
add a,9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Just like the &lt;code class=&quot;highlighter-rouge&quot;&gt;.loop&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;.repeat&lt;/code&gt; blocks, &lt;code class=&quot;highlighter-rouge&quot;&gt;.while&lt;/code&gt; uses the same approach to handle its local scope, 
symbols, labels, and variables. This block also provides the &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; loop counter that starts  from 1 and increments 
in every loop cycle.&lt;/p&gt;

&lt;p&gt;This code demonstrates the &lt;code class=&quot;highlighter-rouge&quot;&gt;.while&lt;/code&gt; block with labels and using &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; value:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;counter = 0
.while counter &amp;lt; 21 
    .db low(EndLabel), high(Endlabel), $cnt
    counter = counter + 3
EndLabel: .endw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The compiler translates the code to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #03, #80, #01
.db #06, #80, #02
.db #09, #80, #03
.db #0C, #80, #04
.db #0F, #80, #05
.db #12, #80, #06
.db #15, #80, #07
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use many flavors for the &lt;code class=&quot;highlighter-rouge&quot;&gt;.endw&lt;/code&gt; block closing statement. &lt;code class=&quot;highlighter-rouge&quot;&gt;.endw&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;endw&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.wend&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wend&lt;/code&gt;
are all accepted — with fully uppercase letters, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-fornext-loop&quot;&gt;The FOR..NEXT Loop&lt;/h2&gt;

&lt;p&gt;Tou can use the traditional &lt;code class=&quot;highlighter-rouge&quot;&gt;.for&lt;/code&gt;..&lt;code class=&quot;highlighter-rouge&quot;&gt;.next&lt;/code&gt; loop to create a loop:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.for myVar = 2 .to 5
  .db 1 &amp;lt;&amp;lt; int(myVar)
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This loop uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; variable as its &lt;em&gt;iteration variable&lt;/em&gt;, which iterates from 1 to 4. As you expect, 
the compiler translates the for-loop into this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #04
.db #08
.db #10
.db #20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can specify a &lt;code class=&quot;highlighter-rouge&quot;&gt;.step&lt;/code&gt; close to change the loop increment value:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.for myVar = 1 .to 7 .step 2
  .db 1 &amp;lt;&amp;lt; int(myVar)
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, the code translates to this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #02
.db #08
.db #20
.db #80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can create a loop with decrementing iteration variable value:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.for myVar = 7 .to 1 .step -2
  .db 1 &amp;lt;&amp;lt; int(myVar)
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you expect, now you get this translation:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #80
.db #20
.db #08
.db #02
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Just as with the other statements, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;.for&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.to&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;.step&lt;/code&gt; keywords without the &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;
prefix, so &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;to&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt; are also valid.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The for-loop can do the same stunts as the other kind of loops; it handles labels, symbols, and variables exactly 
the same way. There’s only one exception, the loop iteration variable. If this variable is found in an outer scope,
instead of using that value, the compiler raises an error. You can us the for-loop only with a freshly created
variable.&lt;/p&gt;

&lt;p&gt;So both cases in this code raise an error:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myVar = 0
.for myVar = 1 .to 4 ; ERROR: Variable myVar is already declared
  ; ...
.next

.for _i = 1 .to 3
  .for _i = 3 .to 8 ; ; ERROR: Variable _i is already declared
    ; ...
  .next
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;As &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; is a reserved token (it represents the &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; register), you cannot use &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; as a variable name. Nonetheless,
&lt;code class=&quot;highlighter-rouge&quot;&gt;_i&lt;/code&gt; is a valid variable name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The for-loop works with both integer and float variables. If any of the initial value, the last value (the one after &lt;code class=&quot;highlighter-rouge&quot;&gt;.to&lt;/code&gt;), 
or the increment value (the one after &lt;code class=&quot;highlighter-rouge&quot;&gt;.step&lt;/code&gt;) is a float value, the for-loop uses float operations; otherwise it uses
integer operations.&lt;/p&gt;

&lt;p&gt;This code snippet demonstrates the difference:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.for myVar = 1 .to 4 .step 1
  .db 1 &amp;lt;&amp;lt; myVar
.next

.for myVar = 1 .to 4 .step 1.4
  .db 1 &amp;lt;&amp;lt; myVar ; ERROR: Right operand of the shift left operator must be integral
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nonetheless, you can solve this issue with applying the &lt;code class=&quot;highlighter-rouge&quot;&gt;int()&lt;/code&gt; function:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.for myVar = 1 .to 4 .step 1.4
  .db 1 &amp;lt;&amp;lt; int(myVar) ; Now, it's OK.
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can still use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$cnt&lt;/code&gt; value in for loops. Just like with other loop, it indicates the count of
cycles strating from one and incremented by one in each iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;maximum-loop-count&quot;&gt;Maximum Loop Count&lt;/h2&gt;

&lt;p&gt;It’s pretty easy to create an infinite (or at least a very long) loop. For example, these loops are
obviously infinite ones:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.repeat
.until false

.while true
.wend 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The assembler checks the loop counter during compilation. Whenever it exceeds #FFFF (65535), it raises an error.&lt;/p&gt;

&lt;h2 id=&quot;the-ifelifelseendif-statement&quot;&gt;The IF..ELIF..ELSE..ENDIF Statement&lt;/h2&gt;

&lt;p&gt;You can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt; statement to create branches with conditions. For example, this code emits &lt;code class=&quot;highlighter-rouge&quot;&gt;inc b&lt;/code&gt;
or &lt;code class=&quot;highlighter-rouge&quot;&gt;inc c&lt;/code&gt; statement depending on whether the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt; is even or odd:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.if branch % 2 == 0
  inc b
.else
  inc c
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You do not have to specify an &lt;code class=&quot;highlighter-rouge&quot;&gt;.else&lt;/code&gt; branch, so this statement is entirely valid:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.if branch % 2 == 0
  inc b
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can nest if statements like this to manage four different code branches according to the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.if branch == 1
  inc b
.else
  .if branch == 2
    inc c
  .else 
    .if branch == 3
      inc d
    .else
      inc e
    .endif
  .endif
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nonetheless, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;.elif&lt;/code&gt; statement to create the code snippet above in clearer way:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.if branch == 1
  inc b
.elif branch == 2
  inc c
.elif branch == 3
  inc d
.else
  inc e
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;if-and-scopes&quot;&gt;IF and Scopes&lt;/h2&gt;

&lt;p&gt;Unlike the loop statements, &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt; does not provide its local scope. Whenever you create a symbol, a label or
a variable, those get into the current scope. This code defines a label with the same name in each branches. Because
the compiler evaluates the &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt; branches from top to down, it either compiles one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.elif&lt;/code&gt; branches —
the first with a matching condition — or the else branch. Thus, this code does not define &lt;code class=&quot;highlighter-rouge&quot;&gt;MyLabel&lt;/code&gt; twice:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;branch = 4 ; Try to set up a different value
; Do something (omitted from code)
    ld hl,MyLabel
.if branch == 1
  inc b
  MyLabel ld a,20
.elif branch &amp;gt; 2
  MyLabel ld a,30
  inc c
.elif branch &amp;lt; 6
  inc d
  MyLabel ld a,40
.else
  MyLabel ld a,50
  inc e
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Generally, you can decorate any statement with labels. The &lt;code class=&quot;highlighter-rouge&quot;&gt;.elif&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.else&lt;/code&gt; statements are exception. If you
do so, the compiler raises an error:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.if branch == 1
  inc b
  MyLabel ld a,20
.elif branch &amp;gt; 2
  MyLabel ld a,30
  inc c
Other .elif branch &amp;lt; 6 ; ERROR: ELIF section cannot have a label
  inc d
  MyLabel ld a,40
Another .else          ; ERROR: ELSE section cannot have a label
  MyLabel ld a,50
  inc e
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;if-nesting&quot;&gt;IF Nesting&lt;/h2&gt;

&lt;p&gt;When you nest &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt; statements, take care that each of them has a corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;.endif&lt;/code&gt;. Whenever
the compiler finds an &lt;code class=&quot;highlighter-rouge&quot;&gt;.endif&lt;/code&gt;, is associates it with the closest &lt;code class=&quot;highlighter-rouge&quot;&gt;.if&lt;/code&gt; statement before &lt;code class=&quot;highlighter-rouge&quot;&gt;.endif&lt;/code&gt;.
I suggest you use indentation to make the structure more straightforward, as the following code snippet shows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;row = 2
col = 2
; Change row and col (omitted from code)
.if row == 0
  .if col == 0
    .db #00
  .elif col == 1
    .db #01
  .else
    .db #02
  .endif
.elif row == 1
  .if col == 0
    .db #03
  .elif col == 1
    .db #04
  .else
    .db #05
  .endif
.elif row == 2
  .if col == 0
    .db #06
  .elif col == 1
    .db #07
  .else
    .db #08
  .endif
.else
  .if col == 0
    .db #09
  .elif col == 1
    .db #0A
  .else
    .db #0B
  .endif
.endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;block-statements-without-a-closing-statement&quot;&gt;Block Statements without a Closing Statement&lt;/h2&gt;

&lt;p&gt;The compiler automatically recognizes if a block does not have a closing statement, and provides an
error message accordingly.&lt;/p&gt;

&lt;h2 id=&quot;orphan-closing-statements&quot;&gt;Orphan Closing Statements&lt;/h2&gt;

&lt;p&gt;When the compiler finds a closing statement (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;.endw&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.endl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.until&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.endif&lt;/code&gt;, etc.) it will
issue an error.&lt;/p&gt;

&lt;h2 id=&quot;the-break-statement&quot;&gt;The BREAK statement&lt;/h2&gt;

&lt;p&gt;You can exit the loop — independently of the loop’s exit condition — with the &lt;code class=&quot;highlighter-rouge&quot;&gt;.break&lt;/code&gt; statement:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; LOOP sample
.loop 5
  .if $cnt == 4
    .break
  .endif
  .db $cnt
.endl

; REPEAT sample
.repeat
  .if $cnt == 4
    .break
  .endif
  .db $cnt
.until $cnt == 5

; WHILE sample
.while $cnt &amp;lt; 5
  .if $cnt == 4
    .break
  .endif
  .db $cnt
.endw

; FOR-loop sample
.for value = 1 to 5
  .if value == 4
    .break
  .endif
  .db value
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because all these loops are exited at the beginning of the 4th iteration, they produce this output:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #01
.db #02
.db #03
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot use the &lt;code class=&quot;highlighter-rouge&quot;&gt;.break&lt;/code&gt; statement outside of a loop construct. If you do so, the compiler 
raises an error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-continue-statement&quot;&gt;The CONTINUE Statement&lt;/h2&gt;

&lt;p&gt;You can interrupt the current iteration of the loop and carry on the next iteration with the &lt;code class=&quot;highlighter-rouge&quot;&gt;.continue&lt;/code&gt; statement:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; LOOP sample
.loop 5
  .if $cnt == 4
    .continue
  .endif
  .db $cnt
.endl

; REPEAT sample
.repeat
  .if $cnt == 4
    .continue
  .endif
  .db $cnt
.until $cnt == 5

; WHILE sample
.while $cnt &amp;lt;= 5 
  .if $cnt == 4
    .continue
  .endif
  .db $cnt
.endw

; FOR-loop sample
.for value = 1 to 5
  .if value == 4
    .continue
  .endif
  .db value
.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because all these loops skip the 4th iteration, they produce this output:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.db #01
.db #02
.db #03
; #04 is skipped
.db #05
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot use the &lt;code class=&quot;highlighter-rouge&quot;&gt;.continue&lt;/code&gt; statement outside of a loop construct. If you do so, the compiler 
raises an error.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Statements are SpectNetIDE specific control flow constructs — thanks again for the inspiration by Simon Brattel — that instruct the compiler about loop-like and conditional compilation.</summary></entry></feed>