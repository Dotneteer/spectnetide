{
  "Labels": {
    "0": "START",
    "4": "START_1",
    "199": "MAIN_RESET",
    "40": "ROM1_CALL",
    "56": "MASK_INT",
    "72": "MASK_INT_RET",
    "107": "SWAP",
    "127": "YOUNGER",
    "136": "ONERR",
    "195": "ONERR_CONT",
    "154": "P_IN",
    "1752": "RS232_INP",
    "162": "P_OUT_1",
    "1994": "RS232_OUT",
    "159": "P_OUT",
    "1510": "RS232_HANDLER",
    "181": "P_OUT_2",
    "201": "MAIN_RESET_1",
    "305": "FATAL_RAM_ERR",
    "311": "MAIN_RESET_2",
    "74": "ERR_128",
    "92": "ROM1_CALL_1",
    "309": "INF_LOOP",
    "7268": "PAGE_IN_RAM",
    "413": "NEW",
    "1417": "CHAN_INFO",
    "1438": "INI_STREAM_DATA",
    "1377": "COPYR_MSG",
    "698": "RET_SYN_CHECK",
    "705": "SYNTAX_OK",
    "735": "SYN_OK_1",
    "619": "EXEC_CMD",
    "8005": "WKSP_RAM",
    "756": "SYN_OK_2",
    "7968": "NORM_RAM",
    "801": "ERR_HANDLER",
    "842": "ERR_H_1",
    "846": "ERR_H_2",
    "893": "ERR_H_3",
    "895": "ERR_H_4",
    "924": "ERR_H_5",
    "1132": "ERR_MSG_VECTORS",
    "930": "ERR_H_6",
    "972": "ERR_H_7",
    "975": "ERR_H_8",
    "989": "ERR_H_9",
    "991": "ERR_H_10",
    "1007": "BASIC_ERRH",
    "1015": "PARSE_L_NUMB",
    "1034": "PARSE_LN_1",
    "1065": "PARSE_LN_2",
    "1090": "PARSE_LN_3",
    "1130": "PARES_LN_4",
    "1405": "PRINT_MSG",
    "1452": "REPORT_ERROR",
    "1480": "REPORT_ERROR_1",
    "1494": "TEST_BREAK",
    "1546": "RS232_H_1",
    "1556": "RS232_H_2",
    "1552": "RS232_H_RET",
    "1560": "RS232_NON_CHAR",
    "1563": "RS232_CHAR",
    "1581": "RS232_CR",
    "1591": "INKEY_PRINT",
    "1597": "INKEY_RET",
    "1601": "FORMAT",
    "1633": "FORMAT_SYNTAX",
    "1625": "FORMAT_STR_1",
    "1661": "FORMAT_SYNTAX_1",
    "1673": "FORMAT_CHECK_END",
    "6418": "ERROR_C",
    "1688": "FORMAT_BAUD",
    "1720": "BAUD_TABLE",
    "1711": "BAUD_FOUND",
    "1765": "RS232_READB",
    "1806": "RS232_BIT",
    "1822": "RS232_START_BIT",
    "1879": "RS232_COMPL",
    "1813": "RS232_BIT_1",
    "1846": "BAUD_DELAY",
    "1841": "RS232_NEXT_BIT",
    "1867": "RS_BIT_0_REC",
    "1876": "RS_BYTE_REC",
    "1894": "STOP_B_DELAY",
    "1919": "RS_START_BIT_2",
    "1905": "RS_WAIT_STARTB",
    "1954": "BAUD_DELAY_2",
    "1949": "RS_NEXT_BIT_2",
    "1975": "RS_BIT_0_REC_2",
    "1984": "RS_REC_COMPL",
    "2016": "RS_OUT_NO_PARS",
    "2011": "RS_OUT_2",
    "2034": "RS_OUT_NO_TOKEN",
    "2045": "RS_OUT_NO_SPC",
    "2051": "RS_OUT_NO_GR",
    "2078": "RS_OUT_CTRL",
    "2074": "RS_OUT_NO_ROW",
    "2082": "RS_OUT_CRLF",
    "2096": "RS_OUT_TEST_COM",
    "2106": "RS_OUT_3",
    "2112": "RS_OUT_4",
    "2120": "RS_OUT_5",
    "2131": "RS_OUT_TEST_AT",
    "2144": "RS_OUT_AT_TAB",
    "2153": "RS_OUT_INK",
    "2162": "RS_OUT_PARS",
    "2178": "RS_PROC_AT_TAB",
    "2186": "RS_AT_1",
    "2192": "RS_AT_2",
    "2197": "RS_AT_3",
    "2211": "RS_WR_BYTE",
    "2223": "RS_WR_ISREADY",
    "2248": "RS_WR_BIT",
    "2272": "RS_WR_BIT_3",
    "2266": "RS_WR_BIT_2",
    "2288": "COPY_TO_PRN",
    "2293": "COPY_TO_2",
    "2425": "PRINTER_CONFIG",
    "2432": "PRINTER_LF",
    "2434": "PRINTER_RESET",
    "2318": "COPY_TO_3",
    "2325": "COPY_HALF_ROW",
    "2330": "COPY_HALF_2",
    "2342": "COPY_COLUMN",
    "2362": "COPY_COL_2",
    "2372": "COPY_COL_3",
    "2389": "COPY_PIXELS",
    "2399": "PR_OUT_TABLE",
    "2401": "PR_OUT_TB_2",
    "2413": "TEST_PIXEL",
    "2420": "TEST_PIXEL_2",
    "2437": "PLAY_SOUND",
    "2445": "PLAY_SOUND_2",
    "2464": "PLAY_SOUND_3",
    "2565": "PLAY_MSTRING",
    "3708": "SET_SGREG",
    "2609": "CALC_TM_LOOP",
    "2622": "TEST_BREAK_2",
    "2634": "CD_DUR_PTR",
    "2639": "CD_PTRS",
    "2642": "CD_PTRS_2",
    "2663": "CDB_ADDR_STR",
    "2670": "NEXT_CD_PTR",
    "2685": "PLAY_SOUND_4",
    "2688": "PLAY_SOUND_5",
    "2700": "PLAY_SOUND_6",
    "2711": "PLAY_NOTES",
    "2719": "PLAY_NOTES_2",
    "2731": "PLAY_NOTES_3",
    "2743": "PLAY_CMD_TABLE",
    "2757": "GET_PLAY_CH",
    "2769": "GET_NEXT_STONE",
    "2772": "GET_NSTONE_2",
    "2783": "GET_NSTONE_3",
    "2785": "GET_NSTONE_4",
    "2796": "GET_NSTONE_5",
    "2803": "GET_NSTONE_6",
    "2810": "GET_NSTONE_7",
    "2820": "GET_NSTONE_8",
    "3874": "REPORT_k",
    "3577": "STONES_TABLE",
    "2845": "GET_PS_NUMVAL",
    "2856": "GET_PS_NV_2",
    "2882": "GET_PS_NV_3",
    "2885": "GET_PS_NV_4",
    "3866": "REPORT_l",
    "2896": "MUL_DE_BY10",
    "2901": "MUL_DE_2",
    "2908": "FIND_NOTE_CHSTR",
    "2921": "FINDN_CHSTR_2",
    "2948": "FINDN_CHSTR_3",
    "2949": "NCMD_EXCL",
    "3530": "CMD_JUMP_TABLE",
    "2960": "NCMD_OCTAVE",
    "3858": "ERROR_n",
    "2981": "NCMD_SEPARATOR",
    "2982": "NCMD_SREPEAT",
    "3882": "REPORT_d",
    "3010": "NCMD_EREPEAT",
    "3056": "NCMD_EREP_2",
    "3083": "NCMD_EREP_3",
    "3111": "GET_ADDR_BRCK",
    "3122": "NCMD_TEMPO",
    "3190": "NCMD_TEMPO_RET",
    "3204": "NCMD_MIXER",
    "3221": "NCMD_VOLUME",
    "3245": "NCMD_VOLEFF",
    "3258": "NCMD_VOLSPEC",
    "3560": "ENV_WAVE_TABLE",
    "3278": "NCMD_VOLDUR",
    "3293": "NCMD_MIDICH",
    "3310": "NCMD_MIDI_PC",
    "3318": "NCMD_STOP",
    "3323": "NCMD_OTHERS",
    "3368": "NCMD_O_2",
    "3378": "NCMD_O_3",
    "3384": "NCMD_O_4",
    "3387": "NCMD_O_5",
    "3423": "NCMD_O_6",
    "3438": "NCMD_O_7",
    "3444": "INC_NOTE_COUNT",
    "3457": "NCMD_NO_DIGIT",
    "3484": "NCMD_O_RET",
    "3898": "REPORT_o",
    "3489": "NCDM_EOS",
    "3490": "NCMD_EOS_2",
    "3500": "CDB_POINT_DUR",
    "3508": "STORE_DUR_LEN",
    "3584": "FINDN_DUR_LEN",
    "3596": "NOTE_DUR_TABLE",
    "3609": "IS_NUM_DIGIT",
    "3616": "PLAY_NOTE_SCC",
    "3890": "REPORT_m",
    "3647": "PLAY_N_2",
    "4246": "NOTE_LOOKUP_TBL",
    "3671": "PLAY_N_3",
    "3678": "PLAY_N_4",
    "3721": "GET_SGREG",
    "3731": "SOUND_OFF",
    "3756": "RESET_MIDI_CH",
    "3768": "RESET_MIDI_C_2",
    "3779": "RESET_MIDI_C_3",
    "3784": "GET_PR_PLAY_CH",
    "3792": "GET_PR_PLCH_2",
    "3811": "GET_PLAY_CURR",
    "3820": "GET_PLAY_CUR_2",
    "3835": "GET_PLAY_CUR_3",
    "3845": "GET_PLAY_CUR_4",
    "3849": "GET_PLAY_CUR_5",
    "3906": "PLAYN_EACH_CH",
    "3909": "PLAYN_ECH_2",
    "3945": "PLAYN_ECH_3",
    "3948": "PLAYN_ECH_4",
    "3958": "WAIT_NOTE_DUR",
    "3974": "WAIT_NDUR_2",
    "3985": "SMALLEST_DUR",
    "3991": "SMALL_DUR_2",
    "4015": "SMALL_DUR_3",
    "4026": "SMALL_DUR_4",
    "4033": "PLAY_UPD_DUR",
    "4040": "PLAY_UPD_2",
    "4092": "PLAY_UPD_3",
    "4108": "PLAY_UPD_4",
    "4134": "PLAY_UPD_5",
    "4157": "PLAY_UPD_6",
    "4186": "PLAY_UPD_7",
    "4198": "PLAY_UPD_8",
    "4207": "PLAY_UPD_9",
    "4233": "PLAY_UPD_10",
    "4236": "PLAY_UPD_11",
    "4462": "PLAYN_MIDI",
    "4493": "MIDI_OFF",
    "4515": "MIDI_SEND_BYTE",
    "4532": "MIDI_SENDB_2",
    "4542": "MIDI_SENDB_3",
    "4553": "MIDI_SENDB_4",
    "4559": "MIDI_SEND_5",
    "4561": "MIDI_SENDB_6",
    "4583": "MIDI_SENDB_7",
    "4587": "SAVE_ROUT",
    "4594": "LOAD_ROUT",
    "4601": "VERIFY_ROUT",
    "4608": "MERGE_ROUT",
    "4613": "MERGE_ROUT_2",
    "4633": "REPORT_C",
    "4637": "RAM_DISK_CMD",
    "4686": "RAMD_CMD_2",
    "4736": "RAMD_CMD_3",
    "4740": "RAMD_CMD_4",
    "4752": "RAMD_CMD_5",
    "4763": "RAMD_VERIFY",
    "4805": "RAMD_MERGE",
    "4827": "RAMD_LOAD",
    "4782": "RAMD_VER_2",
    "4792": "RAMD_VER_3",
    "4801": "RAMD_VER_4",
    "4845": "RAMD_LOAD_2",
    "4854": "RAMD_LOAD_3",
    "4863": "RAMD_LOAD_4",
    "4885": "RAMD_LOAD_5",
    "4913": "RAMD_LOAD_6",
    "4917": "RAMD_LPROG",
    "4976": "RAMD_LPROG_2",
    "4990": "RAMD_LOAD_BYTES",
    "4997": "GET_EXPR",
    "5011": "CHECK_FNAME_COPY",
    "5037": "CHECK_FNAME_2",
    "5050": "CHECK_FNAME_3",
    "5054": "CAS_RAM_CMD",
    "5074": "CAS_RAM_2",
    "5084": "CAS_RAM_3",
    "5113": "CAS_RAM_4",
    "5120": "CAS_RAM_5",
    "5127": "CAS_RAM_6",
    "5157": "CAS_RAM_7",
    "5167": "CAS_RAM_8",
    "5188": "CAS_RAM_9",
    "5198": "CAS_RAM_10",
    "5201": "CAS_RAM_11",
    "5215": "CAS_RAMSC",
    "5250": "CAS_RAMS_2",
    "5280": "CAS_RAMSC_3",
    "5295": "CAS_RAMSC_4",
    "5300": "CAS_RAMSC_5",
    "5304": "CAS_RAMSC_6",
    "5327": "CAS_RAMSC_7",
    "5333": "CAS_RAM_SL",
    "5346": "CAS_RAM_SL_2",
    "5369": "CAS_RAM_SL_3",
    "5401": "CAS_RAM_RET",
    "5419": "CAS_RAM_RER_2",
    "5423": "RELIST",
    "5430": "RELIST_2",
    "5440": "RELIST_3",
    "5460": "RELIST_4",
    "5475": "RELIST_5",
    "5487": "RELIST_6",
    "5524": "RELIST_7",
    "5526": "RELIST_8",
    "5547": "RELIST_9",
    "5568": "RELIST_10",
    "5579": "RELIST_11",
    "5587": "RELIST_12",
    "5620": "RELIST_13",
    "5629": "RELIST_14",
    "5634": "RELIST_15",
    "5637": "DISP_BUFF",
    "5644": "DISP_BUFF_2",
    "5662": "DISP_BUFF_3",
    "5680": "CLEAR_EDIT_DISP",
    "5689": "ED_SHIFT_UP",
    "5704": "ED_SHIFT_UP_2",
    "5718": "ED_SHIFT_UP_3",
    "5731": "ED_SHIFT_UP_4",
    "5743": "ED_SHIFT_DW",
    "5749": "ED_SHIFT_DW_2",
    "5774": "ED_SHIFT_DW_3",
    "5786": "ED_SHIFT_DW_4",
    "5801": "ED_SHIFT_DW_5",
    "5804": "CHINS_SHLEFT",
    "5811": "CHINS_SHLEFT_2",
    "5825": "CHINS_SHRIGHT",
    "5836": "CHINS_SHRIG_2",
    "5843": "CHINS_SHRIG_3",
    "5846": "CHINS_SHRIG_4",
    "5852": "SYN_OFFS_TABLE",
    "5902": "SYN_PAR_TABLE",
    "6063": "MAIN_PARSER",
    "6080": "STMT_LOOP",
    "6081": "STMT_LOOP_2",
    "6177": "STMT_RET",
    "6057": "SPECTRUM_PARS",
    "6060": "PLAY_PARS",
    "6132": "STMT_LOOP_3",
    "6144": "STMT_LOOP_4",
    "6141": "STMT_LOOP_RET",
    "6325": "CMD_CLASS_TABLE",
    "6170": "P_SEPARATOR",
    "6186": "STMT_RET_2",
    "6200": "LINE_RUN",
    "6220": "LINE_NEW",
    "6242": "LINE_REM",
    "6243": "LINE_END",
    "6256": "LINE_USE",
    "6274": "LINE_NEXT",
    "6301": "REPORT_N",
    "6305": "CHECK_END",
    "6312": "STMT_NEXT",
    "6340": "CLASS_CDE",
    "6358": "CLASS_000305",
    "6392": "CLASS_035_RET",
    "6393": "CLASS_01",
    "6397": "CLASS_02",
    "6405": "CLASS_04",
    "6409": "CLASS_08",
    "6414": "CLASS_06",
    "6422": "CLASS_0A",
    "6426": "CLASS_07",
    "6439": "CLASS_07_2",
    "6468": "CLASS_09",
    "6472": "CLASS_0B",
    "6503": "IF_ROUT",
    "6526": "IF_ROUT_2",
    "6529": "FOR_ROUT",
    "6542": "FOR_ROUT_2",
    "6566": "FOR_ROUT_3",
    "6570": "READ_ROUT",
    "6603": "READ_ROUT_2",
    "6626": "READ_ROUT_3",
    "6635": "DATA_ROUT",
    "6641": "DATA_ROUT_2",
    "6652": "DATA_ROUT_3",
    "6654": "PASS_BY",
    "6658": "RUN_ROUT",
    "6669": "CLEAR_ROUT",
    "6672": "CLEAR_ROUT_2",
    "6680": "CLEAR_ROUT_3",
    "6715": "CLEAR_ROUT_4",
    "6719": "CLEAR_ROUT_5",
    "6739": "GOSUB_ROUT",
    "6767": "RETURN_ROUT",
    "6790": "RETURN_ROUT_2",
    "6796": "DEFFN_ROUT",
    "6807": "DEFFN_ROUT_2",
    "6826": "DEFFN_ROUT_3",
    "6835": "DEFFN_ROUT_4",
    "6838": "DEFFN_ROUT_5",
    "6849": "DEFFN_ROUT_6",
    "6867": "DEFFN_ROUT_7",
    "6890": "DEFFN_ROUT_8",
    "6897": "RUN_TAP_LOADER",
    "6896": "MOVE_ROUT",
    "6932": "RUN_LLIST",
    "6955": "SPECTRUM_ROUT",
    "6983": "BASIC_48",
    "6995": "SET_P_CHDATA",
    "7022": "LOAD_CMD_BYTES",
    "7025": "LLIST_ROUT",
    "7029": "LIST_ROUT",
    "7031": "LIST_ROUT_2",
    "7043": "LIST_ROUT_3",
    "7062": "LIST_ROUT_4",
    "7070": "LIST_ROUT_5",
    "7075": "LIST_ROUT_6",
    "7078": "LIST_ROUT_7",
    "7085": "RAMD_SAVE",
    "7141": "CAT_ROUT",
    "7180": "ERASE_ROUT",
    "7214": "RAMD_LOAD_HEAD",
    "7297": "RAMBANK_MAPPINGS",
    "7303": "CMP_FILENAMES",
    "7306": "CMP_FN_2",
    "7311": "CMP_FN_3",
    "7319": "NEW_CAT_ENTRY",
    "7328": "NEW_CATE_2",
    "7411": "ADJ_RAMD_SPACE",
    "7427": "ADJ_RAMDS_2",
    "7434": "ADJ_RAMDS_3",
    "7438": "ADJ_RAMDS_4",
    "7442": "FIND_CATE",
    "7451": "FIND_CATE_2",
    "7470": "FIND_CATE_3",
    "7477": "FIND_RAMD_FILE",
    "7486": "FIND_RAMDF_2",
    "7510": "UPD_CATE",
    "7596": "SAVEB_RAMD",
    "7628": "SAVEB_RAMD_2",
    "7637": "SAVEB_RAMD_3",
    "7652": "SAVEB_RAMD_4",
    "7657": "SAVEB_RAMD_5",
    "7668": "SAVEB_RAMD_6",
    "7685": "SAVEB_RAMD_7",
    "7691": "SAVEB_RAMD_8",
    "7716": "SAVEB_RAMD_9",
    "7735": "LOADB_RAMD",
    "7772": "LOADB_RAMD_2",
    "7783": "LOADB_RAMD_3",
    "7798": "LOADB_RAMD_4",
    "7803": "LOADB_RAMD_5",
    "7808": "LOADB_RAMD_6",
    "7825": "LOADB_RAMD_7",
    "7831": "LOADB_RAMD_8",
    "7863": "LOADB_RAMD_9",
    "7868": "LOADB_RAMD_10",
    "7887": "TO_RAM4",
    "7912": "TO_RAM4_2",
    "7940": "FROM_RAM4",
    "7994": "SEL_RAMB",
    "8031": "ERASE_FILE",
    "8040": "ERASEF_2",
    "8170": "ERASEF_3",
    "8205": "ERASEF_4",
    "8228": "ERASEF_5",
    "8251": "ERASEF_6",
    "8254": "ERASEF_7",
    "8289": "ERASEF_8",
    "8316": "ERASEF_9",
    "8345": "ERASEF_10",
    "8402": "PRINT_CAT",
    "8481": "LOWEST_NAME",
    "8491": "HIGHEST_NAME",
    "8410": "PRCAT_2",
    "8417": "PRCAT_3",
    "8458": "PRCAT_4",
    "8465": "PRCAT_5",
    "8501": "PRINT_CAT_ENTRY",
    "8530": "PRCATE_2",
    "8564": "LPRINT_ROUT",
    "8568": "PRINT_ROUT",
    "8570": "PRINT_ROUT_2",
    "8578": "PRINT_ROUT_3",
    "8588": "INPUT_ROUT",
    "8601": "INPUT_ROUT_2",
    "8615": "COPY_ROUT",
    "8618": "NEW_ROUT",
    "8638": "DRAW_ROUT",
    "8650": "DRAW_ROUT_2",
    "8661": "DIM_ROUT",
    "8679": "DIM_ROUT_2",
    "8683": "REPORT_C_2",
    "8687": "CLS_ROUT",
    "8696": "EV_NUM_EXPR",
    "8762": "EVNUMEX_2",
    "8766": "EVNUMEX_3",
    "8804": "EVNUMEX_4",
    "8815": "PREC_KEY_PRESS",
    "8846": "FIND_SBASIC",
    "8855": "IS_LET_CMD",
    "8864": "ISLET_2",
    "8875": "IS_OPER",
    "8879": "IS_OPER_2",
    "8889": "IS_OPER_3",
    "8893": "OP_TOKENS_TABLE",
    "8907": "IS_FUNC_CHAR",
    "8925": "ISFUNC_2",
    "8928": "IS_NUM_OR_FUNC",
    "8941": "ISNOF_2",
    "8950": "ISNOF_3",
    "8967": "ISNOF_4",
    "8970": "IS_NUM_CHAR",
    "8980": "ISNUM_2",
    "8983": "PLAY_ROUT",
    "8986": "PLAY_ROUT_2",
    "8999": "PLAY_ROUT_3",
    "9008": "PLAY_ROUT_4",
    "9527": "ED_KEYS_TABLE",
    "9591": "MENU_KEYS_TABLE",
    "9604": "INIT_MSETTINGS",
    "9631": "SHOW_MENU",
    "10052": "MENU_JUMP_TABLE",
    "10068": "MENU_TEXT_TABLE",
    "10128": "EDIT_MENU_TABLE",
    "10144": "EDIT_TEXT_TABLE",
    "9645": "SMENU_2",
    "9675": "RET_MENU_ERR",
    "9699": "RETMERR_2",
    "9729": "CALC_MODE",
    "9732": "RET_EDIT",
    "9770": "RET_EDIT_2",
    "9773": "RET_EDIT_3",
    "9811": "MAIN_WAIT_LOOP",
    "9833": "PROCESS_KEY",
    "9847": "PROCKEY_2",
    "9857": "PROCKEY_3",
    "9865": "PROCKEY_4",
    "9876": "PROCKEY_5",
    "9883": "TOGGLE_KH",
    "9910": "TOGGLE_KH_2",
    "9913": "TOGGLE_KH_3",
    "9915": "SEL_LOW_SCREEN",
    "9934": "SEL_UPP_SCREEN",
    "9945": "SELUPP_2",
    "9959": "ERR_BEEP",
    "9964": "ERR_BEEP_2",
    "9972": "ERR_BEEP_3",
    "9978": "SUCCESS_BEEP",
    "9988": "MENU_KH",
    "10007": "SELECT_KH",
    "10030": "CURSOR_UP_KH",
    "10033": "CURSOR_DW_KH",
    "10034": "CURSOR_DW_KH_2",
    "10187": "CALC_MENU_TABLE",
    "10194": "CALC_MENU_TEXT",
    "10219": "TAPE_LDR_TEXT",
    "10257": "EDT_OPT",
    "10262": "TAPE_TEST_OPT",
    "10268": "EXIT_OPT",
    "10289": "TAPE_LOAD_OPT",
    "10321": "RENUM_OPT",
    "10338": "PRINT_OPT",
    "10341": "EDIT_OPT_2",
    "10356": "EDIT_OPT_3",
    "10373": "CALC_OPT",
    "10417": "ED_OPT_4",
    "10430": "RES_CURPOS",
    "10439": "RET_MAIN_MENU",
    "10449": "MS_ERR_CURS_SET",
    "10463": "INIT_LWS_SET",
    "10456": "MS_LW_CURS_SET",
    "10472": "INIT_UPS_SET",
    "10481": "HANDLE_KEY_CODE",
    "10523": "DELRIGHT_KH",
    "10539": "DEL_KH",
    "10564": "ENTER_KH",
    "10590": "ENTER_KH_2",
    "10602": "ENTER_KH_3",
    "10618": "ENTER_KH_4",
    "10623": "ENTER_KH_5",
    "10627": "TOP_OF_PR_KH",
    "10667": "END_OF_PR_KH",
    "10708": "WLEFT_KH",
    "10732": "REMOVE_CURS",
    "10738": "SHOW_CURS",
    "10759": "FETCH_CURS",
    "10769": "STORE_CURS",
    "10778": "GETC_EDITBUF",
    "10789": "DW_10L_KH",
    "10795": "DW_10L0_KH_2",
    "10818": "DW_10L_KH_3",
    "10831": "UP_10L_KH",
    "10837": "UP_10L_KH_2",
    "10861": "UP_10L_KH_3",
    "10874": "EOL_KH",
    "10887": "SOL_KH",
    "10900": "CUR_UP_KH",
    "10933": "CUR_DOWN_KH",
    "10967": "CUR_LEFT_KH",
    "10979": "CUR_RIGHT_KH",
    "10744": "DISP_CURS",
    "11001": "FCL_EDPOS_RTHL",
    "11010": "FCL_EDPOS_LTHR",
    "11019": "INS_BASIC_SHDW",
    "11053": "INSB_SHDW_2",
    "11055": "INSB_SHDW_3",
    "11056": "INS_BASIC_SHUP",
    "11071": "INSB_SHUP_2",
    "11096": "INSB_SHUP_3",
    "11098": "INSB_SHUP_4",
    "11099": "FN_EDPOS_LWA",
    "11110": "FN_LWA_2",
    "11128": "FN_EDPOS_RWA",
    "11141": "FN_RWA_2",
    "11200": "FN_RWA_3",
    "11220": "FN_EDPOS_PCR",
    "11231": "FN_EDPOS_L",
    "11242": "FN_STW_L",
    "11244": "FN_STW_L_2",
    "11256": "FN_STW_L_3",
    "11271": "FN_STW_L_4"
  },
  "Comments": {
    "0": "Ensure interrupts are disabled.",
    "2865": "Advance to the next character.",
    "7": "[There is no RST $08. No instruction fetch at $0008 hence ZX Interface 1 will not be paged in from this ROM. Credit: Paul Farrow].",
    "9": "to the main reset routine.",
    "12": "[Spare bytes]",
    "20": "[Spare bytes]",
    "28": "[Spare bytes]",
    "36": "[Spare bytes]",
    "40": "Get the address after the RST $28 into HL, saving HL on the stack.",
    "41": "saving HL on the stack.",
    "42": "Save the AF registers.",
    "43": "Point HL to the byte after",
    "44": "the required address.",
    "48": "(There is no RST $30)",
    "49": "Fetch the second address byte.",
    "50": "HL=Subroutine to call.",
    "51": "Restore AF.",
    "52": "Jump ahead to continue.",
    "55": "[Spare byte]",
    "56": "Save HL register pair.",
    "57": "Return address of $0048 (ROM 0).",
    "61": "$5B00. Address of swap ROM routine held in RAM at $5B00.",
    "65": "Maskable interrupt routine address $0038 (ROM 0).",
    "69": "$5B00. Switch to other ROM (ROM 1) via routine held in RAM at $5B00.",
    "72": "Restore the HL register pair.",
    "73": "End of interrupt routine.",
    "77": "ROM 0, Bank 0, Screen 0, 128K mode.",
    "78": "Ensure interrupts are disabled whilst paging.",
    "81": "$5B5C. Note the new paging status.",
    "84": "Re-enable interrupts.",
    "85": "A=$FF.",
    "86": "Set ERR_NR to no error ($FF).",
    "89": "Jump ahead to continue.",
    "92": "Save the address in ROM 0 to call.",
    "95": "HL='Return to ROM 0' routine held in RAM.",
    "98": "Stack HL.",
    "99": "Save previous stack address.",
    "100": "Produce error report.",
    "103": "Stack HL.",
    "104": "Switch to other ROM (ROM 1) and return to address to call.",
    "107": "Save AF and BC.",
    "115": "Select other ROM.",
    "117": "Disable interrupts whilst switching ROMs.",
    "121": "Switch to the other ROM.",
    "124": "Restore BC and AF.",
    "127": "Toggle to the other ROM.",
    "135": "Return to the address held in RETADDR.",
    "136": "Ensure interrupts are disabled whilst paging.",
    "137": "Fetch current paging configuration.",
    "140": "Select ROM 0.",
    "142": "Save the new configuration",
    "148": "Switch to ROM 0.",
    "151": "Jump to ONERR_CONT (ROM 0) to continue.",
    "154": "RS232 input routine within ROM 0.",
    "159": "RS232 output routine within ROM 0.",
    "162": "Save AF registers.",
    "166": "Fetch the current paging configuration",
    "169": "and save it.",
    "170": "Select ROM 0.",
    "172": "Ensure interrupts are disabled whilst paging.",
    "173": "Store the new paging configuration.",
    "176": "Switch to ROM 0.",
    "178": "Jump to the RS232 channel input/output handler routine.",
    "181": "Save AF registers. For a read, A holds the byte read and the flags the success status.",
    "182": "Retrieve original paging configuration.",
    "186": "Ensure interrupts are disabled whilst paging.",
    "187": "Store original paging configuration.",
    "190": "Switch back to original paging configuration.",
    "193": "Restore AF registers. For a read, A holds the byte read and the flags the success status.",
    "195": "Fetch the address to call.",
    "198": "and execute it.",
    "199": "Loop through all RAM banks.",
    "202": "Save B register.",
    "203": "RAM bank number 0 to 7. 128K mode, ROM 0, Screen 0.",
    "207": "Switch RAM bank.",
    "209": "Start of the current RAM bank.",
    "215": "All 16K of RAM bank.",
    "220": "Store $FF into RAM location.",
    "221": "Check RAM integrity.",
    "222": "Jump if RAM error found.",
    "225": "Store $00 into RAM location.",
    "226": "Check RAM integrity.",
    "227": "Jump if difference found.",
    "229": "Clear the whole page",
    "231": "Restore B registers.",
    "234": "Signal no communications in progress to the keypad.",
    "243": "BC=$FFFD, DE=$FFBF.",
    "246": "Select AY register 14.",
    "248": "BC=$BFFD.",
    "251": "Set AY register 14 to $FF. This will force a communications reset to the keypad if present.",
    "255": "[Spare byte]",
    "256": "BASIC interpreter parser.",
    "259": "'Line Run' entry point.",
    "262": "Transfer bytes to logical RAM bank 4.",
    "265": "Transfer bytes from logical RAM bank 4.",
    "268": "128K error routine.",
    "271": "Error routine. Called from patch at $3B3B in ROM 1.",
    "274": "'Statement Return' routine. Called from patch at $3B4D in ROM 1.",
    "277": "'Statement Next' routine. Called from patch at $3B5D in ROM 1.",
    "280": "Scan the keypad.",
    "283": "Play music strings.",
    "286": "MIDI byte output routine.",
    "289": "RS232 byte input routine.",
    "292": "RS232 text output routine.",
    "295": "RS232 byte output routine.",
    "298": "COPY (screen dump) routine.",
    "301": "Call keypad scan routine in ROM 1.",
    "302": "$3B01. [*BUG* - The address jumps into the middle of the keypad decode routine in ROM 1. It looks like it is supposed to deal with the keypad and so the most likely addresses are $3A42 (read keypad) or $39A0 (scan keypad). At $3C01 in ROM 1 is a vector jump command to $39A0 to scan the keypad and this is similar enough to the $3B01 to imply a simple error in one of the bytes. Credit: Paul Farrow]",
    "305": "Retrieve RAM bank number + 1 in B.",
    "306": "Indicate which RAM bank failed by",
    "307": "setting the border colour.",
    "309": "Infinite loop.",
    "311": "Complete setting up the sound chip registers.",
    "314": "Select AY register 7.",
    "317": "Disable AY-3-8912 sound channels.",
    "321": "Copy the various paging routines to the old printer buffer.",
    "324": "The source is in this ROM.",
    "327": "There are eighty eight bytes to copy.",
    "330": "Copy the block of bytes.",
    "332": "Load A with the code for the Z80 instruction 'RST $08'.",
    "334": "Insert into new System Variable RAMRST.",
    "337": "Set the stack pointer to last location of old buffer.",
    "342": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "345": "First free entry in RAM disk.",
    "368": "AHL=Free space in RAM disk.",
    "370": "$5B85. Current address.",
    "373": "$5B87. Current RAM bank.",
    "378": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "381": "Load HL with known last working byte - 65535.",
    "384": "Set physical RAM top to 65535.",
    "387": "Set DE to address of the last bitmap of 'U' in ROM 1.",
    "390": "There are 21 User Defined Graphics to copy.",
    "393": "Swap so destination is $FFFF.",
    "395": "(MAKE_ROOM+#000C) Calling this address (LDDR/RET) in the main ROM cleverly copies the 21 characters to the end of RAM.",
    "397": "Transfer DE to HL.",
    "398": "Increment to address first byte of UDG 'A'.",
    "399": "Update standard System Variable UDG.",
    "403": "Set values 0 for PIP and 64 for RASP.",
    "406": "Update standard System Variables RASP and PIP.",
    "410": "Update standard System Variable RAMTOP - the last byte of the BASIC system area. Any machine code and graphics above this address are protected from NEW.",
    "413": "(CHAR_SET-#0100) Set HL to where, in theory character zero would be.",
    "416": "Update standard System Variable CHARS.",
    "419": "Load HL with value of System Variable RAMTOP.",
    "422": "Address next location.",
    "423": "Set the Stack Pointer.",
    "424": "Select Interrupt Mode 1.",
    "426": "Set the IY register to address the standard System Variables and many of the new System Variables and even those of ZX Interface 1 in some cases.",
    "430": "FLAGS. Signal 128K mode. [This bit was unused and therefore never set by 48K BASIC]",
    "434": "With a stack and the IY register set, interrupts can be enabled.",
    "435": "Set HL to eleven, timing constant for 9600 baud.",
    "438": "Select default RS232 baud rate of 9600 baud.",
    "441": "Clear accumulator.",
    "442": "Indicate no byte waiting in RS232 receive buffer.",
    "445": "Set RS232 output column position to 0.",
    "448": "Indicate no control code parameters expected.",
    "451": "[*BUG* - Should write to RAM bank 7. Main RAM has now been corrupted. The value stored is subsequently never used. Credit: Geoff Wearmouth]",
    "454": "This is a remnant from the Spanish 128, which used this workspace variable to hold the location of the Screen Buffer, but it also suffered from this bug. In fact there was never a need to write to the value at this point since it is written again later during the initialisation process. [The 1985 Sinclair Research ESPAGNOL source code says that this instruction will write to the (previously cleared) main BASIC RAM during initialization but that a different page of RAM will be present during NEW. Stuff and Nonsense! Assemblers and other utilities present above RAMTOP will be corrupted by the BASIC NEW command since $FF24, and later $EC13, will be written to even if they are above RAMTOP.]",
    "457": "Default to a printer width of 80 columns.",
    "459": "Set RS232 printer output width.",
    "462": "Use 10 as the initial renumber line and increment.",
    "465": "Store the initial line number when renumbering.",
    "468": "Store the renumber line increment.",
    "471": "Address after the System Variables.",
    "474": "Set the default location for the channel area.",
    "477": "Point to Initial Channel Information in this ROM. This is similar to that in main ROM but channel 'P' has input and output addresses in the new $5Bxx region.",
    "480": "There are 21 bytes to copy.",
    "483": "Switch pointer so destination is CHANS.",
    "484": "Copy the block of bytes.",
    "487": "Decrement to point to channel information end-marker.",
    "488": "Set the default address of the terminator for the last DATA item.",
    "492": "Set the default address of the BASIC program area.",
    "495": "Set the default address of the BASIC variables area.",
    "498": "Insert the Variables end-marker.",
    "501": "Set the default address of the editing line area.",
    "504": "Insert a carriage return.",
    "507": "Insert the editing line end-marker.",
    "510": "Set the address of the workspace.",
    "513": "Set the address of the start of the calculator stack.",
    "516": "Set the address of the end of the calculator stack.",
    "519": "Attribute colour of black ink on white paper.",
    "521": "Set the permanent attribute colour.",
    "524": "Set the permanent attribute mask.",
    "527": "Set the default border colour.",
    "531": "Temporary P_FLAG. Clear the temporary store for P-FLAG. [*BUG* - Should write this to RAM bank 7. Main RAM has now been corrupted again. The effect of the bug can be seen by typing INVERSE 1: PRINT \"Hello\", followed by NEW, followed by PRINT \"World\", and will cause the second word to also be printed in inverse. Credit: Geoff Wearmouth]",
    "536": "Set the border white.",
    "538": "The values five and thirty five.",
    "541": "Set the default values for key delay and key repeat.",
    "544": "Set KSTATE+0 to $FF.",
    "547": "Set KSTATE+4 to $FF.",
    "550": "Address of the Initial Stream Data within this ROM (which is identical to that in main ROM).",
    "1417": "K channel output routine.",
    "1419": "K channel input routine.",
    "1421": "Channel identifier 'K'.",
    "1422": "S channel output routine.",
    "1424": "S channel input routine.",
    "1426": "Channel identifier 'S'.",
    "1427": "R channel output routine.",
    "1429": "R channel input routine.",
    "1431": "Channel identifier 'R'.",
    "1432": "P Channel output routine.",
    "1434": "P Channel input routine.",
    "1436": "Channel identifier 'P'.",
    "1437": "End marker.",
    "1438": "Stream $FD leads to channel 'K'.",
    "1440": "Stream $FE leads to channel 'S'.",
    "1442": "Stream $FF leads to channel 'R'.",
    "1444": "Stream $00 leads to channel 'K'.",
    "1446": "Stream $01 leads to channel 'K'.",
    "1448": "Stream $02 leads to channel 'S'.",
    "1450": "Stream $03 leads to channel 'P'.",
    "553": "Address of the system variable holding the channels attached to streams data.",
    "559": "Initialise the streams system variables.",
    "561": "FLAGS. Signal printer not is use.",
    "565": "ERR_NR. Signal no error.",
    "569": "DF_SZ. Set the lower screen size to two rows.",
    "576": "Attempt to display TV tuning test screen.",
    "577": "$3C04. Will return if BREAK is not being pressed.",
    "579": "Address of the Sinclair copyright message.",
    "582": "Display the copyright message.",
    "585": "DF_SZ. Set the lower screen size to two rows.",
    "589": "TV_FLAG. Signal lower screen will require clearing.",
    "596": "Use the temporary stack as the previous stack.",
    "599": "Use Workspace RAM configuration (physical RAM bank 7).",
    "602": "Set colours to black ink on white paper.",
    "604": "Temporary ATTR_T used by the 128 BASIC Editor.",
    "607": "Temporary ATTR_P used by the 128 BASIC Editor.",
    "610": "Initialise mode and cursor settings. IX will point at editing settings information.",
    "613": "Use Normal RAM Configuration (physical RAM bank 0).",
    "616": "Jump to show the Main menu.",
    "622": "Select BASIC/Calculator mode.",
    "624": "ERR_NR. Set to '0 OK' status.",
    "628": "DF_SZ. Reset the number of rows in the lower screen.",
    "632": "Return address should an error occur.",
    "635": "Stack it.",
    "636": "Save the stack pointer in ERR_SP.",
    "640": "Return address in ROM 0 after syntax checking.",
    "643": "Store it in SYNRET.",
    "646": "Point to start of typed in BASIC command.",
    "649": "Is the first character a function token, i.e. the start of a numerical expression?",
    "652": "Jump if so to evaluate it.",
    "655": "\"(\": Is the first character the start of an expression?",
    "657": "Jump if so to evaluate it.",
    "660": "\"-\": Is the first character the start of an expression?",
    "665": "\"+\": Is the first character the start of an expression?",
    "662": "Jump if so to evaluate it.",
    "667": "Jump if so to evaluate it.",
    "670": "Is text just a number or a numerical expression?",
    "673": "Jump if a numerical expression to evaluate it.",
    "676": "Use Workspace RAM configuration (physical RAM bank 7).",
    "679": "Fetch mode.",
    "682": "Use Normal RAM Configuration (physical RAM bank 0).",
    "685": "Calculator mode?",
    "687": "Jump if not to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "690": "Is it a single LET command?",
    "693": "Jump if so to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "696": "Drop ONERR return address.",
    "698": "Test ERR_NR.",
    "702": "Jump ahead if no error.",
    "705": "Point to start of editing area.",
    "704": "Simply return if an error.",
    "708": "Store in CH_ADD.",
    "712": "Call E_LINE_NO in ROM 1 to read the line number into editing area.",
    "716": "Jump ahead if there was a line number.",
    "719": "Get character.",
    "720": "End of the line reached, i.e. no BASIC statement?",
    "722": "Return if so.",
    "723": "Clear screen if it requires it.",
    "726": "TVFLAG. Clear lower screen?",
    "730": "Jump ahead if no need to clear lower screen.",
    "735": "TVFLAG. Signal to clear lower screen.",
    "739": "Use Workspace RAM configuration (physical RAM bank 7).",
    "742": "Editor flags.",
    "745": "Using lower screen area for editing?",
    "747": "Jump ahead if so.",
    "750": "Fetch the mode.",
    "751": "In Edit Menu mode?",
    "753": "If so then clear lower editing area display.",
    "756": "Use Normal RAM Configuration (physical RAM bank 0).",
    "762": "Signal mode has not changed.",
    "764": "25.",
    "766": "S_POSN+1. Subtract the current print row position.",
    "769": "Set the number of scrolls.",
    "772": "FLAGS. Not syntax checking.",
    "776": "NSPPC. Set line to be jumped to as line 1.",
    "780": "The end of GO SUB stack marker.",
    "783": "Place it on the stack.",
    "784": "The return address should an error occur.",
    "787": "Place it on the stack.",
    "788": "Store error routine address.",
    "792": "Address of error handler routine in ROM 0.",
    "795": "Store it in SYNRET.",
    "798": "Jump ahead to the main parser routine to execute the line.",
    "805": "Reset SP to top of memory map.",
    "809": "Use the temporary stack as the previous stack.",
    "812": "Trap error conditions where interrupts are disabled.",
    "813": "FLAGS. Signal no new key.",
    "820": "Editing RAM disk catalogue?",
    "822": "Jump if not.",
    "824": "Use Workspace RAM configuration (physical RAM bank 7).",
    "831": "Catalogue entry size.",
    "834": "Remove last entry.",
    "836": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "839": "Use Normal RAM Configuration (physical RAM bank 0).",
    "842": "Fetch error number from ERR_NR.",
    "845": "Increment to give true error code.",
    "846": "Save the error code.",
    "850": "FLAGX. Ensure not INPUT mode.",
    "853": "X_PTR_hi. Clear to suppress error '?' marker.",
    "856": "Clear to signal no defined function is currently being evaluated.",
    "859": "[Could have saved 2 bytes by using INC L].",
    "862": "STRMS+$0006. Ensure STRMS-00 specifies the keyboard.",
    "865": "Clears editing area and areas after it.",
    "868": "Clears editing area and areas after it.",
    "873": "Clear lower editing screen.",
    "875": "TVFLAG. Signal lower screen requires clearing.",
    "879": "Retrieve error code.",
    "880": "Store error code in B.",
    "881": "Is it a numeric error code (1-9), i.e. suitable for immediate display?",
    "883": "If so jump ahead to display it.",
    "885": "Is it one of the standard errors (A-R)?",
    "887": "If so jump ahead to convert it into an upper case letter.",
    "889": "Otherwise convert it into a lower case letter.",
    "891": "Jump ahead to display it. [Could have saved 2 bytes by using ADD A,$0C instead of these two instructions]",
    "893": "Increase code to point to upper case letters.",
    "896": "Display the character held in the A register.",
    "898": "Display a space.",
    "901": "Retrieve the error code.",
    "902": "Is it one of the standard errors (A-R)?",
    "904": "Jump if an standard error message (A-R).",
    "906": "A=Code $00 - $0E.",
    "915": "Find address in error message vector table.",
    "910": "Pass code to BC.",
    "918": "DE=Address of message to print.",
    "919": "Print error message.",
    "930": "Select the first message \", \" (a 'comma' and a 'space').",
    "922": "Jump ahead.",
    "924": "Position of the error messages in ROM 1.",
    "928": "Call message printing routine.",
    "931": "$1536. Message base address in ROM 1.",
    "935": "Print a comma followed by a space.",
    "937": "Fetch current line number.",
    "942": "Print the line number.",
    "944": "Print ':'.",
    "947": "SUBPPC. Fetch current statement number.",
    "953": "Print the statement number.",
    "956": "Clear editing and workspace areas.",
    "958": "Fetch the error code.",
    "962": "Jump ahead for \"0 OK\".",
    "966": "Jump for \"A Invalid argument\", thereby advancing to the next statement.",
    "970": "Jump unless \"M Ramtop no good\".",
    "972": "SUBPPC. Advance to the next statement.",
    "978": "Continue statement number.",
    "981": "Next statement number.",
    "984": "Is there a statement number?",
    "986": "Jump if so.",
    "988": "HL=SUBPPC. The current statement number.",
    "989": "Copy SUBPPC and PPC to OSPPC and OLDPPC, for use by CONTINUE.",
    "991": "NSPPC. Signal no current statement number.",
    "995": "FLAGS. Select K-Mode.",
    "1002": "Select 128 Editor mode.",
    "1004": "Jump ahead to return control to the Editor.",
    "1007": "Error code 'G - No room for line'.",
    "1012": "Jump to print the error code.",
    "1015": "Store the line as the current line number with the program cursor.",
    "1019": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1022": "[This test could have been performed before paging in bank 7 and hence could have benefited from a slight speed improvement.",
    "1023": "The test is redundant since BC holds a non-zero line number]",
    "1024": "Jump if no line number",
    "1026": "Current edit line number. [Redundant instruction - Line number has already been stored]",
    "1030": "Temporary E_PPC used by BASIC Editor.",
    "1034": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1037": "Point to the next character in the BASIC line.",
    "1041": "Address of error handler routine should there be no room for the line.",
    "1044": "Stack it.",
    "1049": "HL=Length of BASIC line.",
    "1051": "Stack it.",
    "1053": "Transfer edit line number to HL.",
    "1055": "Returns address of the line in HL.",
    "1057": "Jump if the line does not exist.",
    "1060": "Find the address of the next line.",
    "1063": "Delete the line.",
    "1065": "BC=Length of the BASIC line.",
    "1067": "Is it 1, i.e. just an 'Enter' character, and hence only",
    "1068": "a line number was entered?",
    "1069": "Jump if there is a BASIC statement.",
    "1071": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1074": "Save the address of the line.",
    "1075": "Fetch current edit line number.",
    "1078": "Find closest line number (or $0000 if no line).",
    "1081": "Store current edit line number. Effectively refresh E_PPC.",
    "1084": "HL=Address of the line.",
    "1085": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1088": "Jump ahead to exit.",
    "1090": "BC=Length of the BASIC line. Stack it.",
    "1094": "BC=BC+4. Allow for line number and length bytes.",
    "1095": "Point to before the current line, i.e. the location to insert bytes at.",
    "1096": "Get start address of the BASIC program.",
    "1100": "Stack it.",
    "1102": "Insert BC spaces at address HL.",
    "1104": "HL=Start address of BASIC program.",
    "1105": "Save start address of BASIC program.",
    "1108": "BC=Length of the BASIC line.",
    "1110": "Point to the first location of the newly created space.",
    "1111": "Address of end of the BASIC line in the workspace.",
    "1115": "Skip over the newline and terminator bytes.",
    "1116": "Copy the BASIC line from the workspace into the program area.",
    "1118": "Current edit line number.",
    "1122": "BC=Length of BASIC line.",
    "1123": "Store the line length.",
    "1127": "DE=line number.",
    "1129": "Store the line number.",
    "1130": "Drop item (address of error handler routine).",
    "1131": "Exit with HL=Address of the line.",
    "1132": "Error report 'a'.",
    "1134": "Error report 'b'.",
    "1136": "Error report 'c'.",
    "1138": "Error report 'd'.",
    "1140": "Error report 'e'.",
    "1142": "Error report 'f'.",
    "1144": "Error report 'g'.",
    "1146": "Error report 'h'.",
    "1148": "Error report 'i'.",
    "1150": "Error report 'j'.",
    "1152": "Error report 'k'.",
    "1154": "Error report 'l'.",
    "1156": "Error report 'm'.",
    "1158": "Error report 'n'.",
    "1160": "Error report 'o'.",
    "1162": "Error report 'p'.",
    "1164": "\"MERGE error\"",
    "1175": "\"Wrong file type\"",
    "1190": "\"CODE error\"",
    "1200": "\"Too many brackets\"",
    "1217": "\"File already exists\"",
    "1236": "\"Invalid name\"",
    "1248": "\"File does not exist\"",
    "1267": "\"Invalid device\"",
    "1281": "\"Invalid baud rate\"",
    "1298": "\"Invalid note name\"",
    "1315": "\"Number too big\"",
    "1329": "\"Note out of range\" ",
    "1346": "\"Out of range\"",
    "1358": "\"Too many tied notes\"",
    "1377": "\"(c) 1986 Sinclair Research Ltd\"",
    "1405": "Fetch next byte.",
    "1406": "Mask off top bit.",
    "1408": "Save address of current message byte.",
    "1409": "Print character.",
    "1410": "Restore message byte pointer.",
    "1413": "Carry flag will be set if byte is $FF.",
    "1414": "Else print next character.",
    "1452": "Point to the error byte.",
    "1456": "ROM 0, Screen 0, Bank 0, 128 mode.",
    "1457": "Ensure interrupts disable whilst paging.",
    "1458": "Store new state in BANK_M.",
    "1461": "Switch to ROM 0.",
    "1464": "Restore SP from ERR_SP.",
    "1468": "Fetch the error number.",
    "1469": "Store the error number.",
    "1473": "[*BUG* - This should be $1D. As such, error code 'a' will be diverted to ROM 1 for handling. Credit: Paul Farrow]",
    "1478": "Call the error handler routine in ROM 1.",
    "1481": "Store in ERR_NR.",
    "1487": "Set up the address of the character after the '?' marker.",
    "1491": "Set the calculator stack.",
    "1493": "Return to the error routine.",
    "1494": "Read keyboard row B - SPACE.",
    "1498": "Extract the SPACE key.",
    "1499": "Return if SPACE not pressed.",
    "1500": "Read keyboard row CAPS SHIFT - V.",
    "1504": "Extract the CAPS SHIFT key.",
    "1505": "Return if CAPS SHIFT not pressed.",
    "1506": "Produce an error.",
    "1509": "\"L Break into program\"",
    "1510": "Enabled interrupts.",
    "1511": "Save AF registers.",
    "1512": "Address of the RS232 exit routine held in RAM.",
    "1515": "Stack it.",
    "1516": "TVFLAG. Indicate not automatic listing.",
    "1520": "Save the input/output routine address.",
    "1521": "Fetch location of error handler routine from ERR_SP.",
    "1526": "DE=Address of error handler routine.",
    "1528": "ED_ERROR in ROM 1.",
    "1533": "Jump if error handler address is different, i.e. due to INKEY$# or PRINT#.",
    "1535": "Retrieve the input/output routine address.",
    "1540": "Discard the error handler routine address.",
    "1541": "Fetch the original address of ERR_SP (this was stacked at the beginning of the INPUT routine in ROM 1).",
    "1546": "Save the input/output routine address.",
    "1547": "Address to return to.",
    "1550": "Stack the address.",
    "1551": "Jump to the RS232 input/output routine.",
    "1552": "Jump if a character was received.",
    "1554": "Jump if a character was not received.",
    "1556": "Produce an error \"8 End of file\".",
    "1560": "Retrieve the input routine address.",
    "1561": "Jump back to await another character.",
    "1563": "Is it a carriage return?",
    "1567": "Fetch the return address.",
    "1572": "Insert the character into the INPUT line.",
    "1575": "Restore the return address.",
    "1578": "Retrieve the input routine address.",
    "1579": "Jump back to await another character.",
    "1581": "Discard the input routine address.",
    "1582": "Fetch current paging configuration.",
    "1585": "Select ROM 1.",
    "1587": "Stack the required paging configuration.",
    "1588": "Exit",
    "1591": "Retrieve the input/output routine address.",
    "1595": "Stack the return address.",
    "1596": "Jump to input or output routine.",
    "1597": "Return if a character was received.",
    "1598": "Return if a character was not received or was written.",
    "1599": "Produce error report \"8 End of file\".",
    "1601": "[Could just do RST $18]",
    "1348": "Get an expression.",
    "1604": "Get an expression.",
    "1607": "FLAGS.",
    "1611": "Jump ahead if syntax checking.",
    "1613": "Fetch the expression.",
    "1619": "Jump ahead if string is 1 character long.",
    "1621": "Produce error report.",
    "1624": "\"i Invalid device\".",
    "1625": "Get character.",
    "1626": "Convert to upper case.",
    "1628": "\"P\". Is it channel 'P'?",
    "1630": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1633": "Next character to be interpreted.",
    "1637": "Next character must be ';'.",
    "1639": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1642": "Skip past the ';' character.",
    "1645": "Get a numeric expression from the line.",
    "1648": "FLAGS. Checking syntax mode?",
    "1652": "Jump ahead if so.",
    "1654": "Get the result as an integer.",
    "1657": "Store the result temporarily for use later.",
    "1661": "[Could just do RST $18]",
    "1662": "Get the next character in the BASIC line.",
    "1664": "It should be ENTER.",
    "1666": "Jump ahead if it is.",
    "1668": "Or the character is allowed to be ':'.",
    "1670": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1673": "Check for end of line.",
    "1676": "Get the baud rate saved earlier.",
    "1681": "Is it zero?",
    "1682": "Jump if not, i.e. a numeric value was specified.",
    "1684": "Produce error report.",
    "1687": "\"j invalid baud rate\"",
    "1720": "Baud=50.",
    "1724": "Baud=110.",
    "1728": "Baud=300.",
    "1732": "Baud=600.",
    "1736": "Baud=1200.",
    "1740": "Baud=2400.",
    "1744": "Baud=4800.",
    "1748": "Baud=9600.",
    "1688": "Table of supported baud rates.",
    "1695": "HL=Supported baud rate value.",
    "1697": "Reached the last baud rate value in the table?",
    "1699": "Jump is so to use a default baud rate of 9600.",
    "1702": "Table entry matches or is higher than requested baud rate?",
    "1704": "Jump ahead if so to use this baud rate.",
    "1707": "Skip past the timing constant value",
    "1708": "for this baud rate entry.",
    "1711": "HL points to timing value for the baud rate.",
    "1714": "DE=Timing value for the baud rate.",
    "1715": "Store new value in system variable BAUD.",
    "1752": "SERFL holds second char that can be received",
    "1755": "Is the second-character received flag set?",
    "1756": "i.e. have we already received data?",
    "1757": "Jump ahead if not.",
    "1759": "Otherwise clear the flag",
    "1762": "and return the data which we received earlier.",
    "1763": "Set carry flag to indicate success",
    "1765": "Check the BREAK key, and produce error message if it is being pressed.",
    "1768": "Ensure interrupts are disabled to achieve accurate timing.",
    "1770": "Fetch the baud rate timing constant.",
    "1779": "HL=BAUD/2. So that will sync to half way point in each bit.",
    "1781": "[Redundant byte]",
    "1782": "Waiting time for start bit.",
    "1784": "Save B.",
    "1794": "Selects register 14, port I/O of AY-3-8912.",
    "1796": "Read the current state of the I/O lines.",
    "1798": "%11110000. Default all input lines to 1.",
    "1800": "%11111011. Force CTS line to 0.",
    "1802": "B=$BF.",
    "1803": "Make CTS (Clear To Send) low to indicate ready to receive.",
    "1805": "Store status of other I/O lines.",
    "1807": "Read the input line.",
    "1809": "%10000000. Test TXD (input) line.",
    "1811": "Jump if START BIT found.",
    "1813": "Fetch timeout counter",
    "1814": "and decrement it.",
    "1815": "Store it.",
    "1816": "Continue to wait for start bit if not timed out.",
    "1818": "Reset carry flag to indicate no byte read.",
    "1819": "Save the failure flag.",
    "1820": "Timed out waiting for START BIT.",
    "1822": "Second test of START BIT - it should still be 0.",
    "1824": "Test TXD (input) line.",
    "1826": "Jump back if it is no longer 0.",
    "1828": "Third test of START BIT - it should still be 0.",
    "1830": "Test TXD (input) line.",
    "1832": "Jump back if it is no longer 0.",
    "1838": "Preload A with the START BIT. It forms a shift counter used to count",
    "1840": "the number of bits to read in.",
    "1841": "HL=1.5*(BAUD).",
    "1842": "(4) Fine tune the following delay.",
    "1846": "(6) Delay for 26*BAUD.",
    "1847": "(4)",
    "1848": "(4)",
    "1849": "(12) Jump back to until delay completed.",
    "1851": "Read a bit.",
    "1853": "Test TXD (input) line.",
    "1855": "Jump if a 0 received.",
    "1867": "Fetch the bit counter.",
    "1858": "Fetch the bit counter.",
    "1859": "Set carry flag to indicate received a 1.",
    "1860": "Shift received bit into the byte (C->76543210->C).",
    "1861": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1863": "Save the bit counter.",
    "1864": "Jump back to read the next bit.",
    "1868": "Clear carry flag to indicate received a 0.",
    "1869": "Shift received bit into the byte (C->76543210->C).",
    "1870": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1872": "Save the bit counter.",
    "1873": "Jump back to read next bit.",
    "1876": "Signal success.",
    "1877": "Push success flag.",
    "1880": "A=%1111x1xx. Force CTS line to 1.",
    "1882": "B=$BF.",
    "1883": "Make CTS (Clear To Send) high to indicate not ready to receive.",
    "1887": "HL=(BAUD).",
    "1892": "HL=(BAUD)-7.",
    "1894": "Delay for the stop bit.",
    "1897": "Jump back until delay completed.",
    "1899": "HL will be $0000.",
    "1902": "DE=(BAUD).",
    "1904": "HL=3*(BAUD). This is how long to wait for the next start bit.",
    "1905": "Read the input line.",
    "1907": "%10000000. Test TXD (input) line.",
    "1909": "Jump if START BIT found.",
    "1911": "Decrement timeout counter.",
    "1914": "Jump back looping for a start bit until a timeout occurs.",
    "1916": "Return status of first byte read attempt - carry flag reset for no byte received or",
    "1917": "carry flag set and A holds the received byte.",
    "1919": "Second test of START BIT - it should still be 0.",
    "1921": "Test TXD (input) line.",
    "1923": "Jump back if it is no longer 0.",
    "1925": "Third test of START BIT - it should still be 0.",
    "1927": "Test TXD (input) line.",
    "1929": "Jump back if it is no longer 0.",
    "1932": "HL=(BAUD).",
    "1938": "HL=(BAUD)/2.",
    "1941": "HL=(BAUD)/2 - 2.",
    "1946": "Preload A with the START BIT. It forms a shift counter used to count",
    "1948": "the number of bits to read in.",
    "1949": "Fine tune the following delay.",
    "1953": "HL=1.5*(BAUD).",
    "1954": "Delay for 26*(BAUD).",
    "1957": "Jump back to until delay completed.",
    "1959": "Read a bit.",
    "1961": "Test TXD (input) line.",
    "1963": "Jump if a 0 received.",
    "1966": "Fetch the bit counter.",
    "1967": "Set carry flag to indicate received a 1.",
    "1968": "Shift received bit into the byte (C->76543210->C).",
    "1969": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1971": "Save the bit counter.",
    "1972": "Jump back to read the next bit.",
    "1975": "Fetch the bit counter.",
    "1976": "Clear carry flag to indicate received a 0.",
    "1977": "Shift received bit into the byte (C->76543210->C).",
    "1978": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1980": "Save the bit counter.",
    "1981": "Jump back to read next bit.",
    "1987": "Set the flag indicating a second byte is in the buffer.",
    "1990": "Store the second byte read in the buffer.",
    "1991": "Return the first byte.",
    "1992": "Re-enable interrupts.",
    "1994": "Save the character to print.",
    "1995": "Number of parameters expected.",
    "1999": "Jump if no parameters.",
    "2001": "Ignore the parameter.",
    "2005": "Jump ahead if we have not processed all parameters.",
    "2007": "Retrieve character to print.",
    "2008": "Jump ahead to continue.",
    "2011": "Retrieve character to print.",
    "2012": "TVDATA+1. Store it for use later.",
    "2016": "Retrieve character to print.",
    "2017": "Test against code for 'SPECTRUM'.",
    "2019": "Jump ahead if not a token.",
    "2021": "Save RETADDR temporarily.",
    "2026": "Print tokens via call to ROM 1 routine PO-T&UDG.",
    "2029": "Restore the original contents of RETADDR.",
    "2037": "Suppress printing a leading space.",
    "2039": "Is character to output a space?",
    "2043": "Signal leading space required.",
    "2041": "Jump ahead if not a space.",
    "2045": "Compare against copyright symbol.",
    "2047": "Jump ahead if not a graphic or UDG character.",
    "2049": "\"?\". Print a '?' for all graphic and UDG characters.",
    "2051": "Is it a control character?",
    "2053": "Jump ahead if so.",
    "2055": "Save the character to print.",
    "2056": "Point to the column number.",
    "2059": "Increment the column number.",
    "2060": "Fetch the number of columns.",
    "2064": "Jump if end of row not reached.",
    "2066": "Print a carriage return and line feed.",
    "2071": "Set the print position to column 1.",
    "2074": "Retrieve character to print.",
    "2075": "Jump ahead to print the character.",
    "2078": "Is it a carriage return?",
    "2080": "Jump ahead if not.",
    "2083": "Set the print position back to column 0.",
    "2088": "Print a carriage return.",
    "2093": "Print a line feed.",
    "2096": "Is it a comma?",
    "2098": "Jump ahead if not.",
    "2100": "Fetch the column position.",
    "2104": "Will count number of columns to move across to reach next comma position.",
    "2106": "Increment column counter.",
    "2107": "Increment column position.",
    "2109": "End of row reached?",
    "2110": "Jump if so.",
    "2114": "Jump if column 8, 16, 24 or 32 reached.",
    "2116": "Column position greater so subtract another 8.",
    "2118": "Jump back and increment column position again.",
    "2120": "Save column counter in E.",
    "2123": "Output a space via a recursive call.",
    "2126": "Retrieve column counter to E.",
    "2127": "More spaces to output?",
    "2128": "Return if no more to output.",
    "2129": "Repeat for the next space to output.",
    "2131": "Is it AT?",
    "2133": "Jump ahead to handle AT.",
    "2135": "Is it TAB?",
    "2137": "Jump ahead to handle TAB.",
    "2139": "Check for INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2141": "Ignore if not one of these.",
    "2142": "Jump ahead to handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2144": "Store the control code for use later, $16 (AT) or $17 (TAB).",
    "2147": "Two parameters expected (even for TAB).",
    "2152": "Return with zero flag set.",
    "2153": "Store the control code for use later.",
    "2156": "Two parameters expected. [*BUG* - Should be 1 parameter. 'LPRINT INK 4' will produce error report 'C Nonsense in BASIC'. Credit: Toni Baker, ZX Computing Monthly].",
    "2161": "[*BUG* - Should return with the carry flag reset and the zero flag set. It causes a statement such as 'LPRINT INK 1;' to produce error report '8 End of file'. It is due to the main RS232 processing loop using the state of the flags to determine the success/failure response of the RS232 output routine. Credit: Ian Collier (+3), Andrew Owen (128)] [The bug can be fixed by inserting a XOR A instruction before the RET instruction. Credit: Paul Farrow]",
    "2162": "D=Character to print.",
    "2163": "Fetch the control code.",
    "2166": "Is it AT?",
    "2170": "Is it TAB?",
    "2168": "Jump ahead to handle AT parameter.",
    "2172": "Disable interrupts to ensure accurate timing.",
    "2173": "Ignore if not TAB.",
    "2174": "TV_DATA+1. Fetch the saved parameter.",
    "2177": "Fetch parameter to D.",
    "2181": "Reached end of row?",
    "2182": "Jump ahead if so.",
    "2184": "Jump ahead if before end of row.",
    "2186": "(WIDTH).",
    "2187": "TAB/AT column position.",
    "2188": "TAB/AT position - WIDTH.",
    "2189": "The new required column position.",
    "2190": "Handle the new TAB/AT position.",
    "2192": "Fetch the desired column number.",
    "2194": "Jump to output a carriage return if column 0 required.",
    "2197": "Fetch the current column position.",
    "2200": "Compare against desired column position.",
    "2201": "Done if reached requested column.",
    "2202": "Save the number of spaces to output.",
    "2205": "Output a space via a recursive call.",
    "2208": "Retrieve number of spaces to output.",
    "2209": "Keep outputting spaces until desired column reached.",
    "2211": "Save the byte to send.",
    "2221": "Select AY register 14 to control the RS232 port.",
    "2223": "Check the BREAK key, and produce error message if it is being pressed.",
    "2226": "Read status of data register.",
    "2228": "%01000000. Test the DTR line.",
    "2230": "Jump back until device is ready for data.",
    "2232": "HL=Baud rate timing constant.",
    "2239": "DE=(BAUD)-2.",
    "2242": "Retrieve the byte to send.",
    "2243": "Invert the bits of the byte (RS232 logic is inverted).",
    "2244": "Carry is used to send START BIT.",
    "2245": "B=Number of bits to send (1 start + 8 data + 2 stop).",
    "2247": "Disable interrupts to ensure accurate timing.",
    "2248": "Save the number of bits to send.",
    "2249": "Save the data bits.",
    "2253": "HL=(BAUD)-2.",
    "2254": "AY-3-8912 data register.",
    "2257": "Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).",
    "2260": "Clear the RXD (out) line.",
    "2262": "Send out a 0 (high level).",
    "2264": "Jump ahead to continue with next bit.",
    "2266": "Set the RXD (out) line.",
    "2268": "Send out a 1 (low level).",
    "2270": "Jump ahead to continue with next bit. [We use theis unnecessary looking JR for timing]",
    "2272": "(6) Delay 26*BAUD cycles.",
    "2273": "(4)",
    "2274": "(4)",
    "2275": "(12) Jump back until delay is completed.",
    "2277": "(4) Fine tune the timing.",
    "2278": "(4)",
    "2279": "(4)",
    "2280": "Retrieve the data bits to send.",
    "2281": "Retrieve the number of bits left to send.",
    "2282": "Clear carry flag.",
    "2283": "Shift the next bit to send into the carry flag.",
    "2284": "Jump back to send next bit until all bits sent.",
    "2286": "Re-enable interrupts.",
    "2287": "Return with carry and zero flags reset.",
    "2288": "Half row counter.",
    "2291": "Set the half row counter to 43 half rows (will output 44 half rows in total).",
    "2293": "Point to printer configuration data (7/72 inch line spacing, double density bit graphics).",
    "2425": "6 characters follow.",
    "2426": "ESC '1'     - 7/72 inch line spacing.",
    "2428": "ESC 'L' 0 3 - Double density (768 bytes per row).",
    "2432": "1 character follows.",
    "2433": "Line feed.",
    "2434": "2 characters follow.",
    "2435": "ESC '2' - 1/6 inch line spacing.",
    "2296": "Send the configuration data to printer.",
    "2299": "Output a half row, at double height.",
    "2302": "Table holds a line feed only.",
    "2305": "Send a line feed to printer.",
    "2308": "The half row counter is tested to see if it is zero",
    "2311": "and if so then the line spacing is reset to its",
    "2312": "original value.",
    "2313": "Jump if done, resetting printer line spacing.",
    "2315": "Decrement half row counter.",
    "2316": "Repeat for the next half row.",
    "2318": "Point to printer configuration data (1/6 inch line spacing).",
    "2321": "Send the configuration data to printer.",
    "2324": "[Could have saved 1 byte by using JP $095F (ROM 0)]",
    "2325": "Pixel column counter.",
    "2328": "Set pixel column counter to 255 pixels.",
    "2330": "Output a column of pixels, at double height.",
    "2333": "Pixel column counter.",
    "2337": "Check if all pixels in this row have been output.",
    "2338": "Return if so.",
    "2339": "Decrement pixel column counter.",
    "2340": "Repeat for all pixels in this row.",
    "2342": "D=%11000000. Used to hold the double height pixel.",
    "2345": "C=Pixel column counter, B=Half row counter.",
    "2350": "B=2xB+1",
    "2353": "B=4xB+3. The pixel row coordinate.",
    "2355": "Pixel column counter.",
    "2357": "C=255-C. The pixel column coordinate.",
    "2358": "Clear A. Used to generate double height nibble of pixels to output.",
    "2361": "Save registers.",
    "2362": "Test whether pixel (B,C) is set",
    "2366": "Restore registers.",
    "2367": "Set double height pixel = 0.",
    "2369": "Jump if pixel is reset.",
    "2371": "The double height pixel to output (%11000000, %00110000, %00001100 or %00000011).",
    "2375": "Decrement half row coordinate.",
    "2373": "Add the double height pixel value to the byte to output.",
    "2378": "Create next double height pixel value (%00110000, %00001100 or %00000011).",
    "2382": "Repeat for all four pixels in the half row.",
    "2385": "Unload the stack.",
    "2387": "Send double height nibble of pixels output 3 times.",
    "2391": "Send byte to RS232 port.",
    "2399": "Get number of bytes to send.",
    "2400": "Point to the data to send.",
    "2401": "Retrieve value.",
    "2404": "Send byte to RS232 port.",
    "2409": "Point to next data byte to send.",
    "2410": "Repeat for all bytes.",
    "2414": "Get address of (B,C) pixel into HL and pixel position within byte into A.",
    "2416": "B=Pixel position within byte (0-7).",
    "2418": "Pixel mask.",
    "2419": "Carry flag holds bit to be rotated into the mask.",
    "2420": "Shift the mask bit into the required bit position.",
    "2423": "Isolate this pixel from A.",
    "2437": "Disable interrupts to ensure accurate timing.",
    "2445": "Calculate HL=$003C + ($0037 * B).",
    "2449": "BC=Space required (maximum = $01F4).",
    "2451": "Make BC bytes of space in the workspace.",
    "2453": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2455": "IY=Points at first new byte - the command data block.",
    "2458": "IX=Points at last new byte - byte after all channel information blocks.",
    "2460": "Initial channel bitmap with value meaning 'zero strings'",
    "2464": "$-37 ($37 bytes is the size of a play channel string information block).",
    "2467": "IX points to start of space for the last channel.",
    "2469": "Default octave is 5.",
    "2473": "No MIDI channel assigned.",
    "2477": "Default volume is 15.",
    "2481": "Default note duration.",
    "2485": "Count of the number of tied notes.",
    "2489": "Signal not to repeat the string indefinitely.",
    "2493": "No opening bracket nesting level.",
    "2497": "No closing bracket nesting level.",
    "2501": "Return address for closing bracket nesting level 0.",
    "2505": "[No need to initialise this since it is written to before it is ever tested]",
    "2510": "Get the details of the string from the stack.",
    "2512": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2513": "Store the current position within in the string, i.e. the beginning of it.",
    "2519": "Store the return position within the string for a closing bracket,",
    "2522": "which is initially the start of the string in case a single closing bracket is found.",
    "2525": "HL=Points to start of string. BC=Length of string.",
    "2526": "HL=Points to address of byte after the string.",
    "2527": "Store the address of the character just",
    "2530": "after the string.",
    "2533": "B=String index number (range 1 to 8).",
    "2534": "Save it on the stack again.",
    "2535": "Reduce the index so it ranges from 0 to 7.",
    "2539": "BC=String index*2.",
    "2543": "HL=Address of the command data block.",
    "2544": "Skip 8 channel data pointer words.",
    "2547": "BC=Address of current channel information block.",
    "2548": "Store the pointer to the channel information block.",
    "2551": "Clear the carry flag.",
    "2552": "Rotate one zero-bit into the least significant bit of the channel bitmap. This initially holds $FF but once this loop is over, this byte has a zero bit for each string parameter of the PLAY command.",
    "2556": "B=Current string index.",
    "2557": "Decrement string index so it ranges from 0 to 7.",
    "2558": "Save it for future use on the next iteration.",
    "2559": "Store the channel number.",
    "2562": "Jump back while more channel strings to process.",
    "2564": "Drop item left on the stack.",
    "2565": "Set the initial tempo timing value.",
    "2569": "Corresponds to a 'T' command value of 120, and gives two crotchets per second.",
    "2575": "HL=Points to the command data block.",
    "2580": "DE=Address to store RAM routine.",
    "2581": "HL=Address of the RAM routine bytes.",
    "2587": "Copy the calculator routine to RAM.",
    "2589": "Register 7 - Mixer.",
    "2591": "I/O ports are inputs, noise output off, tone output on.",
    "2593": "Write to sound generator register.",
    "2596": "Register 11 - Envelope Period (Fine).",
    "2598": "Set period to maximum.",
    "2600": "Write to sound generator register.",
    "2603": "Register 12 - Envelope Period (Coarse).",
    "2604": "Write to sound generator register.",
    "2607": "Jump ahead to continue. [Could have saved these 2 bytes by having the code at $0A7D (ROM 0) immediately follow]",
    "2609": "Invoke the floating point calculator.",
    "2610": "x, 10",
    "2611": "10, x",
    "2612": "10/x",
    "2619": "(10/x)/7.33e-6",
    "2627": "Return with carry flag set if SPACE not pressed.",
    "2633": "Return with carry flag set if CAPS not pressed.",
    "2634": "Offset to the channel data block duration pointers table.",
    "2637": "Jump ahead to continue.",
    "2639": "Offset to the channel data block pointers table.",
    "2644": "HL=Point to the command data block.",
    "2645": "Point to the desired channel pointers table.",
    "2649": "Store the start address of channels pointer table.",
    "2652": "Fetch the channel bitmap.",
    "2655": "Initialise the working copy.",
    "2658": "Channel selector. Set the shift register to indicate the first channel.",
    "2665": "Fetch the address of the current channel data block.",
    "2667": "Return it in IX.",
    "2670": "The address of current channel data pointer.",
    "2677": "Advance to the next channel data pointer.",
    "2681": "The address of new channel data pointer.",
    "2685": "Select channel data block pointers.",
    "2688": "Working copy of channel bitmap. Test if next string present.",
    "2692": "Jump ahead if there is no string for this channel.",
    "2694": "Get address of channel data block for the current string into IX.",
    "2697": "Find the first note to play for this channel from its play string.",
    "2700": "Have all channels been processed?",
    "2704": "Jump ahead if so.",
    "2706": "Advance to the next channel data block pointer.",
    "2709": "Jump back to process the next channel.",
    "2711": "Find smallest duration length of the current notes across all channels.",
    "2714": "Save the smallest duration length.",
    "2715": "Play a note on each channel.",
    "2718": "DE=The smallest duration length.",
    "2719": "Channel bitmap.",
    "2722": "Is there anything to play?",
    "2724": "Jump if there is.",
    "2726": "Turn off all sound and restore IY.",
    "2729": "Re-enable interrupts.",
    "2730": "End of play command.",
    "2731": "DE=Smallest channel duration length, i.e. duration until the next channel state change.",
    "2732": "Perform a wait.",
    "2735": "Play a note on each channel and update the channel duration lengths.",
    "2738": "Find smallest duration length of the current notes across all channels.",
    "2741": "Jump back to see if there is more to process.",
    "2743": "\"HZYXWUVMT)(NO!\"",
    "2757": "Get the current character from the play string for this channel.",
    "2760": "Return if no more characters.",
    "2761": "Increment the low byte of the string pointer.",
    "2764": "Return if it has not overflowed.",
    "2765": "Else increment the high byte of the string pointer.",
    "2768": "Returns with carry flag reset.",
    "2769": "Save HL.",
    "2770": "Default is for a 'natural' note, i.e. no adjustment.",
    "2772": "Get the current character from the PLAY string, and advance the position pointer.",
    "2775": "Jump if at the end of the string.",
    "2777": "\"&\". Is it a rest?",
    "2779": "Jump ahead if not.",
    "2781": "Signal that it is a rest.",
    "2783": "Restore HL.",
    "2785": "Fetch the channel selector.",
    "2788": "Clear the channel flag for this string.",
    "2791": "Store the new channel bitmap.",
    "2794": "Jump back to return.",
    "2796": "\"#\". Is it a sharpen?",
    "2798": "Jump ahead if not.",
    "2800": "Increment by a semitone.",
    "2801": "Jump back to get the next character.",
    "2803": "\"$\". Is it a flatten?",
    "2805": "Jump ahead if not.",
    "2807": "Decrement by a semitone.",
    "2808": "Jump back to get the next character.",
    "2810": "Is it a lower case letter?",
    "2812": "Jump ahead if lower case.",
    "2814": "It is an upper case letter so",
    "2815": "increase an octave",
    "2817": "by adding 12 semitones.",
    "2822": "Reduce to range 'A'->0 .. 'G'->6.",
    "2820": "Convert to upper case.",
    "2824": "Jump if below 'A' to produce error report \"k Invalid note name\".",
    "2827": "Is it 7 or above?",
    "2829": "Jump if so to produce error report \"k Invalid note name\".",
    "2832": "C=Number of semitones.",
    "2835": "BC holds 0..6 for 'a'..'g'.",
    "2836": "Look up the number of semitones above note C for the note.",
    "2840": "A=Number of semitones above note C.",
    "2841": "C=Number of semitones due to sharpen/flatten characters.",
    "2842": "Adjust number of semitones above note C for the sharpen/flatten characters.",
    "2843": "Restore HL.",
    "3577": "'A,', 'B', 'C', 'D', 'E', 'F', 'G'",
    "2845": "Save registers.",
    "2847": "Get the pointer into the PLAY string.",
    "2853": "Initialise result to 0.",
    "2857": "\"0\". Is character numeric?",
    "2859": "Jump ahead if not.",
    "2861": "\":\". Is character numeric?",
    "2863": "Jump ahead if not.",
    "2866": "Save the pointer into the string.",
    "2867": "Multiply result so far by 10.",
    "2870": "\"0\". Convert ASCII digit to numeric value.",
    "2874": "HL=Numeric digit value.",
    "2875": "Add the numeric value to the result so far.",
    "2876": "Jump ahead if an overflow to produce error report \"l number too big\".",
    "2878": "Transfer the result into DE.",
    "2879": "Retrieve the pointer into the string.",
    "2880": "Loop back to handle any further numeric digits.",
    "2882": "Jump to produce error report \"l number too big\".",
    "2885": "Store the new pointer position into the string.",
    "2892": "Return the result in BC.",
    "2893": "Restore registers.",
    "2899": "Add DE to HL ten times.",
    "2902": "Jump ahead if an overflow to produce error report \"l number too big\".",
    "2906": "Transfer the result into DE.",
    "2908": "Test for BREAK being pressed.",
    "2911": "Jump ahead if not pressed.",
    "2913": "Turn off all sound and restore IY.",
    "2916": "Re-enable interrupts.",
    "2917": "Produce error report. [Could have saved 1 byte by using JP $05D6 (ROM 0)]",
    "2920": "\"L Break into program\"",
    "2921": "Get the current character from the PLAY string, and advance the position pointer.",
    "2924": "Jump if at the end of the string.",
    "2927": "Find the handler routine for the PLAY command character.",
    "2932": "Generate the offset into the",
    "2934": "command vector table.",
    "2937": "HL points to handler routine for this command character.",
    "2940": "Fetch the handler routine address.",
    "2941": "HL=Handler routine address for this command character.",
    "2942": "Make an indirect call to the handler routine.",
    "2945": "Jump back to handle the next character in the string.",
    "2949": "Get the current character from the PLAY string, and advance the position pointer.",
    "2952": "Jump if at the end of the string.",
    "2955": "\"!\". Is it the end-of-comment character?",
    "2957": "Return if it is.",
    "2958": "Jump back to test the next character.",
    "3530": "Command handler routine for all other characters.",
    "3532": "'!' command handler routine.",
    "3534": "'O' command handler routine.",
    "3536": "'N' command handler routine.",
    "3538": "'(' command handler routine.",
    "3540": "')' command handler routine.",
    "3542": "'T' command handler routine.",
    "3544": "'M' command handler routine.",
    "3546": "'V' command handler routine.",
    "3548": "'U' command handler routine.",
    "3550": "'W' command handler routine.",
    "3552": "'X' command handler routine.",
    "3554": "'Y' command handler routine.",
    "3556": "'Z' command handler routine.",
    "3558": "'H' command handler routine.",
    "2960": "Get following numeric value from the string into BC.",
    "2963": "Is it between 0 and 8?",
    "2966": "Jump if above 8 to produce error report \"n Out of range\".",
    "2969": "Multiply A by 12.",
    "2977": "Store the octave value.",
    "2981": "Nothing to do so make an immediate return.",
    "2982": "A=Current level of open bracket nesting.",
    "2985": "Increment the count.",
    "2986": "Only 4 levels supported.",
    "2988": "Jump if this is the fifth to produce error report \"d Too many brackets\".",
    "2991": "Store the new open bracket nesting level.",
    "2994": "Offset to the bracket level return position stores.",
    "2997": "HL=Address of the pointer in which to store the return location of the bracket.",
    "3000": "Store the current string position as the return address of the open bracket.",
    "3010": "Fetch the nesting level of closing brackets.",
    "3013": "Offset to the closing bracket return address store.",
    "3016": "Is there any bracket nesting so far?",
    "3017": "Jump if none. [Could have been faster by jumping to $0BF3 (ROM 0)]",
    "3020": "HL=Address of the pointer to the corresponding closing bracket return address store.",
    "3023": "Fetch the low byte of the current address.",
    "3026": "Re-reached the closing bracket?",
    "3027": "Jump ahead if not.Jump ahead if not.",
    "3029": "Point to the high byte.",
    "3030": "Fetch the high byte address of the current address.",
    "3033": "Re-reached the closing bracket?",
    "3034": "Jump ahead if not.",
    "3036": "Decrement the closing bracket nesting level since this level has been repeated.",
    "3039": "[There is no need for the LD A,(IX+$16) and OR A instructions since the DEC (IX+$16) already set the flags]",
    "3042": "Reached the outer bracket nesting level?",
    "3043": "Return if not the outer bracket nesting level such that the character after the closing bracket is processed next.",
    "3044": "Was this a single closing bracket?",
    "3048": "Return if it was not.",
    "3049": "Restore one level of closing bracket nesting.",
    "3053": "Select closing bracket nesting level 0.",
    "3054": "Jump ahead to continue.",
    "3056": "Fetch the nesting level of closing brackets.",
    "3059": "Increment the count.",
    "3060": "Only 5 levels supported (4 to match up with opening brackets and a 5th to repeat indefinitely).",
    "3062": "Jump if this is the fifth to produce error report \"d Too many brackets\".",
    "3065": "Store the new closing bracket nesting level.",
    "3068": "HL=Address of the pointer to the appropriate closing bracket return address store.",
    "3071": "Store the current string position as the return address for the closing bracket.",
    "3080": "Fetch the nesting level of opening brackets.",
    "3086": "HL=Address of the pointer to the opening bracket nesting level return address store.",
    "3089": "Set the return address of the nesting level's opening bracket",
    "3090": "as new current position within the string.",
    "3094": "For a single closing bracket only, this will be the start address of the string.",
    "3098": "Decrement level of open bracket nesting.",
    "3101": "Return if the closing bracket matched an open bracket.",
    "3102": "Set the opening brackets nesting level to 0.",
    "3106": "Signal a single closing bracket only, i.e. to repeat the string indefinitely.",
    "3113": "HL=IX.",
    "3114": "HL=IX+DE.",
    "3120": "HL=IX+DE+2*A.",
    "3122": "Get following numeric value from the string into BC.",
    "3127": "Jump if 256 or above to produce error report \"n Out of range\".",
    "3133": "Jump if 59 or below to produce error report \"n Out of range\".",
    "3138": "Jump if 241 or above to produce error report \"n Out of range\".",
    "3141": "Fetch the channel number.",
    "3144": "Tempo 'T' commands have to be specified in the first string.",
    "3145": "If it is in a later string then ignore it.",
    "3146": "[Redundant instruction - B is already zero]",
    "3148": "C=Tempo value.",
    "3151": "HL=Tempo*4.",
    "3153": "BC=Tempo*4. [Would have been quicker to use the combination LD B,H and LD C,L]",
    "3154": "Save the pointer to the play command data block.",
    "3157": "Place the contents of BC onto the stack. The call restores IY to $5C3A.",
    "3159": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3160": "Restore IY to point at the play command data block.",
    "3162": "Save the pointer to the play command data block.",
    "3166": "HL=pointer to the play command data block.",
    "3170": "HL =IY+$002B.",
    "3171": "Reset IY to $5C3A since this is required by the floating point calculator.",
    "3175": "HL=Points to the calculator RAM routine.",
    "3176": "Set up the return address.",
    "3179": "Set up the return address.",
    "3185": "Stack the address of the swap routine used when returning to this ROM.",
    "3186": "Re-stack the address of the calculator RAM routine.",
    "3187": "Toggle to other ROM and make a return to the calculator RAM routine.",
    "3190": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3192": "Fetch the value on the top of the calculator stack.",
    "3194": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3195": "Restore IY to point at the play command data block.",
    "3197": "Store tempo timing value.",
    "3204": "Get following numeric value from the string into BC.",
    "3207": "A=Mixer value.",
    "3208": "Is it 64 or above?",
    "3210": "Jump if so to produce error report \"n Out of range\".",
    "3213": "Invert the bits since the sound generator's mixer register uses active low enable. This also sets bit 6 1, which selects the I/O port as an output.",
    "3214": "E=Mixer value.",
    "3215": "D=Register 7 - Mixer.",
    "3217": "Write to sound generator register to set the mixer.",
    "3220": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3221": "Get following numeric value from the string into BC.",
    "3225": "Is it 16 or above?",
    "3227": "Jump if so to produce error report \"n Out of range\".",
    "3230": "Store the volume level.",
    "3233": "E=Channel number.",
    "3236": "Offset by 8.",
    "3238": "A=8+index.",
    "3239": "D=Sound generator register number for the channel.",
    "3240": "E=Volume level.",
    "3241": "Write to sound generator register to set the volume for the channel.",
    "3244": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3245": "Get the channel number.",
    "3248": "Offset by 8.",
    "3250": "A=8+index.",
    "3251": "D=Sound generator register number for the channel. [This is not used and so there is no need to generate it. It was probably a left over from copying and modifying the 'V' command routine. Deleting it would save 7 bytes. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "3252": "E=Select envelope defined by register 13, and reset volume bits to maximum (though these are not used with the envelope).",
    "3254": "Store that the envelope is being used (along with the reset volume level).",
    "3258": "Get following numeric value from the string into BC.",
    "3262": "Is it 8 or above?",
    "3264": "Jump if so to produce error report \"n Out of range\".",
    "3272": "HL points to the corresponding value in the table.",
    "3269": "Envelope waveform lookup table.",
    "3274": "Store new effect waveform value.",
    "3560": "W0 - Single decay then off.   (Continue off, attack off, alternate off, hold off)",
    "3561": "W1 - Single attack then off.  (Continue off, attack on,  alternate off, hold off)",
    "3562": "W2 - Single decay then hold.  (Continue on,  attack off, alternate on,  hold on)",
    "3278": "Get following numeric value from the string into BC.",
    "3281": "Register 11 - Envelope Period Fine.",
    "3284": "Write to sound generator register to set the envelope period (low byte).",
    "3287": "Register 12 - Envelope Period Coarse.",
    "3289": "Write to sound generator register to set the envelope period (high byte).",
    "3292": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3293": "Get following numeric value from the string into BC.",
    "3297": "Is it 0?",
    "3298": "Jump if so to produce error report \"n Out of range\".",
    "3301": "Is it 10 or above?",
    "3303": "Jump if so to produce error report \"n Out of range\".",
    "3306": "Store MIDI channel number that this string is assigned to.",
    "3310": "Get following numeric value from the string into BC.",
    "3313": "A=(low byte of) the value.",
    "3314": "Write byte to MIDI device.",
    "3317": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3318": "Indicate no channels to play, thereby causing",
    "3322": "the play command to terminate.",
    "3323": "Is the current character a number?",
    "3326": "Jump if not number digit.",
    "3329": "HL=Address of the duration length within the channel data block.",
    "3332": "Store address of duration length in command data block's channel duration length pointer table.",
    "3336": "Set no tied notes.",
    "3339": "Get the previous character in the string, the note duration.",
    "3342": "Get following numeric value from the string into BC.",
    "3346": "Is the value 0?",
    "3347": "Jump if so to produce error report \"n Out of range\".",
    "3350": "Is it 13 or above?",
    "3352": "Jump if so to produce error report \"n Out of range\".",
    "3355": "Is it below 10?",
    "3357": "Jump if so.",
    "3359": "DE=Note duration length for the duration value.",
    "3362": "Increment the tied notes counter.",
    "3365": "HL=Address of the duration length within the channel data block.",
    "3367": "Store the duration length.",
    "3368": "Increment the counter of tied notes.",
    "3373": "Store the subsequent note duration length in the channel data block.",
    "3376": "Jump ahead to continue.",
    "3378": "C=Note duration value (1..9).",
    "3381": "DE=Duration length for this duration value.",
    "3384": "Increment the tied notes counter.",
    "3387": "Get the current character from the play string for this channel.",
    "3390": "\"_\". Is it a tied note?",
    "3392": "Jump ahead if not.",
    "3394": "Get the current character from the PLAY string, and advance the position pointer.",
    "3397": "Get following numeric value from the string into BC.",
    "3400": "Place the value into A.",
    "3401": "Is it below 10?",
    "3403": "Jump ahead for 1 to 9 (semiquaver ... semibreve).",
    "3405": "HL=Address of the duration length within the channel data block.",
    "3406": "DE=First tied note duration length.",
    "3407": "DE=Note duration length for this new duration value.",
    "3410": "HL=Current tied note duration length.",
    "3411": "HL=Current+new tied note duration lengths.",
    "3413": "BC=Note duration length for the duration value.",
    "3414": "DE=Current+new tied note duration lengths.",
    "3415": "HL=Address of the duration length within the channel data block.",
    "3418": "Store the combined note duration length in the channel data block.",
    "3420": "DE=Note duration length for the second duration value.",
    "3421": "Jump back.",
    "3423": "Store the note duration value.",
    "3426": "HL=Address of the duration length within the channel data block.",
    "3427": "DE=First tied note duration length.",
    "3428": "DE=Note duration length for this new duration value.",
    "3431": "HL=Current tied note duration length.",
    "3432": "HL=Current+new tied not duration lengths.",
    "3433": "DE=Current+new tied not duration lengths.",
    "3434": "HL=Address of the duration length within the channel data block.",
    "3435": "Jump back to process the next character in case it is also part of a tied note.",
    "3438": "HL=Address of the duration length within the channel data block.",
    "3439": "(For triplet notes this could be the address of the subsequent note duration length)",
    "3440": "Store the duration length.",
    "3441": "Jump forward to make a return.",
    "3444": "Increment counter of tied notes.",
    "3448": "Has it reached 11?",
    "3450": "Jump if so to produce to error report \"o too many tied notes\".",
    "3453": "Store the new tied notes counter.",
    "3457": "Get the previous character from the string.",
    "3460": "Set the number of tied notes to 1.",
    "3464": "HL=Address of the duration length within the channel data block.",
    "3467": "Store address of duration length in command data block's channel duration length pointer table.",
    "3470": "C=The duration value of the note (1 to 9).",
    "3473": "[Not necessary]",
    "3477": "[Not necessary]",
    "3474": "Find the duration length for the note duration value.",
    "3478": "Store it in the channel data block.",
    "3481": "Jump to the instruction below. [Redundant instruction]",
    "3486": "Modify the return address to point to the RET instruction at $0B83 (ROM 0).",
    "3488": "[Over elaborate when a simple POP followed by RET would have sufficed, saving 3 bytes]",
    "3490": "Fetch the channel selector.",
    "3493": "Clear the channel flag for this string.",
    "3496": "Store the new channel bitmap.",
    "3502": "HL=Address of the channel data block.",
    "3506": "HL=Address of the store for the duration length.",
    "3508": "Save the address of the duration length within the channel data block.",
    "3511": "HL=Address of the command data block.",
    "3515": "HL=Address within the command data block of the channel duration length pointer table.",
    "3518": "BC=Channel number.",
    "3521": "BC=2*Index number.",
    "3523": "HL=Address within the command data block of the pointer to the current channel's data block duration length.",
    "3524": "DE=Address of the duration length within the channel data block.",
    "3525": "Store the pointer to the channel duration length in the command data block's channel duration pointer table.",
    "3563": "W3 - Single attack then hold. (Continue on,  attack on,  alternate off, hold on)",
    "3564": "W4 - Repeated decay.          (Continue on,  attack off, alternate off, hold off)",
    "3565": "W5 - Repeated attack.         (Continue on,  attack on,  alternate off, hold off)",
    "3566": "W6 - Repeated attack-decay.   (Continue on,  attack on,  alternate on,  hold off)",
    "3567": "W7 - Repeated decay-attack.   (Continue on,  attack off, alternate on,  hold off)",
    "3568": "Number of characters + 1 in command table.",
    "3571": "Start of command table.",
    "3574": "Search for a match.",
    "3584": "Save HL.",
    "3587": "Note duration table.",
    "3590": "Index into the table.Index into the table.",
    "3593": "Fetch the length from the table.",
    "3594": "Restore HL.",
    "3596": "Rest [Not used since table is always indexed into with a value of 1 or more]",
    "3597": "Semi-quaver (sixteenth note).",
    "3598": "Dotted semi-quaver (3/32th note).",
    "3599": "Quaver (eighth note).",
    "3600": "Dotted quaver (3/16th note).",
    "3601": "Crotchet (quarter note).",
    "3602": "Dotted crotchet (3/8th note).",
    "3603": "Minim (half note).",
    "3604": "Dotted minim (3/4th note).",
    "3605": "Semi-breve (whole note).",
    "3606": "Triplet semi-quaver (1/24th note).",
    "3607": "Triplet quaver (1/12th note).",
    "3608": "Triplet crochet (1/6th note).",
    "3609": "\"0\". Is it '0' or less?",
    "3611": "Return with carry flag set if so.",
    "3612": "\":\". Is it more than '9'?",
    "3615": "Return with carry flag set if so.",
    "3616": "C=The note value.",
    "3617": "Octave number * 12.",
    "3620": "Add the octave number and the note value to form the note number.",
    "3621": "Is note within range?",
    "3623": "Jump if not to produce error report \"m Note out of range\".",
    "3626": "C=Note number.",
    "3627": "Get the channel number.",
    "3630": "Is it the first channel?",
    "3631": "Jump ahead if not.",
    "3633": "A=Note number (0..107), in ascending audio frequency.",
    "3634": "Invert since noise register value is in descending audio frequency.",
    "3635": "Mask off bit 7.",
    "3639": "Divide by 4 to reduce range to 0..31.",
    "3641": "Register 6 - Noise pitch.",
    "3644": "Write to sound generator register.",
    "3647": "Store the note number.",
    "3650": "Get the channel number.",
    "3653": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "3655": "Do not output anything for play strings 4 to 8.",
    "3656": "Start of note lookup table.",
    "3659": "BC=Note number.",
    "3661": "A=Note number.",
    "3662": "A=Note number - 21.",
    "3664": "Jump if note number was 21 or above.",
    "3666": "Note numbers $00 to $14 use the lowest note value.",
    "3669": "[Could have saved 4 bytes by using XOR A and dropping through to $0E57 (ROM 0)]",
    "3672": "Generate offset into the table.",
    "3674": "Point to the entry in the table.",
    "3677": "DE=Word to write to the sound chip registers to produce this note.",
    "3678": "HL=Register word value to produce the note.",
    "3679": "Get the channel number.",
    "3682": "D=2*Channel number, to give the tone channel register (fine control) number 0, 2, or 4.",
    "3684": "E=The low value byte.",
    "3685": "Write to sound generator register.",
    "3688": "D=Tone channel register (coarse control) number 1, 3, or 5.",
    "3689": "E=The high value byte.",
    "3690": "Write to sound generator register.",
    "3693": "Is the envelope waveform being used?",
    "3697": "Return if it is not.",
    "3698": "Register 13 - Envelope Shape.",
    "3700": "Get the effect waveform value.",
    "3704": "Write to sound generator register.",
    "3707": "[Could have saved 4 bytes by dropping down into the routine below.]",
    "3712": "Select the register.",
    "3717": "Write out the value.",
    "3725": "Select the register.",
    "3727": "Read the register's value.",
    "3731": "Register 7 - Mixer.",
    "3733": "I/O ports are inputs, noise output off, tone output off.",
    "3735": "Write to sound generator register.",
    "3738": "Register 8 - Channel A volume.",
    "3740": "Volume of 0.",
    "3742": "Write to sound generator register to set the volume to 0.",
    "3745": "Register 9 - Channel B volume.",
    "3746": "Write to sound generator register to set the volume to 0.",
    "3750": "Write to sound generator register to set the volume to 0.",
    "3749": "Register 10 - Channel C volume.",
    "3753": "Select channel data block pointers.",
    "3756": "Working copy of channel bitmap. Test if next string present.",
    "3760": "Jump ahead if there is no string for this channel.",
    "3762": "Get address of channel data block for the current string into IX.",
    "3765": "Turn off the MIDI channel sound assigned to this play string.",
    "3768": "Have all channels been processed?",
    "3772": "Jump ahead if so.",
    "3774": "Advance to the next channel data block pointer.",
    "3777": "Jump back to process the next channel.",
    "3779": "Restore IY.",
    "3784": "Save registers.",
    "3786": "Get the current pointer into the PLAY string.",
    "3792": "Point to previous character.",
    "3793": "Fetch the character.",
    "3794": "Is it a space?",
    "3796": "Jump back if a space.",
    "3798": "Is it an 'Enter'?",
    "3800": "Jump back if an 'Enter'.",
    "3802": "Store this as the new current pointer into the PLAY string.",
    "3808": "Restore registers.",
    "3811": "Save registers.",
    "3814": "HL=Pointer to next character to process within the PLAY string.",
    "3821": "Reached end-of-string address high byte?",
    "3824": "Jump forward if not.",
    "3827": "Reached end-of-string address low byte?",
    "3830": "Jump forward if not.",
    "3832": "Indicate string all processed.",
    "3833": "Jump forward to return.",
    "3835": "Get the next play character.",
    "3836": "Is it a space?",
    "3838": "Ignore the space by jumping ahead to process the next character.",
    "3840": "Is it 'Enter'?",
    "3842": "Ignore the 'Enter' by jumping ahead to process the next character.",
    "3844": "Clear the carry flag to indicate a new character has been returned.",
    "3845": "Restore registers.",
    "3849": "Point to the next character.",
    "3853": "Update the pointer to the next character to process with the PLAY string.",
    "3856": "Jump back to get the next character.",
    "3858": "Turn off all sound and restore IY.",
    "3866": "Turn off all sound and restore IY.",
    "3874": "Turn off all sound and restore IY.",
    "3890": "Turn off all sound and restore IY.",
    "3882": "Turn off all sound and restore IY.",
    "3862": "Produce error report.",
    "3870": "Produce error report.",
    "3878": "Produce error report.",
    "3886": "Produce error report.",
    "3894": "Produce error report.",
    "3902": "Produce error report.",
    "3898": "Turn off all sound and restore IY.",
    "3865": "\"n Out of range\"",
    "3873": "\"l Number too big\"",
    "3881": "\"k Invalid note name\"",
    "3889": "\"d Too many brackets\"",
    "3897": "\"m Note out of range\"",
    "3905": "\"o Too many tied notes\"",
    "3906": "Select channel data block pointers.",
    "3909": "Working copy of channel bitmap. Test if next string present.",
    "3913": "Jump ahead if there is no string for this channel.",
    "3915": "Get address of channel data block for the current string into IX.",
    "3921": "Is it a rest?",
    "3923": "Jump ahead if so and do nothing to the channel.",
    "3925": "Play the note if a sound chip channel.",
    "3928": "Get channel number.",
    "3931": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "3933": "Jump if not to skip setting the volume.",
    "3937": "A=0 to 2.",
    "3938": "D=Register (8 + string index), i.e. channel A, B or C volume register.",
    "3939": "E=Volume for the current channel.",
    "3942": "Write to sound generator register to set the output volume.",
    "3945": "Play a note and set the volume on the assigned MIDI channel.",
    "3948": "Have all channels been processed?",
    "3952": "Return if so.",
    "3953": "Advance to the next channel data block pointer.",
    "3956": "Jump back to process the next channel.",
    "3958": "(11) Save HL.",
    "3959": "(19) Get the tempo timing value.",
    "3962": "(19)",
    "3965": "(10) BC=100",
    "3968": "(4)",
    "3969": "(15) HL=tempo timing value - 100.",
    "3971": "(11)",
    "3972": "(10) BC=tempo timing value - 100.",
    "3973": "(10) Restore HL.",
    "3974": "(6)  Wait for tempo-100 loops.",
    "3975": "(4)",
    "3976": "(4)",
    "3977": "(12/7)",
    "3979": "(6) Repeat DE times",
    "3980": "(4)",
    "3981": "(4)",
    "3982": "(12/7)",
    "3984": "(10)",
    "3985": "Set smallest duration length to 'maximum'.",
    "3988": "Select channel data block duration pointers.",
    "3991": "Working copy of channel bitmap. Test if next string present.",
    "3995": "Jump ahead if there is no string for this channel.",
    "3997": "Save the smallest duration length.",
    "4001": "DE=Channel data block duration length.",
    "4004": "DE=Channel duration length.",
    "4006": "HL=Channel duration length.",
    "4007": "Last channel duration length.",
    "4009": "Is current channel's duration length smaller than the smallest so far?",
    "4011": "Jump ahead if so, with the new smallest value in DE.",
    "4014": "DE=Smallest duration length.",
    "4015": "Have all channel strings been processed?",
    "4019": "Jump ahead if so.",
    "4021": "Advance to the next channel data block duration pointer.",
    "4024": "Jump back to process the next channel.",
    "4029": "Store the smallest channel duration length.",
    "4034": "Holds a temporary channel bitmap.",
    "4037": "Select channel data block pointers.",
    "4040": "Working copy of channel bitmap. Test if next string present.",
    "4044": "Jump ahead if there is no string for this channel.",
    "4047": "Get address of channel data block for the current string into IX.",
    "4052": "HL=Address of the command data block.",
    "4056": "HL=Address of channel data block duration pointers.",
    "4059": "BC=Channel number.",
    "4062": "BC=2*Channel number.",
    "4064": "HL=Address of channel data block duration pointer for this channel.",
    "4067": "DE=Address of duration length within the channel data block.",
    "4068": "HL=Address of duration length within the channel data block.",
    "4069": "Save it.",
    "4072": "DE=Duration length for this channel.",
    "4073": "HL=Duration length for this channel.",
    "4077": "DE=Smallest duration length of all current channel notes.",
    "4081": "HL=Duration length - smallest duration length.",
    "4083": "DE=Duration length - smallest duration length.",
    "4084": "HL=Address of duration length within the channel data block.",
    "4085": "Jump if this channel uses the smallest found duration length.",
    "4089": "Update the duration length for this channel with the remaining length.",
    "4090": "Jump ahead to update the next channel.",
    "4092": "Get the channel number.",
    "4095": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "4097": "Jump ahead if not a sound generator channel.",
    "4102": "D=Register (8+channel number) - Channel volume.",
    "4103": "E=Volume level of 0.",
    "4105": "Write to sound generator register to turn the volume off.",
    "4108": "Turn off the assigned MIDI channel sound.",
    "4113": "HL=Address of channel data block.",
    "4117": "HL=Points to the tied notes counter.",
    "4118": "Decrement the tied notes counter. [This contains a value of 1 for a single note]",
    "4119": "Jump ahead if there are more tied notes.",
    "4121": "Find the next note to play for this channel from its play string.",
    "4124": "Fetch the channel selector.",
    "4127": "Test whether this channel has further data in its play string.",
    "4130": "Jump to process the next channel if this channel does not have a play string.",
    "4132": "The channel has more data in its play string so jump ahead.",
    "4136": "HL=Address of the command data block.",
    "4140": "HL=Address of channel data block duration pointers.",
    "4143": "BC=Channel number.",
    "4146": "BC=2*Channel number.",
    "4148": "HL=Address of channel data block duration pointer for this channel.",
    "4151": "DE=Address of duration length within the channel data block.",
    "4153": "Point to the subsequent note duration length.",
    "4156": "Store the new duration length.",
    "4157": "Get next note in the string as number of semitones above note C.",
    "4160": "C=Number of semitones.",
    "4161": "Fetch the channel selector.",
    "4164": "Test whether this channel has a play string.",
    "4167": "Jump to process the next channel if this channel does not have a play string.",
    "4169": "A=Number of semitones.",
    "4170": "Is it a rest?",
    "4172": "Jump to process the next channel if it is.",
    "4174": "Play the new note on this channel at the current volume if a sound chip channel, or simply store the note for play strings 4 to 8.",
    "4177": "Fetch the channel selector.",
    "4180": "Insert a bit in the temporary channel bitmap to indicate this channel has more to play.",
    "4183": "Store it.",
    "4186": "Have all channel strings been processed?",
    "4190": "Jump ahead if so.",
    "4192": "Advance to the next channel data pointer.",
    "4195": "Jump back to update the duration length for the next channel.",
    "4198": "Delay for 1/96th of a note.",
    "4204": "Select channel data block pointers.",
    "4207": "Temporary channel bitmap. Test if next string present.",
    "4211": "Jump ahead if there is no string for this channel.",
    "4213": "Get address of channel data block for the current string into IX.",
    "4216": "Get the channel number.",
    "4219": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "4221": "Jump ahead if so to process the next channel.",
    "4226": "D=Register (8+channel number) - Channel volume.",
    "4227": "Get the current volume.",
    "4230": "Write to sound generator register to set the volume of the channel.",
    "4233": "Play a note and set the volume on the assigned MIDI channel.",
    "4236": "Have all channels been processed?",
    "4240": "Return if so.",
    "4241": "Advance to the next channel data pointer.",
    "4244": "Jump back to process the next channel.",
    "4246": "Octave  1, Note  21 - A  (27.50 Hz, Ideal=27.50 Hz, Error=-0.01%) C0",
    "4248": "Octave  1, Note  22 - A# (29.14 Hz, Ideal=29.16 Hz, Error=-0.08%)",
    "4250": "Octave  1, Note  23 - B  (30.87 Hz, Ideal=30.87 Hz, Error=-0.00%)",
    "4252": "Octave  2, Note  24 - C  (32.71 Hz, Ideal=32.70 Hz, Error=+0.01%) C1",
    "4254": "Octave  2, Note  25 - C# (34.65 Hz, Ideal=34.65 Hz, Error=-0.00%)",
    "4256": "Octave  2, Note  26 - D  (36.70 Hz, Ideal=36.71 Hz, Error=-0.01%)",
    "4258": "Octave  2, Note  27 - D# (38.89 Hz, Ideal=38.89 Hz, Error=+0.01%)",
    "4260": "Octave  2, Note  28 - E  (41.20 Hz, Ideal=41.20 Hz, Error=+0.00%)",
    "4262": "Octave  2, Note  29 - F  (43.66 Hz, Ideal=43.65 Hz, Error=+0.00%)",
    "4264": "Octave  2, Note  30 - F# (46.24 Hz, Ideal=46.25 Hz, Error=-0.02%)",
    "4266": "Octave  2, Note  31 - G  (49.00 Hz, Ideal=49.00 Hz, Error=+0.00%)",
    "4268": "Octave  2, Note  32 - G# (51.92 Hz, Ideal=51.91 Hz, Error=+0.01%)",
    "4270": "Octave  2, Note  33 - A  (55.01 Hz, Ideal=55.00 Hz, Error=+0.01%)",
    "4272": "Octave  2, Note  34 - A# (58.28 Hz, Ideal=58.33 Hz, Error=-0.08%)",
    "4274": "Octave  2, Note  35 - B  (61.75 Hz, Ideal=61.74 Hz, Error=+0.02%)",
    "4276": "Octave  3, Note  36 - C  ( 65.39 Hz, Ideal= 65.41 Hz, Error=-0.02%) C2",
    "4278": "Octave  3, Note  37 - C# ( 69.28 Hz, Ideal= 69.30 Hz, Error=-0.04%)",
    "4280": "Octave  3, Note  38 - D  ( 73.40 Hz, Ideal= 73.42 Hz, Error=-0.01%)",
    "4282": "Octave  3, Note  39 - D# ( 77.78 Hz, Ideal= 77.78 Hz, Error=+0.01%)",
    "4284": "Octave  3, Note  40 - E  ( 82.41 Hz, Ideal= 82.41 Hz, Error=+0.00%)",
    "4286": "Octave  3, Note  41 - F  ( 87.28 Hz, Ideal= 87.31 Hz, Error=-0.04%)",
    "4288": "Octave  3, Note  42 - F# ( 92.52 Hz, Ideal= 92.50 Hz, Error=+0.02%)",
    "4290": "Octave  3, Note  43 - G  ( 98.00 Hz, Ideal= 98.00 Hz, Error=+0.00%)",
    "4292": "Octave  3, Note  44 - G# (103.78 Hz, Ideal=103.83 Hz, Error=-0.04%)",
    "4294": "Octave  3, Note  45 - A  (109.96 Hz, Ideal=110.00 Hz, Error=-0.04%)",
    "4296": "Octave  3, Note  46 - A# (116.55 Hz, Ideal=116.65 Hz, Error=-0.08%)",
    "4298": "Octave  3, Note  47 - B  (123.43 Hz, Ideal=123.47 Hz, Error=-0.03%)",
    "4300": "Octave  4, Note  48 - C  (130.86 Hz, Ideal=130.82 Hz, Error=+0.04%) C3",
    "4302": "Octave  4, Note  49 - C# (138.55 Hz, Ideal=138.60 Hz, Error=-0.04%)",
    "4304": "Octave  4, Note  50 - D  (146.81 Hz, Ideal=146.83 Hz, Error=-0.01%)",
    "4306": "Octave  4, Note  51 - D# (155.68 Hz, Ideal=155.55 Hz, Error=+0.08%)",
    "4308": "Octave  4, Note  52 - E  (164.70 Hz, Ideal=164.82 Hz, Error=-0.07%)",
    "4310": "Octave  4, Note  53 - F  (174.55 Hz, Ideal=174.62 Hz, Error=-0.04%)",
    "4312": "Octave  4, Note  54 - F# (185.04 Hz, Ideal=185.00 Hz, Error=+0.02%)",
    "4314": "Octave  4, Note  55 - G  (195.83 Hz, Ideal=196.00 Hz, Error=-0.09%)",
    "4316": "Octave  4, Note  56 - G# (207.57 Hz, Ideal=207.65 Hz, Error=-0.04%)",
    "4318": "Octave  4, Note  57 - A  (219.92 Hz, Ideal=220.00 Hz, Error=-0.04%)",
    "4320": "Octave  4, Note  58 - A# (232.86 Hz, Ideal=233.30 Hz, Error=-0.19%)",
    "4322": "Octave  4, Note  59 - B  (246.86 Hz, Ideal=246.94 Hz, Error=-0.03%)",
    "4324": "Octave  5, Note  60 - C  (261.42 Hz, Ideal=261.63 Hz, Error=-0.08%) C4 Middle C",
    "4326": "Octave  5, Note  61 - C# (277.10 Hz, Ideal=277.20 Hz, Error=-0.04%)",
    "4328": "Octave  5, Note  62 - D  (294.01 Hz, Ideal=293.66 Hz, Error=+0.12%)",
    "4330": "Octave  5, Note  63 - D# (311.35 Hz, Ideal=311.10 Hz, Error=+0.08%)",
    "4332": "Octave  5, Note  64 - E  (329.88 Hz, Ideal=329.63 Hz, Error=+0.08%)",
    "4334": "Octave  5, Note  65 - F  (349.65 Hz, Ideal=349.23 Hz, Error=+0.12%)",
    "4336": "Octave  5, Note  66 - F# (369.47 Hz, Ideal=370.00 Hz, Error=-0.14%)",
    "4338": "Octave  5, Note  67 - G  (391.66 Hz, Ideal=392.00 Hz, Error=-0.09%)",
    "4340": "Octave  5, Note  68 - G# (415.13 Hz, Ideal=415.30 Hz, Error=-0.04%)",
    "4342": "Octave  5, Note  69 - A  (439.84 Hz, Ideal=440.00 Hz, Error=-0.04%)",
    "4344": "Octave  5, Note  70 - A# (465.72 Hz, Ideal=466.60 Hz, Error=-0.19%)",
    "4346": "Octave  5, Note  71 - B  (494.82 Hz, Ideal=493.88 Hz, Error=+0.19%)",
    "4348": "Octave  6, Note  72 - C  (522.83 Hz, Ideal=523.26 Hz, Error=-0.08%) C5",
    "4350": "Octave  6, Note  73 - C# (554.20 Hz, Ideal=554.40 Hz, Error=-0.04%)",
    "4352": "Octave  6, Note  74 - D  (586.46 Hz, Ideal=587.32 Hz, Error=-0.15%)",
    "4354": "Octave  6, Note  75 - D# (622.70 Hz, Ideal=622.20 Hz, Error=+0.08%)",
    "4356": "Octave  6, Note  76 - E  (659.77 Hz, Ideal=659.26 Hz, Error=+0.08%)",
    "4358": "Octave  6, Note  77 - F  (697.11 Hz, Ideal=698.46 Hz, Error=-0.19%)",
    "4360": "Octave  6, Note  78 - F# (738.94 Hz, Ideal=740.00 Hz, Error=-0.14%)",
    "4362": "Octave  6, Note  79 - G  (786.10 Hz, Ideal=784.00 Hz, Error=+0.27%)",
    "4364": "Octave  6, Note  80 - G# (833.39 Hz, Ideal=830.60 Hz, Error=+0.34%)",
    "4366": "Octave  6, Note  81 - A  (879.69 Hz, Ideal=880.00 Hz, Error=-0.04%)",
    "4368": "Octave  6, Note  82 - A# (931.43 Hz, Ideal=933.20 Hz, Error=-0.19%)",
    "4370": "Octave  6, Note  83 - B  (989.65 Hz, Ideal=987.76 Hz, Error=+0.19%)",
    "4372": "Octave  7, Note  84 - C  (1045.67 Hz, Ideal=1046.52 Hz, Error=-0.08%) C6",
    "4374": "Octave  7, Note  85 - C# (1108.41 Hz, Ideal=1108.80 Hz, Error=-0.04%)",
    "4376": "Octave  7, Note  86 - D  (1179.16 Hz, Ideal=1174.64 Hz, Error=+0.38%)",
    "4378": "Octave  7, Note  87 - D# (1245.40 Hz, Ideal=1244.40 Hz, Error=+0.08%)",
    "4380": "Octave  7, Note  88 - E  (1319.53 Hz, Ideal=1318.52 Hz, Error=+0.08%)",
    "4382": "Octave  7, Note  89 - F  (1403.05 Hz, Ideal=1396.92 Hz, Error=+0.44%)",
    "4384": "Octave  7, Note  90 - F# (1477.88 Hz, Ideal=1480.00 Hz, Error=-0.14%)",
    "4386": "Octave  7, Note  91 - G  (1561.14 Hz, Ideal=1568.00 Hz, Error=-0.44%)",
    "4388": "Octave  7, Note  92 - G# (1654.34 Hz, Ideal=1661.20 Hz, Error=-0.41%)",
    "4390": "Octave  7, Note  93 - A  (1759.38 Hz, Ideal=1760.00 Hz, Error=-0.04%)",
    "4392": "Octave  7, Note  94 - A# (1878.65 Hz, Ideal=1866.40 Hz, Error=+0.66%)",
    "4394": "Octave  7, Note  95 - B  (1979.30 Hz, Ideal=1975.52 Hz, Error=+0.19%)",
    "4396": "Octave  8, Note  96 - C  (2091.33 Hz, Ideal=2093.04 Hz, Error=-0.08%) C7",
    "4398": "Octave  8, Note  97 - C# (2216.81 Hz, Ideal=2217.60 Hz, Error=-0.04%)",
    "4400": "Octave  8, Note  98 - D  (2358.31 Hz, Ideal=2349.28 Hz, Error=+0.38%)",
    "4402": "Octave  8, Note  99 - D# (2463.13 Hz, Ideal=2488.80 Hz, Error=-1.03%)",
    "4404": "Octave  8, Note 100 - E  (2639.06 Hz, Ideal=2637.04 Hz, Error=+0.08%)",
    "4406": "Octave  8, Note 101 - F  (2771.02 Hz, Ideal=2793.84 Hz, Error=-0.82%)",
    "4408": "Octave  8, Note 102 - F# (2995.69 Hz, Ideal=2960.00 Hz, Error=+1.21%)",
    "4410": "Octave  8, Note 103 - G  (3166.88 Hz, Ideal=3136.00 Hz, Error=+0.98%)",
    "4412": "Octave  8, Note 104 - G# (3358.81 Hz, Ideal=3322.40 Hz, Error=+1.10%)",
    "4414": "Octave  8, Note 105 - A  (3575.50 Hz, Ideal=3520.00 Hz, Error=+1.58%)",
    "4416": "Octave  8, Note 106 - A# (3694.69 Hz, Ideal=3732.80 Hz, Error=-1.02%)",
    "4418": "Octave  8, Note 107 - B  (3958.59 Hz, Ideal=3951.04 Hz, Error=+0.19%)",
    "4420": "Octave  9, Note 108 - C  (4263.10 Hz, Ideal=4186.08 Hz, Error=+1.84%) C8",
    "4422": "Octave  9, Note 109 - C# (4433.63 Hz, Ideal=4435.20 Hz, Error=-0.04%)",
    "4424": "Octave  9, Note 110 - D  (4618.36 Hz, Ideal=4698.56 Hz, Error=-1.71%)",
    "4426": "Octave  9, Note 111 - D# (5038.21 Hz, Ideal=4977.60 Hz, Error=+1.22%)",
    "4428": "Octave  9, Note 112 - E  (5278.13 Hz, Ideal=5274.08 Hz, Error=+0.08%)",
    "4430": "Octave  9, Note 113 - F  (5542.03 Hz, Ideal=5587.68 Hz, Error=-0.82%)",
    "4432": "Octave  9, Note 114 - F# (5833.72 Hz, Ideal=5920.00 Hz, Error=-1.46%)",
    "4434": "Octave  9, Note 115 - G  (6157.81 Hz, Ideal=6272.00 Hz, Error=-1.82%)",
    "4436": "Octave  9, Note 116 - G# (6520.04 Hz, Ideal=6644.80 Hz, Error=-1.88%)",
    "4438": "Octave  9, Note 117 - A  (6927.54 Hz, Ideal=7040.00 Hz, Error=-1.60%)",
    "4440": "Octave  9, Note 118 - A# (7389.38 Hz, Ideal=7465.60 Hz, Error=-1.02%)",
    "4442": "Octave  9, Note 119 - B  (7917.19 Hz, Ideal=7902.08 Hz, Error=+0.19%)",
    "4444": "Octave 10, Note 120 - C  ( 8526.20 Hz, Ideal= 8372.16 Hz, Error=+1.84%) C9",
    "4446": "Octave 10, Note 121 - C# ( 9236.72 Hz, Ideal= 8870.40 Hz, Error=+4.13%)",
    "4448": "Octave 10, Note 122 - D  ( 9236.72 Hz, Ideal= 9397.12 Hz, Error=-1.71%)",
    "4450": "Octave 10, Note 123 - D# (10076.42 Hz, Ideal= 9955.20 Hz, Error=+1.22%)",
    "4452": "Octave 10, Note 124 - E  (10076.42 Hz, Ideal=10548.16 Hz, Error=-4.47%)",
    "4454": "Octave 10, Note 125 - F  (11084.06 Hz, Ideal=11175.36 Hz, Error=-0.82%)",
    "4456": "Octave 10, Note 126 - F# (12315.63 Hz, Ideal=11840.00 Hz, Error=+4.02%)",
    "4458": "Octave 10, Note 127 - G  (12315.63 Hz, Ideal=12544.00 Hz, Error=-1.82%)",
    "4460": "Octave 10, Note 128 - G# (13855.08 Hz, Ideal=13289.60 Hz, Error=+4.26%)",
    "4462": "Is a MIDI channel assigned to this string?",
    "4466": "Return if not.",
    "4467": "Set bits 4 and 7 of the channel number. A=$90..$9F.",
    "4469": "Write byte to MIDI device.",
    "4472": "The note number.",
    "4475": "Write byte to MIDI device.",
    "4478": "Fetch the channel's volume.",
    "4481": "Ensure the 'using envelope' bit is reset so",
    "4483": "that A holds a value between $00 and $0F.",
    "4485": "Multiply by 8 to increase the range to $00..$78.",
    "4487": "A=Note velocity.",
    "4489": "Write byte to MIDI device.",
    "4492": "[Could have saved 1 byte by using JP $11A3 (ROM 0)]",
    "4493": "Is a MIDI channel assigned to this string?",
    "4497": "Return if not.",
    "4498": "Set bit 7 of the channel number. A=$80..$8F.",
    "4500": "Write byte to MIDI device.",
    "4503": "The note number.",
    "4506": "Write byte to MIDI device.",
    "4511": "Write byte to MIDI device.",
    "4509": "The note velocity.",
    "4514": "[Could have saved 1 byte by using JP $11A3 (ROM 0)]",
    "4515": "Store the byte to send.",
    "4521": "Select register 14 - I/O port.",
    "4526": "Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4528": "Send out the START bit.",
    "4530": "(7) Introduce delays such that the next bit is output 113 T-states from now.",
    "4532": "(4)",
    "4535": "(4)",
    "4536": "(4)",
    "4537": "(4)",
    "4538": "(4)",
    "4539": "(4) Retrieve the byte to send.",
    "4542": "(4) Rotate the next bit to send into the carry.",
    "4543": "(4) Store the remaining bits.",
    "4533": "(12/7)",
    "4540": "(7) There are 8 bits to send.",
    "4544": "(10) Jump if it is a 0 bit.",
    "4547": "(7) Set RS232 'RXD' transmit line to 1. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4549": "(11)",
    "4551": "(12) Jump forward to process the next bit.",
    "4553": "(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4555": "(11)",
    "4557": "(12) Jump forward to process the next bit.",
    "4559": "(7) Introduce delays such that the next data bit is output 113 T-states from now.",
    "4561": "(4)",
    "4564": "(4)",
    "4571": "(4) Introduce delays such that the stop bit is output 113 T-states from now.",
    "4572": "(4)",
    "4575": "(4)",
    "4576": "(4)",
    "4562": "(12/7)",
    "4565": "(7)",
    "4567": "(4) Retrieve the remaining bits to send.",
    "4568": "(4) Decrement the bit counter.",
    "4569": "(12/7) Jump back if there are further bits to send.",
    "4573": "(7)",
    "4577": "(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4579": "(11) Send out the STOP bit.",
    "4581": "(7) Delay for 101 T-states (28.5us).",
    "4583": "(4)",
    "4584": "(12/7)",
    "4586": "(10)",
    "4590": "Indicate SAVE.",
    "4597": "Indicate LOAD.",
    "4604": "Indicate VERIFY.",
    "4611": "Indicate MERGE.",
    "4616": "Indicate using cassette.",
    "4618": "Get current character.",
    "4619": "'!'",
    "4621": "Jump ahead to handle cassette command.",
    "4627": "Indicate using RAM disk.",
    "4629": "Move on to next character.",
    "4630": "Jump ahead to handle RAM disk command.",
    "4633": "Produce error report.",
    "4636": "\"C Nonsense in BASIC\"",
    "4637": "Save start address.",
    "4640": "Transfer header file information",
    "4643": "from IX to HD_00 onwards.",
    "4673": "Test file type.",
    "4674": "Jump ahead for a program file.",
    "4678": "Jump ahead for a CODE/SCREEN$ file.",
    "4683": "Store array name.",
    "4686": "IX points to file header.",
    "4688": "Retrieve into HL.",
    "4689": "HL points to filename.",
    "4696": "Copy the filename.",
    "4701": "SAVE operation?",
    "4703": "Jump ahead if SAVE.",
    "4715": "Transfer requested details from HD_00 onwards into SC_00 onwards.",
    "4717": "Find and load requested file header into HD_00 ($5B71).",
    "4720": "Requested file type.",
    "4724": "Loaded file type.",
    "4728": "Error 'b' if file types do not match.",
    "4730": "Is it a CODE file type?",
    "4732": "Jump ahead to avoid MERGE program/array check.",
    "4734": "Only file types 0, 1 and 2 are OK.",
    "4736": "Produce error report.",
    "4739": "\"b Wrong file type\"",
    "4743": "Is it a MERGE program/array operation?",
    "4745": "Jump ahead if so.",
    "4747": "Is it a VERIFY program/array operation?",
    "4749": "Jump ahead if LOAD.",
    "4755": "MERGE operation?",
    "4757": "Jump ahead if VERIFY.",
    "4759": "Produce error report.",
    "4762": "\"a MERGE error\"",
    "4763": "Length requested.",
    "4766": "File length.",
    "4772": "Jump ahead if requested length is 0, i.e. not specified.",
    "4774": "Is file length <= requested length?",
    "4776": "Jump ahead if so; requested length is OK.",
    "4778": "Produce error report.",
    "4781": "\"c CODE error\"",
    "4782": "Fetch start address.",
    "4787": "Jump ahead if start address was provided.",
    "4789": "Not provided so use file's start address.",
    "4792": "File type.",
    "4795": "Is it a program?",
    "4796": "Jump ahead if not.",
    "4798": "Set start address as start of program area.",
    "4801": "Load DE bytes at address pointed to by HL. [The Spectrum 128 manual states that the VERIFY keyword is not used with the RAM disk yet it clearly is, although verifying a RAM disk file simply loads it in just as LOAD would do. To support verifying, the routine at $1E37 (ROM 0) which loads blocks of data would need to be able to load or verify a block. The success status would then need to be propagated back to here via routines at $137E (ROM 0), $1C4B (ROM 0) and $1E37 (ROM 0)]",
    "4804": "[Could have saved 1 byte by using JP $137E (ROM 0), although could have saved a lot more by not supporting the VERIFY keyword at all]",
    "4805": "File length.",
    "4809": "Save the length.",
    "4810": "Increment for terminator $80 (added later).",
    "4812": "Create room in the workspace for the file.",
    "4814": "Insert terminator.",
    "4816": "HL=Start address.",
    "4817": "DE=File length.",
    "4818": "Save start address.",
    "4819": "Load DE bytes to address pointed to by HL.",
    "4822": "Retrieve start address.",
    "4824": "Delegate actual merge handling to ROM 1.",
    "4827": "File length.",
    "4831": "Requested start address.",
    "4834": "Save requested start address.",
    "4836": "Was start address specified? (0 if not).",
    "4837": "Jump ahead if start address specified.",
    "4839": "Allow for variable overhead.",
    "4842": "HL=File Length+3.",
    "4843": "Jump ahead to test if there is room.",
    "4845": "Requested length.",
    "4848": "DE=Requested length. HL=File length.",
    "4850": "File length-Requested Length-1",
    "4852": "Jump if file is smaller than requested.",
    "4859": "Space required in BC.",
    "4861": "Will automatically produce error '4' if out of memory.",
    "4863": "Requested start address.",
    "4864": "Get requested file type.",
    "4867": "Test file type.",
    "4868": "Jump if program file type.",
    "4871": "Was start address of existing array specified?",
    "4872": "Jump ahead if not.",
    "4877": "Fetch array length.",
    "4881": "Allow for variable header.",
    "4883": "Delete old array.",
    "4888": "Point to end",
    "4889": "Array length.",
    "4893": "Save array length.",
    "4894": "Allow for variable header.",
    "4897": "Get array name.",
    "4900": "Save array name.",
    "4902": "Create room for new array.",
    "4906": "Store array name.",
    "4911": "Store array length.",
    "4913": "Load DE bytes to address pointed to by HL.",
    "4916": "[Could have saved 1 byte by using JP $137E (ROM 0)]",
    "4920": "Signal do not auto-run BASIC program.",
    "4922": "Address of start of BASIC program.",
    "4926": "Address of end of program area.",
    "4929": "Point before terminator.",
    "4931": "Delete current BASIC program.",
    "4933": "Fetch file length.",
    "4937": "Address of start of BASIC program.",
    "4941": "Create room for the file.",
    "4943": "Allow for terminator.",
    "4944": "Length of variables.",
    "4948": "Determine new address of variables.",
    "4952": "Fetch high byte of auto-run line number.",
    "4958": "If holds $80 then no auto-run line number specified.",
    "4960": "Low byte of auto-run line number.",
    "4964": "Set line number to run.",
    "4967": "NSPPC. Statement 0.",
    "4974": "Signal auto-run BASIC program.",
    "4976": "Address of start of BASIC program.",
    "4979": "Program length.",
    "4984": "Set the address of next line to the end of the program.",
    "4988": "Jump back to load program bytes.",
    "4992": "Return if length is zero.",
    "4993": "Load bytes",
    "4996": "[Could have used JP $1C4B (ROM 0) to save 1 byte]",
    "4998": "Expect an expression on the BASIC line.",
    "5000": "Return early if syntax checking.",
    "5005": "Get the item off the calculator stack",
    "5011": "Advance the pointer into the BASIC line.",
    "5012": "Get expression from BASIC line.",
    "5015": "Return if syntax checking.",
    "5016": "[No need to save AF - see comment below]",
    "5017": "Check for zero length.",
    "5019": "Jump if so to produce error report \"f Invalid name\".",
    "5021": "Check for length greater than 10.",
    "5026": "Jump if so to produce error report \"f Invalid name\".",
    "5028": "Save the filename start address.",
    "5029": "Save the filename length.",
    "5030": "HL points to filename buffer.",
    "5037": "Fill it with 10 spaces.",
    "5041": "Restore filename length.",
    "5042": "Restore filename start address.",
    "5043": "DE points to where to store the filename.",
    "5046": "Perform the copy.",
    "5048": "[No need to have saved AF as not subsequently used]",
    "5050": "Produce error report.",
    "5053": "\"f Invalid name\"",
    "5055": "Pass the parameters of the 'name' to the calculator stack.",
    "5061": "Jump ahead if checking syntax.",
    "5063": "Size of save header, 17 bytes.",
    "5066": "Indicates which BASIC command.",
    "5069": "Is it SAVE?",
    "5070": "Jump ahead if so.",
    "5072": "Otherwise need 34d bytes for LOAD, MERGE and VERIFY commands. 17 bytes for the header of the requested file, and 17 bytes for the files tested from tape.",
    "5075": "Create space in workspace.",
    "5077": "Get start of the created space into IX.",
    "5080": "Clear the filename.",
    "5084": "Set all characters to spaces.",
    "5088": "Indicate a null name.",
    "5093": "The parameters of the name are fetched.",
    "5095": "= -10.",
    "5101": "Jump ahead if filename length within 10 characters.",
    "5103": "Indicates which BASIC command.",
    "5106": "Is it SAVE?",
    "5107": "Jump ahead if not since LOAD, MERGE and VERIFY can have null filenames.",
    "5109": "Produce error report.",
    "5112": "\"F Invalid file name\"",
    "5115": "Jump forward if the name has a null length.",
    "5117": "Truncate longer filenames.",
    "5122": "Transfer address of the workspace to HL.",
    "5123": "Step to the second location.",
    "5125": "Copy the filename.",
    "5127": "Get character from BASIC line.",
    "5128": "Is it 'DATA'?",
    "5130": "Jump if not DATA.",
    "5132": "Check the BASIC command.",
    "5135": "Is it MERGE?",
    "5137": "\"C Nonsense in BASIC\" if so.",
    "5140": "Get next character from BASIC line.",
    "5142": "Look in the variables area for the array.",
    "5144": "Jump if handling an existing array.",
    "5146": "Signal 'using a new array'.",
    "5149": "FLAGS. Is it a string Variable?",
    "5153": "Jump forward if so.",
    "5155": "Set bit 7 of the array's name.",
    "5160": "Give an error if trying to",
    "5161": "SAVE or VERIFY a new array.",
    "5163": "Produce error report.",
    "5166": "\"2 Variable not found\"",
    "5167": "Jump if not an array to produce \"C Nonsense in BASIC\".",
    "5170": "FLAGS.",
    "5174": "Jump forward if checking syntax.",
    "5177": "Point to the 'low length' of the variable.",
    "5178": "The low length byte goes into",
    "5179": "the work space.",
    "5183": "The high length byte goes into",
    "5184": "the work space.",
    "5187": "Step past the length bytes.",
    "5188": "Copy the array's name.",
    "5191": "Assume an array of numbers - Code $01.",
    "5195": "Jump if it is so.",
    "5197": "Indicate it is an array of characters - Code $02.",
    "5198": "Save the 'type' in the first location of the header area.",
    "5201": "Save the pointer in DE.",
    "5203": "Is the next character a ')'?",
    "5205": "Give report C if it is not.",
    "5207": "Advance to next character.",
    "5208": "Move on to the next statement if checking syntax.",
    "5211": "Return the pointer to the HL. (The pointer indicates the start of an existing array's contents).",
    "5212": "Jump forward.",
    "5215": "Is the present code the token 'SCREEN$'?",
    "5217": "Jump ahead if not.",
    "5219": "Check the BASIC command.",
    "5222": "Is it MERGE?",
    "5224": "Jump to \"C Nonsense in BASIC\" if so since it is not possible to have 'MERGE name SCREEN$'.",
    "5227": "Advance pointer into BASIC line.",
    "5228": "Move on to the next statement if checking syntax.",
    "5231": "Length of the block.",
    "5235": "The display area and the attribute area occupy $1800 locations.",
    "5239": "Start of the block, beginning of the display file $4000.",
    "5245": "Store in the workspace.",
    "5248": "Jump forward.",
    "5250": "Is the present code the token 'CODE'?",
    "5252": "Jump ahead if not.",
    "5254": "Check the BASIC command.",
    "5257": "Is it MERGE?",
    "5259": "Jump to \"C Nonsense in BASIC\" if so since it is not possible to have 'MERGE name CODE'.",
    "5262": "Advance pointer into BASIC line.",
    "5266": "Jump forward if the statement has not finished",
    "5271": "It is not possible to have 'SAVE name CODE' by itself.",
    "5272": "Jump if so to produce \"C Nonsense in BASIC\".",
    "5276": "Put a zero on the calculator stack - for the 'start'.",
    "5278": "Jump forward.",
    "5281": "Fetch the first number.",
    "5284": "Is the present character a ','?",
    "5286": "Jump if it is - the number was a 'starting address'",
    "5291": "Refuse 'SAVE name CODE' that does not have a 'start' and a 'length'.",
    "5292": "Jump if so to produce \"C Nonsense in BASIC\".",
    "5296": "Put a zero on the calculator stack - for the 'length'.",
    "5298": "Jump forward.",
    "5300": "Advance to next character.",
    "5302": "Fetch the 'length'.",
    "5304": "But move on to the next statement now if checking syntax.",
    "5308": "Compress the 'length' into BC.",
    "5317": "Compress the 'starting address' into BC.",
    "5310": "Store the length of the CODE block.",
    "5319": "Store the start address of the CODE block.",
    "5325": "Transfer start address pointer to HL.",
    "5327": "Store file type = $03 (CODE).",
    "5331": "Rejoin the other pathways.",
    "5333": "Is the present code the token 'LINE'?",
    "5335": "Jump ahead if so.",
    "5337": "Move on to the next statement if checking syntax.",
    "5340": "Indicate no LINE number.",
    "5344": "Jump forward.",
    "5346": "Only allow 'SAVE name LINE number'.",
    "5349": "Is it SAVE?",
    "5350": "Produce \"C Nonsense in BASIC\" if not.",
    "5353": "Advance pointer into BASIC line.",
    "5355": "Get LINE number onto calculator stack",
    "5357": "Move on to the next statement if checking syntax.",
    "5361": "Compress the 'line number' into BC.",
    "5363": "Store the LINE number.",
    "5369": "Store file type = $00 (program).",
    "5373": "The pointer to the end of the variables area.",
    "5376": "The pointer to the start of the BASIC program.",
    "5381": "Perform the subtraction to find the length of the 'program + variables'.",
    "5386": "Store the length.",
    "5389": "Repeat the operation but this",
    "5392": "time storing the length of the",
    "5394": "'program' only.",
    "5400": "Transfer pointer to HL.",
    "5404": "Using RAM disk?",
    "5406": "Jump if the operation is on the RAM disk.",
    "5409": "Get the BASIC command.",
    "5412": "Is it SAVE?",
    "5413": "Jump ahead if not.",
    "5416": "Run the save routine in ROM 1.",
    "5420": "Run the load/merge/verify routine in ROM 1.",
    "5423": "Flags.",
    "5426": "Signal this is not the current line.",
    "5428": "Signal not yet located the current line.",
    "5430": "Fetch current line number.",
    "5434": "Is there a currently selected line?",
    "5435": "Jump ahead if so.",
    "5437": "Set to $0000 to indicate no editable characters before the cursor.",
    "5440": "Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer,",
    "5443": "i.e. that are off the top of the screen.",
    "5444": "Line number of the BASIC line at the top of the screen (or 0 for the first line).",
    "5447": "Find closest line number (or $0000 if no subsequent line exists).",
    "5450": "Store the line number of the BASIC line being edited in the buffer.",
    "5453": "Set default Above-Screen Line Edit Buffer settings.",
    "5456": "Set default Below-Screen Line Edit Buffer settings.",
    "5459": "A=Number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer.",
    "5460": "Are there any rows off the top of the screen?",
    "5461": "Jump ahead if not.",
    "5463": "Save the number of rows off the top of the screen.",
    "5464": "Copy a BASIC line from the program area into the Below-Screen Line Edit Buffer.",
    "5467": "DE=Address of the Below-Screen Line Edit Buffer.",
    "5468": "Shift up a row into the Above-Screen Line Edit Buffer.",
    "5471": "Retrieve the number of rows off the top of the screen.",
    "5472": "Decrement the number of rows.",
    "5473": "Jump back to shift up another row if required.",
    "5475": "C=Row 0.",
    "5477": "DE=Start address in Screen Line Edit Buffer of the first row, as specified in C.",
    "5480": "B=Row 0.",
    "5481": "The number of editing rows on screen.",
    "5484": "C=Number of editing rows on screen.",
    "5485": "B=Row number, C=Number of editing rows on screen.",
    "5486": "DE=Start address in Screen Line Edit Buffer of the first row.",
    "5487": "Shift up all rows of the BASIC line in the Below-Screen Line Edit Buffer, or if empty then copy a BASIC line from the program area into it. If no BASIC line available then empty the first row of the Below-Screen Line Edit Buffer.",
    "5490": "Listing flags.",
    "5493": "Has the current line been previously found?",
    "5495": "Jump if so.",
    "5497": "DE=Start address in Screen Line Edit Buffer of the current row.",
    "5498": "HL=Address of the first row in the Below-Screen Line Edit Buffer.",
    "5502": "Point to the flag byte for the first row.",
    "5503": "Is it the first row of a BASIC line?",
    "5505": "Jump if not.",
    "5508": "Get line number into DE.",
    "5512": "Current line number.",
    "5517": "Jump ahead unless this is the current line.",
    "5522": "Signal this is the current line.",
    "5524": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5525": "DE=Start address in Screen Line Edit Buffer of the current row.",
    "5526": "B=Row number, C=Number of editing rows on screen.",
    "5527": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5531": "Copy the first row of the BASIC line in the Below-Screen Line Edit Buffer into the next row of the Screen Line Edit Buffer.",
    "5533": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5534": "B=Row number, C=Number of editing rows on screen.",
    "5535": "DE=Start address in Screen Line Edit Buffer of the next row.",
    "5536": "B=Row number, C=Number of editing rows on screen.",
    "5537": "DE=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5538": "Flags.",
    "5541": "Is this the current line?",
    "5543": "Jump if not.",
    "5545": "Column 0.",
    "5547": "HL=Count of the number of editable characters in the BASIC line up to the cursor within the Screen Line Edit Buffer.",
    "5551": "Are there any editable characters in this row prior to the cursor?",
    "5552": "Jump if there are none, i.e. cursor at start of the row.",
    "5554": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "5559": "Jump if no editable character found on this row, i.e. there must be more characters on the next row.",
    "5561": "Decrement the count of characters prior to the cursor.",
    "5562": "Advance to next column.",
    "5563": "Update the count of the number of editable characters up to the cursor.",
    "5566": "Jump back to test next column.",
    "5568": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "5571": "If no editable character found then find editable position to the left, returning column number in B.",
    "5574": "Flags.",
    "5577": "Signal 'not the current line', 'current line has previously been found' and 'update display file enabled'.",
    "5579": "A=Column number. This will be the preferred column number.",
    "5580": "B=Row number, C=Number of editing rows on screen.",
    "5582": "C=Row number.",
    "5583": "B=Column number.",
    "5584": "Store this as the current cursor editing position.",
    "5587": "B=Row number, C=Number of editing rows on screen.",
    "5588": "DE=Start address in Screen Line Edit Buffer of the next row.",
    "5589": "A=Number of editing rows on screen.",
    "5590": "Next row.",
    "5591": "Reached the bottom screen row?",
    "5592": "Jump back if not to display the next row.",
    "5594": "Listing flags.",
    "5597": "Has the current line been previously found?",
    "5599": "Jump if so.",
    "5601": "Is this the current line?",
    "5603": "Jump if so.",
    "5605": "Current line number.",
    "5610": "Jump if there is no current line number.",
    "5612": "Store it as the line number at top of the screen.",
    "5615": "Set default Above-Screen Line Edit Buffer settings to clear the count of the number of rows it contains.",
    "5618": "Jump forward.",
    "5623": "Create line number representation in the Keyword Construction Buffer of the next BASIC line.",
    "5620": "Set the line number at top of the screen to $0000, i.e. first available.",
    "5626": "Current line number is the first in the BASIC program.",
    "5629": "DE=Start address in Screen Line Edit Buffer of the first row.",
    "5630": "B=Row number, C=Number of editing rows on screen.",
    "5631": "Jump back to continue listing the program until the current line is found.",
    "5634": "Save the zero flag.",
    "5635": "Save the number of editing rows on screen.",
    "5636": "Set the zero flag if current line has yet to be found, hence signal do not update cursor position settings.",
    "5637": "Save the zero flag.",
    "5638": "Save the number of editing rows on screen.",
    "5639": "C=Row number.",
    "5640": "DE=Start address in Screen Line Edit Buffer of row held in C",
    "5643": "and transfer into HL.",
    "5644": "A=Number of editing rows on screen.",
    "5645": "Print a row of the edit buffer to the screen.",
    "5649": "Point to the start of the next row.",
    "5655": "Jump back if not to print next row.",
    "5654": "All rows printed?",
    "5653": "Advance to the next row.",
    "5657": "Retrieve the zero flag.",
    "5658": "Return if 'not the current line' and 'current line has previously been found'.",
    "5659": "Get current cursor position (C=row, B=column, A=preferred column).",
    "5662": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary. Returns column number in B.",
    "5665": "Fetch the number of editable characters on this row prior to the cursor.",
    "5668": "Decrement the count.",
    "5669": "Are there any characters?",
    "5671": "Store the new count.",
    "5674": "Jump if there are some characters prior to the cursor.",
    "5676": "Store cursor editing position, with preferred column of 0.",
    "5679": "[Redundant byte]",
    "5680": "Top row of editing area.",
    "5682": "The number of editing rows on screen.",
    "5685": "D=Number of rows in editing area.",
    "5686": "Clear specified display rows.",
    "5689": "Row number to start shifting from.",
    "5691": "Save the address of the 'Bottom Row Scroll Threshold' within the editing area information.",
    "5692": "Find the address of row 0.",
    "5693": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "5696": "Attempt to shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer.",
    "5699": "Retrieve the address of the 'Bottom Row Scroll Threshold' within the editing area information.",
    "5700": "Return if the Above-Screen Line Edit Buffer is full, i.e. no edit buffer rows shifted.",
    "5701": "Shift up rows of the BASIC line in Below-Screen Line Edit Buffer, inserting the next line BASIC line if the buffer becomes empty. Returns with HL holding the address of the first row in the Below-Screen Line Edit Buffer.",
    "5704": "B=Row counter.",
    "5705": "HL=Address of first row in the Below-Screen Line Edit Buffer.",
    "5706": "DE=Address of the current row in the Screen Line Edit Buffer.",
    "5709": "HL=Address of the next row in the Screen Line Edit Buffer.",
    "5713": "C=Number of editing rows on screen.",
    "5714": "Any rows to shift?",
    "5715": "Jump if not.",
    "5717": "C=Number of editing rows on screen.",
    "5718": "C=Number of editing rows on screen.",
    "5719": "DE=Current Screen Line Edit Buffer row, HL=Next Screen Line Edit Buffer row.",
    "5722": "Shift one row of the Screen Line Edit Buffer up.",
    "5724": "C=Number of editing rows on screen.",
    "5725": "Fetch the number of editing rows on screen.",
    "5726": "Next row.",
    "5727": "All rows shifted?",
    "5728": "Repeat for all edit buffer rows to shift.",
    "5730": "C=Number of editing rows on screen, B=Row number, i.e. 0.",
    "5731": "HL=Address of the first row in the Below-Screen Line Edit Buffer.",
    "5732": "Shift up all edit rows in the display file if updating required.",
    "5735": "HL=Address of the first row in the Below-Screen Line Edit Buffer, DE=Address of last row in Screen Line Edit Buffer.",
    "5738": "Copy the first row of the Below-Screen Line Edit Buffer into the last row of the Screen Line Edit Buffer.",
    "5740": "Signal that edit buffer rows were shifted.",
    "5741": "B=Row counter.",
    "5743": "Last row number to shift.",
    "5745": "Attempt to shift down the Above-Screen Line Edit Buffer, loading in a new BASIC line if it is empty.",
    "5748": "Return if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.",
    "5749": "B=Last row number to shift.",
    "5750": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "5751": "A=Number of editing rows on screen.",
    "5754": "C=Number of editing rows on screen.",
    "5755": "DE=Start address in Screen Line Edit Buffer of the last editing row.",
    "5758": "Shift down all rows in the Below-Screen Line Edit Buffer, or empty the buffer a row does not straggle off the bottom of the screen.",
    "5761": "Jump if the Below-Screen Line Edit Buffer is full.",
    "5763": "DE=Address of the last flag byte of the penultimate editing row in the Screen Line Edit Buffer.",
    "5764": "Length of an edit buffer row.",
    "5767": "HL=Address of the last flag byte of the last editing row in the Screen Line Edit Buffer.",
    "5768": "DE=Address of last flag byte of last editing row in Screen Line Edit Buffer, HL=Address of last flag byte of penultimate editing row in Screen Line Edit Buffer.",
    "5769": "C=Number of editing rows on screen, B=Last row number to shift.",
    "5771": "Any rows to shift?",
    "5772": "Jump if not.",
    "5774": "C=Row number to shift, B=Last row number to shift.",
    "5778": "Copy one row of the Screen Line Edit Buffer down.",
    "5780": "C=Number of editing rows on screen, B=Row shift counter.",
    "5781": "A=Row shift counter.",
    "5784": "Repeat for all edit buffer rows to shift.",
    "5786": "HL=Address of last flag byte of first editing row in Screen Line Edit Buffer, DE=Address of byte before start of first editing row in Screen Line Edit Buffer.",
    "5787": "DE=Start of first row in Screen Line Edit Buffer.",
    "5788": "C=Number of editing rows on screen, B=Last row number to shift.",
    "5789": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "5790": "Shift down all edit rows in the display file if updating required.",
    "5796": "Copy the next row of the Above-Screen Line Edit Buffer into the first row of the Screen Line Edit Buffer.",
    "5798": "Signal Below-Screen Line Edit Buffer is not full.",
    "5799": "B=Last row number to shift.",
    "5801": "Restore registers.",
    "5802": "B=Last row number to shift.",
    "5804": "Save DE.",
    "5807": "HL=Start column number.",
    "5808": "HL=Address of the starting column.",
    "5809": "Store the character to shift in.",
    "5810": "A=Start column number.",
    "5811": "Fetch a character from the row.",
    "5812": "Replace it with the character to shift in.",
    "5813": "Store the old character for use next time.",
    "5814": "Point to the next column.",
    "5816": "End of row reached?",
    "5818": "Jump if not to shift the next character.",
    "5820": "A=Character that was shifted out.",
    "5821": "Return with zero flag set if the character was $00.",
    "5823": "Restore DE",
    "5825": "Save DE.",
    "5826": "32 columns.",
    "5829": "Point to the flag byte for this row.",
    "5830": "Save it.",
    "5831": "Store the character to shift in.",
    "5832": "Maximum of 31 shifts.",
    "5834": "Jump ahead to start shifting.",
    "5836": "Fetch a character from the row.",
    "5837": "Replace it with the character to shift in.",
    "5838": "Store the old character for use next time.",
    "5839": "End column reached?",
    "5840": "Jump if so to exit.",
    "5842": "Decrement column counter.",
    "5843": "Point back a column.",
    "5844": "Loop back to shift the next character.",
    "5846": "A=Character that was shifted out.",
    "5847": "Return with zero flag set if the character was $00.",
    "5849": "Fetch address of next flag byte for the row.",
    "5850": "Restore DE.",
    "5852": "DEF FN    -> $178D (ROM 0)",
    "5853": "CAT       -> $17A6 (ROM 0)",
    "5854": "FORMAT    -> $179A (ROM 0)",
    "5855": "MOVE      -> $179D (ROM 0)",
    "5856": "ERASE     -> $17A3 (ROM 0)",
    "5857": "OPEN #    -> $1790 (ROM 0)",
    "5858": "CLOSE #   -> $1796 (ROM 0)",
    "5859": "MERGE     -> $1776 (ROM 0)",
    "5860": "VERIFY    -> $1775 (ROM 0)",
    "5861": "BEEP      -> $1777 (ROM 0)",
    "5862": "CIRCLE    -> $177B (ROM 0)",
    "5863": "INK       -> $177F (ROM 0)",
    "5864": "PAPER     -> $1780 (ROM 0)",
    "5865": "FLASH     -> $1781 (ROM 0)",
    "5866": "BRIGHT    -> $1782 (ROM 0)",
    "5867": "INVERSE   -> $1783 (ROM 0)",
    "5868": "OVER      -> $1784 (ROM 0)",
    "5869": "OUT       -> $1785 (ROM 0)",
    "5870": "LPRINT    -> $176D (ROM 0)",
    "5871": "LLIST     -> $1770 (ROM 0)",
    "5872": "STOP      -> $171E (ROM 0)",
    "5873": "READ      -> $175D (ROM 0)",
    "5874": "DATA      -> $1760 (ROM 0)",
    "5875": "RESTORE   -> $1763 (ROM 0)",
    "5876": "NEW       -> $173C (ROM 0)",
    "5877": "BORDER    -> $1789 (ROM 0)",
    "5878": "CONTINUE  -> $174C (ROM 0)",
    "5879": "DIM       -> $1736 (ROM 0)",
    "5880": "REM       -> $1739 (ROM 0)",
    "5881": "FOR       -> $1724 (ROM 0)",
    "5882": "GO TO     -> $1711 (ROM 0)",
    "5883": "GO SUB    -> $171A (ROM 0)",
    "5884": "INPUT     -> $1733 (ROM 0)",
    "5885": "LOAD      -> $1774 (ROM 0)",
    "5886": "LIST      -> $1742 (ROM 0)",
    "5887": "LET       -> $170E (ROM 0)",
    "5888": "PAUSE     -> $1759 (ROM 0)",
    "5889": "NEXT      -> $172C (ROM 0)",
    "5890": "POKE      -> $1745 (ROM 0)",
    "5891": "PRINT     -> $1730 (ROM 0)",
    "5892": "PLOT      -> $1755 (ROM 0)",
    "5893": "RUN       -> $173F (ROM 0)",
    "5894": "SAVE      -> $1773 (ROM 0)",
    "5895": "RANDOMIZE -> $1749 (ROM 0)",
    "5896": "IF        -> $1715 (ROM 0)",
    "5897": "CLS       -> $1752 (ROM 0)",
    "5898": "DRAW      -> $1766 (ROM 0)",
    "5899": "CLEAR     -> $174F (ROM 0)",
    "5900": "RETURN    -> $1721 (ROM 0)",
    "5901": "COPY      -> $176A (ROM 0)",
    "5902": "LET: CLASS-01, \"=\", CLASS-02",
    "5905": "GOTO: CLASS-06, CLASS-00",
    "5909": "IF: CLASS-06, \"THEN\", CLASS-0E",
    "5914": "GO SUB: CLASS-06, CLASS-0C",
    "5918": "STOP: CLASS-00",
    "5921": "RETURN: CLASS-0C",
    "5924": "FOR: CLASS-04, \"=\", CLASS-06, \"TO\", CLASS-06, CLASS-0E",
    "5932": "NEXT: CLASS-04",
    "5936": "PRINT: CLASS-0E",
    "5939": "INPUT: CLASS-0E",
    "5942": "DIM: CLASS-0E",
    "5945": "REM: CLASS-0E",
    "5948": "NEW: CLASS-0C",
    "5951": "RUN: CLASS-0D",
    "5954": "LIST: CLASS-0E",
    "5957": "POKE: CLASS-08, CLASS-00",
    "5961": "RANDOMIZE: CLASS-03",
    "5964": "CONTINUE: CLASS-00",
    "5967": "CLEAR: CLASS-0D",
    "5970": "CLS: CLASS-00",
    "5973": "PLOT: CLASS-09, CLASS-00",
    "5977": "PAUSE: CLASS-06, CLASS-00",
    "5981": "READ: CLASS-0E",
    "5984": "DATA: CLASS-0E",
    "5987": "RESTORE: CLASS-03",
    "5990": "DRAW: CLASS-09, CLASS-0E",
    "5994": "COPY: CLASS-0C",
    "5997": "LPRINT: CLASS-0E",
    "6000": "LLIST: CLASS-0E",
    "6003": "SAVE: CLASS-0B",
    "6004": "LOAD: CLASS-0B",
    "6005": "VIRIFY: CLASS-0B",
    "6006": "MERGE: CLASS-0B",
    "6007": "BEEP: CLASS-08, CLASS-00",
    "6011": "CIRCLE: CLASS-09, CLASS-0E",
    "6015": "INK: CLASS-07",
    "6016": "PAPER: CLASS-07",
    "6017": "FLASH: CLASS-07",
    "6018": "BRIGHT: CLASS-07",
    "6019": "INVERSE: CLASS-07",
    "6020": "OVER: CLASS-07",
    "6021": "OUT: CLASS-08, CLASS-00",
    "6025": "BORDER: CLASS-06, CLASS-00",
    "6029": "DEF FN: CLASS-0E",
    "6032": "OPEN #: CLASS-06, \",\", CLASS-0A, CLASS-00",
    "6038": "CLOSE #: CLASS-06, CLASS-00",
    "6042": "FORMAT: CLASS-0E",
    "6045": "MOVE: CLASS-0A, \",\" CLASS-0A, CLASS-0C",
    "6051": "ERASE: CLASS-0E",
    "6054": "CAT: CLASS-0E",
    "6057": "SPECTRUM: CLASS-0C",
    "6060": "PLAY: CLASS-0E",
    "6063": "Signal 'syntax checking'.",
    "6068": "CH-ADD is made to point to the first code after any line number",
    "6071": "Set to $00.",
    "6075": "Set to $FF.",
    "6078": "Jump forward to consider the first statement of the line.",
    "6080": "Advance CH-ADD along the line.",
    "6082": "The work space is cleared.",
    "6084": "Increase SUBPPC on each passage around the loop.",
    "6087": "Only '127' statements are allowed in a single line. Jump to report \"C Nonsense in BASIC\".",
    "6090": "Fetch a character.",
    "6091": "Clear the register for later.",
    "6093": "Is the character a 'carriage return'?",
    "6095": "jump if it is.",
    "6098": "Go around the loop again if it is a ':'.",
    "6102": "Pre-load the machine stack with the return address.",
    "6106": "Save the command temporarily",
    "6107": "in the C register whilst CH-ADD is advanced again.",
    "6109": "Reduce the command's code by $CE giving the range indexed from $00.",
    "6111": "Jump for DEF FN and above.",
    "6118": "Is it 'SPECTRUM'?",
    "6120": "Jump if so into the scanning loop with this address.",
    "6125": "Is it 'PLAY'?",
    "6127": "Jump if so into the scanning loop with this address.",
    "6129": "Produce error report \"C Nonsense in BASIC\".",
    "6132": "Move the command code to BC (B holds $00).",
    "6133": "The base address of the syntax offset table.",
    "6138": "Find address for the command's entries in the parameter table.",
    "6139": "Jump forward into the scanning loop with this address.",
    "6144": "Fetch each entry in turn.",
    "6145": "Update the pointer to the entries for the next pass.",
    "6149": "Pre-load the machine stack with the return address.",
    "6153": "Copy the entry to the C register for later.",
    "6156": "Jump forward if the entry is a 'separator'.",
    "6163": "Index into the table.",
    "6165": "HL=base + code + (base + code).",
    "6166": "HL=The starting address of the required command class routine.",
    "6167": "Before making an indirect jump to the command class routine pass the command code",
    "6168": "to the A register and set the B register to $FF.",
    "6169": "Return to the stacked address.",
    "6170": "The current character is",
    "6171": "fetched and compared to the entry in the parameter table.",
    "6172": "Give the error report if there is not a match.",
    "6175": "Step past a correct character",
    "6176": "and return.",
    "6177": "Check for BREAK",
    "6180": "Jump if not pressed.",
    "6182": "Produce error report.",
    "6185": "\"L Break into program\"",
    "6186": "NSPPC - statement number in line to be jumped to",
    "6190": "Jump forward if there is not a 'jump' to be made.",
    "6193": "NEWPPC, line number to be jumped to.",
    "6198": "Jump forward unless dealing with a further statement in the editing area.",
    "6200": "A line in the editing area is considered as line '-2'.",
    "6206": "Make HL point to the end marker of the editing area.",
    "6210": "Make DE point to the location before the end marker of the editing area.",
    "6215": "Fetch the number of the next statement to be handled.",
    "6218": "Jump forward.",
    "6221": "The starting address of the line, or the 'first line after' is found.",
    "6223": "Collect the statement number.",
    "6226": "Jump forward if the required line was found.",
    "6228": "Check the validity of the statement number - must be zero.",
    "6229": "Jump if not to produce error report \"N Statement lost\".",
    "6231": "Also check that the 'first",
    "6232": "line after' is not after the",
    "6233": "actual 'end of program'.",
    "6236": "Jump forward with valid addresses; otherwise signal the error 'OK'.",
    "6238": "Produce error report.",
    "6241": "\"0 OK\"",
    "6242": "Drop the statement return address.",
    "6247": "Return if syntax is being checked.",
    "6255": "Signal 'statement zero' before proceeding.",
    "6251": "Return if the address is after the end of the program - the 'run' is finished.",
    "6256": "Statement zero becomes statement 1.",
    "6260": "The line number of the line to be used is collected and",
    "6261": "passed to PPC.",
    "6268": "Now find the 'length' of the line.",
    "6271": "Switch over the values.",
    "6272": "Form the address of the start of the line after in HL and the",
    "6273": "location before the 'next' line's first character in DE.",
    "6274": "Set NXTLIN for use once the current line has been completed.",
    "6278": "CH_ADD points to the location before the first character to be considered.",
    "6281": "The statement number is fetched.",
    "6282": "The E register is cleared in case the 'Each Statement' routine is used.",
    "6284": "Signal 'no jump'.",
    "6289": "SUB_PPC. Statement number-1.",
    "6292": "Jump if the first statement.",
    "6295": "For later statements the 'starting address' has to be found.",
    "6299": "Jump forward unless the statement does not exist.",
    "6301": "Produce error report.",
    "6304": "\"N Statement lost\"",
    "6305": "Very like CHECK-END at 1BEE in ROM 1",
    "6309": "Return unless checking syntax.",
    "6310": "Drop scan loop and statement return addresses.",
    "6312": "Fetch the present character.",
    "6313": "Consider the 'next line' if",
    "6315": "it is a 'carriage return'.",
    "6317": "\":\". Consider the 'next statement'",
    "6319": "if it is a ':'.",
    "6322": "Otherwise there has been a syntax error so produce \"C Nonsense in BASIC\".",
    "6325": "CLASS-00 -> L18D9 = $24",
    "6326": "CLASS-01 -> L18F9 = $43",
    "6327": "CLASS-02 -> L18FD = $46",
    "6328": "CLASS-03 -> L18D6 = $1E",
    "6329": "CLASS-04 -> L1905 = $4C",
    "6330": "CLASS-05 -> L18DA = $20",
    "6331": "CLASS-06 -> L190E = $53",
    "6332": "CLASS-07 -> L191A = $5E",
    "6333": "CLASS-08 -> L190A = $4D",
    "6334": "CLASS-09 -> L1944 = $86",
    "6335": "CLASS-0A -> L1916 = $57",
    "6336": "CLASS-0B -> L1948 = $88",
    "6337": "CLASS-0C -> L18C7 = $06",
    "6338": "CLASS-0D -> L18C4 = $02",
    "6339": "CLASS-0E -> L18C8 = $05",
    "6340": "Code 0D enters here.",
    "6343": "Code 0C enters here. Set zero flag.",
    "6344": "Code 0E enters here. Retrieve return address.",
    "6345": "If handling commands of classes 0C & 0D and syntax is being checked move on now to consider the next statement.",
    "6348": "Save the line pointer in DE.",
    "6352": "Fetch the pointer to the entries in the parameter table",
    "6353": "and fetch the address of the",
    "6354": "required command routine.",
    "6355": "Exchange the pointers back.",
    "6356": "Make an indirect jump to the command routine.",
    "6358": "Code 03 enters here.",
    "6359": "A number is fetched but zero is used in cases of default.",
    "6361": "Code 00 enters here. Set the zero flag.",
    "6362": "Code 05 enters here. Drop return address.",
    "6363": "If handling commands of classes 00 & 03 and syntax is being checked move on now to consider the next statement.",
    "6366": "Save the line pointer in DE.",
    "6367": "Fetch the pointer to the entries in the parameter table.",
    "6372": "Fetch the address of the required command routine.",
    "6373": "Exchange the pointers back.",
    "6374": "Save command routine address.",
    "6375": "The address to return to (the RET below).",
    "6378": "Store the return address.",
    "6381": "Paging subroutine.",
    "6384": "Replace the return address with the address of the YOUNGER routine.",
    "6385": "Save the original top stack item.",
    "6387": "HL=Address of command routine.",
    "6388": "Put onto the stack so that an indirect jump will be made to it.",
    "6389": "Switch to other ROM and 'return' to the command routine.",
    "6393": "Delegate handling to ROM 1.",
    "6397": "Code 02 enters here. Delegate handling to ROM 1.",
    "6399": "\"... used by LET, READ and INPUT statements to first evaluate and then assign values to the previously designated variable\" (Logan/O'Hara)",
    "6401": "Move on to the next statement if checking syntax",
    "6404": "else return here.",
    "6405": "Code 04 enters here. Delegate handling to ROM 1.",
    "6409": "[Redundant byte]",
    "6410": "Delegate handling to ROM 1.",
    "6414": "Code 06 enters here. Delegate handling to ROM 1.",
    "6418": "Produce error report. [Could have saved 4 bytes by using the identical routine at $1219 (ROM 0) instead]",
    "6421": "\"C Nonsense in BASIC\"",
    "6422": "Code 0A enters here. Delegate handling to ROM 1.",
    "6426": "The syntax/run flag is read.",
    "6430": "TV_FLAG. Signal 'main screen'.",
    "6434": "Jump ahead if syntax checking.",
    "6436": "Only during a 'run' call TEMPS to ensure the temporary",
    "6437": "colours are the main screen colours.",
    "6439": "Drop the return address.",
    "6443": "Reduce to range $D9-$DE which are the token codes for INK to OVER.",
    "6446": "Change the temporary colours as directed by the BASIC statement.",
    "6448": "Move on to the next statement if checking syntax.",
    "6451": "Now the temporary colour",
    "6454": "values are made permanent",
    "6460": "Value of P_FLAG also has to be considered.",
    "6461": "Move the mask leftwards.",
    "6462": "Impress onto the mask",
    "6463": "only the even bits of the",
    "6465": "other byte.",
    "6466": "Restore the result.",
    "6469": "Code 09 enters here. Delegate handling to ROM 1.",
    "6472": "Drop the return address.",
    "6476": "Clear LOAD/SAVE/VERIFY/MERGE indication bits.",
    "6484": "Correct by $74 so that SAVE = $00, LOAD = $01, VERIFY = $02, MERGE = $03.",
    "6489": "Jump to handle SAVE.",
    "6493": "Jump to handle LOAD.",
    "6497": "Jump to handle VERIFY.",
    "6500": "Jump to handle MERGE.",
    "6503": "Drop the return address.",
    "6508": "Jump forward if checking syntax.",
    "6516": "The present 'last value' is deleted.",
    "6513": "-5",
    "6517": "HL point to the first byte of the value.",
    "6521": "Is the value zero?",
    "6523": "If the value was 'FALSE' jump to the next line.",
    "6526": "But if 'TRUE' jump to the next statement (after the THEN).",
    "6529": "Jump forward unless a 'STEP' is given.",
    "6533": "Advance pointer",
    "6534": "Indirectly call EXPT_1NUM in ROM 1 to get the value of the STEP.",
    "6537": "Move on to the next statement if checking syntax.",
    "6540": "Otherwise jump forward.",
    "6542": "Move on to the next statement if checking syntax.",
    "6560": "Place a value of 1 on the calculator stack.",
    "6570": "Come here on each pass, after the first, to move along the READ statement.",
    "6571": "Indirectly call CLASS_01 in ROM 1 to consider whether the variable has been used before, and find the existing entry if it has.",
    "6578": "Jump forward if checking syntax.",
    "6581": "Save the current pointer CH_ADD in X_PTR.",
    "6584": "Fetch the current DATA list pointer",
    "6587": "and jump forward unless a new",
    "6590": "DATA statement has to be found.",
    "6592": "The search is for 'DATA'.",
    "6597": "Jump forward if the search is successful.",
    "6599": "Produce error report.",
    "6602": "\"E Out of Data\"",
    "6603": "Advance the pointer along the DATA list.",
    "6609": "Fetch the value and assign it to the variable.",
    "6615": "Fetch the current value of CH_ADD and store it in DATADD.",
    "6618": "X_PTR_hi. Clear the address of the character after the '?' marker.",
    "6622": "Make CH-ADD once again point to the READ statement.",
    "6626": "GET the present character",
    "6627": "Check if it is a ','.",
    "6629": "If it is then jump back as there are further items.",
    "6631": "Return if checking syntax",
    "6634": "or here if not checking syntax.",
    "6635": "Jump forward unless checking syntax.",
    "6642": "Scan the next expression.",
    "6644": "Check for the correct separator ','.",
    "6646": "but move on to the next statement if not matched.",
    "6649": "Whilst there are still expressions to be checked",
    "6650": "go around again.",
    "6652": "It is a 'DATA' statement that is to be passed-by.",
    "6655": "Delegate handling to ROM 1.",
    "6661": "Now perform a 'RESTORE 0'.",
    "6667": "Exit via the CLEAR command routine.",
    "6670": "Fetch the operand - using zero by default.",
    "6672": "Jump forward if the operand is",
    "6673": "other than zero. When called",
    "6674": "from RUN there is no jump.",
    "6676": "Use RAMTOP if the parameter is 0.",
    "6680": "BC = Address to clear to. Save it.",
    "6689": "Delete the variables area.",
    "6692": "Clear the screen",
    "6695": "The current value of STKEND",
    "6698": "is increased by 50 before",
    "6701": "being tested. This forms the",
    "6702": "ADE = address to clear to lower limit.",
    "6705": "Ramtop no good.",
    "6707": "For the upper test the value",
    "6710": "for RAMTOP is tested against P_RAMT.",
    "6713": "Jump forward if acceptable.",
    "6715": "Produce error report.",
    "6718": "\"M Ramtop no good\"",
    "6723": "Retrieve interpreter return address from stack",
    "6724": "Retrieve 'error address' from stack",
    "6725": "Retrieve the GO SUB stack end marker. [*BUG* - It is assumed that the top of the GO SUB stack will be empty and hence only contain the end marker. This will not be the case if CLEAR is used within a subroutine, in which case BC will now hold the calling line number and this will be stacked in place of the end marker. When a RETURN command is encountered, the GO SUB stack appears to contain an entry since the end marker was not the top item. An attempt to return is therefore made. The CLEAR command handler within the 48K Spectrum ROM does not make any assumption about the contents of the GO SUB stack and instead always re-inserts the end marker. The bug could be fixed by inserting the line LD BC,$3E00 after the POP BC. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "6731": "Stack the GO SUB stack end marker.",
    "6732": "Stack 'error address'.",
    "6737": "Stack the interpreter return address.",
    "6739": "Save the return address.",
    "6740": "SUBPPC. Fetch the statement number and increment it.",
    "6744": "Exchange the 'error address' with the statement number.",
    "6745": "Reclaim the use of a location.",
    "6750": "Next save the present line number.",
    "6751": "Return the 'error address' to the machine stack",
    "6752": "and reset ERR-SP to point to it.",
    "6756": "Stack the return address.",
    "6758": "Now set NEWPPC & NSPPC to the required values.",
    "6760": "But before making the jump make a test for room.",
    "6764": "Will automatically produce error '4' if out of memory.",
    "6767": "Fetch the return address.",
    "6768": "Fetch the 'error address'.",
    "6769": "Fetch the last entry on the GO SUB stack.",
    "6770": "The entry is tested to see if",
    "6771": "it is the GO SUB stack end marker.",
    "6773": "Jump if it is.",
    "6775": "The full entry uses three locations only.",
    "6776": "Exchange the statement number with the 'error address'.",
    "6777": "Move the statement number.",
    "6778": "Reset the error pointer.",
    "6782": "Replace the return address.",
    "6783": "Enter the line number.",
    "6786": "Enter the statement number.",
    "6790": "Replace the end marker and",
    "6791": "the 'error address'.",
    "6792": "Produce error report.",
    "6795": "\"7 RETURN without GO SUB\"",
    "6800": "Jump forward if checking syntax.",
    "6802": "Otherwise bass-by the",
    "6804": "'DEF FN' statement.",
    "6807": "Signal 'a numeric variable'.",
    "6812": "Check that the present code is a letter.",
    "6814": "Jump forward if not.",
    "6816": "Fetch the next character.",
    "6819": "Jump forward unless it is a '$'.",
    "6821": "Change bit 6 as it is a string variable.",
    "6825": "Fetch the next character.",
    "6826": "A '(' must follow the variable's name.",
    "6828": "Jump forward if not.",
    "6830": "Fetch the next character",
    "6833": "as there are no parameters of the function.",
    "6831": "Jump forward if it is a ')'",
    "6838": "The present code must be a letter.",
    "6841": "Save the pointer in DE.",
    "6842": "Fetch the next character.",
    "6847": "Otherwise save the new pointer in DE instead.",
    "6845": "Jump forward unless it is a '$'.",
    "6848": "Fetch the next character.",
    "6849": "Move the pointer to the last character of the name to HL.",
    "6850": "Now make six locations after that last character.",
    "6858": "Enter a 'number marker' into the first of the new locations.",
    "6860": "If the present character is a ',' then jump back as",
    "6862": "there should be a further parameter.",
    "6865": "Otherwise jump out of the loop.",
    "6867": "Check that the ')' does exist.",
    "6869": "Jump if not.",
    "6871": "The next character is fetched.",
    "6872": "It must be an '='.",
    "6874": "Jump if not.",
    "6876": "Fetch the next character.",
    "6880": "Save the nature (numeric or string) of the variable",
    "6881": "Now consider the definition as an expression.",
    "6884": "Fetch the nature of the variable.",
    "6885": "FLAGS. Check that it is of the same type",
    "6888": "as found for the definition.",
    "6890": "Give an error report if required.",
    "6893": "Move on to consider the next statement in the line.",
    "6896": "Simply return.",
    "6897": "Fetch mode.",
    "6900": "Set Tape Loader mode.",
    "6902": "Use Normal RAM Configuration (physical RAM bank 0).",
    "6906": "Clear out editing area.",
    "6911": "Create 3 bytes of space for the LOAD \"\" command.",
    "6917": "Address of command bytes for LOAD \"\".",
    "6927": "Copy LOAD \"\" into the line editing area.",
    "6929": "Parse and execute the BASIC line. [Will not return here but will exit via the error handler routine]",
    "6932": "Use Normal RAM Configuration (physical RAM bank 0).",
    "6936": "Clear out editing area.",
    "6941": "Create 1 byte of space.",
    "6950": "Copy LLIST into the line editing area.",
    "6952": "Parse and execute the BASIC line. [Will not return here but will exit via the error handler routine]",
    "6955": "Overwrite 'P' channel data to use the ZX Printer.",
    "6958": "Purge the stack.",
    "6963": "The main execution loop within ROM 1.",
    "6967": "Address of a $FF byte within ROM 1, used to generate error report \"0 OK\".",
    "6971": "The address of the error handler within ROM 1.",
    "6975": "Force 48K mode.",
    "6980": "Swap to ROM 1 and return via a RST $08 / DEFB $FF.",
    "6983": "Stack a $0000 address to return to.",
    "6987": "Force 48 mode.",
    "6992": "Swap to ROM 1, return to $0000.",
    "7005": "HL=$000A, DE=Address 'S' channel data.",
    "7001": "HL=Address 'S' channel data.",
    "7006": "HL=Address 'P' channel data.",
    "7007": "DE=Address 'P' channel data, HL=Address 'S' channel data.",
    "7011": "Copy the 'S' channel data over the 'P' channel data.",
    "7013": "FLAGS2. Signal caps lock unset. [Not really necessary for switching back to 48 BASIC mode]",
    "7017": "FLAGS. Signal not 128K mode.",
    "7022": "LOAD \"\"",
    "7025": "Printer channel.",
    "7027": "Jump ahead to join LIST.",
    "7029": "Main screen channel.",
    "7031": "TV_FLAG. Signal 'an ordinary listing in the main part of the screen'.",
    "7044": "[Could just do RST $18]",
    "7041": "Open the channel.",
    "7038": "Do not open the channel if checking syntax.",
    "7047": "See if the stream is to be changed.",
    "7052": "Get current character.",
    "7054": "Is it a ';'?",
    "7056": "Jump if it is.",
    "7058": "Is it a ','?",
    "7060": "Jump if it is not.",
    "7063": "Get the next character.",
    "7065": "Indirectly call EXPT-1NUM in ROM 1 to check that",
    "7068": "a numeric expression follows, e.g. LIST #5,20.",
    "7071": "Otherwise use zero and",
    "7073": "jump forward.",
    "7076": "Fetch any line or use zero if none supplied.",
    "7078": "If checking the syntax of the edit-line move on to the next statement.",
    "7082": "Delegate handling to ROM 1.",
    "7085": "Save SP.",
    "7089": "Use temporary stack.",
    "7092": "Create new catalogue entry.",
    "7095": "Get the length of the file.",
    "7099": "-9 (9 is the length of the file header).",
    "7102": "Extend the negative number into the high byte.",
    "7104": "AHL=-(length of file + 9).",
    "7106": "Check for space in RAM disk (produce \"4 Out of memory\" if no room).",
    "7109": "File header length.",
    "7112": "Address of file header.",
    "7115": "Store file header to RAM disk.",
    "7118": "Start address of file data.",
    "7121": "Length of file data.",
    "7125": "Store bytes to RAM disk.",
    "7128": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "7131": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7136": "Use original stack.",
    "7142": "Get the current character.",
    "7144": "Is it '!'?",
    "7146": "Jump to \"C Nonsense in BASIC\" if not.",
    "7150": "Get the next character.",
    "7152": "Check for end of statement.",
    "7155": "Select main screen.",
    "7160": "Store SP.",
    "7164": "Use temporary stack.",
    "7167": "Print out the catalogue.",
    "7170": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7175": "Use original stack.",
    "7181": "Get character from BASIC line.",
    "7183": "Is it '!'?",
    "7185": "Jump to \"C Nonsense in BASIC\" if not.",
    "7188": "Get the filename into N_STR1.",
    "7191": "Make sure we've reached the end of the BASIC statement.",
    "7194": "Store SP.",
    "7198": "Use temporary stack.",
    "7201": "Do the actual erasing (leaves logical RAM bank 4 paged in).",
    "7204": "Restore RAM configuration.",
    "7206": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7209": "Use original stack.",
    "7214": "Store SP.",
    "7218": "Use temporary stack.",
    "7221": "Find file (return details pointed to by IX). Leaves logical RAM bank 4 paged in.",
    "7224": "Load 9 header bytes.",
    "7230": "Load bytes from RAM disk.",
    "7233": "Restore RAM configuration.",
    "7235": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7238": "Use original stack.",
    "7243": "Store SP",
    "7247": "Use temporary stack.",
    "7251": "BC=Length.",
    "7252": "Load bytes from RAM disk.",
    "7255": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "7258": "Restore RAM configuration.",
    "7260": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7263": "Use original stack.",
    "7268": "Save BC and HL.",
    "7270": "Physical banks used by RAM disk.",
    "7275": "BC=Logical RAM bank.",
    "7276": "Point to table entry.",
    "7277": "Look up physical page.",
    "7278": "Disable interrupts whilst paging.",
    "7279": "Fetch the current configuration.",
    "7282": "Mask off current RAM bank.",
    "7284": "Include new RAM bank.",
    "7285": "Store the new configuration.",
    "7291": "Perform the page.",
    "7293": "Re-enable interrupts.",
    "7294": "Restore BC and HL.",
    "7297": "Logical bank $00, $01, $02, $03, $04, $05",
    "7309": "Maximum of 10 characters.",
    "7313": "compare each character.",
    "7315": "Return if characters are different.",
    "7316": "Repeat for all characters of the filename.",
    "7319": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "7322": "Jump ahead if does not exist.",
    "7324": "Produce error report.",
    "7327": "\"e File already exists\"",
    "7330": "16384-20 (maximum size of RAM disk catalogue).",
    "7333": "IX grows downwards as new RAM disk catalogue entries added. If adding the maximum size to IX does not result in the carry flag being set then the catalogue is full, so issue an error report \"4 Out of Memory\".",
    "7337": "Jump if out of memory.",
    "7339": "-20 (20 bytes is the size of a RAM disk catalogue entry).",
    "7342": "Extend the negative number into the high byte.",
    "7344": "Ensure space in RAM disk area.",
    "7350": "Signal editing RAM disk catalogue.",
    "7354": "DE=Address of new catalogue entry.",
    "7355": "Filename.",
    "7358": "10 characters in the filename.",
    "7361": "Copy the filename.",
    "7363": "Indicate catalogue entry requires updating.",
    "7367": "Set the file access address to be the",
    "7370": "start address of the file.",
    "7385": "Set the fill length to zero.",
    "7397": "Logical RAM bank 5 (physical RAM bank 0).",
    "7402": "HL=Address of new catalogue entry.",
    "7403": "-20 (20 bytes is the size of a catalogue entry).",
    "7407": "Store address of next free catalogue entry.",
    "7415": "A'HL=Requested space.",
    "7416": "ADE=Free space on RAM disk.",
    "7419": "CDE=Free space.",
    "7420": "AHL=Requested space.",
    "7421": "A negative adjustment, i.e. adding data?",
    "7423": "Jump ahead if so.",
    "7426": "AHL=Free space left.",
    "7427": "Store free space.",
    "7436": "Jump back to store free space if space left.",
    "7438": "Produce error report.",
    "7441": "\"4 Out of memory\"",
    "7444": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7447": "Point to first catalogue entry.",
    "7451": "Pointer to last catalogue entry.",
    "7455": "Clear carry flag.",
    "7458": "HL=First catalogue entry.",
    "7461": "Return with zero flag set if end of catalogue reached and hence filename not found.",
    "7462": "Test filename match with N_STR1 ($5B67).",
    "7465": "Jump ahead if names did not match.",
    "7467": "Reset zero flag to indicate filename exists.",
    "7470": "-20 bytes (20 bytes is the size of a catalogue entry).",
    "7473": "Point to the next directory entry.",
    "7475": "Test the next name.",
    "7477": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "7480": "Jump ahead if it exists.",
    "7485": "\"h File does not exist\"",
    "7482": "Produce error report.",
    "7486": "Take the current start address (bank + location)",
    "7489": "and store it as the current working address.",
    "7504": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7509": "[Could have saved 1 byte by using JP $1C64 (ROM 0)]",
    "7510": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7519": "Ignore if catalogue entry does not require updating.",
    "7520": "Indicate catalogue entry updated.",
    "7527": "Signal not editing RAM disk catalogue.",
    "7529": "Points to end address within logical RAM bank.",
    "7535": "Points to end logical RAM bank.",
    "7538": "Start address within logical RAM bank.",
    "7544": "Start logical RAM bank.",
    "7547": "Clear carry flag.",
    "7548": "HL=End address-Start address. Maximum difference fits within 14 bits.",
    "7550": "A=End logical RAM bank-Start logical RAM bank - 1 if addresses overlap.",
    "7551": "Work out how many full banks of 16K are being used.",
    "7555": "Place this in the upper two bits of H.",
    "7561": "HL=Total length.",
    "7563": "Length within logical RAM bank.",
    "7572": "End address within logical RAM bank.",
    "7578": "End logical RAM bank.",
    "7581": "-20 bytes (20 bytes is the size of a catalogue entry).",
    "7584": "Address of next catalogue entry.",
    "7586": "Start address within logical RAM bank.",
    "7592": "Start logical RAM bank.",
    "7597": "Check whether a data length of zero was requested.",
    "7598": "Ignore if so since all bytes already saved.",
    "7599": "Save the source address.",
    "7600": "DE=The start of the upper RAM bank.",
    "7603": "HL=The start of the RAM bank. DE=Source address.",
    "7604": "HL=RAM bank start - Source address.",
    "7606": "Jump ahead if saving bytes from $C000.",
    "7608": "Jump ahead if saving bytes from an address above $C000.",
    "7610": "HL=Distance below $C000 (RAM bank start - Source address).",
    "7613": "Jump if requested bytes are all below $C000.",
    "7616": "HL=Requested length.",
    "7617": "BC=Distance below $C000.",
    "7619": "HL=Bytes occupying upper RAM bank.",
    "7621": "Stack it. HL=Source address.",
    "7622": "Start of upper RAM bank.",
    "7626": "Jump forward.",
    "7628": "Forget the 'distance below $C000' count.",
    "7629": "HL=Source address.",
    "7630": "Remaining bytes to transfer.",
    "7634": "Stack dummy Start of upper RAM bank.",
    "7635": "Jump forward.",
    "7638": "HL=Requested length.",
    "7639": "DE=Length of buffer.",
    "7643": "HL=Requested length-Length of buffer = Buffer overspill.",
    "7645": "Jump if requested length will fit within the buffer.",
    "7647": "Stack buffer overspill. HL=$0000.",
    "7649": "BC=Buffer length.",
    "7650": "Jump forward.",
    "7652": "HL=Destination address.",
    "7653": "Remaining bytes to transfer.",
    "7656": "Stack 'transfer buffer in use' flag.",
    "7657": "Stack the length.",
    "7658": "Transfer buffer",
    "7661": "Transfer bytes.",
    "7663": "BC=Length.",
    "7664": "HL=New source address.",
    "7665": "Transfer buffer.",
    "7668": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7676": "Fetch the address from the current logical RAM bank.",
    "7679": "Logical RAM bank.",
    "7682": "Page in appropriate logical RAM bank.",
    "7685": "Transfer a byte from the file to the required RAM disk location or transfer buffer.",
    "7688": "Has DE been incremented to $0000?",
    "7689": "Jump if end of RAM bank reached.",
    "7693": "Repeat until all bytes transferred.",
    "7698": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7704": "Store the next RAM bank source address.",
    "7709": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7712": "HL=Source address.",
    "7713": "BC=Length.",
    "7714": "Re-enter this routine to transfer another block.",
    "7718": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7721": "Increment to the new logical RAM bank.",
    "7724": "Fetch the new logical RAM bank.",
    "7727": "The start of the RAM disk",
    "7730": "Page in next RAM bank.",
    "7733": "Jump back to transfer another block.",
    "7735": "Check whether a data length of zero was requested.",
    "7737": "Ignore if so since all bytes already loaded.",
    "7738": "Save the destination address.",
    "7739": "DE=The start of the upper RAM bank.",
    "7742": "HL=The start of the RAM bank. DE=Destination address.",
    "7743": "HL=RAM bank start - Destination address.",
    "7745": "Jump if destination is $C000.",
    "7747": "Jump if destination is above $C000.",
    "7749": "HL=Distance below $C000 (RAM bank start - Destination address).",
    "7752": "Jump if requested bytes all fit below $C000.",
    "7755": "HL=Requested length.",
    "7756": "BC=Distance below $C000.",
    "7758": "HL=Bytes destined for upper RAM bank.",
    "7760": "Stack it. HL=Destination address.",
    "7761": "Remaining bytes to transfer.",
    "7765": "Start of upper RAM bank.",
    "7769": "HL=Start of upper RAM bank.",
    "7770": "Jump forward.",
    "7772": "Forget the 'distance below $C000' count.",
    "7773": "HL=Destination address.",
    "7774": "Remaining bytes to transfer.",
    "7778": "Stack dummy Start of upper RAM bank.",
    "7780": "HL=$0000, DE=Destination address.",
    "7781": "Jump forward.",
    "7784": "HL=Requested length.",
    "7785": "DE=Length of buffer.",
    "7789": "HL=Requested length-Length of buffer = Buffer overspill.",
    "7791": "Jump if requested length will fit within the buffer.",
    "7793": "Stack buffer overspill. HL=$0000.",
    "7795": "BC=Buffer length.",
    "7796": "Jump forward.",
    "7798": "HL=Destination address.",
    "7799": "Remaining bytes to transfer.",
    "7802": "Stack 'transfer buffer in use' flag.",
    "7803": "Stack the length.",
    "7804": "Stack destination address.",
    "7805": "Transfer buffer.",
    "7808": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7813": "RAM bank address.",
    "7819": "Logical RAM bank.",
    "7822": "Page in appropriate logical RAM bank.",
    "7825": "Transfer a byte from the file to the required location or transfer buffer.",
    "7828": "Has HL been incremented to $0000?",
    "7829": "Jump if end of RAM bank reached.",
    "7833": "Repeat until all bytes transferred.",
    "7836": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7844": "Store the next RAM bank destination address.",
    "7847": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7852": "DE=Destination address.",
    "7853": "BC=Length.",
    "7854": "Transfer buffer.",
    "7858": "All bytes transferred?",
    "7859": "Jump forward if so.",
    "7861": "Transfer code in buffer to the required address.",
    "7863": "HL=New destination address.",
    "7864": "BC=Remaining bytes to transfer.",
    "7865": "Re-enter this routine to transfer another block.",
    "7868": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7873": "Increment to the new logical RAM bank.",
    "7876": "Fetch the new logical RAM bank.",
    "7879": "The start of the RAM disk.",
    "7882": "Page in next logical RAM bank.",
    "7885": "Jump back to transfer another block.",
    "7887": "Save AF.",
    "7888": "Fetch current physical RAM bank configuration.",
    "7891": "Save it.",
    "7892": "Save source address.",
    "7893": "Save destination address.",
    "7894": "Save length.",
    "7899": "Store destination address as the current address pointer.",
    "7905": "Destination is in logical RAM bank 4 (physical RAM bank 7).",
    "7909": "Store bytes to RAM disk.",
    "7912": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7917": "Get length.",
    "7918": "Get destination address.",
    "7919": "Get source address.",
    "7920": "HL=Address after end of source.",
    "7921": "DE=Address after end of source. HL=Destination address.",
    "7922": "HL=Address after end of destination.",
    "7923": "HL=Address after end of source. DE=Address after end of destination.",
    "7924": "Get original RAM bank configuration.",
    "7928": "Disable interrupts whilst paging.",
    "7934": "Re-enable interrupts.",
    "7935": "Signal all bytes loaded/saved.",
    "7938": "Restore AF.",
    "7940": "Save AF.",
    "7941": "Fetch current physical RAM bank configuration.",
    "7944": "Save it.",
    "7945": "Save source address.",
    "7946": "Save destination address.",
    "7947": "Save length.",
    "7952": "Store source address as the current address pointer.",
    "7958": "Source is in logical RAM bank 4 (physical RAM bank 7).",
    "7962": "HL=Destination address.",
    "7963": "Load bytes from RAM disk.",
    "7966": "Join the save vector routine above.",
    "7968": "Save AF.",
    "7969": "Physical RAM bank 0.",
    "7971": "Disable interrupts whilst paging.",
    "7972": "Page in physical RAM bank 0.",
    "7975": "AF=Address on stack when CALLed.",
    "7976": "Store HL.",
    "7979": "Fetch the old stack.",
    "7982": "Save the current stack.",
    "7986": "Use the old stack.",
    "7987": "Re-enable interrupts.",
    "7988": "Restore HL.",
    "7991": "Get AF back.",
    "7994": "Save BC",
    "7998": "Perform requested paging.",
    "8003": "Restore BC.",
    "8005": "Save A.",
    "8006": "Disable interrupts whilst paging.",
    "8007": "Fetch return address.",
    "8008": "Store HL.",
    "8011": "Fetch the old stack.",
    "8014": "Save the current stack.",
    "8018": "Use the old stack.",
    "8019": "Restore HL.",
    "8022": "Stack return address.",
    "8023": "RAM bank 7.",
    "8025": "Page in RAM bank 7.",
    "8028": "Re-enable interrupts.",
    "8029": "Restore A.",
    "8031": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "8034": "Jump ahead if it was found. [Could have saved 3 bytes by using JP Z,$1D3E (ROM 0)]",
    "8036": "Produce error report.",
    "8039": "\"h File does not exist\"",
    "8040": "AHL=Length of file.",
    "8046": "Bit 7 of A will be 0 indicating to delete rather than add.",
    "8049": "Free up this amount of space.",
    "8052": "Preserve current value of IY.",
    "8054": "IY points to next free catalogue entry.",
    "8058": "BC=-20 (20 bytes is the size of a catalogue entry).",
    "8061": "IX points to the next catalogue entry",
    "8063": "AHL=First spare byte in RAM disk file area.",
    "8072": "Restore IY to normal value.",
    "8074": "BDE=Start of address of next RAM disk file entry.",
    "8097": "HL=Length of all files to be moved.",
    "8099": "20 bytes is the size of a catalogue entry.",
    "8102": "IX=Catalogue entry to delete.",
    "8104": "Store file length in the 'deleted' catalogue entry.",
    "8113": "-20 (20 bytes is the size of a catalogue entry).",
    "8116": "IX=Next catalogue entry.",
    "8118": "DHL=Start address of next RAM disk file entry.",
    "8127": "20 bytes is the size of a catalogue entry.",
    "8130": "IX points to catalogue entry to delete.",
    "8132": "Page in logical RAM bank for start address of entry to delete.",
    "8139": "Save current RAM bank configuration in E.",
    "8143": "Select physical RAM bank 7.",
    "8145": "Disable interrupts whilst performing paging operations.",
    "8146": "Page in selected RAM bank.",
    "8148": "DHL'=Start address of next RAM disk file entry.",
    "8149": "DHL=Start of address of RAM disk file entry to delete.",
    "8159": "Page in logical RAM bank for file entry (will update BANK_M).",
    "8165": "Get RAM bank configuration for the file in E.",
    "8169": "DHL=Start address of next RAM disk file entry.",
    "8170": "Select physical RAM bank 7.",
    "8172": "Disable interrupts whilst performing paging operations.",
    "8173": "Page in selected RAM bank.",
    "8175": "Decrement end address.",
    "8183": "If no carry then the decrement is finished.",
    "8185": "Otherwise decrement the middle byte.",
    "8193": "If no carry then the decrement is finished.",
    "8195": "Otherwise decrement the highest byte.",
    "8203": "Jump forward if finished moving the file.",
    "8205": "Page in RAM bank containing the next file.",
    "8207": "Get the byte from the next file.",
    "8208": "Increment DHL.",
    "8209": "If not zero then the increment is finished.",
    "8212": "If not zero then the increment is finished.",
    "8211": "Otherwise increment the middle byte.",
    "8214": "Save the byte read from the next file.",
    "8215": "Advance to next logical RAM bank for the next file.",
    "8217": "Page in next logical RAM bank for next file entry (will update BANK_M).",
    "8223": "Get RAM bank configuration for the next file in E.",
    "8224": "The next file continues at the beginning of the next RAM bank.",
    "8227": "Retrieve the byte read from the next file.",
    "8228": "DHL=Address of file being deleted.",
    "8229": "Disable interrupts whilst performing paging operations.",
    "8230": "Page in next RAM bank containing the next file.",
    "8232": "Store the byte taken from the next file.",
    "8233": "Increment DHL.",
    "8234": "If not zero then the increment is finished.",
    "8237": "If not zero then the increment is finished.",
    "8236": "Otherwise increment the middle byte.",
    "8239": "Advance to next logical RAM bank for the file being deleted.",
    "8241": "Page in next logical RAM bank for file being deleted entry (will update BANK_M).",
    "8247": "Get RAM bank configuration for the file being deleted in E.",
    "8248": "The file being deleted continues at the beginning of the next RAM bank.",
    "8251": "DHL'=Address of byte in file being deleted. DHL'=Address of byte in file being deleted.",
    "8254": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "8261": "AHL=20 bytes is the size of a catalogue entry.",
    "8264": "Delete a catalogue entry.",
    "8273": "CDE=File length of file entry to delete.",
    "8281": "C=RAM bank.",
    "8284": "Mask off upper bits to leave length in this bank (range 0-16383).",
    "8286": "DE=Length in this bank.",
    "8287": "Save address of catalogue entry to delete.",
    "8290": "-20 (20 bytes is the size of a catalogue entry).",
    "8293": "Point to next catalogue entry.",
    "8295": "DE=Length in this bank.",
    "8302": "AHL=File start address.",
    "8306": "Will move into next RAM bank?",
    "8311": "Jump if same RAM bank.",
    "8313": "New address in next RAM bank.",
    "8315": "Next RAM bank.",
    "8322": "Save new start address of file.",
    "8331": "Fetch end address of file.",
    "8335": "Will move into next RAM bank?",
    "8340": "Jump if same RAM bank.",
    "8342": "New address in next RAM bank.",
    "8344": "Next RAM bank.",
    "8351": "Save new end address of file.",
    "8356": "HL=Address of next catalogue entry.",
    "8363": "End of catalogue reached?",
    "8365": "DE=Length in this bank.",
    "8366": "Jump if not to move next entry.",
    "8368": "Start address of the next available catalogue entry.",
    "8373": "HL=Start address of catalogue entry to delete.",
    "8378": "BC=Length of catalogue entries to move.",
    "8379": "HL=Start address of catalogue entry to delete.",
    "8381": "20 bytes is the size of a catalogue entry.",
    "8384": "HL=Start address of previous catalogue entry.",
    "8385": "DE=Start address of previous catalogue entry.",
    "8386": "HL=Start address of catalogue entry to delete.",
    "8387": "DE=End address of catalogue entry to delete.",
    "8389": "Move all catalogue entries.",
    "8388": "HL=End address of next catalogue entry.",
    "8391": "Start address of the next available catalogue entry.",
    "8394": "20 bytes is the size of a catalogue entry.",
    "8398": "Store the new location of the next available catalogue entry.",
    "8402": "Page in logical RAM bank 4 (physical RAM bank 7)",
    "8407": "HL points to ten $00 bytes, the initial comparison filename.",
    "8410": "BC point to ten $FF bytes.",
    "8481": "Lowest theoretical filename.",
    "8491": "Highest theoretical filename.",
    "8413": "IX points to first catalogue entry.",
    "8417": "Check for BREAK.",
    "8420": "Save address of catalogue entry.",
    "8422": "HL points to current catalogue entry. Top of stack points to ten $00 data.",
    "8423": "Find address of next free catalogue entry.",
    "8428": "Have we reached end of catalogue?",
    "8430": "Fetch address of catalogue entry.",
    "8431": "Jump ahead if end of catalogue reached.",
    "8434": "DE=Current catalogue entry.",
    "8437": "Compare current filename (initially ten $00 bytes).",
    "8442": "Jump if current catalogue name is 'above' the previous.",
    "8445": "DE=Last filename",
    "8448": "Compare current filename (initially ten $FF bytes).",
    "8453": "Jump if current catalogue name is 'below' the previous.",
    "8457": "BC=Address of current catalogue entry name.",
    "8458": "-20 (20 bytes is the size of a catalogue entry).",
    "8461": "Point to next catalogue entry.",
    "8463": "Check next filename.",
    "8465": "HL points to current catalogue entry.",
    "8466": "Address of highest theoretical filename data.",
    "8470": "Was a new filename to print found?",
    "8473": "Return if all filenames printed.",
    "8475": "HL=Address of current catalogue entry name.",
    "8476": "Print the catalogue entry.",
    "8479": "Repeat for next filename.",
    "8501": "Save address of filename.",
    "8503": "[No need to transfer BC to HL since they already have the same value].",
    "8504": "Copy the filename to N_STR1 so that it",
    "8507": "is visible when this RAM bank is paged out.",
    "8512": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "8520": "Save temporary stack.",
    "8524": "Use original stack.",
    "8525": "HL points to filename.",
    "8528": "10 characters to print.",
    "8530": "Print each character of the filename.",
    "8541": "Print a newline character.",
    "8547": "Copy permanent colours to temporary colours.",
    "8552": "Save original stack.",
    "8556": "Switch back to temporary stack.",
    "8559": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "8562": "HL=Address of filename.",
    "8564": "Printer channel.",
    "8566": "Jump ahead.",
    "8568": "Main screen channel.",
    "8573": "Jump forward if syntax is being checked.",
    "8582": "Delegate handling to ROM 1.",
    "8584": "\"C Nonsense in BASIC\" during syntax checking if not",
    "8587": "at end of line or statement.",
    "8591": "Jump forward if syntax is being checked.",
    "8593": "Open channel 'K'.",
    "8599": "[*BUG* - This call will re-select channel 'S' and so should have been called prior to opening [*BUG* - This call will re-select channel 'S' and so should have been called prior to opening channel 'K'. It is a direct copy of the code that appears in the standard Spectrum ROM (and ROM 1). It is debatable whether it is better to reproduce the bug so as to ensure that the INPUT routine operates the same in 128K mode as it does in 48K mode. Credit: Geoff Wearmouth]",
    "8601": "TV_FLAG. Signal that the lower screen is being handled. [Not a bug as has been reported elsewhere. The confusion seems to have arisen due to the incorrect system variable being originally mentioned in the Spectrum ROM Disassembly by Logan and O'Hara]",
    "8606": "Call the subroutine to deal with the INPUT items.",
    "8608": "Move on to the next statement if checking syntax.",
    "8612": "Delegate handling to ROM 1.",
    "8615": "Jump to new COPY routine.",
    "8619": "Re-initialise the machine.",
    "8622": "Get character from BASIC line.",
    "8623": "\",\". Check for second parameter.",
    "8625": "Jump ahead (for error C) if not.",
    "8627": "Advance pointer into BASIC line.",
    "8628": "Get parameter.",
    "8629": "Radius to calculator stack.",
    "8631": "Move to consider next statement if checking syntax.",
    "8635": "Delegate handling to ROM 1.",
    "8638": "Get current character.",
    "8641": "Jump if there is a third parameter.",
    "8639": "\",\"",
    "8643": "Error C during syntax checking if not at end of line/statement.",
    "8647": "Delegate handling to ROM 1.",
    "8650": "Get the next character.",
    "8652": "Angle to calculator stack.",
    "8654": "Error C during syntax checking if not at end of line/statement.",
    "8658": "Delegate handling to ROM 1.",
    "8662": "Search to see if the array already exists.",
    "8664": "Jump if array variable not found.",
    "8669": "Jump ahead during syntax checking.",
    "8671": "Test the syntax for string arrays as if they were numeric.",
    "8674": "Check the syntax of the parenthesised expression.",
    "8676": "Error when checking syntax unless at end of line/statement.",
    "8680": "Delegate handling to ROM 1.",
    "8683": "Produce error report.",
    "8686": "\"C Nonsense in BASIC\"",
    "8687": "FLAGS2. Is the screen clear?",
    "8691": "Return if it is.",
    "8693": "Otherwise clear the whole display.",
    "8696": "A line in the editing area is considered as line '-2'.",
    "8699": "Signal no current line number.",
    "8702": "Indicate 'syntax checking' mode.",
    "8706": "Point to start of the BASIC command line.",
    "8710": "Evaluate the command line.",
    "8712": "Is it a numeric value?",
    "8716": "Jump to produce an error if a string result.",
    "8718": "Get current character.",
    "8719": "Is it the end of the line?",
    "8721": "Jump if not to produce an error.",
    "8723": "If so, indicate 'execution' mode.",
    "8727": "Point to start of the BASIC command line.",
    "8730": "Set up the error handler routine address.",
    "8737": "Evaluate the command line.",
    "8739": "Is it a numeric value?",
    "8743": "Jump to produce an error if a string result.",
    "8745": "DE points to last calculator value.",
    "8751": "The length of the floating point value.",
    "8755": "HL points to value on top of calculator stack.",
    "8757": "Copy the value in the workspace to the top of the calculator stack.",
    "8759": "[Could have saved 1 byte by using a JR instruction]",
    "8762": "Produce error report.",
    "8765": "\"Q Parameter error\"",
    "8766": "Make it appear that 'Enter' has been pressed.",
    "8768": "Process key press.",
    "8775": "Create a byte in the workspace.",
    "8777": "Address of the cursor.",
    "8780": "Save it.",
    "8784": "Save it.",
    "8781": "Current channel information.",
    "8785": "Channel 'R', the workspace.",
    "8791": "Print a floating point number to the workspace.",
    "8793": "Get the current channel information address.",
    "8795": "Set appropriate flags back for the old channel.",
    "8797": "DE=Address of the old cursor position.",
    "8798": "Address of the cursor.",
    "8802": "HL=Length of floating point number.",
    "8804": "Fetch the character and make it appear to have been typed.",
    "8805": "Process the key press.",
    "8809": "Decrement floating point number character count.",
    "8812": "Repeat for all characters.",
    "8815": "Save registers.",
    "8817": "Use Workspace RAM configuration (physical RAM bank 7).",
    "8820": "Editor flags.",
    "8823": "Reset 'line altered' flag",
    "8826": "Main screen",
    "8832": "Process key press.",
    "8835": "Editor flags.",
    "8838": "Reset 'line altered' flag",
    "8840": "Use Normal RAM Configuration (physical RAM bank 0).",
    "8843": "Restore registers.",
    "8846": "Get the address of command being typed in.",
    "8850": "Store it as the address of next character to be interpreted.",
    "8853": "Get the next character.",
    "8855": "Point to start of typed in command.",
    "8858": "Is it 'LET'?",
    "8860": "Return if not with zero flag reset.",
    "8861": "HL points to next character.",
    "8864": "Fetch next character.",
    "8866": "Has end of line been found?",
    "8868": "Return if so with zero flag set.",
    "8869": "\":\". Has start of new statement been found?",
    "8871": "Loop back if not.",
    "8873": "Return zero flag reset indicating a multi-statement",
    "8874": "LET command.",
    "8875": "Save B.",
    "8876": "Start of operator token table.",
    "8879": "Fetch character from the table.",
    "8880": "Advance to next entry.",
    "8881": "End of table?",
    "8882": "Jump if end of table reached.",
    "8884": "Found required character?",
    "8885": "Jump if not to try next character in table.",
    "8887": "Restore character to A.",
    "8888": "Return with zero flag set to indicate an operator.",
    "8889": "Reset zero flag to indicate not an operator.",
    "8891": "Restore character to A.",
    "8893": "'+',  '-',  '*', '/',  '^',  '=', '>',  '<',",
    "8901": "'<=', '>=', '<>', 'OR', 'AND', end marker",
    "8907": "'RND'. (first 48K token)",
    "8909": "Jump ahead if not a token with zero flag reset.",
    "8913": "Jump ahead if not a function token.",
    "8917": "Jump ahead if not a function token.",
    "8921": "Jump ahead if not a function token.",
    "8911": "'BIN'.",
    "8915": "'AT'.",
    "8919": "'TAB'.",
    "8923": "Return zero flag set if a function token.",
    "8925": "Return zero flag set if a function token.",
    "8928": "Fetch character code.",
    "8929": "Make lowercase.",
    "8931": "Is it 'a' or above?",
    "8933": "Jump ahead if not a letter.",
    "8935": "Is it below '{'?",
    "8937": "Jump ahead if not.",
    "8939": "Character is a letter so return",
    "8940": "with zero flag set.",
    "8941": "Fetch character code.",
    "8942": "Is it '.'?",
    "8944": "Return zero flag set indicating numeric.",
    "8945": "Is character a number?",
    "8948": "Jump ahead if not a number.",
    "8950": "Get next character.",
    "8951": "Is character a number?",
    "8954": "Repeat for next character if numeric.",
    "8956": "Is it '.'?",
    "8958": "Return zero flag set indicating numeric.",
    "8959": "Is it 'E'?",
    "8961": "Return zero flag set indicating  numeric.",
    "8962": "Is it 'e'?",
    "8964": "Return zero flag set indicating  numeric.",
    "8965": "Jump to test for operator tokens.",
    "8967": "Reset the zero flag to indicate non-alphanumeric.",
    "8970": "Is it below '0'?",
    "8972": "Jump below '0'.",
    "8974": "Is it below ':'?",
    "8976": "Jump above '9'",
    "8978": "Set zero flag if numeric.",
    "8980": "This will cause zero flag to be reset.",
    "8983": "String index.",
    "8988": "Get string expression.",
    "8992": "A ',' indicates another string.",
    "8994": "Jump ahead if no more.",
    "8996": "Advance to the next character.",
    "8997": "Loop back.",
    "8999": "Check the index.",
    "9000": "Maximum of 8 strings (to support synthesisers, drum machines or sequencers).",
    "9004": "Produce error report.",
    "9007": "\"p (c) 1986 Sinclair Research Ltd\" [*BUG* - This should be \"Parameter error\". The Spanish 128 produces \"p Bad parameter\" but to save memory perhaps the UK 128 was intended to use the existing \"Q Parameter error\" and the change of the error code byte here was overlooked. In that case it would have had a value of $19. Note that generation of this error when using the main screen editor will result in a crash. Credit: Andrew Owen]",
    "9008": "Ensure end-of-statement or end-of-line.",
    "9011": "Continue with PLAY code.",
    "9527": "Number of table entries.",
    "9528": "Key code: Cursor up.",
    "9529": "CURSOR-UP handler routine.",
    "9531": "Key code: Cursor Down.",
    "9532": "CURSOR-DOWN handler routine.",
    "9534": "Key code: Cursor Left.",
    "9535": "CURSOR-LEFT handler routine.",
    "9537": "Key code: Cursor Right.",
    "9538": "CURSOR-RIGHT handler routine.",
    "9540": "Key code: Extend Mode + P.",
    "9541": "TEN-ROWS-UP handler routine.",
    "9543": "Key code: Symbol Shift + I.",
    "9544": "TEN-ROWS-DOWN handler routine.",
    "9546": "Key code: Extend Mode + I.",
    "9547": "WORD-LEFT handler routine.",
    "9549": "Key code: Extend Mode + Shift + J.",
    "9550": "WORD-RIGHT handler routine.",
    "9552": "Key code: Extend Mode + N, or Graph + W.",
    "9553": "TOP-OF-PROGRAM handler routine.",
    "9555": "Key code: Extend Mode + T, or Graph + V.",
    "9556": "END-OF-PROGRAM handler routine.",
    "9558": "Key code: Extend Mode Symbol Shift + 2, or Graph Y.",
    "9559": "START-OF-LINE handler routine.",
    "9561": "Key code: Extend Mode + M, or Graph + X.",
    "9562": "END-OF-LINE handler routine.",
    "9564": "Key code: Extend Mode + Shift + K.",
    "9565": "DELETE-RIGHT handler routine.",
    "9567": "Key code: Delete.",
    "9568": "DELETE handler routine.",
    "9570": "Key code: Extend Mode + W.",
    "9571": "DELETE-WORD-RIGHT handler routine.",
    "9573": "Key code: Extend Mode + E.",
    "9574": "DELETE-WORD-LEFT handler routine.",
    "9576": "Key code: Extend Mode + J.",
    "9577": "DELETE-TO-END-OF-LINE handler routine.",
    "9579": "Key code: Extend Mode + K.",
    "9580": "DELETE-TO-START-OF-LINE handler routine.",
    "9582": "Key code: Enter.",
    "9583": "ENTER handler routine.",
    "9585": "Key code: Extend Mode + Symbol Shift + 8, or Graph + Z.",
    "9586": "TOGGLE handler routine.",
    "9588": "Key code: Edit.",
    "9589": "MENU handler routine.",
    "9591": "Number of entries.",
    "9592": "Key code: Cursor up.",
    "9593": "MENU-UP handler routine.",
    "9595": "Key code: Cursor down.",
    "9596": "MENU-DOWN handler routine.",
    "9598": "Key code: Edit.",
    "9599": "MENU-SELECT handler routine.",
    "9601": "Key code: Enter.",
    "9602": "MENU-SELECT handler routine.",
    "9604": "Reset Cursor Position.",
    "9607": "No top line.",
    "9610": "Line number at top of screen.",
    "9613": "Signal waiting for key press, and menu is displayed.",
    "9615": "Store the Editor flags.",
    "9618": "No current line number.",
    "9621": "Current line number.",
    "9624": "Reset indentation settings.",
    "9627": "Reset to 'L' Mode",
    "9630": "[Could have saved one byte by using JP $365E (ROM 0)]",
    "9637": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9640": "Select main screen.",
    "9645": "Jump table for Main Menu.",
    "9648": "Store current menu jump table address.",
    "9651": "The Main Menu text.",
    "9654": "Store current menu text table address.",
    "9657": "Store address of menu on stack.",
    "9658": "Editor flags.",
    "9661": "Indicate 'menu displayed'.",
    "9663": "Signal return to main menu.",
    "9665": "Current menu index.",
    "9666": "Select top entry.",
    "9668": "Retrieve address of menu.",
    "9669": "Display menu and highlight first item.",
    "9672": "Jump ahead to enter the main key waiting and processing loop.",
    "10052": "Number of entries.",
    "10054": "Tape Loader option handler.",
    "10057": "128 BASIC option handler.",
    "10060": "Calculator option handler.",
    "10063": "48 BASIC option handler.",
    "10066": "Tape Tester option handler.",
    "10068": "Number of entries.",
    "10069": "\"128     \"",
    "10078": "\"Tape Loader\"",
    "10089": "\"128 BASIC\"",
    "10098": "\"Calculator\"",
    "10116": "\"Tape Tester\" + end mark",
    "10128": "Number of entries.",
    "10130": "(Return to) 128 BASIC option handler.",
    "10133": "Renumber option handler.",
    "10136": "Screen option handler.",
    "10139": "Print option handler.",
    "10142": "Exit option handler.",
    "10145": "\"Options \", \"128 BASIC\", \"Renumber\",",
    "10161": "\"Screen\", \"Print, \"Exit\", end marker",
    "9675": "Point IX at editing settings information.",
    "9685": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9691": "Select main screen.",
    "9693": "Reset 'L' mode.",
    "9699": "Has a key been pressed?",
    "9701": "Wait for a key press.",
    "9703": "Editor flags.",
    "9706": "Signal line has not been altered.",
    "9708": "Is editing area the lower screen?",
    "9710": "If so then skip printing a banner and jump ahead to return to the Editor.",
    "9712": "Fetch mode.",
    "9715": "Calculator mode?",
    "9717": "Jump ahead if so.",
    "9719": "Edit Menu mode?",
    "9721": "Jump if not to re-display Main menu.",
    "9724": "Clear screen and print \"128 BASIC\" in the banner line.",
    "9727": "Jump ahead to return to the Editor.",
    "9729": "Clear screen and print \"Calculator\" in the banner line.",
    "9732": "Reset Below-Screen Line Edit Buffer settings to their default values.",
    "9735": "Reset Above-Screen Line Edit Buffer settings to their default values.",
    "9738": "Fetch the mode.",
    "9741": "Calculator mode?",
    "9743": "Jump ahead if not to wait for a key press.",
    "9745": "Fetch current line number.",
    "9749": "Is there a current line number?",
    "9750": "Jump ahead if so.",
    "9752": "Address of start of BASIC program.",
    "9755": "Address of start of variables area.",
    "9760": "HL=Length of program.",
    "9762": "Jump if a program exists.",
    "9767": "Set no line number last edited.",
    "9770": "Fetch line number of last edited line.",
    "9773": "Use Normal RAM Configuration (physical RAM bank 0).",
    "9777": "Find address of line number held in HL, or the next line if it does not exist.",
    "9780": "Find line number for specified address, and return in DE.",
    "9782": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9785": "Save the current line number.",
    "9789": "Editor flags.",
    "9792": "Process the BASIC line?",
    "9794": "Jump ahead if calculator mode.",
    "9799": "Signal no editable characters in the line prior to the cursor.",
    "9802": "Relist the BASIC program.",
    "9805": "Set attribute at editing position so as to show the cursor.",
    "9808": "Call the ENTER handler routine.",
    "9811": "Use temporary stack.",
    "9814": "Reset 'L' mode.",
    "9817": "Wait for a key. [Note that it is possible to change CAPS LOCK mode whilst on a menu]",
    "9820": "Save key code.",
    "9821": "Tone of keyboard click.",
    "9824": "Produce a key click noise.",
    "9827": "Retrieve key code.",
    "9828": "Process the key press.",
    "9831": "Wait for another key.",
    "9833": "Editor flags.",
    "9836": "Is a menu displayed?",
    "9838": "Save key code and flags.",
    "9839": "Use menu keys lookup table",
    "9842": "Jump if menu is being displayed.",
    "9844": "Use editing keys lookup table.",
    "9847": "Find and call the action handler for this key press.",
    "9850": "Jump ahead if no match found.",
    "9852": "If required then produce error beep.",
    "9855": "Restore key code.",
    "9857": "Restore key code and flags.",
    "9858": "Jump if menu is not being displayed.",
    "9860": "Select 'L' mode.",
    "9865": "Editor flags.",
    "9868": "Is the Screen Line Edit Buffer is full?",
    "9870": "Jump if not to process the key code.",
    "9872": "Produce error beep.",
    "9875": "[Could have save a byte by using JP $26E7 (ROM 0)]",
    "9876": "Was it a supported function key code?",
    "9878": "Ignore by jumping back to wait for another key. [*BUG* - This should be RET NC since it was called from the loop at $2653 (ROM 0). Repeatedly pressing an unsupported key will result in a stack memory leak and eventual overflow. Credit: John Steven (+3), Paul Farrow (128)] ",
    "9880": "Jump forward to handle the character key press.",
    "9883": "Fetch mode.",
    "9886": "Calculator mode?",
    "9888": "Return if so (TOGGLE has no effect in Calculator mode).",
    "9889": "Clear Editing Display.",
    "9892": "Editor flags.",
    "9895": "Reset 'line altered' flag.",
    "9898": "Toggle screen editing area flag.",
    "9903": "Jump forward if the editing area is now the upper area.",
    "9905": "Set the lower area as the current editing area.",
    "9908": "Jump forward.",
    "9910": "Set the upper area as the current editing area.",
    "9913": "Signal do not produce an error beep.",
    "9915": "Clear lower editing area display.",
    "9918": "Editor flags.",
    "9921": "Signal using lower screen.",
    "9923": "Reset to lower screen.",
    "9926": "Set default lower screen editing cursor settings.",
    "9929": "Set default lower screen editing settings.",
    "9932": "Jump ahead to continue.",
    "9934": "Editor flags.",
    "9937": "Signal using main screen.",
    "9939": "Reset Cursor Position.",
    "9942": "Clear screen and print the \"128 BASIC\" banner line.",
    "9945": "Line number at top of screen.",
    "9949": "Is there a line?",
    "9950": "If there is then get the address of BASIC line for this line number.",
    "9953": "Relist the BASIC program.",
    "9956": "Set attribute at editing position so as to show the cursor, and return.",
    "9962": "Divide by 2.",
    "9966": "Pitch.",
    "9969": "Duration.",
    "9973": "Produce a tone.",
    "9978": "Produce Success Beep",
    "9980": "Frequency*Time.",
    "9983": "Duration.",
    "9986": "Jump to produce the tone.",
    "9988": "Remove cursor, restoring old attribute.",
    "9991": "HL points to Editor flags.",
    "9994": "Signal 'menu is being displayed'.",
    "9996": "HL=$EC0C.",
    "9997": "Set 'current menu item' as the top item.",
    "9999": "Address of text for current menu.",
    "10002": "Display menu and highlight first item.",
    "10005": "Signal do not produce an error beep.",
    "10007": "HL points to Editor flags.",
    "10010": "Clear 'displaying menu' flag.",
    "10012": "HL=$EC0C.",
    "10013": "A=Current menu option index.",
    "10014": "HL points to jump table for current menu.",
    "10019": "Restore menu screen area.",
    "10024": "Call the item in the jump table corresponding to the currently selected menu item.",
    "10027": "Set attribute at editing position so as to show the cursor, and return.",
    "10030": "Signal move up.",
    "10031": "Jump ahead to continue.",
    "10033": "Signal moving down.",
    "10039": "Address of text for current menu.",
    "10038": "Save it.",
    "10037": "Fetch current menu index.",
    "10042": "Call if moving up.",
    "10045": "Call if moving down.",
    "10048": "HL=Address of current menu index store.",
    "10049": "Store the new menu index.",
    "10187": "Number of entries.",
    "10189": "(Return to) Calculator option handler.",
    "10192": "Exit option handler.",
    "10194": "Number of entries.",
    "10195": "\"Options \", \"Caluclator\", \"Exit\", end marker",
    "10219": "AT 1,0; INK 0; PAPER 7; BRIGHT 1;",
    "10235": "\"To cancel - press BREAK twice\"",
    "10257": "Toggle between editing in the lower and upper screen areas.",
    "10260": "Jump ahead.",
    "10262": "Clear screen and print the \"Tape Tester\" in the banner.",
    "10265": "Run the tape tester, exiting via the 'Exit' option menu handler.",
    "10268": "Editor flags.",
    "10271": "Indicate main screen editing.",
    "10273": "Reset Cursor Position.",
    "10276": "Top row to clear.",
    "10278": "Bottom row to clear.",
    "10280": "Clear specified display rows.",
    "10283": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10286": "Jump back to show the menu.",
    "10289": "Clear screen and print \"Tape Loader\" in the banner line.",
    "10295": "Signal using lower screen area.",
    "10297": "Point to message \"To cancel - press BREAK twice\".",
    "10300": "Print the text.",
    "10303": "Signal using main screen area.",
    "10305": "[This bit is unused in the 48K Spectrum and only ever set in 128K mode via the Tape Loader option. It is never subsequently tested or reset. It may have been the intention to use this to indicate that the screen requires clearing after loading to remove the \"Tape Loader\" banner and the lower screen message \"To cancel - press BREAK twice\"]",
    "10307": "Tape Loader mode.",
    "10309": "[Redundant since call to $1AF1 (ROM 0) will set it to $FF]",
    "10315": "Perform 'Print AT 0,0;'.",
    "10318": "Run the tape loader.",
    "10321": "Run the renumber routine.",
    "10324": "If not successful then produce error beep if required.",
    "10327": "There is no current line number.",
    "10330": "Current line number.",
    "10333": "Temporary E_PPC used by BASIC Editor.",
    "10336": "Jump ahead to display the \"128 BASIC\" banner if required, set the menu mode and return.",
    "10338": "Perform an LLIST.",
    "10341": "Editor flags.",
    "10344": "Using lower editing screen?",
    "10346": "Jump ahead if so.",
    "10351": "Allow leading space.",
    "10353": "Clear screen and print the \"128 BASIC\" banner line.",
    "10356": "Editor flags.",
    "10359": "Signal not to process the BASIC line.",
    "10361": "Signal return to main menu.",
    "10363": "Select Edit menu mode. [Could have saved 1 byte by using XOR A]",
    "10365": "Edit Menu jump table.",
    "10368": "Edit Menu text table.",
    "10371": "Store the new mode and menu details.",
    "10373": "Editor flags.",
    "10376": "Signal to process the BASIC line.",
    "10378": "Signal return to calculator.",
    "10380": "Signal editing are is the main screen.",
    "10382": "Reset cursor position.",
    "10385": "Clear screen and print \"Calculator\" in the banner line.",
    "10388": "Set calculator mode.",
    "10390": "Store mode.",
    "10393": "No current line number.",
    "10396": "Store current line number.",
    "10399": "Relist the BASIC program.",
    "10402": "B=Row. C=Column. Top left of screen.",
    "10405": "Preferred column.",
    "10406": "Store editing position and print cursor.",
    "10409": "Select calculator mode.",
    "10411": "Calculator Menu jump table",
    "10414": "Calculator Menu text table",
    "10417": "Store mode.",
    "10420": "Store address of current menu jump table.",
    "10423": "Store address of current menu text.",
    "10427": "Return to the Editor.",
    "10430": "Reset to main screen.",
    "10433": "Set default main screen editing cursor details.",
    "10436": "Set default main screen editing settings.",
    "10439": "Top row of editing area.",
    "10441": "Bottom row of editing area.",
    "10443": "Clear specified display rows.",
    "10446": "Jump to show Main menu.",
    "10449": "Number of bytes in table.",
    "10450": "$F6EE = Cursor position - row 0.",
    "10451": "$F6EF = Cursor position - column 0.",
    "10452": "$F6F0 = Cursor position - column 0 preferred.",
    "10453": "$F6F1 = Top row before scrolling up.",
    "10454": "$F6F2 = Bottom row before scrolling down.",
    "10455": "$F6F3 = Number of rows in the editing area.",
    "10456": "Number of bytes in table.",
    "10457": "$F6EE = Cursor position - row 0.",
    "10458": "$F6EF = Cursor position - column 0.",
    "10459": "$F6F0 = Cursor position - column 0 preferred.",
    "10460": "$F6F1 = Top row before scrolling up.",
    "10461": "$F6F2 = Bottom row before scrolling down.",
    "10462": "$F6F3 = Number of rows in the editing area.",
    "10463": "Default lower screen editing information.",
    "10466": "Editing information stores.",
    "10469": "Copy bytes.",
    "10472": "Default main screen editing information.",
    "10475": "Editing information stores.",
    "10478": "Copy bytes.",
    "10481": "Editor flags.",
    "10484": "Clear carry flag. [Redundant instruction since carry flag return state never checked]",
    "10485": "[Redundant instruction]",
    "10486": "Is the Screen Line Edit Buffer is full?",
    "10488": "Jump if it is to set attribute at editing position so as to show the cursor, and return.",
    "10491": "Signal got a key press.",
    "10493": "Signal current line has been altered.",
    "10495": "Save address of the flags.",
    "10496": "Save key code.",
    "10497": "Remove cursor, restoring old attribute.",
    "10501": "Get and save key code.",
    "10502": "Insert the character into the Screen Line Edit Buffer.",
    "10505": "Get key code.",
    "10506": "B=Current cursor column position.",
    "10507": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.",
    "10510": "Get address of the flags.",
    "10511": "Signal wait for a key.",
    "10513": "Jump if new position not available to set cursor attribute at existing editing position, and return.",
    "10516": "A=New cursor column position.",
    "10517": "Jump if new position is editable to store editing position and print cursor. [This only needs to be JP $29F8 (ROM 0), thereby saving 3 bytes, since a branch to $29F2 (ROM 0) would have been taken above if the carry flag was reset]",
    "10520": "Set attribute at editing position so as to show the cursor, and return.",
    "10523": "HL points to Editor flags.",
    "10526": "Indicate 'line altered'.",
    "10528": "Remove cursor, restoring old attribute. Exit with C=row, B=column.",
    "10531": "Delete character to the right, shifting subsequent rows as required.",
    "10534": "Signal do not produce an error beep.",
    "10535": "A=The new cursor editing position.",
    "10536": "Store editing position and print cursor, and then return.",
    "10539": "HL points to Editor flags.",
    "10542": "Signal that the Screen Line Edit Buffer is not full.",
    "10544": "Indicate 'line altered'.",
    "10546": "Remove cursor, restoring old attribute. Exit with C=row, B=column.",
    "10549": "Select previous column position (Returns carry flag set if editable).",
    "10552": "Signal do not produce an error beep if not editable.",
    "10553": "Jump if not editable to set attribute at editing position so as to show the cursor, and return.",
    "10556": "Delete character to the right, shifting subsequent rows as required.",
    "10559": "Signal do not produce an error beep.",
    "10560": "A=The new cursor editing position.",
    "10561": "Store editing position and print cursor, and then return.",
    "10564": "Remove cursor, restoring old attribute.",
    "10567": "Save preferred column number.",
    "10568": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "10571": "Stack current editing position.",
    "10572": "Column 0.",
    "10574": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "10577": "Retrieve current editing position.",
    "10578": "Jump ahead if editable position found, i.e. not a blank row.",
    "10583": "Point to the flag byte for the row.",
    "10584": "Fetch the flag byte.",
    "10585": "Invert it.",
    "10586": "Keep the 'first row' and 'last row' flags.",
    "10588": "Jump if both flags were set indicating not on a BASIC line.",
    "10590": "Editor flags.",
    "10593": "Has the current line been altered?",
    "10595": "Jump ahead if not.",
    "10597": "Enter line into program.",
    "10600": "Jump if syntax error to produce an error beep.",
    "10602": "Find end of the current BASIC line in the Screen Line Edit Buffer, scrolling up rows as required. Returns column number into B.",
    "10605": "Find address of end position in current BASIC line. Returns address into HL.",
    "10608": "Insert a blank line in the Screen Line Edit Buffer, shifting subsequent rows down.",
    "10611": "First column.",
    "10613": "A=Preferred column number.",
    "10614": "Signal do not produce an error beep.",
    "10615": "Store editing position and print cursor, and then return.",
    "10618": "Discard stacked item.",
    "10619": "Signal do not produce an error beep.",
    "10620": "Set attribute at current editing position so as to show the cursor, and return.",
    "10623": "Discard stacked item.",
    "10624": "Set attribute at current editing position so as to show the cursor, and return.",
    "10627": "Fetch mode.",
    "10630": "Calculator mode?",
    "10632": "Exit if so.",
    "10633": "Remove cursor, restoring old attribute.",
    "10636": "The first possible line number.",
    "10639": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10642": "Find address of line number 0, or the next line if it does not exist.",
    "10643": "Return address in HL.",
    "10645": "Find line number for specified address, and return in DE.",
    "10646": "DE=Address of first line in the BASIC program.",
    "10648": "Use Workspace RAM configuration (physical RAM bank 7).",
    "10651": "Store the current line number.",
    "10655": "Paper 1, Ink 7 - Blue.",
    "10657": "Set the cursor colour.",
    "10660": "Relist the BASIC program.",
    "10663": "Signal do not produce an error beep.",
    "10664": "Set attribute at editing position so as to show the cursor, and return.",
    "10667": "Fetch mode.",
    "10670": "Calculator mode?",
    "10672": "Exit if so.",
    "10673": "Remove cursor, restoring old attribute.",
    "10676": "The last possible line number, 9999.",
    "10679": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10682": "Find address of line number 9999, or the previous line if it does not exist.",
    "10683": "Return address in HL.",
    "10685": "DE=Address of last line number.",
    "10686": "Find line number for specified address, and return in DE.",
    "10687": "DE=Address of last line in the BASIC program.",
    "10689": "Use Workspace RAM configuration (physical RAM bank 7).",
    "10692": "Store the current line number.",
    "10696": "Paper 1, Ink 7 - Blue.",
    "10698": "Set the cursor colour.",
    "10701": "Relist the BASIC program.",
    "10704": "Signal do not produce an error beep.",
    "10705": "Set attribute at editing position so as to show the cursor, and return.",
    "10708": "Remove cursor, restoring old attribute.",
    "10711": "Find start of the current word to the left.",
    "10714": "Jump if no word to the left to restore cursor attribute at current editing position, and return. [Could have saved 4 bytes by joining the routine below, i.e. JR $29E7]",
    "10717": "A=New cursor column number. Carry flag is set indicating not to produce an error beep.",
    "10718": "Store editing position and print cursor, and then return.",
    "10721": "Remove cursor, restoring old attribute.",
    "10724": "Find start of the current word to the right.",
    "10727": "Jump if no word to the right to restore cursor attribute at current editing position, and return.",
    "10729": "A=The new cursor editing column number. Carry is set indicating not to produce an error beep.",
    "10730": "Store editing position and print cursor, and then return.",
    "10732": "Get current cursor position (C=row, B=column, A=preferred column).",
    "10735": "Restore previous colour to character square",
    "10738": "Get current cursor position (C=row, B=column, A=preferred column).",
    "10741": "Set editing position character square to cursor colour to show it. [Could have saved 1 byte by using a JR instruction to join the end of the routine below]",
    "10744": "Store new editing position.",
    "10749": "Paper 1, Ink 7 - Blue.",
    "10751": "Store new cursor colour.",
    "10756": "Set editing position character square to cursor colour to show it.",
    "10759": "Editing info.",
    "10762": "Row number.",
    "10764": "Column number.",
    "10766": "Preferred column number.",
    "10769": "Editing information.",
    "10772": "Row number.",
    "10774": "Column number.",
    "10776": "Preferred column number.",
    "10779": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "10782": "[Could have saved 2 bytes by calling the unused routine at $2E7B (ROM 0)]",
    "10784": "Point to the column position within the row.",
    "10786": "Get character at this position.",
    "10789": "Remove cursor, restoring old attribute.",
    "10792": "E=Preferred column.",
    "10793": "The ten lines to move down.",
    "10796": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "10799": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "10800": "Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.",
    "10802": "A=Preferred column.",
    "10803": "Store cursor editing position.",
    "10806": "B=Preferred column.",
    "10807": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10810": "Jump if no editable position found on the row, i.e. a blank row.",
    "10812": "Decrement row counter.",
    "10813": "Repeat to move down to the next row.",
    "10815": "A=Preferred column.",
    "10816": "Jump if editable row exists to store editing position and print cursor, and then return.",
    "10819": "Move back up to the previous row.",
    "10823": "B=Preferred column.",
    "10824": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10827": "A=Preferred column.",
    "10828": "Carry will be reset indicating to produce an error beep.",
    "10829": "Store editing position and print cursor, and then return.",
    "10831": "Remove cursor, restoring old attribute.",
    "10834": "E=Preferred column.",
    "10835": "The ten lines to move up.",
    "10838": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "10841": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "10842": "Jump if there was no row above to set cursor attribute colour at existing editing position, and return.",
    "10844": "A=Preferred column.",
    "10845": "Store cursor editing position.",
    "10848": "B=Preferred column.",
    "10849": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10852": "Jump if no editable positions were found in the row, i.e. it is a blank row.",
    "10854": "Decrement row counter.",
    "10855": "Repeat to move up to the previous row.",
    "10857": "A=Preferred column.",
    "10858": "Jump if editable row exists to store editing position and print cursor, and then return. [Redundant check of the carry flag, should just be JP $29F8 (ROM 0)]",
    "10861": "Save the preferred column number and the flags.",
    "10862": "Move back down to the next row. Returns new row number in C.",
    "10865": "Column 0.",
    "10867": "Find editable position in the Screen Line Edit Buffer row to the right, return column position in B.",
    "10870": "A=Preferred column. Carry will be reset indicating to produce an error beep.",
    "10871": "Store editing position and print cursor, and then return.",
    "10874": "Remove cursor, restoring old attribute.",
    "10877": "Find the end of the current BASIC line in the Screen Line Edit Buffer.",
    "10880": "Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.",
    "10883": "A=The new cursor editing column number. Carry is set indicating not to produce an error beep.",
    "10884": "Store editing position and print cursor, and then return.",
    "10887": "Remove cursor, restoring old attribute.",
    "10890": "Find the start of the current BASIC line in the Screen Line Edit Buffer.",
    "10893": "Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.",
    "10896": "A=The new cursor editing position. Carry is set indicating not to produce an error beep.",
    "10897": "Store editing position and print cursor, and then return.",
    "10900": "Remove cursor, restoring old attribute.",
    "10903": "E=Preferred column.",
    "10905": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "10908": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "10909": "Jump if there was no row above to set cursor attribute colour at existing editing position, and return.",
    "10912": "B=Preferred column.",
    "10913": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10916": "A=Preferred column.",
    "10917": "Jump if an editable position was found to store editing position and print cursor, and then return.",
    "10920": "Save the preferred column number and the flags.",
    "10921": "Move down to the next row, shifting rows up as appropriate. Returns new row number in C.",
    "10924": "Column 0.",
    "10926": "Find closest Screen Line Edit Buffer editable position to the right.",
    "10929": "A=Preferred column. Carry flag is reset indicating to produce an error beep.",
    "10930": "Store editing position and print cursor, and then return.",
    "10933": "Remove cursor, restoring old attribute.",
    "10936": "E=Preferred column.",
    "10945": "B=Preferred column.",
    "10938": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "10941": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "10942": "Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.",
    "10946": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10949": "A=Preferred column.",
    "10950": "Jump if an editable position was found to store editing position and print cursor, and then return.",
    "10953": "Save the preferred column.",
    "10954": "Move up to the previous row, shifting rows down as appropriate.",
    "10962": "A=Preferred column.",
    "10958": "B=Preferred column.",
    "10959": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10963": "Reset carry flag to indicate to produce an error beep.",
    "10964": "Store editing position and print cursor, and then return.",
    "10967": "Remove cursor, restoring old attribute. Returns with C=row, B=column.",
    "10970": "Find next Screen Line Edit Buffer editable position to left, wrapping to previous row as necessary.",
    "10973": "Jump if editable position found to store editing position and print cursor, and then return.",
    "10976": "Set cursor attribute at existing editing position, and return. Carry flag is reset indicating to produce an error beep.",
    "10979": "Remove cursor, restoring old attribute.",
    "10982": "Find next Screen Line Edit Buffer editable position to right, wrapping to next row if necessary.",
    "10985": "Jump if editable position found to store editing position and print cursor, and then return.",
    "10988": "Save the carry flag and preferred column number.",
    "10989": "Move up to the previous row, shifting rows down as appropriate.",
    "10992": "Column 31.",
    "10994": "Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)",
    "10997": "Carry flag is reset indicating to produce an error beep.",
    "10998": "Store editing position and print cursor, and then return.",
    "11002": "Find Screen Line Edit Buffer editable position from previous column (or current column if the previous column does not exist) to the right, return column position in B.",
    "11005": "If no editable character found then search to the left for an editable character, return column position in B.",
    "11011": "Find Screen Line Edit Buffer editable position to the left, returning column position in B.",
    "11014": "If no editable character found then search from previous column (or current column if the previous column does not exist) to the right, return column position in B.",
    "11019": "If current BASIC line has been altered and moved off of then insert it into the program.",
    "11022": "Jump if BASIC line was not inserted. [Could have saved 1 byte by using RET NC]",
    "11024": "Save the new cursor row and column numbers.",
    "11025": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11028": "Column 0.",
    "11030": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "11033": "If no editable position found then the cursor is on a blank row so shift all BASIC lines below it up to close the gap.",
    "11036": "Retrieve the new cursor row and column numbers.",
    "11037": "Point to the editing area information.",
    "11040": "Fetch the upper scroll threshold.",
    "11042": "Jump if on a row below the threshold.",
    "11041": "Is it on the threshold?",
    "11044": "Save the new cursor row and column numbers.",
    "11045": "Shift all edit buffer rows down, and update display file if required.",
    "11049": "Return if edit buffer rows were shifted.",
    "11050": "On the top row of the editing area?",
    "11052": "Return with carry flag reset if on the top row.",
    "11053": "Move onto the previous row.",
    "11054": "Signal a new row was moved to.",
    "11056": "Save row number.",
    "11057": "DE=Start address in Screen Line Edit Buffer of row held in C, i.e. the new cursor row.",
    "11060": "Column 0.",
    "11062": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "11065": "Get row number.",
    "11066": "Jump if editable position found, i.e. the row exists. [Could have saved 2 bytes by using JP NC,$2F80 (ROM 0)]",
    "11068": "Cursor is on a blank row so shift all BASIC lines below it up to close the gap.",
    "11071": "Insert the BASIC Line into the BASIC program if the line has been altered.",
    "11074": "Jump if the line was inserted into the program. [Could have saved 1 byte by using RET NC]",
    "11076": "Point to the editing area information.",
    "11079": "Point to the 'Bottom Row Scroll Threshold' value. [Could have saved 1 byte by using LD HL,$F6F2]",
    "11080": "Fetch the new cursor row number.",
    "11081": "Is it on the lower scroll threshold?",
    "11082": "Jump if on a row above the threshold.",
    "11084": "Save the new cursor row and column numbers.",
    "11085": "Save the editing area information address.",
    "11086": "Shift all edit buffer rows up, and update display file if required.",
    "11091": "Return if edit buffer rows were shifted.",
    "11092": "Point to the 'Number of Rows in the Editing Area' value.",
    "11093": "A=Number of rows in the editing area.",
    "11094": "On the last row of the editing area?",
    "11095": "Return with carry flag reset if on the bottom row.",
    "11096": "Move onto the next row.",
    "11097": "Signal a new row was moved to.",
    "11099": "Save the key code character.",
    "11100": "Back one column position.",
    "11101": "Jump if already at beginning of row.",
    "11104": "E=Column number.",
    "11105": "Find Screen Line Edit Buffer editable position to the left, returning column position in B.",
    "11108": "A=Column number.",
    "11109": "Return if the new column is editable, i.e. the cursor can be moved within this row.",
    "11110": "E=Store the column number.",
    "11111": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "11114": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "11115": "A=Column number.",
    "11116": "Return if there was no row above.",
    "11117": "Column 31.",
    "11119": "Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)",
    "11122": "A=Column number of the closest editable position.",
    "11123": "Return if an editable position was found, i.e. the cursor can be moved.",
    "11124": "Restore the key code character.",
    "11125": "Set column position 0.",
    "11127": "[*BUG* - This should really ensure the carry flag is reset to signal that no editable position to the left exists, e.g. by using OR A. Fortunately, the carry flag is always reset when this routine is called and so the bug is harmless. Credit: Paul Farrow]",
    "11128": "Save the key code character.",
    "11129": "Advance to the next column position.",
    "11130": "Column 31.",
    "11135": "E=New column number.",
    "11133": "Jump if reached end of row.",
    "11136": "Find Screen Line Edit Buffer editable position from previous column to the right, returning column position in B.",
    "11139": "A=New column number.",
    "11140": "Return if the new column is editable, i.e. the cursor can be moved within this row.",
    "11141": "B=Original column position.",
    "11142": "Save original column and row numbers.",
    "11143": "HL=Address of the new editable position.",
    "11144": "Editor flags.",
    "11147": "Got a key press?",
    "11149": "Jump if not.",
    "11151": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11157": "Point to the flag byte for the current row.",
    "11159": "Does the BASIC line row span onto another row?",
    "11161": "Jump if so to test the next row (it could just be the cursor).",
    "11163": "Signal that the row spans onto another row, i.e. a new blank row containing the cursor.",
    "11165": "Signal that the row is not the last row of the BASIC line.",
    "11167": "Point to the next row.",
    "11171": "DE=Address of the next row. [Redundant calculation as never used. Could have saved 5 bytes]",
    "11172": "HL=Address of the new editable position.",
    "11173": "B=Original column number. C=Row number.",
    "11174": "Save flag byte for the previous row.",
    "11175": "Move down to the next row, shifting rows up as appropriate. Returns new row number in C.",
    "11178": "Retrieve flag byte for the previous row.",
    "11179": "DE=Start address in Screen Line Edit Buffer of the new row, as specified in C.",
    "11185": "HL=Address of the row after the new row.",
    "11186": "DE=Address of the row after the new row. HL=Address of the new row.",
    "11187": "Signal 'not the start row of the BASIC line'.",
    "11189": "Signal 'end row of the BASIC line'.",
    "11191": "Insert a blank row into the Screen Edit Buffer at row specified by C, shifting rows down.",
    "11194": "Indent the row by setting the appropriate number of null characters in the current Screen Line Edit Buffer row.",
    "11197": "A=First column after indentation.",
    "11198": "Signal not to produce an error beep.",
    "11200": "HL=Address of the new editable position.",
    "11201": "B=Original column position.",
    "11202": "E=New column number.",
    "11203": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "11206": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "11207": "A=Original column position.",
    "11208": "Return if there was no row below.",
    "11209": "Column 0.",
    "11211": "Find Screen Line Edit Buffer editable position to the right, returning column position in B.",
    "11214": "A=New column position.",
    "11215": "Return if an editable position was found, i.e. the cursor can be moved.",
    "11216": "A=Preferred column number.",
    "11217": "Column 0.",
    "11219": "Return with carry flag reset.",
    "11220": "Save registers.",
    "11222": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11225": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "11228": "Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]",
    "11231": "Save registers.",
    "11242": "Save registers.",
    "11233": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11239": "Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]",
    "11236": "Find editable position from current column to the left, returning the column number in B.",
    "11244": "Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.",
    "11247": "Jump if not editable, i.e. at start of line.",
    "11249": "Get character at new position.",
    "11252": "Is it a space?",
    "11254": "Jump back if it is, until a non-space or start of line is found.",
    "11256": "Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.",
    "11259": "Jump if not editable, i.e. at start of line.",
    "11261": "Get character at new position.",
    "11264": "Is it a space?",
    "11266": "Jump back if it is not, until a space or start of line is found.",
    "11268": "Find next Screen Line Edit Buffer editable position to right to start of the word, moving to next row if necessary. [Returns carry flag set since the character will exist]",
    "11271": "Jump forward to restore registers and return."
  },
  "PrefixComments": {
    "0": "RST $00 - Reset Machine",
    "16": "RST $10 - Print A Character",
    "24": "RST $18 - Collect A Character",
    "40": "RST 28 calls a routine in ROM 1 (or alternatively a routine in RAM while ROM 1 is paged in). Call as follows: RST 28 / DEFW address.",
    "56": "This routine preserves the HL register pair. It then performs the following: 1) Execute the ROM switching code held in RAM to switch to ROM 1; 2) Execute the maskable interrupt routine in ROM 1; 3) Execute the ROM switching code held in RAM to return to ROM 0; Return to address $0048 (ROM 0)",
    "74": "ERROR HANDLER ROUTINES - PART 1 - 128K Error Routine",
    "92": "RESTART ROUTINES - PART 2 -Call ROM 1 Routine (RST $28 Continuation); Continuation from routine at $0028 (ROM 0).",
    "107": "RAM ROUTINES: The following code will be copied to locations $5B00 to $5B57, within the old ZX Printer buffer.",
    "127": "Return to Other ROM Routine (copied to $5B14)",
    "136": "Error Handler Routine (copied to $5B1D)",
    "154": "'P' Channel Input Routine (copied to $5B2F)",
    "159": "'P' Channel Output Routine (copied to $5B34)",
    "181": "'P' Channel Exit Routine (copied to $5B4A)",
    "195": "ERROR HANDLER ROUTINES - PART 2: Called from ONERR ($5B1D) to execute the routine pointed to by system variable SYNRET.",
    "199": "Reset Routine (RST $00 Continuation, Part 1): Continuation from routine at $0000 (ROM 0). It performs a test on all RAM banks. This test is crude and can fail to detect a variety of RAM errors.",
    "256": "ROUTINE VECTOR TABLE",
    "305": "INITIALISATION ROUTINES - PART 2: Fatal RAM Error -- Set the border colour to indicate which RAM bank was found faulty.",
    "311": "Reset Routine (RST $00 Continuation, Part 2): Continuation from routine at $00C7 (ROM 0).",
    "413": "Entry point for NEW with interrupts disabled and physical RAM bank 0 occupying the upper RAM region $C000 - $FFFF, i.e. the normal BASIC memory configuration.",
    "1417": "The 'Initial Channel Information': Initially there are four channels ('K', 'S', 'R', & 'P') for communicating with the 'keyboard', 'screen', 'work space' and 'printer'. For each channel the output routine address comes before the input routine address and the channel's code. This table is almost identical to that in ROM 1 at $15AF but with changes to the channel P routines to use the RS232 port instead of the ZX Printer. Used at $01DD (ROM 0).",
    "1438": "The 'Initial Stream Data': Initially there are seven streams - $FD to $03. This table is identical to that in ROM 1 at $15C6. Used at $0226 (ROM 0).",
    "610": "[Note this is where $EC13 (temporary P_FLAG) and $FF24 should be set]",
    "619": "COMMAND EXECUTION ROUTINES - PART 1: Execute Command Line - A typed in command resides in the editing workspace. Execute it.  The command could either be a new line to insert, or a line number to delete, or a numerical expression to evaluate.",
    "690": "Calculator mode",
    "696": "Otherwise ignore the command",
    "698": "Return from BASIC Line Syntax Check: This routine is returned to when a BASIC line has been syntax checked.",
    "705": "The syntax check was successful, so now proceed to parse the line for insertion or execution",
    "719": "Parse a BASIC Line with No Line Number",
    "780": "[*BUG* - Whenever a typed in command is executed directly from the editing workspace, a new GO SUB marker is set up on the stack. Any existing GO SUB calls that were on the stack are lost and as a result attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. However, the stack marker will already have been lost due to the error handler routine at $0321. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. This is why it is necessary for a new GO SUB marker needs to be set up. Credit: Michal Skrzypek]",
    "801": "ERROR HANDLER ROUTINES - PART 3: Error Handler Routine - [*BUG* - Upon terminating a BASIC program, either via reaching the end of the program or due to an error occurring, execution is passed to this routine. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. However, this means that any existing GO SUB calls that were on the stack are lost and so attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. When a new typed in command is executed, the code at $030C sets up a new GO SUB marker on the stack. Credit: Michal Skrzypek]",
    "842": "Display error code held in ERR_NR",
    "906": "Display a new error message - [Note that there is no test to range check the error code value and therefore whether a message exists for it. Poking directly to system variable ERR_NR with an invalid code (43 or above) will more than likely cause a crash]",
    "924": "Display a standard error message.",
    "1007": "Error Handler Routine When Parsing BASIC Line",
    "1015": "COMMAND EXECUTION ROUTINES - PART 2: Parse a BASIC Line with a Line Number - This routine handles insertion of a BASIC line specified with a line number, or just a line number specified on its own, i.e. delete the line.",
    "1059": "The line already exists so delete it",
    "1071": "Just a line number entered. The requested line has already been deleted so move the program cursor to the next line",
    "1132": "ERROR HANDLER ROUTINES - PART 4: New Error Message Vector Table",
    "1164": "New Error Message Table",
    "1405": "Print a message which is terminated by having bit 7 set, pointed at by DE.",
    "1452": "ERROR HANDLER ROUTINES - PART 5: Produce Error Report",
    "1477": "Handle a standard error code",
    "1480": "Handle a new error code",
    "1494": "Check for BREAK into Program",
    "1510": "RS232 PRINTER ROUTINES: RS232 Channel Handler Routines - This routine handles input and output RS232 requested. It is similar to the routine in the ZX Interface 1 ROM at $0D5A, but in that ROM the routine is only used for input.",
    "1535": "Handle INPUT#",
    "1552": "Return here from the input/output routine",
    "1560": "A character was not received",
    "1563": "A character was received",
    "1581": "Enter was received so end reading the stream",
    "1591": "Handle INKEY$# and PRINT#",
    "1597": "Return here from the input/output routine. When returning from the output routine, either the carry or zero flags should always be set to avoid the false generation of error report \"8 End of file\" [though this is not always the case - see bugs starting at $086C (ROM 0)].",
    "1601": "FORMAT Routine: The format command sets the RS232 baud rate, e.g. FORMAT \"P\"; 9600. It attempts to match against one of the supported baud rates, or uses the next higher baud rate if a non-standard value is requested. The maximum baud rate supported is 9600, and this is used for any rates specified that are higher than this.",
    "1688": "Lookup the timing constant to use for the specified baud rate",
    "1720": "Baud Rate Table: Consists of entries of baud rate value followed by timing constant to use in the RS232 routines.",
    "1711": "The baud rate has been matched",
    "1752": "RS232 Input Routine - Exit: Carry flag set if a byte was read with the byte in A. Carry flag reset upon error.",
    "1765": "Read Byte from RS232 Port: The timing of the routine is achieved using the timing constant held in system variable BAUD. Exit: Carry flag set if a byte was read, or reset upon error. A=Byte read in.",
    "1806": "Look for the start bit",
    "1834": "A start bit has been found, so the 8 data bits are now read in. As each bit is read in, it is shifted into the msb of A. Bit 7 of A is preloaded with a 1 to represent the start bit and when this is shifted into the carry flag it signifies that 8 data bits have been read in.",
    "1858": "Received one 1",
    "1867": "Received one 0",
    "1876": "After looping 8 times to read the 8 data bits, the start bit in the bit counter will be shifted out and hence A will contain a received byte.",
    "1879": "The success and failure paths converge here",
    "1905": "The device at the other end of the cable may send a second byte even though CTS is low. So repeat the procedure to read another byte.",
    "1916": "No second byte incoming so return status of the first byte read attempt",
    "1931": "A second byte is on its way and is received exactly as before",
    "1966": "Received one 1",
    "1975": "Received one 0",
    "1984": "Exit with the byte that was read in",
    "1994": "RS232 Output Routine: This routine handles control codes, token expansion, graphics and UDGs. It therefore cannot send binary data and hence cannot support EPSON format ESC control codes [Credit: Andrew Owen]. The routine suffers from a number of bugs as described in the comments below. It also suffers from a minor flaw in the design, which prevents interlacing screen and printer control codes and their parameters. Entry: A=character to output. Exit : Carry flag reset indicates success.",
    "2007": "All parameters processed",
    "2021": "Process tokens",
    "2055": "Printable character",
    "2082": "Handle a carriage return",
    "2078": "Process control codes",
    "2100": "Handle a comma",
    "2120": "Column 8, 16, 24 or 32 reached. Output multiple spaces until the desired column position is reached.",
    "2144": "Handle AT and TAB",
    "2153": "Handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER",
    "2162": "All parameters processed",
    "2174": "Handle TAB parameter",
    "2178": "Process AT and TAB",
    "2186": "Column position equal or greater than length of row requested",
    "2211": "Write Byte to RS232 Port - The timing of the routine is achieved using the timing constant held in system variable BAUD. Entry: A holds character to send. Exit:  Carry and zero flags reset.",
    "2248": "Transmit each bit",
    "2260": "Transmit a 0",
    "2266": "Transmit a 1",
    "2288": "COPY Command Routine - This routine copies 22 rows of the screen, outputting them to the printer a half row at a time. It is designed for EPSON compatible printers supporting double density bit graphics and 7/72 inch line spacing. Only the pixel information is processed; the attributes are ignored.",
    "2425": "EPSON Printer Control Code Tables",
    "2318": "Copy done so reset printer line spacing before exiting",
    "2325": "Output Half Row",
    "2342": "Output a column of pixels (at double height)",
    "2389": "Output Nibble of Pixels: Send each nibble of pixels (i.e. column of 4 pixels) output 3 times so that the width of a pixel is the same size as its height.",
    "2399": "Output Characters from Table: This routine is used to send a sequence of EPSON printer control codes out to the RS232 port. It sends (HL) characters starting from HL+1.",
    "2413": "Test Whether Pixel (B,C) is Set",
    "2509": "[*BUG* - At this point interrupts are disabled and IY is now being used as a pointer to the master PLAY information block. Unfortunately, interrupts are enabled during the STK_FETCH call and IY is left containing the wrong value. This means that if an interrupt were to occur during execution of the subroutine then there would be a one in 65536 chance that (IY+$40) will be corrupted - this corresponds to the volume setting for music channel A. Rewriting the SWAP routine to only re-enable interrupts if they were originally enabled would cure this bug (see end of file for description of her suggested fix). Credit: Toni Baker, ZX Computing Monthly]",
    "2437": "PLAY COMMAND ROUTINES - Up to 3 channels of music/noise are supported by the AY-3-8912 sound generator. Up to 8 channels of music can be sent to support synthesisers, drum machines or sequencers via the MIDI interface, with the first 3 channels also played by the AY-3-8912 sound generator. For each channel of music, a MIDI channel can be assigned to it using the 'Y' command. Entry: B=The number of strings in the PLAY command (1..8).",
    "2565": "Entry point here from the vector table at $011B",
    "2609": "Calculate Timing Loop Counter <<< RAM Routine >>> - This routine is copied into the command data block (offset $2B..$37) by the routine at $0A05 (ROM 0). It uses the floating point calculator found in ROM 1, which is usually invoked via a RST $28 instruction. Since ROM 0 uses RST $28 to call a routine in ROM 1, it is unable to invoke the floating point calculator this way. It therefore copies the following routine to RAM and calls it with ROM 1 paged in.",
    "2622": "Test BREAK Key: Test for BREAK being pressed. Exit: Carry flag reset if BREAK is being pressed.",
    "2634": "Select Channel Data Block Duration Pointers: Point to the start of the channel data block duration pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2639": "Select Channel Data Block Pointers: Point to the start of the channel data block pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2663": "Get Channel Data Block Address for Current String: Entry: HL=Address of channel data block pointer. Exit : IX=Address of current channel data block.",
    "2670": "Next Channel Data Pointer",
    "2685": "PLAY Command (Continuation): This section is responsible for processing the PLAY command and is a continuation of the routine at $0985 (ROM 0). It begins by determining the first note to play on each channel and then enters a loop to play these notes, fetching the subsequent notes to play at the appropriate times.",
    "2694": "HL=Address of channel data pointer.",
    "2711": "The first notes to play for each channel have now been determined. A loop is entered that coordinates playing the notes and fetching subsequent notes when required. Notes across channels may be of different lengths and so the shortest one is determined, the tones for all channels set and then a waiting delay entered for the shortest note delay. This delay length is then subtracted from all channel note lengths to leave the remaining lengths that each note needs to be played for. For the channel with the smallest note length, this will now have completely played and so a new note is fetched for it. The smallest length of the current notes is then determined again and the process described above repeated. A test is made on each iteration to see if all channels have run out of data to play, and if so this ends the PLAY command.",
    "2743": "PLAY Command Character Table: Recognised characters in PLAY commands.",
    "2757": "Get Play Character: Get the current character from the PLAY string and then increment the character pointer within the string. Exit: Carry flag set if string has been fully processed. Carry flag reset if character is available. A=Character available.",
    "2769": "Get Next Note in Semitones: Finds the number of semitones above C for the next note in the string, Entry: IX=Address of the channel data block. Exit : A=Number of semitones above C, or $80 for a rest.",
    "3577": "Semitones Table: This table contains an entry for each note of the scale, A to G, and is the number of semitones above the note C.",
    "2845": "Get Numeric Value from Play String: Get a numeric value from a PLAY string, returning 0 if no numeric value present. Entry: IX=Address of the channel data block. Exit : BC=Numeric value, or 0 if no numeric value found.",
    "2885": "The end of the numeric value was reached",
    "2896": "Multiply DE by 10: Entry: DE=Value to multiple by 10. Exit : DE=Value*10.",
    "2908": "Find Next Note from Channel String: Entry: IX=Address of channel data block.",
    "2947": "Comes here after processing a non-numeric digit that does not have a specific command routine handler Hence the next note to play has been determined and so a return is made to process the other channels.",
    "2949": "Play Command '!' (Comment): A comment is enclosed within exclamation marks, e.g. \"! A comment !\". Entry: IX=Address of the channel data block.",
    "3530": "PLAY Command Jump Table: Handler routine jump table for all PLAY commands.",
    "2960": "Play Command 'O' (Octave): The 'O' command is followed by a numeric value within the range 0 to 8, although due to loose range checking the value MOD 256 only needs to be within 0 to 8. Hence O256 operates the same as O0. Entry: IX=Address of the channel data block.",
    "2981": "Play Command 'N' (Separator): The 'N' command is simply a separator marker and so is ignored. Entry: IX=Address of the channel data block.",
    "2982": "Play Command '(' (Start of Repeat): A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice. Entry: IX=Address of the channel data block.",
    "3010": "Play Command ')' (End of Repeat): A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice. Brackets can also be nested within each other, to 4 levels deep. If a closing bracket if used without a matching opening bracket then the whole string up until that point is repeated indefinitely. Entry: IX=Address of the channel data block.",
    "3020": ";Has the bracket level been repeated, i.e. re-reached the same position in the string as the closing bracket return address?",
    "3036": "The bracket level has been repeated. Now check whether this was the outer bracket level.",
    "3044": "The outer bracket level has been repeated",
    "3049": "The repeat was caused by a single closing bracket so re-initialise the repeat",
    "3056": "A new level of closing bracket nesting",
    "3102": "There is one more closing bracket then opening brackets, i.e. repeat string indefinitely",
    "3111": "Get Address of Bracket Pointer Store: Entry: IX=Address of the channel data block. DE=Offset to the bracket pointer stores. A=Index into the bracket pointer stores. Exit : HL=Address of the specified pointer store.",
    "3122": "Play Command 'T' (Tempo): A tempo command must be specified in the first play string and is followed by a numeric value in the range 60 to 240 representing the number of beats (crotchets) per minute. Entry: IX=Address of the channel data block.",
    "3141": "A holds a value in the range 60 to 240",
    "3190": "Tempo Command Return: The calculator stack now holds the value (10/(Tempo*4))/7.33e-6 and this is stored as the tempo value. The result is used an inner loop counter in the wait routine at $0F76 (ROM 0). Each iteration of this loop takes 26 T-states. The time taken by 26 T-states is 7.33e-6 seconds. So the total time for the loop to execute is 2.5/TEMPO seconds.",
    "3204": "Play Command 'M' (Mixer): This command is used to select whether to use tone and/or noise on each of the 3 channels. It is followed by a numeric value in the range 1 to 63, although due to loose range checking the value MOD 256 only needs to be within 0 to 63. Hence M256 operates the same as M0. Entry: IX=Address of the channel data block.",
    "3213": "Bit 0: 1=Enable channel A tone. Bit 0: 1=Enable channel A tone. Bit 1: 1=Enable channel B tone. Bit 2: 1=Enable channel C tone. Bit 3: 1=Enable channel A noise. Bit 4: 1=Enable channel B noise. Bit 5: 1=Enable channel C noise.",
    "3221": "Play Command 'V' (Volume): This sets the volume of a channel and is followed by a numeric value in the range 0 (minimum) to 15 (maximum), although due to loose range checking the value MOD 256 only needs to be within 0 to 15. Hence V256 operates the same as V0. Entry: IX=Address of the channel data block.",
    "3233": "[*BUG* - An attempt to set the volume for a sound chip channel is now made. However, this routine fails to take into account that it is also called to set the volume for a MIDI only channel, i.e. play strings 4 to 8. As a result, corruption occurs to various sound generator registers, causing spurious sound output. There is in fact no need for this routine to set the volume for any channels since this is done every time a new note is played - see routine at $0A97 (ROM 0). the bug fix is to simply to make a return at this point. This routine therefore contains 11 surplus bytes. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "3245": "Play Command 'U' (Use Volume Effect): This command turns on envelope waveform effects for a particular sound chip channel. The volume level is now controlled by the selected envelope waveform for the channel, as defined by the 'W' command. MIDI channels do not support envelope waveforms and so the routine has the effect of setting the volume of a MIDI channel to maximum, i.e. 15. It might seem odd that the volume for MIDI channels is set to 15 rather than just filtered out. However, the three sound chip channels can also drive three MIDI channels and so it would be inconsistent for these MIDI channels to have their volume set to 15 but have the other MIDI channels behave differently. However, it could be argued that all MIDI channels should be unaffected by the 'U' command. There are no parameters to this command. Entry: IX=Address of the channel data block.",
    "3258": "Play command 'W' (Volume Effect Specifier): This command selects the envelope waveform to use and is followed by a numeric value in the range 0 to 7, although due to loose range checking the value MOD 256 only needs to be within 0 to 7. Hence W256 operates the same as W0. Entry: IX=Address of the channel data block.",
    "3278": "Play Command 'X' (Volume Effect Duration): This command allows the duration of a waveform effect to be specified, and is followed by a numeric value in the range 0 to 65535. A value of 1 corresponds to the minimum duration, increasing up to 65535 and then maximum duration for a value of 0. If no numeric value is specified then the maximum duration is used. Entry: IX=Address of the channel data block.",
    "3293": "Play Command 'Y' (MIDI Channel): This command sets the MIDI channel number that the string is assigned to and is followed by a numeric value in the range 1 to 16, although due to loose range checking the value MOD 256 only needs to be within 1 to 16. Hence Y257 operates the same as Y1. Entry: IX=Address of the channel data block.",
    "3310": "Play Command 'Z' (MIDI Programming Code): This command is used to send a programming code to the MIDI port. It is followed by a numeric value in the range 0 to 255, although due to loose range checking the value MOD 256 only needs to be within 0 to 255. Hence Z256 operates the same as Z0. Entry: IX=Address of the channel data block.",
    "3318": "Play Command 'H' (Stop): This command stops further processing of a play command. It has no parameters. Entry: IX=Address of the channel data block.",
    "3323": "Play Commands 'a'..'g', 'A'..'G', '1'..\"12\", '&' and '_': This handler routine processes commands 'a'..'g', 'A'..'G', '1'..\"12\", '&' and '_', and determines the length of the next note to play. It provides the handling of triplet and tied notes. It stores the note duration in the channel data block's duration length entry, and sets a pointer in the command data block's duration lengths pointer table to point at it. A single note letter is deemed to be a tied note count of 1. Triplets are deemed a tied note count of at least 2. Entry: IX=Address of the channel data block. A=Current character from play string.",
    "3329": "The character is a number digit",
    "3359": "It is a triplet semi-quaver (10), triplet quaver (11) or triplet crotchet (12)",
    "3378": "The note duration was in the range 1 to 9",
    "3405": "A triplet note was found as part of a tied note",
    "3423": "A non-triplet tied note",
    "3438": "The number found was not part of a tied note, so store the duration value",
    "3444": "This subroutine is called to increment the tied notes counter",
    "3457": "The character is not a number digit so is 'A'..'G', '&' or '_'",
    "3464": "Store a pointer to the channel data block's duration length into the command data block",
    "3489": "End of String Found: This routine is called when the end of string is found within a comment. It marks the string as having been processed and then returns to the main loop to process the next string.",
    "3490": "Enter here if the end of the string is found whilst processing a string.",
    "3500": "Point to Duration Length within Channel Data Block: Entry: IX=Address of the channel data block. Exit : HL=Address of the duration length within the channel data block.",
    "3508": "Store Entry in Command Data Block's Channel Duration Length Pointer Table: Entry: IY=Address of the command data block. IX=Address of the channel data block for the current string. HL=Address of the duration length store within the channel data block. Exit : HL=Address of the duration length store within the channel data block. DE=Channel duration.",
    "3568": "Identify Command Character: This routines attempts to match the command character to those in a table. The index position of the match indicates which command handler routine is required to process the character. Note that commands are case sensitive. Entry: A=Command character. Exit : Zero flag set if a match was found. BC=Indentifying the character matched, 1 to 15 for match and 0 for no match.",
    "3584": "Find Note Duration Length: Entry: C=Duration value (0 to 12, although a value of 0 is never used). Exit : DE=Note duration length.",
    "3596": "Note Duration Table: A whole note is given by a value of 96d and other notes defined in relation to this. The value of 96d is the lowest common denominator from which all note durations can be defined.",
    "3609": "Is Numeric Digit?: Tests whether a character is a number digit. Entry: A=Character. Exit : Carry flag reset if a number digit.",
    "3616": "Play a Note On a Sound Chip Channel: This routine plays the note at the current octave and current volume on a sound chip channel. For play strings 4 to 8, it simply stores the note number and this is subsequently played later. Entry: IX=Address of the channel data block. A=Note value as number of semitones above C (0..11).",
    "3633": "Only set the noise generator frequency on the first channel",
    "3656": "Channel 0, 1 or 2",
    "3671": ";Note number 21 to 107 (range 0 to 86)",
    "3708": "Set Sound Generator Register: Entry: D=Register to write. E=Value to set register to.",
    "3721": "Read Sound Generator Register: Entry: A=Register to read. Exit : A=Value of currently selected sound generator register.",
    "3731": "Turn Off All Sound",
    "3738": "Turn off the sound from the AY-3-8912",
    "3756": "Now reset all MIDI channels in use",
    "3784": "Get Previous Character from Play String: Get the previous character from the PLAY string, skipping over spaces and 'Enter' characters. Entry: IX=Address of the channel data block.",
    "3811": "Get Current Character from Play String: Get the current character from the PLAY string, skipping over spaces and 'Enter' characters. Exit: Carry flag set if string has been fully processed. Carry flag reset if character is available. A=Character available.",
    "3858": "Produce Play Error Reports",
    "3906": "Play Note on Each Channel: Play a note and set the volume on each channel for which a play string exists.",
    "3935": "One of the 3 sound chip generator channels so set the channel's volume for the new note",
    "3958": "Wait Note Duration: This routine is the main timing control of the PLAY command. It waits for the specified length of time, which will be the lowest note duration of all active channels. The actual duration of the wait is dictated by the current tempo. Entry: DE=Note duration, where 96d represents a whole note. Enter a loop waiting for (135+ ((26*(tempo-100))-5) )*DE+5 T-states",
    "3974": "Tempo timing value = (10/(TEMPO*4))/7.33e-6, where 7.33e-6 is the time for 26 T-states. The loop below takes 26 T-states per iteration, where the number of iterations is given by the tempo timing value. So the time for the loop to execute is 2.5/TEMPO seconds. For a TEMPO of 60 beats (crotchets) per second, the time per crotchet is 1/24 second. The duration of a crotchet is defined as 24 from the table at $0E0C, therefore the loop will get executed 24 times and hence the total time taken will be 1 second. The tempo timing value above has 100 subtracted from it, presumably to approximately compensate for the overhead time previously taken to prepare the notes for playing. This reduces the total time by 2600 T-states, or 733us.",
    "3985": "Find Smallest Duration Length: This routine finds the smallest duration length for all current notes being played across all channels. Exit: DE=Smallest duration length.",
    "3997": "HL=Address of channel data pointer. DE holds the smallest duration length found so far.",
    "4013": "The current channel's duration was not smaller so restore the last smallest into DE.",
    "4033": "Play a Note on Each Channel and Update Channel Duration Lengths: This routine is used to play a note and set the volume on all channels. It subtracts an amount of time from the duration lengths of all currently playing channel note durations. The amount subtracted is equivalent to the smallest note duration length currently being played, and as determined earlier. Hence one channel's duration will go to 0 on each call of this routine, and the others will show the remaining lengths of their corresponding notes. Entry: IY=Address of the command data block.",
    "4092": "The current channel uses the smallest found duration length",
    "4134": "The channel has more tied notes",
    "4186": "Check whether another channel needs its duration length updated",
    "4198": "[*BUG* - By this point, the volume for both sound chip and MIDI channels has been set to 0, i.e. off. So although the new notes have been set playing on the sound chip channels, no sound is audible. For MIDI channels, no new notes have yet been output and hence these are also silent. If the time from turning the volume off for the current note to the time to turn the volume on for the next note is short enough, then it will not be noticeable. However, the code at $1066 (ROM 0) introduces a 1/96th of a note delay and as a result a 1/96th of a note period of silence between notes. The bug can be resolved by simply deleting the two instructions below that introduce the delay. A positive side effect of the bug in the 'V' volume command at $0C95 (ROM 0) is that it can be used to overcome the gaps of silence between notes for sound chip channels. By interspersing volume commands between notes, a new volume level is immediately set before the 1/96th of a note delay is introduced for the new note. Therefore, the delay occurs when the new note is audible instead of when it is silent. For example, PLAY \"cV15cV15c\" instead of PLAY \"ccc\". The note durations are still 1/96th of a note longer than they should be though. This technique will only work on the sound chip channels and not for any MIDI channels. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "4207": "All channel durations have been updated. Update the volume on each sound chip channel, and the volume and note on each MIDI channel",
    "4246": "Note Lookup Table: Each word gives the value of the sound generator tone registers for a given note. There are 9 octaves, containing a total of 108 notes. These represent notes 21 to 128. Notes 0 to 20 cannot be reproduced on the sound chip and so note 21 will be used for all of these (they will however be sent to a MIDI device if one is assigned to a channel). [Note that both the sound chip and the MIDI port can not play note 128 and so its inclusion in the table is a waste of 2 bytes]. The PLAY command does not allow octaves higher than 8 to be selected directly. Using PLAY \"O8G\" will select note 115. To select higher notes, sharps must be included, e.g. PLAY \"O8#G\" for note 116, PLAY \"O8##G\" for note 117, etc, up to PLAY \"O8############G\" for note 127. Attempting to access note 128 using PLAY \"O8#############G\" will lead to error report \"m Note out of range\".",
    "4462": "Play Note on MIDI Channel: This routine turns on a note on the MIDI channel and sets its volume, if MIDI channel is assigned to the current string. Three bytes are sent, and have the following meaning: Byte 1: Channel number $00..$0F, with bits 4 and 7 set. Byte 2: Note number $00..$7F. Byte 3: Note velocity $00..$78.",
    "4467": "A holds the assigned channel number ($00..$0F)",
    "4493": "Turn MIDI Channel Off: This routine turns off a note on the MIDI channel, if a MIDI channel is assigned to the current string. Three bytes are sent, and have the following meaning: Byte 1: Channel number $00..$0F, with bit 7 set. Byte 2: Note number $00..$7F. Byte 3: Note velocity $40. Entry: IX=Address of the channel data block.",
    "4498": "A holds the assigned channel number ($00..$0F)",
    "4515": "Send Byte to MIDI Device: This routine sends a byte to the MIDI port. MIDI devices communicate at 31250 baud, although this routine actually generates a baud rate of 31388, which is within the 1% tolerance supported by MIDI devices. Entry: A=Byte to send.",
    "4587": "SAVE Routine",
    "4594": "LOAD Routine",
    "4601": "VERIFY Routine",
    "4608": "MERGE Routine",
    "4624": "RAM disk operation",
    "4637": "RAM Disk Command Handling: The information relating to the file is copied into memory in $5B66 (FLAGS3) to ensure that it is available once other RAM banks are switched in. This code is very similar to that in the ZX Interface 1 ROM at $08F6. Entry: HL=Start address. IX=File header descriptor.",
    "4673": "A copy of the header information has now been copied from IX+$00 onwards to HD_00 onwards",
    "4720": "The file exists else the call above would have produced an error \"h file does not exist\"",
    "4752": "Either a verify program/array or a load/verify CODE/SCREEN$ type file",
    "4759": "Cannot merge CODE/SCREEN$",
    "4763": "RAM Disk VERIFY! Routine",
    "4778": "File was smaller than requested",
    "4805": "RAM Disk MERGE! Routine",
    "4827": "RAM Disk LOAD! Routine",
    "4839": "Start address was not specified",
    "4854": "Test if there is room since file is bigger than requested",
    "4863": "Test file type",
    "4870": "Array type",
    "4874": "Start address of existing array was specified",
    "4885": "Insert new array entry into variables area",
    "4917": "Program type",
    "4990": "RAM Disk Load Bytes: Make a check that the requested length is not zero before proceeding to perform the LOAD, MERGE or VERIFY. Note that VERIFY simply performs a LOAD. Entry: HL=Destination address. DE=Length. IX=Address of catalogue entry. HD_00-HD_11 holds file header information.",
    "4997": "Get Expression from BASIC Line: Returns in BC.",
    "5011": "Check Filename and Copy: Called to check a filename for validity and to copy it into N_STR1 ($5B67).",
    "5054": "Cassette / RAM Disk Command Handling: Handle SAVE, LOAD, MERGE, VERIFY commands. Bit 3 of FLAGS3 indicates whether a cassette or RAM disk command. This code is very similar to that in ROM 1 at $0605.",
    "5113": "Continue to handle the name of the program.",
    "5120": "The name is now transferred to the work space (second location onwards)",
    "5127": "The many different parameters, if any, that follow the command are now considered. Start by handling 'xxx \"name\" DATA'.",
    "5132": "'xxx \"name\" DATA'",
    "5167": "Continue with the handling of an existing array",
    "5188": "The next part is common to both 'old' and 'new' arrays",
    "5201": "The last part of the statement is examined before joining the other pathways",
    "5215": "Now Consider 'SCREEN$'",
    "5219": "'xxx \"name\" SCREEN$'",
    "5250": "Now consider 'CODE'",
    "5254": "'xxx \"name\" CODE'",
    "5280": "Look for a 'starting address'",
    "5300": "Fetch the 'length' as it was specified",
    "5304": "The parameters are now stored in the header area of the work space",
    "5327": "'SCREEN$' and 'CODE' are both of type 3",
    "5333": "'xxx \"name\"' / 'SAVE \"name\" LINE'",
    "5369": "'LINE' and 'no further parameters' are both of type 0",
    "5401": "In all cases the header information has now been prepared: The location 'IX+00' holds the type number. Locations 'IX+01 to IX+0A' holds the name ($FF in 'IX+01' if null). Locations 'IX+0B & IX+0C' hold the number of bytes that are to be found in the 'data block'. Locations 'IX+0D to IX+10' hold a variety of parameters whose exact interpretation depends on the 'type'. The routine continues with the first task being to separate SAVE from LOAD, VERIFY and MERGE.",
    "5419": "In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of the 'header area' in the work space hold the prepared information, as detailed above; and it is now time to fetch a 'header' from the tape.",
    "5423": "Relist the BASIC Program from the Current Line: This routine lists the BASIC program from the current line number. It initially shows the last line displayed but rows may subsequently be scrolled up until the required BASIC line has been found. The structure of the ROM program only supports listing BASIC lines that are 20 rows or less; larger lines are shown truncated to 20 rows.",
    "5430": "A loop is entered to display a screenful of program listing. If the current line number is not found in the lines displayed then all lines are scrolled up and the listing reproduced. This procedure repeats until the current line number has been found and displayed.",
    "5463": "The current settings indicate that the top BASIC line straggles into the Above-Screen Line Edit Buffer. It is therefore necessary to insert the current BASIC line into the Below-Screen Line Edit Buffer and then shift the appropriate number of rows into the Above-Screen Line Edit Buffer.",
    "5475": "Either there the top BASIC line does not straggle off the top of the the screen or the appropriate number of rows have been copied into the Above-Screen Line Edit Buffer. In the latter case, the Below-Screen Line Edit Buffer contains the remaining rows of the BASIC line and which be copied into the top of the Screen Line Edit Buffer.",
    "5487": "Enter a loop to copy BASIC line rows into the Screen Line Edit Buffer. The Below-Screen Line Edit Buffer is used as a temporary store for holding each BASIC line as it is copied into the Screen Line Edit Buffer. If the top BASIC line straggles above the screen then this loop is entered with the remains of the line already in the Below-Screen Line Edit Buffer.",
    "5497": "The current line has not yet been found so examine the current row in case it is the current line",
    "5507": "The Below-Screen Line Edit Buffer contains a complete BASIC line so determine whether this is the current line",
    "5545": "This is the current line so scan across the BASIC line to locate the cursor column position",
    "5526": "Copy the row of the BASIC line from the Below-Screen Line Edit Buffer into the Screen Line Edit Buffer",
    "5554": "There are editable characters on this row prior to the cursor. [*BUG* - Entering '  10 REM' or '0010 REM' will insert the line into the program area but instead of placing the cursor on the following row it is placed after the following BASIC line, or if the line inserted was the last in the program then the cursor is placed on row 20. The bug occurs due to the leading spaces or zeros, and hence will apply to every BASIC command. When the line is inserted into the Screen Line Edit Buffer, the leading spaces are discarded and hence the line length is shorter than that typed in. However, it is the typed in line length that is used when parsing the BASIC line in the Screen Line Edit Buffer and as a result this causes an attempt to find the remaining characters on the following row of the Screen Line Edit Buffer. If another BASIC line is on the following Screen Line Edit Buffer row then the search completes and the cursor is placed on the row after this BASIC line. If there is not a BASIC line on the following row then the search continues on the next row. Since this will also be empty, the search advances onto the next row, and then the next, and so on until row 20 is reached. To fix the bug, the typed in character count until the cursor (held in $EC06) ideally needs to be adjusted to match the actual number of characters stored in the Screen Line Edit Buffer. However, this is not a trivial change to implement. A simpler solution to fix the bug is to intercept when a move to the next row is made and to determine whether the BASIC line actually continues on this row. Credit: Paul Farrow]",
    "5561": "An editable character was found to the right on the current row",
    "5568": "Column position of cursor located, find the closest editable character",
    "5579": "Store the current cursor position",
    "5587": "Move to next row",
    "5594": "The bottom screen row has been exceeded",
    "5601": "Current line has not yet been found",
    "5605": "This is not the current line",
    "5620": "There is no current line number",
    "5657": "All rows printed",
    "5637": "Print All Screen Line Edit Buffer Rows to the Display File: Print all rows of the edit buffer to the display file, and updating the cursor position settings if required. Entry: Zero flag reset if update of cursor position settings required. B=Row number. C=Number of editing rows on screen.",
    "5659": "Find the new cursor column position",
    "5680": "Clear Editing Display",
    "5689": "Shift All Edit Buffer Rows Up and Update Display File if Required: This routine shifts all edit buffer rows up, updating the display file if required. Entry: HL=Address of the 'Bottom Row Scroll Threshold' within the editing area information. Exit : Carry flag set if edit buffer rows were shifted.",
    "5692": "Attempt to shift a row into the Above-Screen Line Edit Buffer",
    "5701": ";A change to the number of rows in the Above-Screen Line Edit Buffer occurred",
    "5704": "Shift All Screen Line Edit Buffer Rows Up and Update Display File if Required",
    "5717": "Shift all Screen Line Edit Buffer rows up",
    "5730": "All Screen Line Edit Buffer rows have been shifted up",
    "5743": "Shift All Edit Buffer Rows Down and Update Display File if Required: This routine shifts all edit buffer rows down, updating the display file if required. Exit : Carry flag set if edit buffer rows were shifted. B=Last row number to shift. Shift all rows in the Above-Screen Line Edit Buffer, shifting in a new BASIC line if applicable",
    "5749": "Entry point from routine at $2ED3 (ROM 0) to insert a blank row",
    "5751": "Shift all rows in the Below-Screen Line Edit Buffer down, shifting in a new BASIC line if applicable",
    "5786": "All Screen Line Edit Buffer rows have been shifted down",
    "5801": ";The Below-Screen Line Edit Buffer is full",
    "5804": "Insert Character into Edit Buffer Row, Shifting Row Right: This routine shifts a byte into an edit buffer row, shifting all existing characters right until either the end of the row is reached or the specified end column is reached. Entry: DE=Start address of an edit buffer row. A=Character to shift into left of row. B=Column to start shifting at. Exit : A=Byte shifted out from last column. HL=Points byte after row (i.e. flag byte). Zero flag set if the character shifted out was a null ($00).",
    "5811": "Shift all bytes in the row to the right.",
    "5825": "Insert Character into Edit Buffer Row, Shifting Row Left: This routine shifts a byte into an edit buffer row, shifting all existing characters left until either the beginning of the row is reached or the specified end column is reached. Entry: DE=Start address of an edit buffer row. A=Character to shift into right of row. B=Column to stop shifting at. Exit : A=Byte shifted out. HL=Points byte before row. Zero flag set if the character shifted out was a null ($00).",
    "5852": "The Syntax Offset Table: Similar in construction to the table in ROM 1 at $1A48. [No instruction fetch at $1708 hence ZX Interface 1 will not be paged in by this ROM. Credit: Paul Farrow].",
    "6063": "The 'Main Parser' Of the BASIC Interpreter: The parsing routine of the BASIC interpreter is entered at $17AF (ROM 0) when syntax is being checked, and at $1838 (ROM 0) when a BASIC program of one or more statements is to be executed. This code is similar to that in ROM 1 at $1B17.",
    "6080": "The Statement Loop: Each statement is considered in turn until the end of the line is reached.",
    "6102": "A statement has been identified so, first, its initial command is considered",
    "6141": "Each of the command class routines applicable to the present command are executed in turn. Any required separators are also considered.",
    "6170": "The 'Separator' Subroutine: The report 'Nonsense in BASIC is given if the required separator is not present. But note that when syntax is being checked the actual report does not appear on the screen - only the 'error marker'. This code is similar to that in ROM 1 at $1B6F.",
    "6177": "The 'Statement Return' Subroutine: After the correct interpretation of a statement, a return is made to this entry point. This code is similar to that in ROM 1 at $1B76.",
    "6200": "The 'Line Run' Entry Point: This entry point is used wherever a line in the editing area is to be 'run'. In such a case the syntax/run flag (bit 7 of FLAGS) will be set. The entry point is also used in the syntax checking of a line in the editing area that has more than one statement (bit 7 of FLAGS will be reset). This code is similar to that in ROM 1 at $1B8A.",
    "6220": "The 'Line New' Subroutine: There has been a jump in the program and the starting address of the new line has to be found. This code is similar to that in ROM 1 at 1B9E.",
    "6242": "REM Routine: The return address to STMT-RET is dropped which has the effect of forcing the rest of the line to be ignored. This code is similar to that in ROM 1 at $1BB2.",
    "6243": "The 'Line End' Routine: If checking syntax a simple return is made but when 'running' the address held by NXTLIN has to be checked before it can be used. This code is similar to that in ROM 1 at $1BB3.",
    "6256": "The 'Line Use' Routine: This routine has three functions: 1) Change statement zero to statement '1'. 2)Find the number of the new line and enter it into PPC. 3) Form the address of the start of the line after. This code is similar to that in ROM 1 at $1BBF.",
    "6274": "The 'Next Line' Routine: On entry the HL register pair points to the location after the end of the 'next' line to be handled and the DE register pair to the location before the first character of the line. This applies to lines in the program area and also to a line in the editing area - where the next line will be the same line again whilst there are still statements to be interpreted. This code is similar to that in ROM 1 at $1BD1.",
    "6312": "The 'STMT-NEXT' Routine: If the present character is a 'carriage return' then the 'next statement' is on the 'next line', if ':' it is on the same line; but if any other character is found then there is an error in syntax. The routine is the equivalent of routine STMT_NEXT in ROM 1 at $1BF4.",
    "6305": "The 'CHECK-END' Subroutine: This is called when the syntax of the edit-line is being checked. The purpose of the routine is to give an error report if the end of a statement has not been reached and to move on to the next statement if the syntax is correct. The routine is the equivalent of routine CHECK_END in ROM 1 at $1BEE.",
    "6340": "The 'Command Classes - 0C, 0D & 0E': For commands of class-0D a numeric expression must follow.",
    "6343": "The commands of class-0C must not have any operands. e.g. SPECTRUM.",
    "6344": "The commands of class-0E may be followed by a set of items. e.g. PLAY.",
    "6349": "After the command class entries and the separator entries in the parameter table have been considered the jump to the appropriate command routine is made. The routine is similar to JUMP-C-R in ROM 1 at $1C16.",
    "6358": "The 'Command Classes - 00, 03 & 05': These routines are the equivalent of the routines in ROM 1 starting at $1C0D. The commands of class-03 may, or may not, be followed by a number. e.g. RUN & RUN 200.",
    "6361": "The commands of class-00 must not have any operands. e.g. COPY & CONTINUE.",
    "6362": "The commands of class-05 may be followed by a set of items. e.g. PRINT & PRINT \"222\".",
    "6393": "The 'Command Class - 01': Command class 01 is concerned with the identification of the variable in a LET, READ or INPUT statement.",
    "6397": "The 'Command Class - 02': Command class 02 is concerned with the actual calculation of the value to be assigned in a LET statement.",
    "6405": "The 'Command Class - 04': The command class 04 entry point is used by FOR & NEXT statements.",
    "6409": "The 'Command Class - 08': Command class 08 allows for two numeric expressions, separated by a comma, to be evaluated.",
    "6414": "The 'Command Class - 06': Command class 06 allows for a single numeric expression to be evaluated.",
    "6418": "Report C - Nonsense in BASIC",
    "6422": "The 'Command Class - 0A': Command class 0A allows for a single string expression to be evaluated.",
    "6426": "The 'Command Class - 07': Command class 07 is the command routine for the six colour item commands. Makes the current temporary colours permanent.",
    "6461": "The following instructions cleverly copy the even bits of the supplied byte to the odd bits. In effect making the permanent bits the same as the temporary ones.",
    "6468": "The 'Command Class - 09': This routine is used by PLOT, DRAW & CIRCLE statements in order to specify the default conditions of 'FLASH 8; BRIGHT 8; PAPER 8;' that are set up before any embedded colour items are considered.",
    "6472": "The 'Command Class - 0B': This routine is used by SAVE, LOAD, VERIFY & MERGE statements.",
    "6503": "IF Routine: On entry the value of the expression between the IF and the THEN is the 'last value' on the calculator stack. If this is logically true then the next statement is considered; otherwise the line is considered to have been finished.",
    "6510": "Now 'delete' the last value on the calculator stack",
    "6529": "FOR Routine: This command routine is entered with the VALUE and the LIMIT of the FOR statement already on the top of the calculator stack.",
    "6542": "There has not been a STEP supplied so the value '1' is to be used.",
    "6566": "The three values on the calculator stack are the VALUE (v), the LIMIT (l) and the STEP (s). These values now have to be manipulated. Delegate handling to ROM 1.",
    "6570": "READ Routine",
    "6603": "Pick up a value from the DATA list.",
    "6635": "DATA Routine: During syntax checking a DATA statement is checked to ensure that it contains a series of valid expressions, separated by commas. But in 'run-time' the statement is passed by.",
    "6641": "A loop is now entered to deal with each expression in the DATA statement.",
    "6652": "The DATA statement has to be passed-by in 'run-time'.",
    "6654": "On entry the A register will hold either the token 'DATA' or the token 'DEF FN': depending on the type of statement that is being 'passed-by'.",
    "6658": "RUN Routine: The parameter of the RUN command is passed to NEWPPC by calling the GO TO command routine. The operations of 'RESTORE 0' and 'CLEAR 0' are then performed before a return is made.",
    "6669": "CLEAR Routine: This routine allows for the variables area to be cleared, the display area cleared and RAMTOP moved. In consequence of the last operation the machine stack is rebuilt thereby having the effect of also clearing the GO SUB stack.",
    "6695": "The value in the BC register pair which will be used as RAMTOP is tested to ensure it is neither too low nor too high.",
    "6739": "GO SUB Routine: The present value of PPC and the incremented value of SUBPPC are stored on the GO SUB stack.",
    "6767": "RETURN Routine: The line number and the statement number that are to be made the object of a 'return' are fetched from the GO SUB stack.",
    "6796": "DEF FN Routine: During syntax checking a DEF FN statement is checked to ensure that it has the correct form. Space is also made available for the result of evaluating the function. But in 'run-time' a DEF FN statement is passed-by.",
    "6807": "First consider the variable of the function.",
    "6835": "A loop is now entered to deal with each parameter in turn.",
    "6867": "Next the definition of the function is considered.",
    "6896": "MOVE Routine",
    "6897": "Run Tape Loader: Used by Main Menu - Tape Loader option.",
    "6932": "List Program to Printer: Used by Edit Menu - Print option.",
    "6955": "SPECTRUM Routine: Return to 48K BASIC Mode. This routine will force caps lock is off.",
    "6975": "[*BUG* - Although the channel 'P' information has been reconfigured to use the ZX Printer, the ZX printer buffer and associated system variables still need to be cleared. Failure to do so means that the first use of the ZX Printer will cause garbage to the printed, i.e. the paging routines and new system variables still present in the ZX Printer buffer. Subsequently printer output will then be ok since the ZX Printer buffer and system variables will be cleared. Worse still, there is the possibility that new data to be printed will be inserted beyond the ZX Printer buffer since ROM 1 does not trap whether the ZX Printer system variable PR_POSN and PR_CC hold invalid values. The bug can be fixed by inserting the following instructions, which cause the ZX Printer buffer to be cleared immediately after switching to ROM 1 and before the error report \"0 OK\" is produced. Credit: Paul Farrow and Andrew Owen.]",
    "6983": "Main Menu - 48 BASIC Option",
    "6995": "Set 'P' Channel Data: This routine overwrites the 'P' channel data with the 'S' channel data, i.e. the default values when using the ZX Printer.",
    "7022": "LOAD \"\" Command Bytes: Used by the Tape Loader routine.",
    "7025": "LLIST Routine",
    "7029": "LIST Routine",
    "7075": "Come here if the stream was unaltered.",
    "7085": "RAM Disk SAVE! Routine",
    "7141": "CAT! Routine",
    "7180": "ERASE! Routine",
    "7214": "Load Header from RAM Disk",
    "7224": "The file exists else the call above would have produced an error \"h file does not exist\"",
    "7243": "Load from RAM Disk: Used by LOAD, VERIFY and MERGE. Note that VERIFY will simply perform a LOAD. Entry: HL=Destination address. DE=Length (will be greater than zero). IX=File descriptor. IX=Address of catalogue entry (IX+$10-IX+$12 points to the address of the file's data, past its header). HD_00-HD_11 holds file header information.",
    "7268": "Page Logical RAM Bank: This routine converts between logical and physical RAM banks and pages the selected bank in. Entry: A=Logical RAM bank.",
    "7297": "Physical RAM Bank Mapping Table",
    "7303": "Compare Filenames: Compare filenames at N_STR1 and IX. Exit: Zero flag set if filenames match. Carry flag set if filename at DE is alphabetically lower than filename at IX.",
    "7306": "Compare filenames at DE and IX",
    "7319": "Create New Catalogue Entry: Add a catalogue entry with filename contained in N_STR1. Exit: HL=Address of next free catalogue entry. IX=Address of newly created catalogue entry.",
    "7411": "Adjust RAM Disk Free Space: Adjust the count of free bytes within the RAM disk. The routine can produce \"4 Out of memory\" when adding. Entry: AHL=Size adjustment (negative when a file added, positive when a file deleted). A=Bit 7 set for adding data, else deleting data.",
    "7425": "Deleting data",
    "7434": "Adding data",
    "7442": "Find Catalogue Entry for Filename: Entry: Filename stored at N_STR1 ($5B67). Exit : Zero flag set if file does not exist. If file exists, IX points to catalogue entry. Always leaves logical RAM bank 4 paged in.",
    "7477": "Find RAM Disk File: Find a file in the RAM disk matching name held in N_STR1, and return with IX pointing to the catalogue entry.",
    "7510": "Update Catalogue Entry: Entry: IX=Address of catalogue entry (IX+$10-IX+$12 points to end of the file). Exits with logical RAM bank 4 paged in.",
    "7572": "Copy the end address of the previous entry into the new entry",
    "7596": "Save Bytes to RAM Disk: Entry: IX=Address of catalogue entry. HL=Source address in conventional RAM. BC=Length. Advances IX+$10-IX+$12 as bytes are saved so that always points to next location to fill, eventually pointing to the end of the file.",
    "7610": "Source is below $C000",
    "7615": "Source spans across $C000",
    "7628": "Source fits completely below upper RAM bank (less than $C000)",
    "7637": "Source fits completely within upper RAM bank (greater than or equal $C000)",
    "7647": "Source spans transfer buffer",
    "7652": "Source fits completely within transfer buffer",
    "7657": "Transfer a block",
    "7716": "The end of a RAM bank has been reached so switch to the next bank",
    "7735": "Load Bytes from RAM Disk: Used for loading file header and data. Entry: IX=RAM disk catalogue entry address. IX+$10-IX+$12 points to the next address to fetch from the file. HL=Destination address. BC=Requested length.",
    "7749": "Destination is below $C000",
    "7754": "Code will span across $C000",
    "7772": "Code fits completely below upper RAM bank (less than $C000)",
    "7783": "Code destined for upper RAM bank (greater than or equal to $C000)",
    "7793": "Code will span transfer buffer",
    "7798": "Code will all fit within transfer buffer",
    "7808": "Transfer a block",
    "7825": "Enter a loop to transfer BC bytes, either to required destination or to the transfer buffer",
    "7868": "The end of a RAM bank has been reached so switch to the next bank",
    "7887": "Transfer Bytes to RAM Bank 4 - Vector Table Entry: This routine can be used to transfer bytes from the current RAM bank into logical RAM bank 4. It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0. Entry: HL=Source address in conventional RAM. DE=Destination address in logical RAM bank 4 (physical RAM bank 7). BC=Number of bytes to save.",
    "7912": "Entered here by load vector routine",
    "7940": "Transfer Bytes from RAM Bank 4 - Vector Table Entry: This routine can be used to transfer bytes from logical RAM bank 4 into the current RAM bank. It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0. Entry: HL=Source address in logical RAM bank 4 (physical RAM bank 7). DE=Destination address in current RAM bank. BC=Number of bytes to load.",
    "7968": "Use Normal RAM Configuration: Page in physical RAM bank 0, use normal stack and stack TARGET address. Entry: HL=TARGET address.",
    "7994": "Select RAM Bank: Used twice by the ROM to select either physical RAM bank 0 or physical RAM bank 7. However, it could in theory also be used to set other paging settings. Entry: A=RAM bank number.",
    "8005": "Use Workspace RAM Configuration: Page in physical RAM bank 7, use workspace stack and stack TARGET address. Entry: HL=TARGET address.",
    "8031": "Erase a RAM Disk File: N_STR1 contains the name of the file to erase.",
    "8170": "At this point we have the registers and alternate registers pointing to the actual bytes in the RAM disk for the file to be deleted and the next file, with length bytes of the catalogue entry for the file to be deleted containing the length of bytes for all subsequent files that need to be moved down in memory. A loop is entered to move all of these bytes where the delete file began. DHL holds the address of the byte to be moved. E contains the value which should be OUTed to $5B5C to page in the relevant RAM page.",
    "8254": "The file has been moved",
    "8402": "Print RAM Disk Catalogue: This routine prints catalogue filenames in alphabetically order. It does this by repeatedly looping through the catalogue to find the next 'highest' name.",
    "8481": "Print Catalogue Filename Data",
    "8501": "Print Single Catalogue Entry: Entry: HL=Address of filename. BC=Address of filename.",
    "8564": "LPRINT Routine",
    "8568": "PRINT Routine",
    "8588": "INPUT Routine: This routine allows for values entered from the keyboard to be assigned to variables. It is also possible to have print items embedded in the INPUT statement and these items are printed in the lower part of the display.",
    "8615": "COPY Routine",
    "8618": "NEW Routine",
    "8622": "CIRCLE Routine: This routine draws an approximation to the circle with centre co-ordinates X and Y and radius Z. These numbers are rounded to the nearest integer before use. Thus Z must be less than 87.5, even when (X,Y) is in the centre of the screen. The method used is to draw a series of arcs approximated by straight lines.",
    "8638": "DRAW Routine: This routine is entered with the co-ordinates of a point X0, Y0, say, in COORDS. If only two parameters X, Y are given with the DRAW command, it draws an approximation to a straight line from the point X0, Y0 to X0+X, Y0+Y. If a third parameter G is given, it draws an approximation to a circular arc from X0, Y0 to X0+X, Y0+Y turning anti-clockwise through an angle G radians.",
    "8661": "DIM Routine: This routine establishes new arrays in the variables area. The routine starts by searching the existing variables area to determine whether there is an existing array with the same name. If such an array is found then it is 'reclaimed' before the new array is established. A new array will have all its elements set to zero if it is a numeric array, or to 'spaces' if it is an array of strings.",
    "8679": "An 'existing array' is reclaimed.",
    "8683": "Error Report C - Nonsense in BASIC",
    "8687": "Clear Screen Routine: Clear screen if it is not already clear.",
    "8696": "Evaluate Numeric Expression: This routine is called when a numerical expression is typed directly into the editor or calculator. A numeric expression is any that begins with '(', '-' or '+', or is one of the function keywords, e.g. ABS, SIN, etc, or is the name of a numeric variable.",
    "8702": "Check the syntax of the BASIC line",
    "8723": "The BASIC line has passed syntax checking so now execute it",
    "8815": "Process Key Press: Entry: A=Key code.",
    "8846": "Find Start of BASIC Command: Point to the start of a typed in BASIC command and return first character in A.",
    "8855": "Is LET Command?: A typed in command resides in the editing workspace. This function tests whether the text is a single LET command. Exit: Zero flag set if a single LET command.",
    "8875": "Is Operator Character?: Exit: Zero flag set if character is an operator.",
    "8887": "Found",
    "8889": "Not found",
    "8893": "Operator Tokens Table",
    "8907": "Is Function Character?: Exit: Zero set if a function token.",
    "8928": "Is Numeric or Function Expression?: Exit: Zero flag set if a numeric or function expression.",
    "8970": "Is Numeric Character?: Exit: Zero flag set if numeric character.",
    "8983": "PLAY Routine",
    "9014": "UNUSED ROUTINES - PART 1: There now follows 513 bytes of routines that are not used by the ROM, from $2336 (ROM 0) to $2536 (ROM 0). They are remnants of the original Spanish 128's ROM code, although surprisingly they appear in a different order within that ROM.",
    "9527": "Editing Keys Action Table: Each editing key code maps to the appropriate handling routine. This includes those keys which mirror the functionality of the add-on keypad; these are found by trapping the keyword produced by the keystrokes in 48K mode. [Surprisingly there is no attempt to produce an intelligible layout; instead the first 16 keywords have been used. Additionally the entries for DELETE and ENTER should probably come in the first six entries for efficiency reasons.]",
    "9591": "Menu Keys Action Table: Each menu key code maps to the appropriate handling routine.",
    "9604": "Initialise Mode Settings: Called before Main menu displayed.",
    "9631": "Show Main Menu",
    "10052": "Main Menu: Jump table for the main 128K menu, referenced at $25AD (ROM 0).",
    "10068": "Text for the main 128K menu",
    "10128": "Edit Menu: Jump table for the Edit menu",
    "10144": "Text for the Edit menu",
    "9675": "Return to Editor / Calculator / Menu from Error",
    "9724": "Edit menu Print mode",
    "9729": "Calculator mode",
    "9732": "Return to the Editor: Either as the result of a re-listing, an error or from completing the Edit Menu Print option.",
    "9745": "Calculator mode",
    "9764": "No program exists",
    "9811": "Main Waiting Loop: Enter a loop to wait for a key press. Handles key presses for menus, the Calculator and the Editor.",
    "9833": "Process Key Press: Handle key presses for the menus and the Editor. Entry: A=Key code. Zero flag set if a menu is being displayed.",
    "9857": "No action defined for key code",
    "9860": "A menu is being displayed, so just ignore key press",
    "9865": "A menu is not being displayed",
    "9872": "The buffer is full so ignore the key press",
    "9883": "TOGGLE Key Handler Routine: Toggle between editing in the lower and upper screen areas. Also used by the editing menu SCREEN option.",
    "9915": "Select Lower Screen: Set the lower screen as the editing area.",
    "9934": "Select Upper Screen: Set the upper screen as the editing area.",
    "9959": "Produce Error Beep: This is the entry point to produce the error beep, e.g. when trying to cursor up or down past the BASIC program.",
    "9964": "This entry point is called to produce the key click tone. In 48K mode, the key click sound uses an HL value of $00C8 and so is 16 times shorter than in 128K mode.",
    "9988": "Menu Key Press Handler - MENU: This is executed when the EDIT key is pressed, either from within a menu or from the BASIC editor.",
    "10007": "Menu Key Press Handler - SELECT",
    "10030": "Menu Key Press Handler - CURSOR UP",
    "10050": "Comes here to complete handling of Menu cursor up and down. Also as the handler routines for Edit Menu return to 128 BASIC option and Calculator menu return to Calculator option, which simply make a return.",
    "10033": "Menu Key Press Handler - CURSOR DOWN",
    "10187": "Calculator Menu: Jump table for the Calculator menu",
    "10194": "Text for the Calculator menu",
    "10219": "Tape Loader Text",
    "10257": "Edit Menu - Screen Option",
    "10262": "Main Menu - Tape Tester Option",
    "10268": "Edit Menu / Calculator Menu - Exit Option",
    "10289": "Main Menu - Tape Loader Option",
    "10321": "Edit Menu - Renumber Option",
    "10338": "Edit Menu - Print Option",
    "10341": "Edit Menu - Renumber option joins here",
    "10356": "Edit Menu - Screen option joins here",
    "10373": "Main Menu - Calculator Option",
    "10417": "Edit Menu - Print option joins here",
    "10430": "Reset Cursor Position",
    "10439": "Return to Main Menu",
    "10449": "Main Screen Error Cursor Settings: Main screen editing cursor settings. Gets copied to $F6EE.",
    "10456": "Lower Screen Good Cursor Settings: Lower screen editing cursor settings. Gets copied to $F6EE.",
    "10463": "Initialise Lower Screen Editing Settings: Used when selecting lower screen. Copies 6 bytes from $28D9 (ROM 0) to $F6EE.",
    "10472": "Initialise Main Screen Editing Settings: Used when selecting main screen. Copies 6 bytes from $28D2 (ROM 0) to $F6EE.",
    "10481": "Handle Key Press Character Code: This routine handles a character typed at the keyboard, inserting it into the Screen Line Edit Buffer as appropriate. Entry: A=Key press character code.",
    "10523": "DELETE-RIGHT Key Handler Routine: Delete a character to the right. An error beep is not produced if there is nothing to delete. Exit: Carry flag set to indicate not to produce an error beep.",
    "10539": "DELETE Key Handler Routine: Delete a character to the left. An error beep is not produced if there is nothing to delete. Exit: Carry flag set to indicate not to produce an error beep.",
    "10564": "ENTER Key Handler Routine: This routine handles ENTER being pressed. If not on a BASIC line then it does nothing. If on an unaltered BASIC line then insert a blank row after it and move the cursor to it. If on an altered BASIC line then attempt to enter it into the BASIC program, otherwise return to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10580": "No editable characters on the row, i.e. a blank row",
    "10590": "On a BASIC line",
    "10597": "The current BASIC line has been altered",
    "10611": "Display the cursor on the first column of the next row",
    "10618": "Cursor is on a blank row, which is not part of a BASIC line",
    "10623": "A syntax error occurred so return signalling to produce an error beep",
    "10627": "TOP-OF-PROGRAM Key Handler Routine: Move to the first row of the first line of the BASIC program. An error beep is not produced if there is no program. Exit: Carry flag set to indicate not to produce an error beep.",
    "10667": "END-OF-PROGRAM Key Handler Routine: Move to the last row of the bottom line of the BASIC program. An error beep is not produced if there is no program. Exit: Carry flag set to indicate not to produce an error beep.",
    "10673": "Editor mode",
    "10708": "WORD-LEFT Key Handler Routine: This routine moves to the start of the current word that the cursor is on, or if it is on the first character of a word then it moves to the start of the previous word. If there is no word to move to then signal to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10721": "WORD-RIGHT Key Handler Routine: This routine moves to the start of the next word. If there is no word to move to then signal to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10732": "Remove Cursor: Remove editing cursor colour from current position. Exit: C=row number. B=Column number.",
    "10738": "Show Cursor: Set editing cursor colour at current position. Exit: C=row number. B=Column number.",
    "10744": "Display Cursor: Set editing cursor position and colour and then show it. Entry: C=Row number. B=Column number. A=Preferred column number.",
    "10759": "Fetch Cursor Position: Returns the three bytes of the cursor position. C=Row number. B=Column number A=Preferred column number.",
    "10769": "Store Cursor Position: Store new editing cursor position. C=Row number. B=Column number. A=Preferred column number.",
    "10778": "Get Current Character from Screen Line Edit Buffer: Entry: C=Row number. B=Column number. Exit : A=Character.",
    "10789": "TEN-ROWS-DOWN Key Handler Routine: Move down 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is not 10 rows below. Exit: Carry flag reset to indicate to produce an error beep.",
    "10818": "A blank row was found below, must be at the end of the BASIC program",
    "10831": "TEN-ROWS-UP Key Handler Routine: Move up 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is not 10 rows above. Exit: Carry flag reset to indicate to produce an error beep.",
    "10861": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10874": "END-OF-LINE Key Handler Routine: Move to the end of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line. Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.",
    "10887": "START-OF-LINE Key Handler Routine: Move to the start of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line. Exit: Carry flag reset to indicate to produce an error beep.",
    "10900": "CURSOR-UP Key Handler Routine: Move up 1 row, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is no row above. Exit: Carry flag reset to indicate to produce an error beep.",
    "10920": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10933": "CURSOR-DOWN Key Handler Routine: Move down 1 row, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is no row below. Exit: Carry flag reset to indicate to produce an error beep.",
    "10953": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10967": "CURSOR-LEFT Key Handler Routine: Move left 1 character, stopping if the start of the first row of the first BASIC line is reached. An error beep is produced if there is no character to the left or no previous BASIC line to move to. Exit: Carry flag reset to indicate to produce an error beep.",
    "10976": "A blank row was found above, must be at the start of the BASIC program",
    "10979": "CURSOR-RIGHT Key Handler Routine: Move right 1 character, stopping if the end of the last row of the last BASIC line is reached. An error beep is produced if there is no character to the right or no next BASIC line to move to. Exit: Carry flag reset to indicate to produce an error beep.",
    "10988": "A blank row was found below, must be at the end of the BASIC program",
    "11001": "Find Closest Screen Line Edit Buffer Editable Position to the Right else Left: This routine searches the specified Screen Line Edit Buffer row from the specified column to the right looking for the first editable position. If one cannot be found then a search is made to the left. Entry: B=Column number. Exit : Carry flag set if character at specified column is editable. B=Number of closest editable column. HL=Address of closest editable position.",
    "11010": "Find Closest Screen Line Edit Buffer Editable Position to the Left else Right: This routine searches the specified Screen Line Edit Buffer row from the specified column to the left looking for the first editable position. If one cannot be found then a search is made to the right. Entry: B=Column number. Exit : Carry flag set if character at specified column is editable. B=Number of closest editable column. HL=Address of closest editable position.",
    "11019": "Insert BASIC Line, Shift Edit Buffer Rows Down If Required and Update Display File If Required: Called from the cursor up and down related key handlers. For example, when cursor up key is pressed the current BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary to shift all rows down should the upper scroll threshold be reached. If the cursor was on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row. Entry: C=Current cursor row number in the Screen Line Edit Buffer. Exit : C=New cursor row number in the Screen Line Edit Buffer. Carry flag set if a new row was moved to.",
    "11044": "The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll down one row",
    "11050": "The edit buffer rows were not shifted down",
    "11056": "Insert BASIC Line, Shift Edit Buffer Rows Up If Required and Update Display File If Required: Called from the cursor up and down related key handlers. For example, when cursor down key is pressed the current BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary to shift all rows up should the lower scroll threshold be reached. If the cursor was on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row. Entry: C=Current cursor row number in the Screen Line Edit Buffer. Exit : C=New cursor row number in the Screen Line Edit Buffer. Carry flag set if a new row was moved to.",
    "11076": "The BASIC line was not inserted into the program. C=New cursor row number, B=New cursor column number, A=New cursor preferred column number",
    "11084": "The lower row threshold for triggering scrolling the screen has been reached so proceed to scroll up one row",
    "11092": "The edit buffer rows were not shifted up",
    "11099": "Find Next Screen Line Edit Buffer Editable Position to Left, Wrapping Above if Required: This routine searches to the left to see if an editable position exists. If there is no editable position available to the left on the current row then the previous row is examined from the last column position. Entry: B=Column number. Carry flag reset. Exit : Carry flag set if a position to the 'left' exists. B=Number of new editable position. HL=Address of new editable position.",
    "11110": "Wrap above to the previous row",
    "11117": "A row above exists",
    "11124": "Return column 0",
    "11128": "Find Next Screen Line Edit Buffer Editable Position to Right, Wrapping Below if Required: This routine searches to the right to see if an editable position exists. If there is no editable position available to the right on the current row then the next row is examined from the first column position. The routine is also called when a character key has been pressed and in this case if the cursor moves to the next row then a blank row is inserted and all affected rows are shifted down. Entry: B=Column number. C=Row number. Exit : Carry flag set if a position to the 'right' exists. B=Number of closest editable column, i.e. new column number. A=New column position, i.e. preferred column number or indentation column number. HL=Address of the new editable position.",
    "11135": "New position is within the row",
    "11141": "Need to wrap below to the next row",
    "11151": "A key is being pressed so need to insert a new row",
    "11163": "The BASIC line row does not span onto another row, i.e. cursor at end of line",
    "11200": "Wrap below to the next row. Either a key was not being pressed, or a key was being pressed and the BASIC line spans onto a row below (which could contain the cursor only)",
    "11209": "A row below exists",
    "11216": "Return column 0",
    "11220": "Find Screen Line Edit Buffer Editable Position from Previous Column to the Right: This routine finds the first editable character position in the specified Screen Line Edit Buffer row from the previous column to the right. It first checks the current column, then the previous column and then the columns to the right. The column containing the first non-null character encountered is returned. Entry: B=Column number to start searching from. C=Row number. Exit : Carry flag set if an editable character was found. B=Number of closest editable column.",
    "11231": "Find Screen Line Edit Buffer Editable Position to the Left: This routine finds the first editable character position in the Screen Line Edit Buffer row from the current column to the left. It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to the left and if an editable character is found then it returns the column to the right of it. Entry: B=Column number to start searching from. C=Row number. Exit : Carry flag set if an editable character was found. B=Number of the column after the editable position.",
    "11242": "Find Start of Word to Left in Screen Line Edit Buffer: This routine searches for the start of the current word to the left within the current Screen Line Edit Buffer. It is called from the WORD-LEFT key handler routine. Entry: C=Row number. Exit : Carry flag set if word to the left is found. B=Column position of the found word.",
    "11244": "Search towards the left of this row until a space or start of line is found",
    "11256": "Search towards the left of this row until the start of the word or start of the line is found",
    "11268": "A space prior to the word was found"
  },
  "Literals": {
    "23386": [
      "RETADDR"
    ],
    "23296": [
      "SWAP",
      "SWAP_RAM"
    ],
    "23388": [
      "BANK_M"
    ],
    "23384": [
      "TARGET"
    ],
    "23316": [
      "YOUNGER",
      "YOUNGER_RAM"
    ],
    "23435": [
      "SYNRET"
    ],
    "23432": [
      "ROW01"
    ],
    "23389": [
      "RAMRST"
    ],
    "23551": [
      "TSTACK"
    ],
    "23427": [
      "SFNEXT"
    ],
    "23429": [
      "SPSPACE",
      "SFSPACE"
    ],
    "23431": [
      "SFSPACE_P2"
    ],
    "23732": [
      "P_RAMT"
    ],
    "23675": [
      "UDG"
    ],
    "23608": [
      "RASP"
    ],
    "23730": [
      "RAMTOP"
    ],
    "23606": [
      "CHARS"
    ],
    "23393": [
      "SERFL"
    ],
    "23391": [
      "BAUD"
    ],
    "23395": [
      "COL"
    ],
    "23397": [
      "TVPARS"
    ],
    "23396": [
      "WIDTH"
    ],
    "23444": [
      "RNFIRST"
    ],
    "23446": [
      "RNSTEP"
    ],
    "23631": [
      "CHANS"
    ],
    "23639": [
      "DATADD"
    ],
    "23635": [
      "PROG"
    ],
    "23627": [
      "VARS"
    ],
    "23641": [
      "E_LINE"
    ],
    "23649": [
      "WORKSP"
    ],
    "23651": [
      "STKBOT"
    ],
    "23653": [
      "STKEND"
    ],
    "23693": [
      "ATTR_P"
    ],
    "23695": [
      "MASK_P"
    ],
    "23624": [
      "BORDCR"
    ],
    "23561": [
      "REPDEL"
    ],
    "23568": [
      "STRMS"
    ],
    "23425": [
      "OLDSP"
    ],
    "23398": [
      "FLAGS3"
    ],
    "23325": [
      "ONERR"
    ],
    "23613": [
      "ERR_SP"
    ],
    "23645": [
      "CH_ADD"
    ],
    "23612": [
      "TVFLAG"
    ],
    "23692": [
      "SCR_CT"
    ],
    "23610": [
      "ERR_NR"
    ],
    "23563": [
      "DEFADD"
    ],
    "5009": [
      "ERR_MSGS"
    ],
    "23621": [
      "PPC"
    ],
    "23664": [
      "OSPPC"
    ],
    "23620": [
      "NSPPC"
    ],
    "23625": [
      "E_PPC"
    ],
    "23390": [
      "RAMERR"
    ],
    "23647": [
      "X_PTR"
    ],
    "23370": [
      "POUT2"
    ],
    "23409": [
      "HD_00"
    ],
    "23611": [
      "FLAGS"
    ],
    "23566": [
      "TD_DATA"
    ],
    "23410": [
      "HD_0B"
    ],
    "23412": [
      "HD_0D"
    ],
    "23416": [
      "HD_11"
    ],
    "23414": [
      "HD_0F"
    ],
    "23399": [
      "N_STR1"
    ],
    "23418": [
      "SC_00"
    ],
    "23419": [
      "SC_0B"
    ],
    "23421": [
      "SC_0D"
    ],
    "23423": [
      "SC_0F"
    ],
    "23618": [
      "NEWPPC"
    ],
    "23668": [
      "T_ADDR"
    ],
    "23623": [
      "SUBPPC"
    ],
    "23637": [
      "NXTLIN"
    ],
    "23697": [
      "P_FLAG"
    ],
    "23448": [
      "STRIP1"
    ],
    "23437": [
      "LASTV"
    ],
    "23643": [
      "K_CUR"
    ],
    "23633": [
      "CURCHL"
    ],
    "23609": [
      "PIP"
    ],
    "23617": [
      "MODE"
    ]
  },
  "LiteralReplacements": {
    "45": "RETADDR",
    "61": "SWAP_RAM",
    "65": "MASK_INT",
    "57": "MASK_INT_RET",
    "81": "BANK_M",
    "92": "TARGET",
    "95": "YOUNGER_RAM",
    "100": "TARGET",
    "112": "BANK_M",
    "118": "BANK_M",
    "131": "RETADDR",
    "137": "BANK_M",
    "142": "BANK_M",
    "154": "RS232_INP",
    "159": "RS232_OUT",
    "166": "BANK_M",
    "173": "BANK_M",
    "187": "BANK_M",
    "195": "SYNRET",
    "234": "ROW01",
    "321": "SWAP_RAM",
    "324": "SWAP",
    "334": "RAMRST",
    "337": "TSTACK",
    "349": "SFNEXT",
    "370": "SFSPACE",
    "373": "SFSPACE_P2",
    "384": "P_RAMT",
    "399": "UDG",
    "406": "RASP",
    "410": "RAMTOP",
    "416": "CHARS",
    "419": "RAMTOP",
    "442": "SERFL",
    "438": "BAUD",
    "445": "COL",
    "448": "TVPARS",
    "459": "WIDTH",
    "465": "RNFIRST",
    "468": "RNSTEP",
    "474": "CHANS",
    "477": "CHAN_INFO",
    "488": "DATADD",
    "492": "PROG",
    "495": "VARS",
    "501": "E_LINE",
    "510": "WORKSP",
    "513": "STKBOT",
    "516": "STKEND",
    "521": "ATTR_P",
    "524": "MASK_P",
    "527": "BORDCR",
    "541": "REPDEL",
    "553": "STRMS",
    "579": "COPYR_MSG",
    "593": "TSTACK",
    "596": "OLDSP",
    "619": "FLAGS3",
    "632": "ONERR",
    "636": "ERR_SP",
    "640": "RET_SYN_CHECK",
    "643": "SYNRET",
    "705": "E_LINE",
    "708": "CH_ADD",
    "759": "TVFLAG",
    "769": "SCR_CT",
    "784": "ONERR",
    "788": "ERR_SP",
    "792": "ERR_HANDLER",
    "795": "SYNRET",
    "801": "RAMTOP",
    "806": "TSTACK",
    "809": "OLDSP",
    "817": "FLAGS3",
    "827": "SFNEXT",
    "842": "ERR_NR",
    "856": "DEFADD",
    "924": "ERR_MSGS",
    "937": "PPC",
    "958": "ERR_NR",
    "978": "OSPPC",
    "981": "NSPPC",
    "999": "FLAGS3",
    "1015": "E_PPC",
    "1026": "E_PPC",
    "1037": "CH_ADD",
    "1041": "BASIC_ERRH",
    "1045": "WORKSP",
    "1075": "E_PPC",
    "1081": "E_PPC",
    "1096": "PROG",
    "1105": "PROG",
    "1111": "WORKSP",
    "1118": "E_PPC",
    "1458": "BANK_M",
    "1464": "ERR_SP",
    "1469": "RAMERR",
    "1484": "CH_ADD",
    "1487": "X_PTR",
    "1512": "POUT2",
    "1521": "ERR_SP",
    "1536": "ERR_SP",
    "1542": "ERR_SP",
    "1547": "RS232_H_RET",
    "1567": "RETADDR",
    "1575": "RETADDR",
    "1582": "BANK_M",
    "1592": "INKEY_RET",
    "1633": "CH_ADD",
    "1657": "HD_00",
    "1676": "HD_00",
    "1688": "BAUD_TABLE",
    "1715": "BAUD",
    "1752": "SERFL",
    "1770": "BAUD",
    "1774": "BAUD",
    "1984": "SERFL",
    "1995": "TVPARS",
    "2002": "TVPARS",
    "2021": "RETADDR",
    "2029": "RETADDR",
    "2034": "FLAGS",
    "2056": "COL",
    "2060": "WIDTH",
    "2071": "COL",
    "2100": "COL",
    "2144": "TD_DATA",
    "2149": "TVPARS",
    "2153": "TD_DATA",
    "2158": "TVPARS",
    "2163": "TD_DATA",
    "2178": "WIDTH",
    "2197": "COL",
    "2232": "BAUD",
    "2288": "HD_0B",
    "2293": "PRINTER_CC_TABLE",
    "2302": "PRINTER_LF",
    "2308": "HD_0B",
    "2318": "PRINTER_RESET",
    "2325": "HD_00",
    "2333": "HD_00",
    "2345": "HD_00",
    "2836": "STONES_TABLE",
    "2934": "CMD_JUMP_TABLE",
    "3179": "RETADDR",
    "3182": "YOUNGER",
    "3269": "ENV_WAVE_TABLE",
    "3571": "PLAY_CMD_TABLE",
    "3656": "NOTE_LOOKUP_TBL",
    "4587": "FLAGS3",
    "4594": "FLAGS3",
    "4601": "FLAGS3",
    "4608": "FLAGS3",
    "4613": "FLAGS3",
    "4624": "FLAGS3",
    "4637": "HD_0D",
    "4643": "HD_00",
    "4652": "HD_0B",
    "4661": "HD_11",
    "4670": "HD_0F",
    "4683": "HD_0F",
    "4690": "N_STR1",
    "4698": "FLAGS3",
    "4706": "HD_00",
    "4709": "SC_00",
    "4720": "SC_00",
    "4724": "HD_00",
    "4740": "FLAGS3",
    "4752": "FLAGS3",
    "4763": "SC_0B",
    "4766": "HD_0B",
    "4782": "SC_0D",
    "4789": "HD_0D",
    "4792": "HD_00",
    "4798": "PROG",
    "4805": "HD_0B",
    "4827": "HD_0B",
    "4831": "SC_0D",
    "4845": "SC_0B",
    "4864": "HD_00",
    "4885": "E_LINE",
    "4889": "HD_0B",
    "4897": "SC_0F",
    "4917": "FLAGS3",
    "4922": "PROG",
    "4926": "E_LINE",
    "4933": "HD_0B",
    "4937": "PROG",
    "4944": "HD_0F",
    "4949": "VARS",
    "4960": "HD_11",
    "4964": "NEWPPC",
    "4971": "FLAGS3",
    "4976": "PROG",
    "4979": "HD_0B",
    "4984": "DATADD",
    "5030": "N_STR1",
    "5043": "N_STR1",
    "5066": "T_ADDR",
    "5103": "T_ADDR",
    "5132": "T_ADDR",
    "5157": "T_ADDR",
    "5219": "T_ADDR",
    "5254": "T_ADDR",
    "5268": "T_ADDR",
    "5288": "T_ADDR",
    "5346": "T_ADDR",
    "5373": "E_LINE",
    "5376": "PROG",
    "5389": "VARS",
    "5401": "FLAGS3",
    "5409": "T_ADDR",
    "5430": "E_PPC",
    "5512": "E_PPC",
    "5605": "E_PPC",
    "5626": "E_PPC",
    "6071": "SUBPPC",
    "6075": "ERR_NR",
    "6102": "STMT_RET",
    "6115": "SPECTRUM_PARS",
    "6122": "PLAY_PARS",
    "6133": "SYN_OFFS_TABLE",
    "6141": "T_ADDR",
    "6146": "T_ADDR",
    "6149": "STMT_LOOP_RET",
    "6158": "CMD_CLASS_TABLE",
    "6193": "NEWPPC",
    "6203": "PPC",
    "6206": "WORKSP",
    "6210": "E_LINE",
    "6215": "NSPPC",
    "6223": "NSPPC",
    "6248": "NXTLIN",
    "6263": "PPC",
    "6274": "NXTLIN",
    "6278": "CH_ADD",
    "6349": "T_ADDR",
    "6367": "T_ADDR",
    "6375": "CLASS_035_RET",
    "6378": "RETADDR",
    "6381": "YOUNGER",
    "6440": "T_ADDR",
    "6451": "MASK_P",
    "6454": "ATTR_P",
    "6457": "P_FLAG",
    "6473": "FLAGS3",
    "6478": "FLAGS3",
    "6481": "T_ADDR",
    "6486": "T_ADDR",
    "6510": "STKEND",
    "6517": "STKEND",
    "6545": "STKEND",
    "6563": "STKEND",
    "6581": "X_PTR",
    "6584": "DATADD",
    "6604": "CH_ADD",
    "6612": "DATADD",
    "6615": "X_PTR",
    "6622": "CH_ADD",
    "6676": "RAMTOP",
    "6681": "VARS",
    "6685": "E_LINE",
    "6695": "STKEND",
    "6707": "P_RAMT",
    "6719": "RAMTOP",
    "6726": "RAMTOP",
    "6733": "ERR_SP",
    "6746": "PPC",
    "6752": "ERR_SP",
    "6778": "ERR_SP",
    "6783": "NEWPPC",
    "6877": "FLAGS",
    "6920": "E_LINE",
    "6938": "E_LINE",
    "6947": "E_LINE",
    "6958": "ERR_SP",
    "6977": "BANK_M",
    "6989": "BANK_M",
    "6995": "CHANS",
    "7085": "OLDSP",
    "7095": "HD_0B",
    "7112": "HD_00",
    "7118": "HD_0D",
    "7121": "HD_0B",
    "7136": "OLDSP",
    "7160": "OLDSP",
    "7175": "OLDSP",
    "7194": "OLDSP",
    "7209": "OLDSP",
    "7214": "OLDSP",
    "7238": "OLDSP",
    "7224": "HD_00",
    "7243": "OLDSP",
    "7263": "OLDSP",
    "7270": "RAMBANK_MAPPINGS",
    "7279": "BANK_M",
    "7285": "BANK_M",
    "7303": "N_STR1",
    "7347": "FLAGS3",
    "7355": "N_STR1",
    "7407": "SFNEXT",
    "7411": "SFSPACE",
    "7416": "SFSPACE_P2",
    "7427": "SFSPACE",
    "7430": "SFSPACE_P2",
    "7451": "SFNEXT",
    "7524": "FLAGS3",
    "7658": "STRIP1",
    "7665": "STRIP1",
    "7805": "STRIP1",
    "7854": "STRIP1",
    "7888": "BANK_M",
    "7931": "BANK_M",
    "7941": "BANK_M",
    "7976": "TARGET",
    "7979": "OLDSP",
    "7982": "OLDSP",
    "7988": "TARGET",
    "8000": "BANK_M",
    "8008": "TARGET",
    "8011": "OLDSP",
    "8014": "OLDSP",
    "8019": "TARGET",
    "8054": "SFNEXT",
    "8136": "BANK_M",
    "8162": "BANK_M",
    "8220": "BANK_M",
    "8244": "BANK_M",
    "8358": "SFNEXT",
    "8368": "SFNEXT",
    "8391": "SFNEXT",
    "8398": "SFNEXT",
    "8407": "LOWEST_NAME",
    "8410": "HIGHEST_NAME",
    "8423": "SFNEXT",
    "8466": "HIGHEST_NAME",
    "8504": "N_STR1",
    "8517": "OLDSP",
    "8520": "OLDSP",
    "8525": "N_STR1",
    "8549": "OLDSP",
    "8552": "OLDSP",
    "8699": "PPC",
    "8730": "ERR_HANDLER",
    "8733": "SYNRET",
    "8745": "LASTV",
    "8748": "STKEND",
    "8777": "K_CUR",
    "8781": "CURCHL",
    "8798": "K_CUR",
    "8846": "E_LINE",
    "8850": "CH_ADD",
    "8861": "CH_ADD",
    "8876": "OP_TOKENS_TABLE",
    "9621": "E_PPC",
    "9631": "TSTACK",
    "9634": "OLDSP",
    "9645": "MENU_JUMP_TABLE",
    "9651": "MENU_TEXT_TABLE",
    "9679": "TSTACK",
    "9682": "OLDSP",
    "9696": "FLAGS",
    "9745": "E_PPC",
    "9752": "PROG",
    "9755": "VARS",
    "9785": "E_PPC",
    "9811": "TSTACK",
    "9821": "PIP",
    "9839": "MENU_KEYS_TABLE",
    "9844": "ED_KEYS_TABLE",
    "9861": "MODE",
    "9959": "RASP",
    "10292": "TVFLAG",
    "10297": "TAPE_LDR_TEXT",
    "10330": "E_PPC",
    "10348": "TVFLAG",
    "10365": "EDIT_MENU_TABLE",
    "10368": "EDIT_TEXT_TABLE",
    "10396": "E_PPC",
    "10411": "CALC_MENU_TABLE",
    "10414": "CALC_MENU_TEXT",
    "10463": "MS_LW_CURS_SET",
    "10472": "MS_ERR_CURS_SET",
    "10651": "E_PPC",
    "10692": "E_PPC"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 11,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 12,
      "EndAddress": 15,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 16,
      "EndAddress": 19,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 20,
      "EndAddress": 23,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 24,
      "EndAddress": 27,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 28,
      "EndAddress": 31,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 32,
      "EndAddress": 35,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 36,
      "EndAddress": 39,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 40,
      "EndAddress": 54,
      "SectionType": 1,
      "Lenght": 15
    },
    {
      "StartAddress": 55,
      "EndAddress": 55,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 56,
      "EndAddress": 1131,
      "SectionType": 1,
      "Lenght": 1076
    },
    {
      "StartAddress": 1132,
      "EndAddress": 1133,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1134,
      "EndAddress": 1135,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1136,
      "EndAddress": 1137,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1138,
      "EndAddress": 1139,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1140,
      "EndAddress": 1141,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1142,
      "EndAddress": 1143,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1144,
      "EndAddress": 1145,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1146,
      "EndAddress": 1147,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1148,
      "EndAddress": 1149,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1150,
      "EndAddress": 1151,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1152,
      "EndAddress": 1153,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1154,
      "EndAddress": 1155,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1156,
      "EndAddress": 1157,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1158,
      "EndAddress": 1159,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1160,
      "EndAddress": 1161,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1162,
      "EndAddress": 1163,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1164,
      "EndAddress": 1174,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 1175,
      "EndAddress": 1189,
      "SectionType": 2,
      "Lenght": 15
    },
    {
      "StartAddress": 1190,
      "EndAddress": 1199,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1200,
      "EndAddress": 1216,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1217,
      "EndAddress": 1235,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1236,
      "EndAddress": 1247,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1248,
      "EndAddress": 1266,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1267,
      "EndAddress": 1280,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1281,
      "EndAddress": 1297,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1298,
      "EndAddress": 1314,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1315,
      "EndAddress": 1328,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1329,
      "EndAddress": 1345,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1346,
      "EndAddress": 1357,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1358,
      "EndAddress": 1376,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1377,
      "EndAddress": 1404,
      "SectionType": 2,
      "Lenght": 28
    },
    {
      "StartAddress": 1405,
      "EndAddress": 1416,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 1417,
      "EndAddress": 1418,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1419,
      "EndAddress": 1420,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1421,
      "EndAddress": 1421,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1422,
      "EndAddress": 1423,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1424,
      "EndAddress": 1425,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1426,
      "EndAddress": 1426,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1427,
      "EndAddress": 1428,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1429,
      "EndAddress": 1430,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1431,
      "EndAddress": 1431,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1432,
      "EndAddress": 1433,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1434,
      "EndAddress": 1435,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1436,
      "EndAddress": 1436,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1437,
      "EndAddress": 1437,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1438,
      "EndAddress": 1439,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1440,
      "EndAddress": 1441,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1442,
      "EndAddress": 1443,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1444,
      "EndAddress": 1445,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1446,
      "EndAddress": 1447,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1448,
      "EndAddress": 1449,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1450,
      "EndAddress": 1451,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1452,
      "EndAddress": 1719,
      "SectionType": 1,
      "Lenght": 268
    },
    {
      "StartAddress": 1720,
      "EndAddress": 1723,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1724,
      "EndAddress": 1727,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1728,
      "EndAddress": 1731,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1732,
      "EndAddress": 1735,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1736,
      "EndAddress": 1739,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1740,
      "EndAddress": 1743,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1744,
      "EndAddress": 1747,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1748,
      "EndAddress": 1751,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1752,
      "EndAddress": 2424,
      "SectionType": 1,
      "Lenght": 673
    },
    {
      "StartAddress": 2425,
      "EndAddress": 2425,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2426,
      "EndAddress": 2427,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2428,
      "EndAddress": 2431,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 2432,
      "EndAddress": 2432,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2433,
      "EndAddress": 2433,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2434,
      "EndAddress": 2434,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2435,
      "EndAddress": 2436,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2437,
      "EndAddress": 2609,
      "SectionType": 1,
      "Lenght": 173
    },
    {
      "StartAddress": 2610,
      "EndAddress": 2620,
      "SectionType": 4,
      "Lenght": 11
    },
    {
      "StartAddress": 2621,
      "EndAddress": 2742,
      "SectionType": 1,
      "Lenght": 122
    },
    {
      "StartAddress": 2743,
      "EndAddress": 2756,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 2757,
      "EndAddress": 3529,
      "SectionType": 1,
      "Lenght": 773
    },
    {
      "StartAddress": 3530,
      "EndAddress": 3531,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3532,
      "EndAddress": 3533,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3534,
      "EndAddress": 3535,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3536,
      "EndAddress": 3537,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3538,
      "EndAddress": 3539,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3540,
      "EndAddress": 3541,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3542,
      "EndAddress": 3543,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3544,
      "EndAddress": 3545,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3546,
      "EndAddress": 3547,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3548,
      "EndAddress": 3549,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3550,
      "EndAddress": 3551,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3552,
      "EndAddress": 3553,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3554,
      "EndAddress": 3555,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3556,
      "EndAddress": 3557,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3558,
      "EndAddress": 3559,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3560,
      "EndAddress": 3560,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3561,
      "EndAddress": 3561,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3562,
      "EndAddress": 3562,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3563,
      "EndAddress": 3563,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3564,
      "EndAddress": 3564,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3565,
      "EndAddress": 3565,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3566,
      "EndAddress": 3566,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3567,
      "EndAddress": 3567,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3568,
      "EndAddress": 3576,
      "SectionType": 1,
      "Lenght": 9
    },
    {
      "StartAddress": 3577,
      "EndAddress": 3583,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 3584,
      "EndAddress": 3595,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 3596,
      "EndAddress": 3596,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3597,
      "EndAddress": 3597,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3598,
      "EndAddress": 3598,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3599,
      "EndAddress": 3599,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3600,
      "EndAddress": 3600,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3601,
      "EndAddress": 3601,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3602,
      "EndAddress": 3602,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3603,
      "EndAddress": 3603,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3604,
      "EndAddress": 3604,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3605,
      "EndAddress": 3605,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3606,
      "EndAddress": 3606,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3607,
      "EndAddress": 3607,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3608,
      "EndAddress": 3608,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3609,
      "EndAddress": 3864,
      "SectionType": 1,
      "Lenght": 256
    },
    {
      "StartAddress": 3865,
      "EndAddress": 3865,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3866,
      "EndAddress": 3872,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3873,
      "EndAddress": 3873,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3874,
      "EndAddress": 3880,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3881,
      "EndAddress": 3881,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3882,
      "EndAddress": 3888,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3889,
      "EndAddress": 3889,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3890,
      "EndAddress": 3896,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3897,
      "EndAddress": 3897,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3898,
      "EndAddress": 3904,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3905,
      "EndAddress": 3905,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3906,
      "EndAddress": 4245,
      "SectionType": 1,
      "Lenght": 340
    },
    {
      "StartAddress": 4246,
      "EndAddress": 4247,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4248,
      "EndAddress": 4249,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4250,
      "EndAddress": 4251,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4252,
      "EndAddress": 4253,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4254,
      "EndAddress": 4255,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4256,
      "EndAddress": 4257,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4258,
      "EndAddress": 4259,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4260,
      "EndAddress": 4261,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4262,
      "EndAddress": 4263,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4264,
      "EndAddress": 4265,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4266,
      "EndAddress": 4267,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4268,
      "EndAddress": 4269,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4270,
      "EndAddress": 4271,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4272,
      "EndAddress": 4273,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4274,
      "EndAddress": 4275,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4276,
      "EndAddress": 4277,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4278,
      "EndAddress": 4279,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4280,
      "EndAddress": 4281,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4282,
      "EndAddress": 4283,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4284,
      "EndAddress": 4285,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4286,
      "EndAddress": 4287,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4288,
      "EndAddress": 4289,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4290,
      "EndAddress": 4291,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4292,
      "EndAddress": 4293,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4294,
      "EndAddress": 4295,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4296,
      "EndAddress": 4297,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4298,
      "EndAddress": 4299,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4300,
      "EndAddress": 4301,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4302,
      "EndAddress": 4303,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4304,
      "EndAddress": 4305,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4306,
      "EndAddress": 4307,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4308,
      "EndAddress": 4309,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4310,
      "EndAddress": 4311,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4312,
      "EndAddress": 4313,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4314,
      "EndAddress": 4315,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4316,
      "EndAddress": 4317,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4318,
      "EndAddress": 4319,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4320,
      "EndAddress": 4321,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4322,
      "EndAddress": 4323,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4324,
      "EndAddress": 4325,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4326,
      "EndAddress": 4327,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4328,
      "EndAddress": 4329,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4330,
      "EndAddress": 4331,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4332,
      "EndAddress": 4333,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4334,
      "EndAddress": 4335,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4336,
      "EndAddress": 4337,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4338,
      "EndAddress": 4339,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4340,
      "EndAddress": 4341,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4342,
      "EndAddress": 4343,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4344,
      "EndAddress": 4345,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4346,
      "EndAddress": 4347,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4348,
      "EndAddress": 4349,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4350,
      "EndAddress": 4351,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4352,
      "EndAddress": 4353,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4354,
      "EndAddress": 4355,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4356,
      "EndAddress": 4357,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4358,
      "EndAddress": 4359,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4360,
      "EndAddress": 4361,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4362,
      "EndAddress": 4363,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4364,
      "EndAddress": 4365,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4366,
      "EndAddress": 4367,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4368,
      "EndAddress": 4369,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4370,
      "EndAddress": 4371,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4372,
      "EndAddress": 4373,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4374,
      "EndAddress": 4375,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4376,
      "EndAddress": 4377,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4378,
      "EndAddress": 4379,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4380,
      "EndAddress": 4381,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4382,
      "EndAddress": 4383,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4384,
      "EndAddress": 4385,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4386,
      "EndAddress": 4387,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4388,
      "EndAddress": 4389,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4390,
      "EndAddress": 4391,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4392,
      "EndAddress": 4393,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4394,
      "EndAddress": 4395,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4396,
      "EndAddress": 4397,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4398,
      "EndAddress": 4399,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4400,
      "EndAddress": 4401,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4402,
      "EndAddress": 4403,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4404,
      "EndAddress": 4405,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4406,
      "EndAddress": 4407,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4408,
      "EndAddress": 4409,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4410,
      "EndAddress": 4411,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4412,
      "EndAddress": 4413,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4414,
      "EndAddress": 4415,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4416,
      "EndAddress": 4417,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4418,
      "EndAddress": 4419,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4420,
      "EndAddress": 4421,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4422,
      "EndAddress": 4423,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4424,
      "EndAddress": 4425,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4426,
      "EndAddress": 4427,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4428,
      "EndAddress": 4429,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4430,
      "EndAddress": 4431,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4432,
      "EndAddress": 4433,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4434,
      "EndAddress": 4435,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4436,
      "EndAddress": 4437,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4438,
      "EndAddress": 4439,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4440,
      "EndAddress": 4441,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4442,
      "EndAddress": 4443,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4444,
      "EndAddress": 4445,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4446,
      "EndAddress": 4447,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4448,
      "EndAddress": 4449,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4450,
      "EndAddress": 4451,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4452,
      "EndAddress": 4453,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4454,
      "EndAddress": 4455,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4456,
      "EndAddress": 4457,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4458,
      "EndAddress": 4459,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4460,
      "EndAddress": 4461,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4462,
      "EndAddress": 4635,
      "SectionType": 1,
      "Lenght": 174
    },
    {
      "StartAddress": 4636,
      "EndAddress": 4636,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4637,
      "EndAddress": 4738,
      "SectionType": 1,
      "Lenght": 102
    },
    {
      "StartAddress": 4739,
      "EndAddress": 4739,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4740,
      "EndAddress": 4761,
      "SectionType": 1,
      "Lenght": 22
    },
    {
      "StartAddress": 4762,
      "EndAddress": 4762,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4763,
      "EndAddress": 4780,
      "SectionType": 1,
      "Lenght": 18
    },
    {
      "StartAddress": 4781,
      "EndAddress": 4781,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4782,
      "EndAddress": 5052,
      "SectionType": 1,
      "Lenght": 271
    },
    {
      "StartAddress": 5053,
      "EndAddress": 5053,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5054,
      "EndAddress": 5111,
      "SectionType": 1,
      "Lenght": 58
    },
    {
      "StartAddress": 5112,
      "EndAddress": 5112,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5113,
      "EndAddress": 5165,
      "SectionType": 1,
      "Lenght": 53
    },
    {
      "StartAddress": 5166,
      "EndAddress": 5166,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5167,
      "EndAddress": 5851,
      "SectionType": 1,
      "Lenght": 685
    },
    {
      "StartAddress": 5852,
      "EndAddress": 5852,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5853,
      "EndAddress": 5853,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5854,
      "EndAddress": 5854,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5855,
      "EndAddress": 5855,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5856,
      "EndAddress": 5856,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5857,
      "EndAddress": 5857,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5858,
      "EndAddress": 5858,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5859,
      "EndAddress": 5859,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5860,
      "EndAddress": 5860,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5861,
      "EndAddress": 5861,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5862,
      "EndAddress": 5862,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5863,
      "EndAddress": 5863,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5864,
      "EndAddress": 5864,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5865,
      "EndAddress": 5865,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5866,
      "EndAddress": 5866,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5867,
      "EndAddress": 5867,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5868,
      "EndAddress": 5868,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5869,
      "EndAddress": 5869,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5870,
      "EndAddress": 5870,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5871,
      "EndAddress": 5871,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5872,
      "EndAddress": 5872,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5873,
      "EndAddress": 5873,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5874,
      "EndAddress": 5874,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5875,
      "EndAddress": 5875,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5876,
      "EndAddress": 5876,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5877,
      "EndAddress": 5877,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5878,
      "EndAddress": 5878,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5879,
      "EndAddress": 5879,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5880,
      "EndAddress": 5880,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5881,
      "EndAddress": 5881,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5882,
      "EndAddress": 5882,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5883,
      "EndAddress": 5883,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5884,
      "EndAddress": 5884,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5885,
      "EndAddress": 5885,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5886,
      "EndAddress": 5886,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5887,
      "EndAddress": 5887,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5888,
      "EndAddress": 5888,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5889,
      "EndAddress": 5889,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5890,
      "EndAddress": 5890,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5891,
      "EndAddress": 5891,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5892,
      "EndAddress": 5892,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5893,
      "EndAddress": 5893,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5894,
      "EndAddress": 5894,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5895,
      "EndAddress": 5895,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5896,
      "EndAddress": 5896,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5897,
      "EndAddress": 5897,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5898,
      "EndAddress": 5898,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5899,
      "EndAddress": 5899,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5900,
      "EndAddress": 5900,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5901,
      "EndAddress": 5901,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5902,
      "EndAddress": 5904,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 5905,
      "EndAddress": 5906,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5907,
      "EndAddress": 5908,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5909,
      "EndAddress": 5911,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 5912,
      "EndAddress": 5913,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5914,
      "EndAddress": 5915,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5916,
      "EndAddress": 5917,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5918,
      "EndAddress": 5918,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5919,
      "EndAddress": 5920,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5921,
      "EndAddress": 5921,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5922,
      "EndAddress": 5923,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5924,
      "EndAddress": 5929,
      "SectionType": 2,
      "Lenght": 6
    },
    {
      "StartAddress": 5930,
      "EndAddress": 5931,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5932,
      "EndAddress": 5933,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5934,
      "EndAddress": 5935,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5936,
      "EndAddress": 5936,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5937,
      "EndAddress": 5938,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5939,
      "EndAddress": 5939,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5940,
      "EndAddress": 5941,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5942,
      "EndAddress": 5942,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5943,
      "EndAddress": 5944,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5945,
      "EndAddress": 5945,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5946,
      "EndAddress": 5947,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5948,
      "EndAddress": 5948,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5949,
      "EndAddress": 5950,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5951,
      "EndAddress": 5951,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5952,
      "EndAddress": 5953,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5954,
      "EndAddress": 5954,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5955,
      "EndAddress": 5956,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5957,
      "EndAddress": 5958,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5959,
      "EndAddress": 5960,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5961,
      "EndAddress": 5961,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5962,
      "EndAddress": 5963,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5964,
      "EndAddress": 5964,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5965,
      "EndAddress": 5966,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5967,
      "EndAddress": 5967,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5968,
      "EndAddress": 5969,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5970,
      "EndAddress": 5970,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5971,
      "EndAddress": 5972,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5973,
      "EndAddress": 5974,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5975,
      "EndAddress": 5976,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5977,
      "EndAddress": 5978,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5979,
      "EndAddress": 5980,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5981,
      "EndAddress": 5981,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5982,
      "EndAddress": 5983,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5984,
      "EndAddress": 5984,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5985,
      "EndAddress": 5986,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5987,
      "EndAddress": 5987,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5988,
      "EndAddress": 5989,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5990,
      "EndAddress": 5991,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5992,
      "EndAddress": 5993,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5994,
      "EndAddress": 5994,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5995,
      "EndAddress": 5996,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5997,
      "EndAddress": 5997,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5998,
      "EndAddress": 5999,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6000,
      "EndAddress": 6000,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6001,
      "EndAddress": 6002,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6003,
      "EndAddress": 6003,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6004,
      "EndAddress": 6004,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6005,
      "EndAddress": 6005,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6006,
      "EndAddress": 6006,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6007,
      "EndAddress": 6008,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6009,
      "EndAddress": 6010,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6011,
      "EndAddress": 6012,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6013,
      "EndAddress": 6014,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6015,
      "EndAddress": 6015,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6016,
      "EndAddress": 6016,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6017,
      "EndAddress": 6017,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6018,
      "EndAddress": 6018,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6019,
      "EndAddress": 6019,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6020,
      "EndAddress": 6020,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6021,
      "EndAddress": 6022,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6023,
      "EndAddress": 6024,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6025,
      "EndAddress": 6026,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6027,
      "EndAddress": 6028,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6029,
      "EndAddress": 6029,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6030,
      "EndAddress": 6031,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6032,
      "EndAddress": 6035,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6036,
      "EndAddress": 6037,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6038,
      "EndAddress": 6039,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6040,
      "EndAddress": 6041,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6042,
      "EndAddress": 6042,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6043,
      "EndAddress": 6044,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6045,
      "EndAddress": 6048,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6049,
      "EndAddress": 6050,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6051,
      "EndAddress": 6051,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6052,
      "EndAddress": 6053,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6054,
      "EndAddress": 6054,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6055,
      "EndAddress": 6056,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6057,
      "EndAddress": 6057,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6058,
      "EndAddress": 6059,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6060,
      "EndAddress": 6060,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6061,
      "EndAddress": 6062,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6063,
      "EndAddress": 6184,
      "SectionType": 1,
      "Lenght": 122
    },
    {
      "StartAddress": 6185,
      "EndAddress": 6185,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6186,
      "EndAddress": 6240,
      "SectionType": 1,
      "Lenght": 55
    },
    {
      "StartAddress": 6241,
      "EndAddress": 6241,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6242,
      "EndAddress": 6303,
      "SectionType": 1,
      "Lenght": 62
    },
    {
      "StartAddress": 6304,
      "EndAddress": 6304,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6305,
      "EndAddress": 6324,
      "SectionType": 1,
      "Lenght": 20
    },
    {
      "StartAddress": 6325,
      "EndAddress": 6325,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6326,
      "EndAddress": 6326,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6327,
      "EndAddress": 6327,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6328,
      "EndAddress": 6328,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6329,
      "EndAddress": 6329,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6330,
      "EndAddress": 6330,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6331,
      "EndAddress": 6331,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6332,
      "EndAddress": 6332,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6333,
      "EndAddress": 6333,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6334,
      "EndAddress": 6334,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6335,
      "EndAddress": 6335,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6336,
      "EndAddress": 6336,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6337,
      "EndAddress": 6337,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6338,
      "EndAddress": 6338,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6339,
      "EndAddress": 6339,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6340,
      "EndAddress": 6420,
      "SectionType": 1,
      "Lenght": 81
    },
    {
      "StartAddress": 6421,
      "EndAddress": 6421,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6422,
      "EndAddress": 6601,
      "SectionType": 1,
      "Lenght": 180
    },
    {
      "StartAddress": 6602,
      "EndAddress": 6602,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6603,
      "EndAddress": 6717,
      "SectionType": 1,
      "Lenght": 115
    },
    {
      "StartAddress": 6718,
      "EndAddress": 6718,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6719,
      "EndAddress": 6794,
      "SectionType": 1,
      "Lenght": 76
    },
    {
      "StartAddress": 6795,
      "EndAddress": 6795,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6796,
      "EndAddress": 7021,
      "SectionType": 1,
      "Lenght": 226
    },
    {
      "StartAddress": 7022,
      "EndAddress": 7024,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 7025,
      "EndAddress": 7296,
      "SectionType": 1,
      "Lenght": 272
    },
    {
      "StartAddress": 7297,
      "EndAddress": 7302,
      "SectionType": 2,
      "Lenght": 6
    },
    {
      "StartAddress": 7303,
      "EndAddress": 7326,
      "SectionType": 1,
      "Lenght": 24
    },
    {
      "StartAddress": 7327,
      "EndAddress": 7327,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7328,
      "EndAddress": 7440,
      "SectionType": 1,
      "Lenght": 113
    },
    {
      "StartAddress": 7441,
      "EndAddress": 7441,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7442,
      "EndAddress": 7484,
      "SectionType": 1,
      "Lenght": 43
    },
    {
      "StartAddress": 7485,
      "EndAddress": 7485,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7486,
      "EndAddress": 8038,
      "SectionType": 1,
      "Lenght": 553
    },
    {
      "StartAddress": 8039,
      "EndAddress": 8039,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8040,
      "EndAddress": 8480,
      "SectionType": 1,
      "Lenght": 441
    },
    {
      "StartAddress": 8481,
      "EndAddress": 8490,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 8491,
      "EndAddress": 8500,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 8501,
      "EndAddress": 8685,
      "SectionType": 1,
      "Lenght": 185
    },
    {
      "StartAddress": 8686,
      "EndAddress": 8686,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8687,
      "EndAddress": 8764,
      "SectionType": 1,
      "Lenght": 78
    },
    {
      "StartAddress": 8765,
      "EndAddress": 8765,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8766,
      "EndAddress": 8892,
      "SectionType": 1,
      "Lenght": 127
    },
    {
      "StartAddress": 8893,
      "EndAddress": 8906,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 8907,
      "EndAddress": 9006,
      "SectionType": 1,
      "Lenght": 100
    },
    {
      "StartAddress": 9007,
      "EndAddress": 9007,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9008,
      "EndAddress": 9526,
      "SectionType": 1,
      "Lenght": 519
    },
    {
      "StartAddress": 9527,
      "EndAddress": 9527,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9528,
      "EndAddress": 9528,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9529,
      "EndAddress": 9530,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9531,
      "EndAddress": 9531,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9532,
      "EndAddress": 9533,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9534,
      "EndAddress": 9534,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9535,
      "EndAddress": 9536,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9537,
      "EndAddress": 9537,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9538,
      "EndAddress": 9539,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9540,
      "EndAddress": 9540,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9541,
      "EndAddress": 9542,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9543,
      "EndAddress": 9543,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9544,
      "EndAddress": 9545,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9546,
      "EndAddress": 9546,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9547,
      "EndAddress": 9548,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9549,
      "EndAddress": 9549,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9550,
      "EndAddress": 9551,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9552,
      "EndAddress": 9552,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9553,
      "EndAddress": 9554,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9555,
      "EndAddress": 9555,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9556,
      "EndAddress": 9557,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9558,
      "EndAddress": 9558,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9559,
      "EndAddress": 9560,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9561,
      "EndAddress": 9561,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9562,
      "EndAddress": 9563,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9564,
      "EndAddress": 9564,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9565,
      "EndAddress": 9566,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9567,
      "EndAddress": 9567,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9568,
      "EndAddress": 9569,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9570,
      "EndAddress": 9570,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9571,
      "EndAddress": 9572,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9573,
      "EndAddress": 9573,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9574,
      "EndAddress": 9575,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9576,
      "EndAddress": 9576,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9577,
      "EndAddress": 9578,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9579,
      "EndAddress": 9579,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9580,
      "EndAddress": 9581,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9582,
      "EndAddress": 9582,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9583,
      "EndAddress": 9584,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9585,
      "EndAddress": 9585,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9586,
      "EndAddress": 9587,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9588,
      "EndAddress": 9588,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9589,
      "EndAddress": 9590,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9591,
      "EndAddress": 9591,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9592,
      "EndAddress": 9592,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9593,
      "EndAddress": 9594,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9595,
      "EndAddress": 9595,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9596,
      "EndAddress": 9597,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9598,
      "EndAddress": 9598,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9599,
      "EndAddress": 9600,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9601,
      "EndAddress": 9601,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9602,
      "EndAddress": 9603,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 9604,
      "EndAddress": 10051,
      "SectionType": 1,
      "Lenght": 448
    },
    {
      "StartAddress": 10052,
      "EndAddress": 10052,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10053,
      "EndAddress": 10053,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10054,
      "EndAddress": 10055,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10056,
      "EndAddress": 10056,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10057,
      "EndAddress": 10058,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10059,
      "EndAddress": 10059,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10060,
      "EndAddress": 10061,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10062,
      "EndAddress": 10062,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10063,
      "EndAddress": 10064,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10065,
      "EndAddress": 10065,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10066,
      "EndAddress": 10067,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10068,
      "EndAddress": 10068,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10069,
      "EndAddress": 10077,
      "SectionType": 3,
      "Lenght": 9
    },
    {
      "StartAddress": 10078,
      "EndAddress": 10088,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 10089,
      "EndAddress": 10097,
      "SectionType": 2,
      "Lenght": 9
    },
    {
      "StartAddress": 10098,
      "EndAddress": 10115,
      "SectionType": 2,
      "Lenght": 18
    },
    {
      "StartAddress": 10116,
      "EndAddress": 10127,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 10128,
      "EndAddress": 10128,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10129,
      "EndAddress": 10129,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10130,
      "EndAddress": 10131,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10132,
      "EndAddress": 10132,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10133,
      "EndAddress": 10134,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10135,
      "EndAddress": 10135,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10136,
      "EndAddress": 10137,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10138,
      "EndAddress": 10138,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10139,
      "EndAddress": 10140,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10141,
      "EndAddress": 10141,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10142,
      "EndAddress": 10143,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10144,
      "EndAddress": 10144,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10145,
      "EndAddress": 10186,
      "SectionType": 2,
      "Lenght": 42
    },
    {
      "StartAddress": 10187,
      "EndAddress": 10187,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10188,
      "EndAddress": 10188,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10189,
      "EndAddress": 10190,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10191,
      "EndAddress": 10191,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10192,
      "EndAddress": 10193,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10194,
      "EndAddress": 10194,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10195,
      "EndAddress": 10218,
      "SectionType": 2,
      "Lenght": 24
    },
    {
      "StartAddress": 10219,
      "EndAddress": 10256,
      "SectionType": 2,
      "Lenght": 38
    },
    {
      "StartAddress": 10257,
      "EndAddress": 10448,
      "SectionType": 1,
      "Lenght": 192
    },
    {
      "StartAddress": 10449,
      "EndAddress": 10449,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10450,
      "EndAddress": 10450,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10451,
      "EndAddress": 10451,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10452,
      "EndAddress": 10452,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10453,
      "EndAddress": 10453,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10454,
      "EndAddress": 10454,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10455,
      "EndAddress": 10455,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10456,
      "EndAddress": 10456,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10457,
      "EndAddress": 10457,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10458,
      "EndAddress": 10458,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10459,
      "EndAddress": 10459,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10460,
      "EndAddress": 10460,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10461,
      "EndAddress": 10461,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10462,
      "EndAddress": 10462,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10463,
      "EndAddress": 16383,
      "SectionType": 1,
      "Lenght": 5921
    },
    {
      "StartAddress": 16384,
      "EndAddress": 23551,
      "SectionType": 2,
      "Lenght": 7168
    },
    {
      "StartAddress": 23552,
      "EndAddress": 49151,
      "SectionType": 1,
      "Lenght": 25600
    },
    {
      "StartAddress": 49152,
      "EndAddress": 65535,
      "SectionType": 2,
      "Lenght": 16384
    }
  ],
  "DisassemblyFlags": 4
}