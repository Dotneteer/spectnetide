<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/spectnetide/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/spectnetide/" rel="alternate" type="text/html" /><updated>2019-10-29T16:49:30+01:00</updated><id>http://localhost:4000/spectnetide/feed.xml</id><title type="html">SpectNet IDE</title><subtitle>Visual Studio 2017/2019 integrated ZX Spectrum IDE for the Community</subtitle><entry><title type="html">Use the Keyboard Tool</title><link href="http://localhost:4000/spectnetide/getting-started/use-keyboard-tool-2" rel="alternate" type="text/html" title="Use the Keyboard Tool" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/use-keyboard-tool</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/use-keyboard-tool-2">&lt;p&gt;SpectNetIDE provides a Keyboard Tool window to help you using the ZX Spectrum Keyboard. Of course, you can use your computer’s keyboard to type, but sometimes the Keyboard Tool makes your work easier.
The IDE allows you to use two keyboard layouts, ZX Spectrum 48K, and ZX Spectrum 128K (+2, +2A, +3), respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/spectrum-48-keyboard.png&quot; alt=&quot;ZX Spectrum 48K keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/spectrum-128-keyboard.png&quot; alt=&quot;ZX Spectrum 128K keyboard&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;selecting-the-keyboard-layout&quot;&gt;Selecting the Keyboard Layout&lt;/h2&gt;

&lt;p&gt;By default, SpectNetIDE uses the layout according to your project’s machine type. Nonetheless, you can change these settings in the Tools|Options dialog within the Spect.Net IDE tab. The Keyboard Tool section contains two configuration properties.
The Keyboard layout allows you to select from the Default, Spectrum48, and Spectrum128 values. Depending on your monitor type, the original layout size may not display very well on the screen. With the Keyboard display mode property, you can change the OriginalSize value to Fit. This setting automatically resizes the keyboard as you change the size of the Keyboard tool window.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/keyboard-options.png&quot; alt=&quot;ZX Spectrum keyboard options&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;keystrokes&quot;&gt;Keystrokes&lt;/h2&gt;

&lt;p&gt;To press a key in the tool window, move the mouse over the part of a particular key you want to enter and click the mouse. The tool window senses which part of the key you clicked and emulates that keystroke, applying &lt;code class=&quot;highlighter-rouge&quot;&gt;CAPS SHIFT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SYMBOL SHIFT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;EXTENDED MODE&lt;/code&gt;, as required.&lt;/p&gt;

&lt;h3 id=&quot;normal-keystroke&quot;&gt;Normal keystroke&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/normal-keystroke-48.png&quot; alt=&quot;Normal keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/normal-keystroke-128.png&quot; alt=&quot;Normal keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The left and right mouse buttons emulate different keystroke. The left button enters the key normally, the right button imitates entering the key with &lt;code class=&quot;highlighter-rouge&quot;&gt;CAPS SHIFT&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;sym-shift-keystroke&quot;&gt;SYM SHIFT keystroke&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/sym-shift-keystroke-48.png&quot; alt=&quot;SYM SHIFT keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/sym-shift-keystroke-128.png&quot; alt=&quot;SYM SHIFT keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;extended-mode-keystroke&quot;&gt;EXTENDED MODE keystroke&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/ext-mode-keystroke-48.png&quot; alt=&quot;EXTENDED MODE keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/ext-mode-keystroke-128.png&quot; alt=&quot;EXTENDED MODE keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;extended-mode--shift-keystroke&quot;&gt;EXTENDED MODE + SHIFT keystroke&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/ext-shift-keystroke-48.png&quot; alt=&quot;EXTENDED MODE shift keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/ext-shift-keystroke-128.png&quot; alt=&quot;EXTENDED MODE shift keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;colors&quot;&gt;Colors&lt;/h3&gt;

&lt;p&gt;The 0…7 keys have a function to change the color of ink and/or paper. For example, key 5 sets the color to &lt;code class=&quot;highlighter-rouge&quot;&gt;CYAN&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/color-keystroke-48.png&quot; alt=&quot;Color keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/color-keystroke-128.png&quot; alt=&quot;Color keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The left mouse button sets the paper color, while the right mouse button modifies the ink color.&lt;/p&gt;

&lt;h3 id=&quot;graphic-symbols&quot;&gt;Graphic symbols&lt;/h3&gt;

&lt;p&gt;The 1…8 keys allow you to enter graphic symbols. Click the particular symbol to emulate the keystroke – left and right buttons work the same way.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/graphic-keystroke-48.png&quot; alt=&quot;Graphic keystroke 48K&quot; /&gt;
&lt;img src=&quot;/spectnetide/assets/images/tutorials/graphic-keystroke-128.png&quot; alt=&quot;Graphic keystroke 128K&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: On specific computers — depending on the amount of free RAM and CPU load — you may experience that entering graphic symbols sometimes fails, or the keyboard does not return the letter mode. In such a situation, click the GRAPHICS function (above key 9) and then to the digit beside the appropriate graphic symbol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;using-the-physical-and-virtual-keyboards-together&quot;&gt;Using the Physical and Virtual Keyboards Together&lt;/h2&gt;

&lt;p&gt;You can use the physical keyboard to type into the ZX Spectrum emulator only when the emulator tool window has the keyboard focus. When you apply keystrokes in the Keyboard tool, that window receives the focus. So to be able to use the physical keyboard again, click the ZX Spectrum emulator to shift the focus.&lt;/p&gt;</content><author><name></name></author><summary type="html">SpectNetIDE provides a Keyboard Tool window to help you using the ZX Spectrum Keyboard. Of course, you can use your computer’s keyboard to type, but sometimes the Keyboard Tool makes your work easier. The IDE allows you to use two keyboard layouts, ZX Spectrum 48K, and ZX Spectrum 128K (+2, +2A, +3), respectively.</summary></entry><entry><title type="html">Install SpectNetIDE</title><link href="http://localhost:4000/spectnetide/getting-started/install-spectnetide-2" rel="alternate" type="text/html" title="Install SpectNetIDE" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/install-spectnetide</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/install-spectnetide-2">&lt;p&gt;&lt;strong&gt;SpectNetIDE&lt;/strong&gt; is an open source project with MIT license, and it is free to install. The ZX Spectrum IDE is implemented as a Visual Studio 2019 extension (VSIX). Thus, you can run it only on Windows.&lt;/p&gt;

&lt;p&gt;You need Visual Studio installed on your machine. You do not have to pay to get a legal license for VS, SpectNetIDE works with the free Community edition seamlessly. You can download the Visual Studio edition of your choice from its &lt;a href=&quot;https://visualstudio.microsoft.com/downloads/&quot;&gt;home page&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: Right now, there are two versions of &lt;strong&gt;SpectNetIDE&lt;/strong&gt;. The old one (v1.x), runs on Visual Studio 2017 and Visual Studio 2019. The new one (v2.x), can be installed only on Visual Studio 2019.
Though both versions can be installed simultaneously in the IDE, they do not work together, so you need to install only one of them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;removing-spectnetide-v1x&quot;&gt;Removing SpectNetIDE v1.x&lt;/h3&gt;

&lt;p&gt;If you have not installed SpectNetIDE v1.x, jump to the next section; otherwise, follow these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Select the &lt;strong&gt;Extensions → Manage Extensions&lt;/strong&gt; menu commands. It displays a dialog to handle your VS extensions. Click the Installed tab, and select SpectNetIde from the list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/extensions-dialog-in-vs-remove.png&quot; alt=&quot;Extensions and Updates&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Click Uninstall. Visual Studio marks the extension to remove. Now, close all open Visual Studio 2019 instances to carry on the removing process!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/confirm-vsix-remove.png&quot; alt=&quot;VSIX Remove&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;Click Modify, and wait while VSIX Installer completes its operation. Next time you start the VS IDE, SpectNetIDE v1.x will not be on its extension list.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;installing-spectnetide-v2x&quot;&gt;Installing SpectNetIDE v2.x&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start Visual Studio 2019, and in its start page, click Continue without code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select the &lt;strong&gt;Extensions → Manage Extensions&lt;/strong&gt; menu command. It displays a dialog to install VS extensions. Click the Online tab and type “SpectNetIDE” in the search box.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The dialog looks up the Visual Studio Marketplace and displays the SpectNetIDE extensions. Select &lt;strong&gt;SpectNetIDE 2.0&lt;/strong&gt; and click Download to start the installation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/extensions-dialog-in-vs-2.png&quot; alt=&quot;Extensions and Updates&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;The IDE prepares the downloaded package for setup. However, it will begin installing it only after you close Visual Studio.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/extension-ready-to-install-2.png&quot; alt=&quot;Ready to Install&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;When you have closed all running instances of Visual Studio, the VSIX installer automatically starts the setup. First, you have to confirm the license terms and click Modify.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/confirm-vsix-install-2.png&quot; alt=&quot;Confirm VSIX Install&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;The VSIX installer sets up the extension—it takes less than a minute—and signs when it completes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/vsix-install-completes-2.png&quot; alt=&quot;VSIX Install Completes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, SpectNetIDE is ready to use. When you start Visual Studio, in the Help|About dialog you can check it’s integrated with VS.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/spectnetide-in-about-2.png&quot; alt=&quot;SpectNetIde in About&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To get familiar with using the ZX Spectrum IDE, take a look at the other tutorials!&lt;/p&gt;</content><author><name></name></author><summary type="html">SpectNetIDE is an open source project with MIT license, and it is free to install. The ZX Spectrum IDE is implemented as a Visual Studio 2019 extension (VSIX). Thus, you can run it only on Windows.</summary></entry><entry><title type="html">Export a Z80 Program</title><link href="http://localhost:4000/spectnetide/getting-started/export-a-z80-program-2" rel="alternate" type="text/html" title="Export a Z80 Program" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/export-a-z80-program</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/export-a-z80-program-2">&lt;p&gt;After you created your Z80 Assembler program, you can easily export it into a &lt;code class=&quot;highlighter-rouge&quot;&gt;.TAP&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;.TZX&lt;/code&gt; file so that you
could load it into a ZX Spectrum emulator, or into a real hardware, such as a ZX Spectrum Next, or ZX Spectrum
(with the help of TZXDuino or CASDuino hardware).&lt;/p&gt;

&lt;p&gt;To try how easy it is, create a simple Z80 program:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create a new ZX Spectrum 48 project (see details &lt;a href=&quot;/spectnetide/getting-started/create-zx-spectrum-48k-project-2.html#article&quot;&gt;here&lt;/a&gt;).
The &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeFiles &lt;/code&gt;&lt;/strong&gt; project of the folder contains a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.z80asm&lt;/code&gt;&lt;/strong&gt; file. Clear the contents of that file, and type this concise program:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;start:
    .org #8000
    ld a,3
    out (#fe),a
    jp #12a2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;In Solution Explorer, right-click the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.z80asm&lt;/code&gt;&lt;/strong&gt; file, and invoke the &lt;strong&gt;Run Z80 program&lt;/strong&gt; command (or use the &lt;strong&gt;Ctrl+M&lt;/strong&gt;, &lt;strong&gt;Ctrl+R&lt;/strong&gt; double shortcut keys):&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/run-z80-code-command-2.png&quot; alt=&quot;Run Z80 code command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This command compiles the Z80 assembly code to binary machine code, starts (or restarts) the Spectrum virtual machine,
injects the binary code, and runs it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/z80-code-runs-2-2.png&quot; alt=&quot;Z80 code runs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can easily export the code with these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In Solution Explorer, right-click the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.z80asm&lt;/code&gt;&lt;/strong&gt; file, and invoke the &lt;strong&gt;Export Z80 program&lt;/strong&gt; command:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/export-z80-code-command-2.png&quot; alt=&quot;Export Z80 code command&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The IDE pops up the &lt;strong&gt;Export Z80 Program&lt;/strong&gt; dialog:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/export-z80-program-dialog.png&quot; alt=&quot;Export Z80 code command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can change the attributes of the exported program. The default settings of the dialog will create a loader program that automatically loads and runs the code. Beside the default options, I set the &lt;strong&gt;Add the exported tape file&lt;/strong&gt; to the project checkbox.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;Click Export.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, you can find the exported code file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp&lt;/code&gt; folder (&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.tzx&lt;/code&gt;), and also in your project, within the &lt;code class=&quot;highlighter-rouge&quot;&gt;TapeFile&lt;/code&gt; folder:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/exported-code-in-project-2.png&quot; alt=&quot;Exported Z80 code in project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have many other options to export your code, I will explain them in another tutorial.&lt;/p&gt;</content><author><name></name></author><summary type="html">After you created your Z80 Assembler program, you can easily export it into a .TAP or .TZX file so that you could load it into a ZX Spectrum emulator, or into a real hardware, such as a ZX Spectrum Next, or ZX Spectrum (with the help of TZXDuino or CASDuino hardware).</summary></entry><entry><title type="html">Create a ZX Spectrum 48K Project</title><link href="http://localhost:4000/spectnetide/getting-started/create-zx-spectrum-48k-project-2" rel="alternate" type="text/html" title="Create a ZX Spectrum 48K Project" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/create-a-zx-spectrum-project</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/create-zx-spectrum-48k-project-2">&lt;ol&gt;
  &lt;li&gt;Run the &lt;strong&gt;File → New → Project&lt;/strong&gt; command (Ctrl+Shift+N). In the Create a new project dialog type “ZX Spectrum” in the search box. The dialog displays the ZX Spectrum Code Discovery Project. Select this type, and click Next.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/new-zx-spectrum-project-2.png&quot; alt=&quot;New Zx Spectrum Project&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Type MyFirstDiscovery in the Project name field, and then click Create.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/specify-project-name.png&quot; alt=&quot;Specify project info&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The IDE displays a list of available Spectrum models. Select the first Spectrum 48K model
(PAL - Normal Speed) from the list, and click &lt;strong&gt;Create&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/select-machine-type-2.png&quot; alt=&quot;Select Spectrum model&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The IDE creates a new project with a few files and folders:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/solution-structure-2.png&quot; alt=&quot;Solution Explorer with the new project&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;File/Folder&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rom&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;The folder that holds Spectrum ROMs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rom/ZxSpectrum.spconfig&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;This file stores the configuration information about the selected ZX Spectrum model&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rom/ZxSpectrum48.rom&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;The binary ROM file for the Spectrum 48K model&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rom/ZxSpectrum48.disann&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Disassembly annotations for the Spectrum 48K ROM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TapeFiles&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Stores &lt;em&gt;.tzx&lt;/em&gt;, &lt;em&gt;.tap&lt;/em&gt; (and, in the future, other) tape files&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80CodeFiles&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;The folder to put your Z80 Assembly code files in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80CodeFiles/Code.z80asm&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A simple Z80 Assembly code file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80UnitTests&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;The folder to put your Z80 unit tests files in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80UnitTests/UnitTest.z80test&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A simple Z80 unit test file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80BasicFiles&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;The folder to put your ZX BASIC files in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80BasicFiles/UnitTest.z80test&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A simple ZX BASIC program file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Annotations.disann&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Your custom disassembly annotations are saved into this file&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;As soon as the IDE created the project, you can discover a new submenu, &lt;strong&gt;ZX Spectrum IDE&lt;/strong&gt;, under &lt;strong&gt;Extensions&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/zx-spectrum-menu-2.png&quot; alt=&quot;ZX Spectrum IDE menu&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;run-the-zx-spectrum-virtual-machine&quot;&gt;Run the ZX Spectrum Virtual Machine&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Run the &lt;strong&gt;ZX Spectrum IDE|ZX Spectrum Emulator&lt;/strong&gt; command. The IDE shows up the emulator tool window.
As the title of the tool window indicates, the virtual machine is not started yet.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/machine-not-started-2.png&quot; alt=&quot;The Emulator Tool Window&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Click the little &lt;em&gt;Play&lt;/em&gt; icon in the toolbar of the emulator to start the virtual machine.
The ZX Spectrum computer comes to life. As you resize the tool window, the emulator changes its screen size, 
accordingly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/machine-started-2.png&quot; alt=&quot;Spectrum VM started&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;Type the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LOAD &quot;&quot;&lt;/code&gt;&lt;/strong&gt; command into the emulator. Take care that the emulator window is the active one, receiving the
keyboard focus, and press the &lt;strong&gt;J&lt;/strong&gt;, and then twice the &lt;strong&gt;Shift+P&lt;/strong&gt; keys again. With pressing &lt;strong&gt;Enter&lt;/strong&gt;, you can execute &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LOAD &quot;&quot;&lt;/code&gt;&lt;/strong&gt;.
Th virtual machine starts loading the &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome.tzx&lt;/code&gt; file.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/machine-loading-2.png&quot; alt=&quot;Loading a Game&quot; /&gt;&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;When the game has been loaded, type the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;&lt;/strong&gt; command into the emulator (while the emulator window is the active one, press the &lt;strong&gt;R&lt;/strong&gt; key),
and then, press &lt;strong&gt;Enter&lt;/strong&gt;. The program starts, and displays its message:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/run-completed-2.png&quot; alt=&quot;Welcome in action&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have just scratched the surface! There are many other features you can use in the
IDE to discover the structure and internals of ZX Spectrum applications.&lt;/p&gt;</content><author><name></name></author><summary type="html">Run the File → New → Project command (Ctrl+Shift+N). In the Create a new project dialog type “ZX Spectrum” in the search box. The dialog displays the ZX Spectrum Code Discovery Project. Select this type, and click Next.</summary></entry><entry><title type="html">Create a Z80 Program</title><link href="http://localhost:4000/spectnetide/getting-started/create-a-z80-program-2" rel="alternate" type="text/html" title="Create a Z80 Program" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/create-a-z80-program</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/create-a-z80-program-2">&lt;p&gt;In this article, you will learn that SpectNetIde provides you a straightforward way to create and run Z80 assembly programs.&lt;/p&gt;

&lt;p&gt;To create your first Z80 assembly program, follow these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create a new ZX Spectrum 48 project (see details &lt;a href=&quot;/spectnetide/getting-started/create-zx-spectrum-48k-project-2.html#article&quot;&gt;here&lt;/a&gt;).
The &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeFiles &lt;/code&gt;&lt;/strong&gt; project of the folder contains a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.z80asm&lt;/code&gt;&lt;/strong&gt; file:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; Put your Z80 assembly code into code files
Start:
    .model Spectrum48
    .org #8000
    ld a,2;	      ; upper screen
    call #1601    ; open the channel
    ld hl,Message ; HL points the the message string
NextCh:
    ld a,(hl)     ; get next character
    or a
    jp z,#12a9    ; jump back to main cycle when terminated
    rst #10       ; display character
    inc hl        ; next character
    jr NextCh     ; next loop

Message:
    .dm &quot;\a\x0A\x08&quot; ; AT 10, 4
    .dm &quot;\p\x04&quot;     ; INK 4
    .dm &quot;ZX Spectrum IDE&quot;
    .db 0x00         ; terminate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Insert these code lines right after &lt;code class=&quot;highlighter-rouge&quot;&gt;.org #8000&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	ld a,3        ; purple
	out (#fe),a   ; set the border color
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;In Solution Explorer, right-click the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Code.z80asm&lt;/code&gt;&lt;/strong&gt; file, and invoke the &lt;strong&gt;Run Z80 program&lt;/strong&gt; command:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/run-z80-code-command-2.png&quot; alt=&quot;Run Z80 code command&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You can use the &lt;strong&gt;Ctrl+M&lt;/strong&gt;, &lt;strong&gt;Ctrl+R&lt;/strong&gt; double shortcut keys to execute the &lt;strong&gt;Run Z80 program&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This command compiles the Z80 assembly code to binary machine code, starts (or restarts) the Spectrum virtual machine,
injects the binary code, and runs it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/z80-code-runs-2.png&quot; alt=&quot;Z80 code runs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have just created your first Z80 assembly program in SpectNetIde!&lt;/p&gt;

&lt;h2 id=&quot;errors-in-the-code&quot;&gt;Errors in the code&lt;/h2&gt;

&lt;p&gt;If you make an error – either syntax or semantic error – the SpectNetIDE assembler gives an error message. Let’s assume you make an error in the code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; Code file
start:
    org #8000
    ld a,hl      ; &quot;hl&quot; is a semantic error
    out (#fe),a 
    jp #12a2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Z80 Assembler displays the issue in the Error List:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/compile-error.png&quot; alt=&quot;Compile error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When you double click the error line, the IDE navigates you to the error line in the source code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/error-marked-in-source.png&quot; alt=&quot;Error marked in source&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a-bit-longer-z80-program&quot;&gt;A Bit Longer Z80 Program&lt;/h2&gt;

&lt;p&gt;If you’re excited, you can try a bit longer Z80 code with border manipulations and delays. When you run it, the code sets the screen colors and uses the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt;&lt;/strong&gt; statement to synchronized border drawing. When you start it, it runs until you press &lt;code class=&quot;highlighter-rouge&quot;&gt;SPACE&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/banner-program-runs-2.png&quot; alt=&quot;Z80 baner runs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here is the entire source code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; Define symbols
LAST_K:		.equ #5c08
MAIN_EX:	.equ #12a2

Start:
    .org #8000

; Set Banner lines
SetScreen:
    call ClearScreen
    ld a,0b00_010_010
    ld b,0
    call ClearLine
    ld a,0b00_110_110
    ld b,1
    call ClearLine
    ld a,0b00_101_101
    ld b,2
    call ClearLine
    ld a,0b00_100_100
    ld b,3
    call ClearLine

; Set banner border area
Top:
    ld bc,#200
    call LongDelay
    ld a,2
    call SetBorder
    ld a,6
    call SetBorder
    ld a,5
    call SetBorder
    ld a,4
    call SetBorder
    ld a,0
    call SetBorder
    halt        ; Wait for the next interrupt
    ld hl,LAST_K
    ld a, (hl)	; put last keyboard press into A
    cp #20		; was &quot;space&quot; pressed?
    jr nz,Top	; If not, back to the cycle
    ld a,7
    call SetBorder
    jp MAIN_EX

; Sets the entire screen to black
ClearScreen:
    ld bc,24*32-1 ; #of screen attribute bytes
    ld hl,#5800 ; First attr address
    ld de,#5801 ; Next attr address
    ld (hl),0   ; Black on Black
    ldir        ; Set all attribute bytes
    ret

; A = Attr byte to set
; B = Line index
ClearLine:
    push af     ; Save A
    ld a,b      ; Multiply the line count with 32
    sla a
    sla a
    sla a
    sla a
    sla a
    ld hl,#5800 ; Calculate the attribute address
    ld d,0
    ld e,a
    add hl,de
    pop af      ; Restore A
    ld b,#20    ; Set all the 32 attribute bytes
SetAttr:
    ld (hl),a
    inc hl
    djnz SetAttr
    ret

; Sets the border color
SetBorder:
    out (#fe),a
    ld b,#86
Delay:
    djnz Delay
    ret

; Delays code execution
LongDelay:
    dec bc
    ld a,b
    or c
    jr nz,LongDelay
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;SpectNetIDE&lt;/strong&gt; makes it extremely simple to reuse the Z80 assembly code, as you
will learn in the next article.&lt;/p&gt;</content><author><name></name></author><summary type="html">In this article, you will learn that SpectNetIde provides you a straightforward way to create and run Z80 assembly programs.</summary></entry><entry><title type="html">Create a BASIC Program</title><link href="http://localhost:4000/spectnetide/getting-started/create-a-basic-program-2" rel="alternate" type="text/html" title="Create a BASIC Program" /><published>2019-10-01T00:00:00+02:00</published><updated>2019-10-01T00:00:00+02:00</updated><id>http://localhost:4000/spectnetide/getting-started/create-a-basic-program</id><content type="html" xml:base="http://localhost:4000/spectnetide/getting-started/create-a-basic-program-2">&lt;p&gt;In a previous tutorial, you could see how easy is to create a new ZX Spectrum program from scratch.&lt;/p&gt;

&lt;p&gt;Here, you will create and run a simple BASIC program. Although you can use the keyboard of the PC to enter a program — provided, the ZX Spectrum Emulator window has the focus — if you’re not familiar with the Spectrum keys and BASIC editor, it may frustrate you while entering the code. To avoid such chaffing, use the ZX Spectrum Keyboard tool window to enter the program.&lt;/p&gt;

&lt;p&gt;First, add this line:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 BORDER 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To enter this BASIC line, press these keys, in this order: “&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;”, “&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;”, “&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;”, “&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;”, “&lt;code class=&quot;highlighter-rouge&quot;&gt;Enter&lt;/code&gt;” (of course, you do not need to click comma between the keys wrapped in double quotes)&lt;/p&gt;

&lt;p&gt;As soon as you’ve added this program line, it appears in the screen listing:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/basic-line-1-2.png&quot; alt=&quot;Basic line 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, add these lines to the code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;20 BORDER 5
30 BORDER 6
40 PAUSE 1
50 GOTO 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/basic-line-2-2.png&quot; alt=&quot;Basic line 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Your first BASIC program is ready to run. Invoke the &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt; command (press
&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;Enter&lt;/code&gt;) to start this code. As you can see from the listing, 
it implements an infinite loop while changing the background color:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/basic-program-runs-2.png&quot; alt=&quot;Basic code runs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To stop the program, press the &lt;code class=&quot;highlighter-rouge&quot;&gt;SPACE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SYM SHIFT&lt;/code&gt; keys simultaneously
or click the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; button in the ZX Spectrum Keyboard window with the right
mouse button:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/tutorials/basic-program-stopped-2.png&quot; alt=&quot;Basic program stopped&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Congratulations! It is time to move on and create a Z80 assembly program!&lt;/p&gt;</content><author><name></name></author><summary type="html">In a previous tutorial, you could see how easy is to create a new ZX Spectrum program from scratch.</summary></entry><entry><title type="html">Syntax Basics</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-basics" rel="alternate" type="text/html" title="Syntax Basics" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-basics</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-basics">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; provides a somple programming language to describe Z80-related unit tests. You can add the 
&lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; files to your project and run the test in the &lt;strong&gt;Unit Test Explorer&lt;/strong&gt; tool window. This document
treats the syntax and semantics of the language.&lt;/p&gt;

&lt;h2 id=&quot;syntax-basics&quot;&gt;Syntax Basics&lt;/h2&gt;

&lt;p&gt;The test language uses a special way of case-sensitivity. You can write the reserved
keywords on lowercase. When you refer to Z80 CPU registers or flags, you can use either with lowercase or
uppercase letters, but you cannot mix these cases. You can mix cases for identifiers, though they are
searched for a case-insensitive manner.&lt;/p&gt;

&lt;h2 id=&quot;test-structure&quot;&gt;Test Structure&lt;/h2&gt;

&lt;p&gt;A ZX Spectrum project may have zero, one, or more test files (files with &lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; extension). Before 
running them, the engine collects all &lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; files from the current project, and compiles them all.&lt;/p&gt;

&lt;p&gt;A single test file may contain one or more &lt;em&gt;test set&lt;/em&gt;. A test set is a collection of cohesive tests that 
all use the very same source code, as the basis of testing:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    // --- Other testset attributes    

    test AddAAndBWorksAsExpected
    {
        // --- Other test attributes

        act call AddAAndB;

        assert
        {
            // --- Here we describe the test assertions
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A &lt;em&gt;test&lt;/em&gt; can have a default &lt;em&gt;act&lt;/em&gt;, such as in the sample above, or may have parameterized test cases:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// --- Wrapping test set omitted
test AddAAndBCallWorksAsExpected2
{
    params parA, parB, Z;
    case 1, 2, 0;
    case 2, 3, 0;
    case -6, 6, 1;

    arrange
    {
        a: parA;
        b: parB;
    }

    act call AddAAndB;

    assert
    {
        a == parA + parB;
        b == parB;
        .z == Z;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This test has three cases, as declared by the lines starting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; keyword.
When running them, the engine substitutes the &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; values with the
values after &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; (fore each &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;To summarize:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Concept&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test file&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A single container for &lt;em&gt;test sets&lt;/em&gt;. Besides keeping test sets together in a single file, there’s no additional semantics.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test set&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A cohesive set of tests. A test set has a single source code file — this contains the code to test — shared between the test within the set.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A single test that runs a piece of the source code to test. It may nest test cases.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test case&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Parameterized test. It runs the same code (although you can run different code) with the case-related parameters.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;syntax-elements&quot;&gt;Syntax Elements&lt;/h2&gt;

&lt;p&gt;The test language contains several constituting elements that you can use in many 
places within the code, such as comments, expressions, identifiers, and so on. Here 
you can learn about them.&lt;/p&gt;

&lt;h3 id=&quot;comments&quot;&gt;Comments&lt;/h3&gt;

&lt;p&gt;Comments can be single line or multi-line comments with the same syntax construct as you may 
use them in many curly-brace-languages, such as C++, Java, C#, etc.:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// --- This is a single line comment you can add to the end of the code lines

/* This is a multi-line comment the spans accross multiple lines, 
   including empty ones

*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;literals&quot;&gt;Literals&lt;/h3&gt;

&lt;p&gt;The language syntax provides these types of literals:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Decimal numbers.&lt;/strong&gt; You can use adjacent digits (0..9) to declare a decimal number. Examples:
16, 32768, 2354.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hexadecimal numbers.&lt;/strong&gt; You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare
a hexadecimal literal. The compiler looks for one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0x&lt;/code&gt; prefix, or one of 
the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; suffixes to recognize them as hexadecimal. Here are a few samples:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #12AC
    0x12ac
    12ACh
    12acH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Binary numbers.&lt;/strong&gt; Literal starting with the one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0b&lt;/code&gt; prefix are taken into 
account as binary literals. You can follow the prefix with up to 16 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; digits. To make
them more readable, you can separate adjacent digits with the underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;) character. These 
are all valid binary literals:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    %01011111
    0b01011111
    0b_0101_1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use negative number with the minus sign in front of them. Actually, the sign is not
the part of the numeric literal, it is an operator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Characters&lt;/strong&gt;. You can put a character between double quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Q&quot;&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Strings&lt;/strong&gt;. You can put a series of character between double quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Sinclair&quot;&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;This is a string. The next sample is a single character&quot;
&quot;c&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;character-and-string-escapes&quot;&gt;Character and String Escapes&lt;/h3&gt;

&lt;p&gt;ZX Spectrum has a character set with special control characters such as AT, INK, PAPER, and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; allows you to utilize special escape sequences to define ZX Spectrum-specific characters:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Escape&lt;/th&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Character&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;INK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x11&lt;/td&gt;
      &lt;td&gt;PAPER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x12&lt;/td&gt;
      &lt;td&gt;FLASH&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x13&lt;/td&gt;
      &lt;td&gt;BRIGHT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x14&lt;/td&gt;
      &lt;td&gt;INVERSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x15&lt;/td&gt;
      &lt;td&gt;OVER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x16&lt;/td&gt;
      &lt;td&gt;AT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x17&lt;/td&gt;
      &lt;td&gt;TAB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x60&lt;/td&gt;
      &lt;td&gt;pound sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x7F&lt;/td&gt;
      &lt;td&gt;copyright sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x5C&lt;/td&gt;
      &lt;td&gt;backslash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\'&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x27&lt;/td&gt;
      &lt;td&gt;single quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x22&lt;/td&gt;
      &lt;td&gt;double quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;binary zero&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observe, some of these sequences have different values than their corresponding
pairs in other languages, such as C, C++, C#, or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To declare a character by its binary code, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;\xH&lt;/code&gt; or&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;\xHH&lt;/code&gt; sequences (&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; is a hexadecimal digit). For example, these
escape sequence pairs are equivalent:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;\i&quot;
&quot;\x10&quot;

&quot;\C by me&quot;
&quot;\x7f \x62y me&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;identifiers&quot;&gt;Identifiers&lt;/h3&gt;

&lt;p&gt;You can use identifiers to refer to labels and other constants. Identifiers must start with 
a letter (a..z or A..Z) or the underscore character (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;). The subsequent characters 
can be digits (0..9), too. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyCycle
ERR_NO
Cycle_4_Wait  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Theoretically, you can use as long identifiers as you want. I suggest you to make them no longer than
32 characters so that readers may read your code easily.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">SpectNetIde provides a somple programming language to describe Z80-related unit tests. You can add the .z80test files to your project and run the test in the Unit Test Explorer tool window. This document treats the syntax and semantics of the language.</summary></entry><entry><title type="html">The Testing Process</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-process" rel="alternate" type="text/html" title="The Testing Process" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-process</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-process">&lt;h1 id=&quot;the-testing-process&quot;&gt;The Testing Process&lt;/h1&gt;

&lt;p&gt;You already learned that tests are organized into a hierarchy of &lt;em&gt;test files&lt;/em&gt;, &lt;em&gt;test sets&lt;/em&gt;, &lt;em&gt;tests&lt;/em&gt;, and parameterized
&lt;em&gt;test cases&lt;/em&gt;. In this section you will learn how the test engine manages these tests.&lt;/p&gt;

&lt;p&gt;The testing process start with the compilation of tests. During this step, all tests are turned into execution plans.
If there is any compilation error, the engine won’t start running the tests.&lt;/p&gt;

&lt;p&gt;The unit of execution is the &lt;strong&gt;test set&lt;/strong&gt;. Test sets are entirelly independent of each other. You can run them in any
sequence; the order won’t change whether they fail or succeed. SpectNetIde loops through all test files declared in the
project (you cannot assume deterministic order), and runs all test sets in their declaration order within a file.&lt;/p&gt;

&lt;p&gt;Each test sets creates and starts a Spectrum virtual machine, and pauses it when the machine reaches its main execution 
cycle. The point a machine is paused depends on its type (different for Spectrum 48K, 128K, +3E), and also the mode the machine
runs. For example, in a Spectrum 128K machine you can run tests in BASIC 128 mode or in Spectrum 48K mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Right now, the unit test engine supports only Spectrum 48K mode, but soon you will be able to use the other modes, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;running-a-test-set&quot;&gt;Running a Test Set&lt;/h2&gt;

&lt;p&gt;Every test within a test set uses this virtual machine. This machine is paused every time a test completes 
(either successfully, with a failure, or in aborted state). &lt;em&gt;If a test disrupts the machine’s memory (for example, it changes
the code being tested), the behavior of a particular test may prevent the subsequent test from running properly.&lt;/em&gt; This demeanor
of test sets is intentional.&lt;/p&gt;

&lt;p&gt;The engine uses these steps to run the tests defined within a tes set:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;After the Spectrum machine reaches its startup state and pauses, the engine copies the compiled source code into
the memory.&lt;/li&gt;
  &lt;li&gt;If the test set declares an &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; section, the engine sets up the registers and flags accordingly, copies byte array
values into the memory. While initializing, it follows the order of &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; assignments.&lt;/li&gt;
  &lt;li&gt;The engine loops through the nested &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; blocks in their declaration order, and executes them.&lt;/li&gt;
  &lt;li&gt;When all tests are completed, the engine stops the virtual machine and disposes its state.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;running-a-test-and-parameterized-cases&quot;&gt;Running a Test and Parameterized Cases&lt;/h2&gt;

&lt;p&gt;To run a single test, the engine follows these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the test has a &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; declaration, the engine invokes the Setup code. If that code fails 
— it exceeds the timeout — the engine aborts the test.&lt;/li&gt;
  &lt;li&gt;If the test has a single default case, the engine runs that case. If the test has multiple cases, 
the engine iterates through all cases in their declaration order.&lt;/li&gt;
  &lt;li&gt;Provided the test has a &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; section, the engine invokes the Cleanup code. If this code 
exceeds the timeout, the Cleanup code aborts the test.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;According to this method, it might happen that all tests run successfully and still the test is
aborted, because its Cleanup code fails. This behavior is intentional: a faulty cleanup code may influence
the subsequent tests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The engine carries out the same steps for a default test case and parameterized test cases. If there are 
more cases, these steps are executed in a loop:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Provided there are &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; declarations, the engine sets up the registers and flags accordingly, 
copies byte array values into the memory — in the order of their declaration. If any &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; 
assignment fails, the test is aborted.&lt;/li&gt;
  &lt;li&gt;The engine invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; code. If it completes within the timeout, the testing process goes on;
otherwise, the test is aborted.&lt;/li&gt;
  &lt;li&gt;If there is no &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; section, the test is successful.&lt;/li&gt;
  &lt;li&gt;If there’s an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; section, the engine evaluates all expresssions within until it iterates through 
all or one of the expression evaluates to false.&lt;/li&gt;
  &lt;li&gt;A false assertion value completes the test as failed. If all assertions are true, the test is successful.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;side-effects&quot;&gt;Side effects&lt;/h2&gt;

&lt;p&gt;A test can have test options (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;di&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;ei&lt;/code&gt;). The engine uses these values whenever
it invokes Z80 code, independently whether that is &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt;. Between these 
code invocations, the engine simply pauses the Spectrum virtual machine and starts it again. There is one
special action the test engine takes: if a code is invoked with &lt;code class=&quot;highlighter-rouge&quot;&gt;halt&lt;/code&gt;, the test removes the CPU from its
halted state before the next test.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Again, the code is injected into the virtual machine only once, at the start of a test set. If any code
changes the memory, it may disrupt the test code, and thus remaining test cases in the test set may fail of
even may be aborted. Nonetheless, these tests won’t cause any harm in your project, they just cause tests fail.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, the following code disrupts the Spectrum virtual machine, because it restarts it, and so it causes
the clearing the RAM:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Crashing
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    test CrashingCode
    {
        with timeout 1000;
        act call #0000;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running it will abort the test after a second.&lt;/p&gt;

&lt;h2 id=&quot;using-callstub&quot;&gt;Using Callstub&lt;/h2&gt;

&lt;p&gt;When you invoke the code with the &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction, the test engine generates a stub
that call your subroutine. By default, the engine places three bytes with a Z80 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt;
instruction to the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA0&lt;/code&gt;&lt;/strong&gt; address, that is an empty area within the ZX Spectrum system
variables (printer buffer in ZX Spectrum 48K). If you do not want to use this address for a
stub, you can change it with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt;&lt;/strong&gt; attribute of a test set:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    callstub #8000;

    // --- Other test code omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This sample code instructs the engine to use the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#8000&lt;/code&gt;&lt;/strong&gt; address to generate the stub.
Be careful with using your custom stub!&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;First, do not forget to provide 3 bytes that the test engine can override.&lt;/li&gt;
  &lt;li&gt;Second, take care that you do not declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; code invocation that addresses a routine
starting at the &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt; + 3 address. The test engine checks if your call is completed so
that it compares &lt;strong&gt;PC&lt;/strong&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt; + 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a pattern you can use with your own custom &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.org #8000

; --- Here is some code

; --- We reserve 4 bytes
CallstubAddress:
    .defs 4;
; --- SomeRoutine starts at CallstubAddress + 4
SomeRoutine:
; --- Add routine code here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, you can define a test line this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    callstub CallstubAddress;

    test 
    {
        // ...
        act call SomeRoutine;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">The Testing Process</summary></entry><entry><title type="html">Expressions</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-expressions" rel="alternate" type="text/html" title="Expressions" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-expressions</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-expressions">&lt;p&gt;The test language has a rich syntax for evaluating expressions. You can use operands 
and operators just like in most programming languages. Nevertheless, the test language
implementation has its particular semantics of evaluating expression, as you will learn soon.&lt;/p&gt;

&lt;h2 id=&quot;operands&quot;&gt;Operands&lt;/h2&gt;
&lt;p&gt;You can use the following operands in epressions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Decimal and hexadecimal literals&lt;/li&gt;
  &lt;li&gt;Character literals&lt;/li&gt;
  &lt;li&gt;Identifiers&lt;/li&gt;
  &lt;li&gt;Test language specific constructs, such as the register, flag, and memory access operands&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;String literals cannot be used as operands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operators&quot;&gt;Operators&lt;/h2&gt;

&lt;p&gt;You can use about a dozen operators, including unary, binary and ternary ones. In this section
you will learn about them. I will introduce them in descending order of their precendence.&lt;/p&gt;

&lt;h3 id=&quot;conditional-operator&quot;&gt;Conditional Operator&lt;/h3&gt;

&lt;p&gt;The assembler supports using only one ternary operator, the conditional operator:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;conditional-expression&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;true-value&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;false-value&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This operation results in -1:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 &amp;gt; 3 ? 2 : -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When the &lt;em&gt;conditional-expression&lt;/em&gt; evaluates to true, the operation results 
in &lt;em&gt;true-value&lt;/em&gt;; otherwise in &lt;em&gt;false-value&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Conditional expressions are evaluated from right to left, in contrast to binary operators,
which use left-to-right evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;binary-bitwise-operators&quot;&gt;Binary Bitwise Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Bitwise OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Bitwise XOR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Bitwise AND&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;relational-operators&quot;&gt;Relational Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Non-equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than or equal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;shift-operators&quot;&gt;Shift Operators&lt;/h3&gt;

&lt;p&gt;The bits of the left operand are shifted by the number of bits given by the right operand.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift left&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift right&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;basic-arithmetic-operators&quot;&gt;Basic Arithmetic Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Addition&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Subtraction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Multiplication&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Division&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Modulo calculation&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;unary-operators&quot;&gt;Unary operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary plus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary minus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary bitwise NOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary logical NOT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Do not forget, you can change the defult precendence with &lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;type-semantics&quot;&gt;Type semantics&lt;/h2&gt;

&lt;p&gt;Expression values can be one of these types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Boolean&lt;/li&gt;
  &lt;li&gt;Number&lt;/li&gt;
  &lt;li&gt;Byte array&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are implicit conversions amont these types. The test language compiler automatically applies
these conversions, knowing the types to operate on.&lt;/p&gt;

&lt;p&gt;Internally, values are stored either as 64-bit numbers, or byte arrays. The compiler utilizes these 
conversions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;When a byte array value is required but a numeric value is found, the numeric value is converted 
into an array of a single byte using the rightmost 8 bits of the number stored in the memory.&lt;/li&gt;
  &lt;li&gt;When a number is required but a byte array is found, the conversion goes like this: A byte array 
of all 0 bytes results 0, any other values retrieve 1.&lt;/li&gt;
  &lt;li&gt;When the compiler needs a boolean number, the zero numeric value results 0 (false), any other value 
values retrieve 1 (true).&lt;/li&gt;
  &lt;li&gt;When the compiler needs a boolean number but it finds a byte array, the conversion takes two steps.
First, it turns the byte array into a number if first converts a byte array into a number (rule #1), 
and then these number into a Boolean (rule #3).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;operator-specific-behavior&quot;&gt;Operator-Specific Behavior&lt;/h2&gt;

&lt;p&gt;The compiler does not apply the conversion rules above automatically for all operators to avoid
unintended programming errors, instead retrieves an error:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No binary operators (including relational operators) accept mixing numeric and byte array values&lt;/li&gt;
  &lt;li&gt;Binary operators (except binary &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;) do not allow two byte array operands&lt;/li&gt;
  &lt;li&gt;The conditional operator ( &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; ) does not allow a byte array as the condition&lt;/li&gt;
  &lt;li&gt;Unary operators except &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; allow only numbers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are a few operators that work with byte arrays:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The binary &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; operator concatenates two byte arrays.&lt;/li&gt;
  &lt;li&gt;The bitwise logical operators work with two byte array operands. The result will be
a byte array with the shorter size of the operands. The elements of the result array are the
corresponding bitwise operations on the bits of the operand arrays.&lt;/li&gt;
  &lt;li&gt;The bitwise NOT unary operation inverts all bits in the byte array.&lt;/li&gt;
  &lt;li&gt;The logical NOT unary operator converts the byte array to a number and applies the logical NOT&lt;/li&gt;
  &lt;li&gt;operator on that number.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">The test language has a rich syntax for evaluating expressions. You can use operands and operators just like in most programming languages. Nevertheless, the test language implementation has its particular semantics of evaluating expression, as you will learn soon.</summary></entry><entry><title type="html">Detailed Syntax</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-details" rel="alternate" type="text/html" title="Detailed Syntax" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-details</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-details">&lt;p&gt;In the following section, I will use a kind of abstract syntax notation to describe the grammar of the 
SpectNetIde test language. Bold characters mark terminal symbols (keywords and other tokens), while 
italic strings ara non-terminal symbols. The &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; after a symbol means that it’s optional. A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 
means zero, one, or more occurrence. &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; means one or more occurrence. The &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; character separates options, exactly one of them can be used.
The language uses parantheses to specify groups of tokens.&lt;/p&gt;

&lt;h2 id=&quot;compilation-units&quot;&gt;Compilation Units&lt;/h2&gt;

&lt;p&gt;Each file is a compilation unit that contains zero, one, or more test sets:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;compileUnit:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testSet*&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;test-sets&quot;&gt;Test Sets&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testSet:&lt;/code&gt;** 
    &lt;strong&gt;testset&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
    &lt;em&gt;&lt;strong&gt;sp48mode&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sourceContext&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlock?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initSettings?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testBlock*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;using-sp48mode&quot;&gt;Using sp48mode&lt;/h3&gt;

&lt;p&gt;When you work with Spectrum 128K, Spectrum ++, or Spectrum Next, you can specify that you intend to
start the Spectrum virtual machine in Spectrum 48K mode:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    sp48mode;
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this mode, you can be sure that the Spectrum 48K ROM is paged into the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt; address range,
and memory paging is forbidden —, and thus, the test behaves exactly as if it were run on a Spectrum 48K model.&lt;/p&gt;

&lt;h3 id=&quot;the-source-context&quot;&gt;The Source Context&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sourceContext:&lt;/code&gt;&lt;/em&gt;	 &lt;strong&gt;source&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;symbols&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier+)?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Each test set is named with a unique identifier. The only mandatory element of a &lt;strong&gt;testset&lt;/strong&gt; declaration is 
the source context that names the source file used within the test set. You can add optional conditional symbols
that to compile the source code. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset MyFirstSet
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
}

testset MySecondSet
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot; symbols DEBUG SP128;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both test sets use the &lt;code class=&quot;highlighter-rouge&quot;&gt;../Z80CodeFiles/CodeSamples.z80asm&lt;/code&gt; source code file (path relative to the test file).
Nonetheless, &lt;code class=&quot;highlighter-rouge&quot;&gt;MySecondSet&lt;/code&gt; passes the &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SP128&lt;/code&gt; pre-defined symbols to the Z80 Assembler.&lt;/p&gt;

&lt;p&gt;The test engine recognizes the symbols you declare in the source context. For example, if you has a &lt;code class=&quot;highlighter-rouge&quot;&gt;MyRoutine&lt;/code&gt; 
symbol in the source code, you can use it within the test file. The compiler will understand it, and replaces the
symbol with its value.&lt;/p&gt;

&lt;h3 id=&quot;the-callstub-option&quot;&gt;The Callstub Option&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;callstub&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This option defines the address to use for a three-byte call stub when running unit tests. You will learn about 
this option later when I treat the semantics of test execution.&lt;/p&gt;

&lt;h3 id=&quot;defining-data-blocks&quot;&gt;Defining Data Blocks&lt;/h3&gt;

&lt;p&gt;A test set’s data block is to define values and byte array patterns that represent a block of the memory. Data block 
entries have unique identifiers you can use in the tests to reference them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlock:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;data&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlockBody*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlockBody:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueDef&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPattern&lt;/code&gt;&lt;/em&gt; 
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueDef:&lt;/code&gt;&lt;/em&gt;	&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPattern:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPatternBody+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPatternBody:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(byteSet&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wordSet&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text)&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;byteSet:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;byte&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wordSet:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;word&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;text&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;?*&lt;/code&gt; ) *&lt;code class=&quot;highlighter-rouge&quot;&gt;string*&lt;/code&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As the abstract syntax notation shows, it’s pretty easy to define values:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data
{
     four: 1 + 3;
     helloWorld: &quot;hello&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; identifier represents the constant 4; &lt;code class=&quot;highlighter-rouge&quot;&gt;helloWorld&lt;/code&gt; represents an array of 5 bytes, each 
byte stands for the corresponding character.&lt;/p&gt;

&lt;p&gt;You can define more complex byte arrays with the &lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;, and optional &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; keywords:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data
{
    myMemBlock
    {
        byte #12, #34, #36;
        word #AC38, #23;
        &quot;012&quot;; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, &lt;code class=&quot;highlighter-rouge&quot;&gt;myMemblock&lt;/code&gt; is a 10 bytes long array with these values:
#12, #34, #36, #38, #AC, #23, #00, #30, #31, #32.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observe, words are stored in LSB/MSB order. The word #23 is two bytes: #23 and #00.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;test-set-initialization-settings&quot;&gt;Test Set Initialization Settings&lt;/h3&gt;

&lt;p&gt;Before running tests, you can initialize a test set by assigning values to Z80 registers, 
setting or reseting flags, copying values into the memory.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initSettings:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;init&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment:&lt;/code&gt;&lt;/em&gt; ( &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regAssignment&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flagStatus&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment&lt;/code&gt;&lt;/em&gt; ) &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regAssignment:&lt;/code&gt;&lt;/em&gt;  &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerSpec&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;a&lt;/strong&gt; | &lt;strong&gt;A&lt;/strong&gt; | &lt;strong&gt;b&lt;/strong&gt; | &lt;strong&gt;B&lt;/strong&gt; | &lt;strong&gt;c&lt;/strong&gt; | &lt;strong&gt;C&lt;/strong&gt; | &lt;strong&gt;d&lt;/strong&gt; | &lt;strong&gt;D&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;e&lt;/strong&gt; | &lt;strong&gt;E&lt;/strong&gt;	| &lt;strong&gt;h&lt;/strong&gt; | &lt;strong&gt;H&lt;/strong&gt; | &lt;strong&gt;l&lt;/strong&gt; | &lt;strong&gt;L&lt;/strong&gt; | &lt;strong&gt;xl&lt;/strong&gt; | &lt;strong&gt;XL&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;xh&lt;/strong&gt; | &lt;strong&gt;XH&lt;/strong&gt; |	&lt;strong&gt;yl&lt;/strong&gt; | &lt;strong&gt;YL&lt;/strong&gt; | &lt;strong&gt;yh&lt;/strong&gt; | &lt;strong&gt;YH&lt;/strong&gt; |	&lt;strong&gt;ixl&lt;/strong&gt;| &lt;strong&gt;IXL&lt;/strong&gt; | &lt;strong&gt;IXl&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;ixh&lt;/strong&gt;| &lt;strong&gt;IXH&lt;/strong&gt; | &lt;strong&gt;IXh&lt;/strong&gt; | &lt;strong&gt;iyl&lt;/strong&gt; | &lt;strong&gt;IYL&lt;/strong&gt; | &lt;strong&gt;IYl&lt;/strong&gt; | &lt;strong&gt;iyh&lt;/strong&gt; | &lt;strong&gt;IYH&lt;/strong&gt; | &lt;strong&gt;IYh&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;i&lt;/strong&gt; | &lt;strong&gt;I&lt;/strong&gt; | &lt;strong&gt;r&lt;/strong&gt; | &lt;strong&gt;R&lt;/strong&gt; | &lt;strong&gt;bc&lt;/strong&gt; | &lt;strong&gt;BC&lt;/strong&gt; |	&lt;strong&gt;de&lt;/strong&gt; | &lt;strong&gt;DE&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;hl&lt;/strong&gt; | &lt;strong&gt;HL&lt;/strong&gt; | &lt;strong&gt;sp&lt;/strong&gt; | &lt;strong&gt;SP&lt;/strong&gt; | &lt;strong&gt;ix&lt;/strong&gt; | &lt;strong&gt;IX&lt;/strong&gt; | &lt;strong&gt;iy&lt;/strong&gt; | &lt;strong&gt;IY&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;af’&lt;/strong&gt; | &lt;strong&gt;AF’&lt;/strong&gt; | &lt;strong&gt;bc’&lt;/strong&gt; | &lt;strong&gt;BC’&lt;/strong&gt;	| &lt;strong&gt;de’&lt;/strong&gt; | &lt;strong&gt;DE’&lt;/strong&gt; | &lt;strong&gt;hl’&lt;/strong&gt; | &lt;strong&gt;HL’&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flagStatus:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;.z&lt;/strong&gt; | &lt;strong&gt;.Z&lt;/strong&gt; | &lt;strong&gt;.nz&lt;/strong&gt; | &lt;strong&gt;.NZ&lt;/strong&gt; |	&lt;strong&gt;.c&lt;/strong&gt; | &lt;strong&gt;.C&lt;/strong&gt; | &lt;strong&gt;.nc&lt;/strong&gt; | &lt;strong&gt;.NC&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.pe&lt;/strong&gt; | &lt;strong&gt;.PE&lt;/strong&gt; | &lt;strong&gt;.po&lt;/strong&gt; | &lt;strong&gt;.PO&lt;/strong&gt;	| &lt;strong&gt;.p&lt;/strong&gt; | &lt;strong&gt;.P&lt;/strong&gt; | &lt;strong&gt;.m&lt;/strong&gt; | &lt;strong&gt;.M&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.n&lt;/strong&gt;| &lt;strong&gt;.N&lt;/strong&gt; | &lt;strong&gt;.a&lt;/strong&gt; | &lt;strong&gt;.A&lt;/strong&gt; | &lt;strong&gt;.h&lt;/strong&gt; | &lt;strong&gt;.H&lt;/strong&gt; | &lt;strong&gt;.nh&lt;/strong&gt; | &lt;strong&gt;.NH&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.3&lt;/strong&gt; | &lt;strong&gt;.n3&lt;/strong&gt; | &lt;strong&gt;.N3&lt;/strong&gt; | &lt;strong&gt;.5&lt;/strong&gt; | &lt;strong&gt;.n5&lt;/strong&gt;| &lt;strong&gt;.N5&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment:&lt;/code&gt;&lt;/em&gt;	 &lt;strong&gt;[&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;]&lt;/strong&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is a short sample:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
{
    bc: 0;
    hl: CustomBuffer;
    .z;
    .nc;
    [#4000]: myLogoArray;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; declaration sets the valuu of the &lt;strong&gt;BC&lt;/strong&gt; and &lt;strong&gt;HL&lt;/strong&gt; register pairs to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CustomBuffer&lt;/code&gt;, respectively.
The Zero flag is set, while Carry is reset. The declaration copies the contents of the &lt;code class=&quot;highlighter-rouge&quot;&gt;myLogoArray&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address.&lt;/p&gt;

&lt;p&gt;With an alternative &lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment&lt;/code&gt; syntax, you can declare the length of a byte array before copying it into the memory.
For example, the following code snippet copies only the first 32 bytes to the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
{
    [#4000]: myLogoArray:32;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test-blocks&quot;&gt;Test Blocks&lt;/h2&gt;

&lt;p&gt;You can declare default and parameterized test cases within test blocks:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testBlock:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;test&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
    ( &lt;strong&gt;category&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOptions?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setupCode?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testParams?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testCase*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrange?*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanupCode?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Each test must have a uniuque indentifier, and may declare a category, which is reserved for future extension. Of course,
multiple tests may have the same category. The only required part of a test is the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; declaration that describes what code
to run within the test.&lt;/p&gt;

&lt;h3 id=&quot;test-options&quot;&gt;Test Options&lt;/h3&gt;

&lt;p&gt;Tests may have options the engine uses when running them:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOptions:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;with&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;timeout&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;di&lt;/strong&gt; | &lt;strong&gt;ei&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The timeout option sets the timeout value for the specified test. When it expires, the engine aborts the test, and thus 
you can even create code with infinite loops, it does not freezes the test engine.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The default timeout value in 100 milliseconds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With the &lt;code class=&quot;highlighter-rouge&quot;&gt;ei&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;di&lt;/code&gt; options you can enable or disable interrupts explicitly before running any code. These 
options are just helpers. For tighter control, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;EI&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DI&lt;/code&gt; Z80 instructions explicitly in your code.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;By default, interrupts are enabled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The following options run a test case with 40 milliseconds of timeout and disable the interrupt before starting the code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with timeout 40, di;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;running-code-in-tests&quot;&gt;Running Code in Tests&lt;/h3&gt;

&lt;p&gt;You can declare three kinds of code to run in a single test. Setup code runs once before each test cases, Cleanup code once 
after all cases completed (either successfully or failed). The Act code runs for every test cases.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setupCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;setup&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;act:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;act&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanupCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;cleanup&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;call&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;start&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;stop&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;halt&lt;/strong&gt; )&lt;/p&gt;

&lt;p&gt;You have three ways to invoke code:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;&lt;/strong&gt; uses the Z80 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt; instruction to call the code with the specified address. Your code should have 
a &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; instruction. When the code successfully executes the &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; statement, the engine completes the test code.&lt;/li&gt;
  &lt;li&gt;With the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;&lt;/strong&gt; combination, you can explicitly specify a start and a stop address. The engine jumps
to the start address, and completes the test code as soon as it reaches the stop address. It does not executes the instruction
at the stop address.&lt;/li&gt;
  &lt;li&gt;With the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;halt&lt;/code&gt;&lt;/strong&gt; combination the test engine starts the code at the specified address, and completes it
when it reaches a &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; statement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-parameters-and-test-cases&quot;&gt;Test Parameters and Test Cases&lt;/h3&gt;

&lt;p&gt;You can define parameterized test cases. You name test parameters, and test cases declare values to substitute a
particular parameter:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testParams:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;params&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testCase:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;case&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of course, the number of parameters and expressions after the &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; keyword must match for each test cases.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Soon, you will see a complete sample that demonstrates these concepts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;arrange-declarations&quot;&gt;Arrange Declarations&lt;/h3&gt;

&lt;p&gt;Each test block has an &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; declaration that runs before the engine invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; code of a test case.
It has the same assignment syntax, as the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; construct of a test set:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrange:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;arrange&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;assertions&quot;&gt;Assertions&lt;/h3&gt;

&lt;p&gt;After the test code ran, you can run assertions. Assertions are a list of Boolean expressions, and the test engine 
evaluates them in their declaration order. All of them should be true to make the test case successful:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;assert&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; ( &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;)*&lt;code class=&quot;highlighter-rouge&quot;&gt;+*&lt;/code&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can use special assertion expressions:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addrSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;[&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;]&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reachSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;.&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;.&amp;gt;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memReadSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;|&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;|&amp;gt;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memWriteSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;||&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;||&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;These assertions retrieves a byte array. This may contain only a single byte (only one address specified)
or a sequence of bytes (both a start address and an inclusive end address is specified).&lt;/p&gt;

&lt;p&gt;An &lt;code class=&quot;highlighter-rouge&quot;&gt;addrSpec&lt;/code&gt; retrives the contenst of memory specified by the address range. Each byte in the array is the
copy of the corresponding memory address.&lt;/p&gt;

&lt;p&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;reachSpec&lt;/code&gt; byte array each byte indicates if the test’s control flow reached that address 
(the instruction at that address was executed) with a Boolean value. Similarly, the arrays retrieved by 
&lt;code class=&quot;highlighter-rouge&quot;&gt;memReadSpec&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;memWriteSpec&lt;/code&gt; indicate if the specified memory address was read, or written, respectively.&lt;/p&gt;

&lt;p&gt;Let’s see an example of using these assertions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    data
    {
        str100: &quot;00100&quot;;
        str1000:  &quot;001000&quot;;
        str12345: &quot;12345&quot;;
        str11211: &quot;11211&quot;;
        str23456: &quot;23456&quot;;
    }

    test BufferIncEachByteWorks
    {
        params value, result;
        case str100, str11211;
        case str12345, str23456;
        case str1000, str11211;
        arrange
        {
            hl: ConversionBuffer;
            b: 5;
            [ConversionBuffer]:value;
        }

        act call IncLoop;

        assert
        {
            [ConversionBuffer..ConversionBuffer+4] == result;
            &amp;lt;. IncLoop .&amp;gt;;
            &amp;lt;| ConversionBuffer .. ConversionBuffer + 4 |&amp;gt;;
            &amp;lt;|| ConversionBuffer .. ConversionBuffer + 4 ||&amp;gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; method accepts a bufferr address in &lt;strong&gt;HL&lt;/strong&gt; and 
a byte count in &lt;strong&gt;B&lt;/strong&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; increments each byte by 1 within the
buffer. As you can see, the assert section checks these conditions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The contents of the conversion buffer is the one specified in &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The code executions reaches the &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; address.&lt;/li&gt;
  &lt;li&gt;The contents of the buffer (5 bytes starting from &lt;code class=&quot;highlighter-rouge&quot;&gt;ConversionBuffer&lt;/code&gt;) is read.&lt;/li&gt;
  &lt;li&gt;The contents of the buffer is written.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-sample&quot;&gt;Test Sample&lt;/h3&gt;

&lt;p&gt;Here is a short sample that demonstrates the concepts you learned:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    test AddAAndBCallWorksAsExpected
    {
        params parA, parB, parExpected;
        case 1, 2, 3;
        case 2, 3, 5;
        case 6, 8, 14;

        arrange
        {
            a: parA;
            b: parB;
        }

        act call AddAAndB;

        assert 
        {
            a == parExpected;
        }
    }

    test AddAAndBWithStartWorksAsExpected
    {
        arrange
        {
            a: 3;
            b: 5;
        }

        act start AddAAndBWithStop stop StopPoint;

        assert 
        {
            a == 8;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The code file behind this test is the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Start:
	.org #8000

; You can invoke this test with 'call AddAAndB'
AddAAndB:
    add a,b
    ret

; You can invoke this test with 'start AddAAndBWithStop stop StopPoint'
AddAAndBWithStop:
    add a,b
StopPoint:
    nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first test, &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndBCallWorksAsExpected&lt;/code&gt;, has three test cases with parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;, 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;parExpected&lt;/code&gt;, respectively. The engine executes each test case with these steps:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sets the &lt;strong&gt;A&lt;/strong&gt; and &lt;strong&gt;B&lt;/strong&gt; CPU registers with the current value of &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;. For the first case, 
these are 1, and 2. The second case runs with 2, and 3.&lt;/li&gt;
  &lt;li&gt;Calls the &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndB&lt;/code&gt; subroutine, that executes the &lt;code class=&quot;highlighter-rouge&quot;&gt;add a,b&lt;/code&gt; instruction, and then completes the 
call with &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Checks if the content of &lt;strong&gt;A&lt;/strong&gt; equals with the expected result, as declared in &lt;code class=&quot;highlighter-rouge&quot;&gt;parExpected&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The second test has only a default case. It sets up &lt;strong&gt;A&lt;/strong&gt; and &lt;strong&gt;B&lt;/strong&gt; explicitly in the &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; section 
and checks the result in &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;. You can observe that it does not call into the code, instead, it the test 
jumps to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndBWithStop&lt;/code&gt; address, and completes when it reaches &lt;code class=&quot;highlighter-rouge&quot;&gt;StopPoint&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">In the following section, I will use a kind of abstract syntax notation to describe the grammar of the SpectNetIde test language. Bold characters mark terminal symbols (keywords and other tokens), while italic strings ara non-terminal symbols. The ? after a symbol means that it’s optional. A * means zero, one, or more occurrence. + means one or more occurrence. The | character separates options, exactly one of them can be used. The language uses parantheses to specify groups of tokens.</summary></entry></feed>