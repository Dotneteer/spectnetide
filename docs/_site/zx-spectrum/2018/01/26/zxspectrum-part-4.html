<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,400i,700,700i|Roboto:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&amp;subset=greek,greek-ext" rel="stylesheet">

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>ZX Spectrum IDE — Part #4: Emulating the Z80 CPU | SpectNet IDE</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="ZX Spectrum IDE — Part #4: Emulating the Z80 CPU" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Starting with this article, you will see tons of C# code. Here, I treat the main concepts and high-level implementation details of the Z80 CPU emulation." />
<meta property="og:description" content="Starting with this article, you will see tons of C# code. Here, I treat the main concepts and high-level implementation details of the Z80 CPU emulation." />
<link rel="canonical" href="http://localhost:4000/zx-spectrum/2018/01/26/zxspectrum-part-4.html" />
<meta property="og:url" content="http://localhost:4000/zx-spectrum/2018/01/26/zxspectrum-part-4.html" />
<meta property="og:site_name" content="SpectNet IDE" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-26T13:20:00+01:00" />
<script type="application/ld+json">
{"headline":"ZX Spectrum IDE — Part #4: Emulating the Z80 CPU","dateModified":"2018-01-26T13:20:00+01:00","datePublished":"2018-01-26T13:20:00+01:00","url":"http://localhost:4000/zx-spectrum/2018/01/26/zxspectrum-part-4.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/zx-spectrum/2018/01/26/zxspectrum-part-4.html"},"description":"Starting with this article, you will see tons of C# code. Here, I treat the main concepts and high-level implementation details of the Z80 CPU emulation.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <!-- HEADER -->
    <div class="outer">
        <header class="inner">
          <h1 class="post-title">ZX Spectrum IDE — Part #4: Emulating the Z80 CPU</h1>
        </header>
    </div>

    <!-- MAIN CONTENT -->

    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="main-columns">
            <section class="main-area">
              <div class="post-attrs">
                <span class="post-label">Published</span>
                <span class="post-value">26 Jan 2018</span>
                <span class="post-label">Category</span>
                <span class="post-value">ZX-Spectrum</span>
              </div>
              <!-- LINKS TO PREVIOUS/NEXT -->
              <div class="links-top">
                <div class="link">
                  
                    <a class="prev" href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">&laquo; ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU</a>
                  
                </div>
                <div class="link-right">
                  
                    <a class="next" href="/zx-spectrum/2018/02/01/zxspectrum-part-5.html">ZX Spectrum IDE — Part #5: Implementing Z80 instructions (1) &raquo;</a>
                  
                </div>
              </div>
              <div class="content-separator"></div>

              <p>Starting with this article, you will see tons of C# code. Here, I treat the main concepts and high-level implementation details of the Z80 CPU emulation.</p>

<p class="note"><strong>Note</strong>: You may ask, why I have chosen the C# programming language—and why not another, e.g., C++. I have a short and a long answer. The short answer is this: I’ve been working with .NET since 2000, and I’m a rabid fan of the framework and the C# programming language. I will share the longer answer as a separate blog post in the future.</p>

<p>In the <a href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">previous post</a>, I already treated the fundamentals of the Z80 CPU, those that were essential when I designed the emulation.</p>

<h3 id="design-and-implementation-principles-used">Design and Implementation Principles Used</h3>

<p>I graduated as a software engineer, back in 1992, and participated over 50 software development projects in almost every role, excluding sales and marketing related positions. In the recent years I’ve been working as an agile coach and architect, still very close to software construction.</p>

<p>When I started <a href="https://github.com/Dotneteer/spectnetide">SpectNetIde</a>, I decided to use my favorite software design principles, namely S.O.L.I.D., and K.I.S.S. I could tell a lot about them, but I’m sure, you know them too—or if not, you can find the info on the internet in a minute. To summarize the value of these principles, I’d say, they help to design and implement software with automatic testing in mind.</p>

<h3 id="devices">Devices</h3>

<p>Although this post is about Z80 CPU emulation, the long-term objective is a ZX Spectrum IDE, which is a combination of a ZX Spectrum Emulator and a set of Development Tools.</p>

<p>Keeping this thought in mind, a ZX Spectrum emulator is a cohesive set of devices working together. Such a device is the Z80 CPU, the memory, the keyboard, the video display, the tape, and so on. So, one of the most important abstraction is <code class="highlighter-rouge">IDevice</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IDevice</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">Reset</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, <code class="highlighter-rouge">IDevice</code> is a simple concept: you can <code class="highlighter-rouge">Reset()</code> it.</p>

<p class="note"><strong>Note</strong>: In the <strong>SpectNetIde</strong> source code, you will find a lot of comments. In the blog post, I omit most of the comments for the sake of brevity. Whenever it has value, I include the namespaces of types, as they help you to lookup the corresponding source code file.</p>

<h3 id="the-z80-cpu-as-a-device">The Z80 CPU as a Device</h3>

<p>Z80 is a more versatile device, as the definition of <code class="highlighter-rouge">IZ80Cpu</code> shows it:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IZ80Cpu</span> <span class="p">:</span> <span class="n">IClockBoundDevice</span>
    <span class="p">{</span>
        <span class="c1">// --- CPU State</span>
        <span class="n">Registers</span> <span class="n">Registers</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Z80StateFlags</span> <span class="n">StateFlags</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">UseGateArrayContention</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">IFF1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">IFF2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">byte</span> <span class="n">InterruptMode</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">IsInterruptBlocked</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">IsInOpExecution</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">// --- Devices closely related to CPU</span>
        <span class="n">IMemoryDevice</span> <span class="n">MemoryDevice</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">IPortDevice</span> <span class="n">PortDevice</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">// --- Common actions</span>
        <span class="k">void</span> <span class="nf">ExecuteCpuCycle</span><span class="p">();</span>
        <span class="k">void</span> <span class="nf">Delay</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticks</span><span class="p">);</span>
        <span class="k">void</span> <span class="nf">SetResetSignal</span><span class="p">();</span>
        <span class="k">void</span> <span class="nf">ReleaseResetSignal</span><span class="p">();</span>

        <span class="c1">// --- Tooling support</span>
        <span class="kt">int</span> <span class="nf">GetCallInstructionLength</span><span class="p">();</span>
        <span class="n">IStackDebugSupport</span> <span class="n">StackDebugSupport</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">IBranchDebugSupport</span> <span class="n">BranchDebugSupport</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">MaskableInterruptModeEntered</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The CPU is a state machine. Several properties (such as <code class="highlighter-rouge">Registers</code>, <code class="highlighter-rouge">StateFlags</code>, and the others) define its current state. When the CPU executes an instruction (this is the responsibility of <code class="highlighter-rouge">ExecuteCpuCycle()</code>), the current state changes accordingly.</p>

<p><code class="highlighter-rouge">IZ80Cpu</code> derives from an interface, <code class="highlighter-rouge">IClockBoundDevice</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IClockBoundDevice</span> <span class="p">:</span> <span class="n">IDevice</span>
    <span class="p">{</span>
        <span class="kt">long</span> <span class="n">Tacts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">IClockBoundDevice</code> represents a general device that works with a clock signal. Its <code class="highlighter-rouge">Tacts</code> properties show the number of clock cycles spent since the system started.</p>

<h3 id="the-state-of-the-cpu">The State of the CPU</h3>

<p>As a state machine, the Z80 needs to store its current state vector that is composed of registers, internal state flags of the CPU, and a few other attributes. Some instructions read and write the memory, transfer data between the CPU and I/O devices. You can take them into account as a part of the CPU’s state, too.</p>

<h4 id="registers-and-flags">Registers and Flags</h4>

<p>As you already learned, the 8-bit registers of Z80 can be paired into 16-bit registers, for example, <strong>B</strong> and <strong>C</strong> together give <strong>BC</strong>. Because of performance reason, I use <code class="highlighter-rouge">StructLayout</code>, and <code class="highlighter-rouge">FieldOffset</code> attributes to define the data structure for Z80 registers:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Runtime.CompilerServices</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Runtime.InteropServices</span><span class="p">;</span>

<span class="c1">// ReSharper disable InconsistentNaming</span>

<span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Cpu</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">StructLayout</span><span class="p">(</span><span class="n">LayoutKind</span><span class="p">.</span><span class="n">Explicit</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Registers</span>
    <span class="p">{</span>
        <span class="c1">// --- Main register set</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">AF</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">2</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">BC</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">4</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">DE</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">6</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">HL</span><span class="p">;</span>

        <span class="c1">// --- Alternate register set</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">8</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">_AF_</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">10</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">_BC_</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">12</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">_DE_</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">14</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">_HL_</span><span class="p">;</span>

        <span class="c1">// ---Special purpose registers</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">16</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">IX</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">18</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">IY</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">20</span><span class="p">)]</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">22</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">PC</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">24</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">SP</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">26</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">ushort</span> <span class="n">WZ</span><span class="p">;</span>

        <span class="c1">// --- 8-bit register access</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">1</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">A</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">F</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">B</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">2</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">C</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">5</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">D</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">4</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">E</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">7</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">H</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">6</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">L</span><span class="p">;</span>

        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">17</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">XH</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">16</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">XL</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">19</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">YH</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">18</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">YL</span><span class="p">;</span>

        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">21</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">I</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">20</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">R</span><span class="p">;</span>

        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">27</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">WZh</span><span class="p">;</span>
        <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">26</span><span class="p">)]</span>
        <span class="k">public</span> <span class="kt">byte</span> <span class="n">WZl</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="n">SFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">S</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">ZFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">Z</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">R5Flag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">R5</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">HFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">H</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">R3Flag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">R3</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">PFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">PV</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">NFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">N</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">CFlag</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">F</span> <span class="p">&amp;</span> <span class="n">FlagsSetMask</span><span class="p">.</span><span class="n">C</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">[StructLayout(LayoutKind.Explicit)]</code> annotation of the <code class="highlighter-rouge">Registers</code> class takes care that we can explicitly control the precise position of each member of the class in unmanaged memory. As you see from the listing, I decorated all fields with the <code class="highlighter-rouge">FieldOffset</code> attribute to indicate the position of that field within Registers.</p>

<p>This is how 16-bit registers and their constituting 8-bit pairs are mapped together:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[FieldOffset(2)]</span>
<span class="k">public</span> <span class="kt">ushort</span> <span class="n">BC</span><span class="p">;</span>
<span class="na">[FieldOffset(3)]</span>
<span class="k">public</span> <span class="kt">byte</span> <span class="n">B</span><span class="p">;</span>
<span class="na">[FieldOffset(2)]</span>
<span class="k">public</span> <span class="kt">byte</span> <span class="n">C</span><span class="p">;</span>
</code></pre></div></div>

<p>The <strong>B</strong> and <strong>C</strong> fields take the locations at offset 3 and 2, respectively, so they precisely overlay with <strong>BC</strong>. When I assign a value to <strong>BC</strong>, it affects the memory area of <strong>B</strong> and <strong>C</strong>, and thus immediately changes the value of these 8-bit registers, and vice-versa.</p>

<p class="note"><strong>Note</strong>: <code class="highlighter-rouge">StructLayout</code> and <code class="highlighter-rouge">FieldOffset</code> together can help to implement the <code class="highlighter-rouge">union</code> construct of C/C++.</p>

<p>You can see a register you probably have not heard about yet, its <strong>WZ</strong>. Well, this is an internal register of the Z80 CPU that helps to put a 16-bit register’s value onto the address bus. The only way to load the contents of these 16-bit registers is via the data bus. Two transfers will be necessary along the data bus to transfer 16 bits, and this is where <strong>WZ</strong> helps. You cannot reach the contents of this internal register programmatically.</p>

<p>The registers class also has read-only properties to obtain field values. These accessors utilize the <code class="highlighter-rouge">FlagSetMask</code> type to get the bits to mask out the individual flags:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Cpu</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">FlagsSetMask</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">S</span> <span class="p">=</span> <span class="m">0x80</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">Z</span> <span class="p">=</span> <span class="m">0x40</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">R5</span> <span class="p">=</span> <span class="m">0x20</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">H</span> <span class="p">=</span> <span class="m">0x10</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">R3</span> <span class="p">=</span> <span class="m">0x08</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">PV</span> <span class="p">=</span> <span class="m">0x04</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">N</span> <span class="p">=</span> <span class="m">0x02</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">C</span> <span class="p">=</span> <span class="m">0x01</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">SZPV</span> <span class="p">=</span> <span class="n">S</span> <span class="p">|</span> <span class="n">Z</span> <span class="p">|</span> <span class="n">PV</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">NH</span> <span class="p">=</span> <span class="n">N</span> <span class="p">|</span> <span class="n">H</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">R3R5</span> <span class="p">=</span> <span class="n">R3</span> <span class="p">|</span> <span class="n">R5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="note"><strong>Note</strong>: Initially I used an enum type, but later refactored it to byte constants. This approach made my flag-related operations shorter as I could avoid unnecessary type casts.</p>

<p>Similarly to <code class="highlighter-rouge">FlagSetMask</code>, I have a collection of byte constants that are more useful when setting or resetting individual flags:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Cpu</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">FlagsResetMask</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">S</span> <span class="p">=</span> <span class="m">0x7F</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">Z</span> <span class="p">=</span> <span class="m">0xBF</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">R5</span> <span class="p">=</span> <span class="m">0xDF</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">H</span> <span class="p">=</span> <span class="m">0xEF</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">R3</span> <span class="p">=</span> <span class="m">0xF7</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">PV</span> <span class="p">=</span> <span class="m">0xFB</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">N</span> <span class="p">=</span> <span class="m">0xFD</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">byte</span> <span class="n">C</span> <span class="p">=</span> <span class="m">0xFE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="signal-and-interrupt-status">Signal and Interrupt Status</h4>

<p>In each execution cycle, the Z80 checks signals. I created an enum type, <code class="highlighter-rouge">Z80StateFlags</code>, to represent them:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Cpu</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Flags</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">enum</span> <span class="n">Z80StateFlags</span>
    <span class="p">{</span>
        <span class="n">None</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">Int</span> <span class="p">=</span> <span class="m">0x01</span><span class="p">,</span>
        <span class="n">Nmi</span> <span class="p">=</span> <span class="m">0x02</span><span class="p">,</span>
        <span class="n">Reset</span> <span class="p">=</span> <span class="m">0x04</span><span class="p">,</span>
        <span class="n">Halted</span> <span class="p">=</span> <span class="m">0x08</span><span class="p">,</span>
        <span class="n">InvInt</span> <span class="p">=</span> <span class="m">0xFF</span> <span class="p">-</span> <span class="n">Int</span><span class="p">,</span>
        <span class="n">InvNmi</span> <span class="p">=</span> <span class="m">0xFF</span> <span class="p">-</span> <span class="n">Nmi</span><span class="p">,</span>
        <span class="n">InvReset</span> <span class="p">=</span> <span class="m">0xFF</span> <span class="p">-</span> <span class="n">Reset</span><span class="p">,</span>
        <span class="n">InvHalted</span> <span class="p">=</span> <span class="m">0xFF</span> <span class="p">-</span> <span class="n">Halted</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you see, <code class="highlighter-rouge">Z80StateFlags</code> contains value members (with the <code class="highlighter-rouge">Inv</code> prefix) that can mask out the individual flag values. The benefit of this way is that I can keep the states of all signals in a variable of <code class="highlighter-rouge">Z80StateFlags</code> and use a simple condition (<code class="highlighter-rouge">state == 0</code>, where <code class="highlighter-rouge">state</code> is a <code class="highlighter-rouge">Z80StateFlags</code>) to check if any of the signals is set.</p>

<p class="note"><strong>Note</strong>: <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Nmi</code>, and <code class="highlighter-rouge">Reset</code> represent the CPU signals with the same names. <code class="highlighter-rouge">Halted</code> is an output signal that the CPU uses to tell the external devices it is in HALTed state.</p>

<p>Earlier, you saw that the <code class="highlighter-rouge">IZ80Cpu</code> interface defines a few members related to interrupt state:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IZ80Cpu</span> <span class="p">:</span> <span class="n">IClockBoundDevice</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">bool</span> <span class="n">IFF1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">IFF2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">byte</span> <span class="n">InterruptMode</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">IsInterruptBlocked</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>IFF1</strong> and <strong>IFF2</strong> are two flip-flops (flags) within the Z80. The CPU uses <strong>IFF1</strong> to check if a maskable interrupt is enabled. When the CPU starts, this flag is set to zero (disabled). The <strong>EI</strong> instruction sets it to 1. The purpose of <strong>IFF2</strong> is to save the status of <strong>IFF1</strong> when a non-maskable interrupt occurs. When a non-maskable interrupt is accepted, <strong>IFF1</strong> resets to prevent further interrupts until re-enabled by the program. Therefore, after a non-maskable interrupt is accepted, maskable interrupts are disabled, but the previous state of <strong>IFF1</strong> is saved so that the complete state of the CPU just before the non-maskable interrupt can be restored when the interrupt routine completes.</p>

<p>The <code class="highlighter-rouge">InterruptMode</code> property retrieves the current mode set by any of the <strong>IM 0</strong>, <strong>IM 1</strong>, or <strong>IM 2</strong> instructions.</p>

<p>The CPU samples the <strong>INT</strong> signal with the rising edge of the final clock at the end of any instruction. Even if the maskable interrupt is enabled (<strong>IFF1</strong> is true), the normal flow of execution cannot be immediately interrupted. The implementation of the CPU uses the <code class="highlighter-rouge">IsInterruptBlocked</code> property to handle this situation.</p>

<h3 id="clock-cycles">Clock Cycles</h3>

<p>Timing is everything. The Spectrum emulator could not work without it—precisely timed graphics effects would fail, so your favorite games would not run the way you expect.</p>

<p>The <code class="highlighter-rouge">IZ80Cpu</code> interface uses it ancestor’s (<code class="highlighter-rouge">IClockBoundDevice</code>) member, <code class="highlighter-rouge">Tacts</code> to manage the time spent since the system had started:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">Tacts</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Tacts</code> counts the clock cycles. Its 64 bits are long enough to count the clock beats until the end of times. You can quickly check this statement: divide the <strong>$7fff_ffff_ffff_ffff</strong> value with 3.500.000, the clock frequency, then with 86.400, the seconds in a day. The result shows the number or days (almost 30.5 million) <code class="highlighter-rouge">Tacts</code> can be used without overflow. It is a surprisingly high number!</p>

<p>There’s no reason to measure the CPU time in absolute units (let’s say, in nanoseconds). It would just make the things more complicated. Of course, when emulating real-time behavior, the time indicated by <code class="highlighter-rouge">Tacts</code> should be converted to absolute time. As you will learn it from a future article, you need this conversion about 50 or 60 times in a single second. These numbers are almost nothing compared to the 3.500.000 clock cycles per second.</p>

<h3 id="opcode-processing-state">Opcode Processing State</h3>

<p>In the <a href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">previous post</a>, you learned that Z80 has instructions with one, two, or three-byte opcodes.</p>

<p>In a single CPU cycle (<strong>M1</strong> machine cycle) the CPU reads only one byte from the program. I use the values of two enum types (<code class="highlighter-rouge">OpPrefixMode</code>, and <code class="highlighter-rouge">OpIndexMode</code>) to keep up the current opcode processing state:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span>  <span class="k">partial</span> <span class="k">class</span> <span class="nc">Z80Cpu</span><span class="p">:</span> <span class="n">IZ80Cpu</span><span class="p">,</span> <span class="n">IZ80CpuTestSupport</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">public</span> <span class="k">enum</span> <span class="n">OpIndexMode</span>
    <span class="p">{</span>
        <span class="n">None</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">IX</span><span class="p">,</span>
        <span class="n">IY</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">enum</span> <span class="n">OpPrefixMode</span> <span class="p">:</span> <span class="kt">byte</span>
    <span class="p">{</span>
        <span class="n">None</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">Extended</span><span class="p">,</span>
        <span class="n">Bit</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="the-memory-and-io-devices">The Memory and I/O Devices</h3>

<p>As I mentioned, the memory and the I/O devices are the part of the CPU’s state. The result of operations may depend on the values read from the memory or a device. Similarly, calculated values are persisted in the memory or sent to devices.</p>

<p>Just like the Z80 CPU, the memory and I/O port are devices, and thus implement the <code class="highlighter-rouge">IDevice</code> interface. I represent these components with the <code class="highlighter-rouge">IMemoryDevice</code> and <code class="highlighter-rouge">IPortDevice</code> interfaces, respectively.</p>

<p>Here, I show you only those interface methods that the CPU uses. This is <code class="highlighter-rouge">IMemoryDevice</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IMemoryDevice</span> <span class="p">:</span> <span class="n">ISpectrumBoundDevice</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="kt">byte</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">noContention</span> <span class="p">=</span> <span class="k">false</span><span class="p">);</span>
        <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">byte</span> <span class="k">value</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I guess this definition is straightforward. The only thing you may not understand at this moment is the <code class="highlighter-rouge">noContention</code> argument of <code class="highlighter-rouge">Read()</code>. Right now, just take it as if it were not there. In a future article—not very long time from now—I will explain it with all other aspects of memory and I/O contention.</p>

<p>The definition of <code class="highlighter-rouge">IPortDevice</code> is very similar to <code class="highlighter-rouge">IMemoryDevice</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IPortDevice</span> <span class="p">:</span> <span class="n">ISpectrumBoundDevice</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="kt">byte</span> <span class="nf">ReadPort</span><span class="p">(</span><span class="kt">ushort</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">void</span> <span class="nf">WritePort</span><span class="p">(</span><span class="kt">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">data</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, you know how the state of the Z80 is stored. Let’s see how the emulation works!</p>

<h3 id="cpu-implementation">CPU Implementation</h3>

<p>I encapsulated all functionality of the Z80 CPU into the <code class="highlighter-rouge">Z80Cpu</code> class, which has this definition:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Cpu</span>
<span class="p">{</span>
    <span class="k">public</span>  <span class="k">partial</span> <span class="k">class</span> <span class="nc">Z80Cpu</span><span class="p">:</span> <span class="n">IZ80Cpu</span><span class="p">,</span> <span class="n">IZ80CpuTestSupport</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You already know that <code class="highlighter-rouge">IZ80Cpu</code> is an abstraction of the CPU. However, you can see that the <code class="highlighter-rouge">Z80Cpu</code> class implements another interface, <code class="highlighter-rouge">IZ80CpuTestSupport</code>. But why?</p>

<p>The <strong>S</strong> in S.O.L.I.D stands for <em>Single Responsibility</em>. <code class="highlighter-rouge">IZ80CpuTestSupport</code> defines those methods that are not part of the CPU’s abstraction, but implementing them helps in testing if the implementation works correctly:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Spect.Net.SpectrumEmu.Abstraction.Devices</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IZ80CpuTestSupport</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">SetTacts</span><span class="p">(</span><span class="kt">long</span> <span class="n">tacts</span><span class="p">);</span>
        <span class="k">void</span> <span class="nf">SetInterruptMode</span><span class="p">(</span><span class="kt">byte</span> <span class="n">im</span><span class="p">);</span>
        <span class="n">Z80Cpu</span><span class="p">.</span><span class="n">OpPrefixMode</span> <span class="n">PrefixMode</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Z80Cpu</span><span class="p">.</span><span class="n">OpIndexMode</span> <span class="n">IndexMode</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">void</span> <span class="nf">BlockInterrupt</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With the methods of <code class="highlighter-rouge">IZ80CpuTestSupport</code>, I can easily disturb the normal operation of the CPU; for example, I can modify its clock, or externally block interrupts. If I’d add these operations to <code class="highlighter-rouge">IZ80Cpu</code>, I could make a programming error, since through an <code class="highlighter-rouge">IZ80Cpu</code> instance I could change the clock. Putting it into a separate interface, I can avoid these issues. Of course, in the concrete implementation of the Spectrum emulator, I must use a reference to an <code class="highlighter-rouge">IZ80Cpu</code> object and not to a <code class="highlighter-rouge">Z80Cpu</code> instance to prevent such a mistake.</p>

<h3 id="multiple-files">Multiple Files</h3>

<p>I defined <code class="highlighter-rouge">Z80Cpu</code> as a partial class, because I implemented it in multiple files:</p>

<table>
  <thead>
    <tr>
      <th>File</th>
      <th>Role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Z80Cpu.cs</strong></td>
      <td>Core routines</td>
    </tr>
    <tr>
      <td><strong>Z80AluHelpers.cs</strong></td>
      <td>Helper methods I use in ALU operations</td>
    </tr>
    <tr>
      <td><strong>Z80Operations.cs</strong></td>
      <td>The implementation of standard Z80 instructions (with no opcode prefix)</td>
    </tr>
    <tr>
      <td><strong>Z80ExtendedOperations.cs</strong></td>
      <td>The implementation of extended Z80 instructions (with <strong>$ED</strong> opcode prefix)</td>
    </tr>
    <tr>
      <td><strong>Z80BitOperations.cs</strong></td>
      <td>The implementation of Z80 bit manipulation instructions (with <strong>$CB</strong> opcode prefix)</td>
    </tr>
    <tr>
      <td><strong>Z80IndexedOperations.cs</strong></td>
      <td>The implementation of indexed Z80 instructions (with <strong>$DD</strong> or <strong>$FD</strong> opcode prefix)</td>
    </tr>
    <tr>
      <td><strong>Z80IndexedBitOperations.cs</strong></td>
      <td>The implementation of indexed Z80 bit manipulation instructions (with <strong>$DD</strong>, <strong>$CB</strong>, or <strong>$FD</strong>, <strong>$CB</strong> opcode prefixes)</td>
    </tr>
    <tr>
      <td><strong>Z80Debug.cs</strong></td>
      <td>The part of the CPU implementation used by the debugger tooling in <strong>SpectNetIde</strong>.</td>
    </tr>
  </tbody>
</table>

<h3 id="rock-around-the-clock">Rock Around the Clock</h3>

<p>Earlier you saw that the <code class="highlighter-rouge">Tacts</code> property of the CPU is crucial in measuring the number of clock cycles. The <code class="highlighter-rouge">Z80Cpu</code> class contains several helpers to make clocking fast and smooth in the code:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span>  <span class="k">partial</span> <span class="k">class</span> <span class="nc">Z80Cpu</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">long</span> <span class="n">_tacts</span><span class="p">;</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="kt">long</span> <span class="n">Tacts</span> <span class="p">=&gt;</span> <span class="n">_tacts</span><span class="p">;</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetTacts</span><span class="p">(</span><span class="kt">long</span> <span class="n">tacts</span><span class="p">)</span> <span class="c1">// --- IZ80CpuTestSupport method</span>
    <span class="p">{</span>
        <span class="n">_tacts</span> <span class="p">=</span> <span class="n">tacts</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>

    <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">AggressiveInlining</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Delay</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticks</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_tacts</span> <span class="p">+=</span> <span class="n">ticks</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">AggressiveInlining</span><span class="p">)]</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">ClockP1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_tacts</span> <span class="p">+=</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">AggressiveInlining</span><span class="p">)]</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">ClockP2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_tacts</span> <span class="p">+=</span> <span class="m">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>

    <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">AggressiveInlining</span><span class="p">)]</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">ClockP7</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_tacts</span> <span class="p">+=</span> <span class="m">7</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you see, I added methods that emulate the time passes (by means of increasing clock cycle counts). Because in the implementation of concrete Z80 instructions it is a typical operation to use delays with 1, 2, … 7 clock cycles, I created named methods for them. To make them as fast as possible, I decorated them with the <code class="highlighter-rouge">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> attribute to let the JIT-compiler create inline code when invoking them.</p>

<p class="note"><strong>Note</strong>: Code inlining of means that the compiler inserts the entire function body into the code wherever you invoke the particular function—instead merely creating the invocation code. In C++, creating inline code is easy. In .NET, it is the task of the JIT compiler. With the <code class="highlighter-rouge">MethodImpl</code> attribute, you can give a hint to the JIT-compiler to inline the code, but you cannot force it.</p>

<h3 id="the-main-execution-cycle">The Main Execution Cycle</h3>

<p>The CPU (as a state machine) works continuously executing a loop, its main execution cycle. Here is how I implement it:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">ExecuteCpuCycle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">ProcessCpuSignals</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// --- Get operation code and refresh the memory</span>
    <span class="n">MaskableInterruptModeEntered</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">opCode</span> <span class="p">=</span> <span class="nf">ReadMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">);</span>
    <span class="nf">ClockP3</span><span class="p">();</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">++;</span>
    <span class="nf">RefreshMemory</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">None</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// -- The CPU is about to execute a standard operation</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">opCode</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="m">0xDD</span><span class="p">:</span>
                <span class="c1">// --- An IX index prefix received</span>
                <span class="n">_indexMode</span> <span class="p">=</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">IX</span><span class="p">;</span>
                <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>

            <span class="k">case</span> <span class="m">0xFD</span><span class="p">:</span>
                <span class="c1">// --- An IY index prefix received</span>
                <span class="n">_indexMode</span> <span class="p">=</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">IY</span><span class="p">;</span>
                <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>

            <span class="k">case</span> <span class="m">0xCB</span><span class="p">:</span>
                <span class="c1">// --- A bit operation prefix received</span>
                <span class="n">_prefixMode</span> <span class="p">=</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Bit</span><span class="p">;</span>
                <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>

            <span class="k">case</span> <span class="m">0xED</span><span class="p">:</span>
                <span class="c1">// --- An extended operation prefix received</span>
                <span class="n">_prefixMode</span> <span class="p">=</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Extended</span><span class="p">;</span>
                <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>

            <span class="k">default</span><span class="p">:</span>
                <span class="c1">// --- Normal (8-bit) operation code received</span>
                <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="n">_opCode</span> <span class="p">=</span> <span class="n">opCode</span><span class="p">;</span>
                <span class="nf">ProcessStandardOrIndexedOperations</span><span class="p">();</span>
                <span class="n">_prefixMode</span> <span class="p">=</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
                <span class="n">_indexMode</span> <span class="p">=</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
                <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Bit</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// --- The CPU is already in BIT operations (0xCB) prefix mode</span>
        <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">_opCode</span> <span class="p">=</span> <span class="n">opCode</span><span class="p">;</span>
        <span class="nf">ProcessCBPrefixedOperations</span><span class="p">();</span>
        <span class="n">_indexMode</span> <span class="p">=</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
        <span class="n">_prefixMode</span> <span class="p">=</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
        <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Extended</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// --- The CPU is already in Extended operations (0xED) prefix mode</span>
        <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">_opCode</span> <span class="p">=</span> <span class="n">opCode</span><span class="p">;</span>
        <span class="nf">ProcessEDOperations</span><span class="p">();</span>
        <span class="n">_indexMode</span> <span class="p">=</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
        <span class="n">_prefixMode</span> <span class="p">=</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
        <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The execution cycle starts with checking whether the CPU receives any new active signals (<strong>INT</strong>, <strong>NMI</strong>, or <strong>RESET</strong>). If it is so—<code class="highlighter-rouge">ProcessCpuSignals()</code> returns true—the CPU processed a signal, and thus this execution cycle completes.</p>

<p>Otherwise, the <strong>M1</strong> machine cycle starts:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Get operation code and refresh the memory</span>
<span class="n">MaskableInterruptModeEntered</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">opCode</span> <span class="p">=</span> <span class="nf">ReadMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">);</span>
<span class="nf">ClockP3</span><span class="p">();</span>
<span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">++;</span>
<span class="nf">RefreshMemory</span><span class="p">();</span>
</code></pre></div></div>

<p>I use the <code class="highlighter-rouge">MaskableInterruptModeEntered</code> flag in the integrated debugger so that I can step over Z80 statements that are the part of the currently running maskable interrupt routine. It does not play any role in the Z80 emulation.</p>

<p>The first real task is reading the subsequent opcode from the memory and incrementing the Program Counter. These operations consume the first three clock cycles of <strong>M1</strong>. Then, as you learned in the <a href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">previous article</a>, at the end of <strong>M1</strong>, the CPU refreshes the subsequent memory page (according to <strong>R</strong>). This is how it happens:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">RefreshMemory</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">R</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(((</span><span class="n">_registers</span><span class="p">.</span><span class="n">R</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">&amp;</span> <span class="m">0x7F</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">R</span> <span class="p">&amp;</span> <span class="m">0x80</span><span class="p">));</span>
    <span class="nf">ClockP1</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Altogether, the <strong>M1</strong> cycle consumes four clock cycles (<code class="highlighter-rouge">ClockP3() + ClockP1()</code>).</p>

<p>The other parts of the <code class="highlighter-rouge">ExecuteCpuCycle()</code> method manage the opcodes and prefixes. When the prefixes and opcodes form a full operation to carry on, one of these three methods is called according to the prefix: <code class="highlighter-rouge">ProcessStandardOrIndexedOperations()</code>, <code class="highlighter-rouge">ProcessCBPrefixedOperations()</code>, or <code class="highlighter-rouge">ProcessEDOperations()</code>.</p>

<p>The CPU takes care that an interrupt cannot suspend the normal operation of the CPU while the opcode bytes are not entirely collected:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">None</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opCode</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="m">0xDD</span><span class="p">:</span>
            <span class="c1">// ... </span>
            <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">0xFD</span><span class="p">:</span>
            <span class="c1">// ...</span>
            <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">0xCB</span><span class="p">:</span>
            <span class="c1">// ...</span>
            <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">0xED</span><span class="p">:</span>
           <span class="c1">// ...</span>
            <span class="n">_isInOpExecution</span> <span class="p">=</span> <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// --- Normal (8-bit) operation code received</span>
            <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="c1">// ...</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Bit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// --- The CPU is already in BIT operations (0xCB) prefix mode</span>
    <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_prefixMode</span> <span class="p">==</span> <span class="n">OpPrefixMode</span><span class="p">.</span><span class="n">Extended</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// --- The CPU is already in Extended operations (0xED) prefix mode</span>
    <span class="n">_isInterruptBlocked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="processing-cpu-signals">Processing CPU Signals</h3>

<p>Every machine cycle starts with examining whether there is a signal the CPU can process. As its name suggests, the <code class="highlighter-rouge">ProcessCpuSignal()</code> method carries out this procedure. Its logic is straightforward:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="kt">bool</span> <span class="nf">ProcessCpuSignals</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_stateFlags</span> <span class="p">==</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">None</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Int</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">_isInterruptBlocked</span> <span class="p">&amp;&amp;</span> <span class="n">_iff1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">ExecuteInterrupt</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Halted</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">ClockP3</span><span class="p">();</span>
        <span class="nf">RefreshMemory</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Reset</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">ExecuteReset</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Nmi</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">ExecuteNmi</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, there is one thing I have not mentioned yet. The CPU can be halted with the <strong>HALT</strong> instruction. It this state, the CPU executes <strong>NOP</strong> (<em>no operation</em>) instructions silently until a maskable interrupt is accepted or the CPU is reset. During that time (this is what the <strong>M1</strong> machine cycle does), the CPU still takes care of refreshing the memory.</p>

<p>When the CPU receives a non-maskable interrupt, this is what it does:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">ExecuteNmi</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Halted</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">++;</span>
        <span class="n">_stateFlags</span> <span class="p">&amp;=</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">InvHalted</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_iff2</span> <span class="p">=</span> <span class="n">_iff1</span><span class="p">;</span>
    <span class="n">_iff1</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">--;</span>
    <span class="nf">ClockP1</span><span class="p">();</span>
    <span class="nf">WriteMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">&gt;&gt;</span> <span class="m">8</span><span class="p">));</span>
    <span class="nf">ClockP3</span><span class="p">();</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">--;</span>
    <span class="nf">WriteMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">&amp;</span> <span class="m">0xFF</span><span class="p">));</span>
    <span class="nf">ClockP3</span><span class="p">();</span>

    <span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">=</span> <span class="m">0x0066</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Provided the processor is in halted mode, it steps to the next instruction that follows <strong>HALT</strong> and retrieves from this mode. It saves the <strong>IFF1</strong> flag to <strong>IFF2</strong> to preserve the <strong>IFF1</strong> value while the interrupt routine completes. Sets <strong>IFF1</strong> to false to disable any further interrupt during that time.</p>

<p>Then, saves the current value of <strong>PC</strong> to the stack, and jumps to the <strong>NMI</strong> routine address at <strong>$0066</strong>.</p>

<p>When a maskable interrupt is accepted, the logic is similar with some additional tasks:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">ExecuteInterrupt</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">_stateFlags</span> <span class="p">&amp;</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">Halted</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_registers</span><span class="p">.</span><span class="n">PC</span><span class="p">++;</span>
        <span class="n">_stateFlags</span> <span class="p">&amp;=</span> <span class="n">Z80StateFlags</span><span class="p">.</span><span class="n">InvHalted</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_iff1</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">_iff2</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">--;</span>
    <span class="nf">ClockP1</span><span class="p">();</span>
    <span class="nf">WriteMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">&gt;&gt;</span> <span class="m">8</span><span class="p">));</span>
    <span class="nf">ClockP3</span><span class="p">();</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">--;</span>
    <span class="nf">WriteMemory</span><span class="p">(</span><span class="n">_registers</span><span class="p">.</span><span class="n">SP</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">&amp;</span> <span class="m">0xFF</span><span class="p">));</span>
    <span class="nf">ClockP3</span><span class="p">();</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">_interruptMode</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
        <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
            <span class="n">_registers</span><span class="p">.</span><span class="n">MW</span> <span class="p">=</span> <span class="m">0x0038</span><span class="p">;</span>
            <span class="nf">ClockP5</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nf">ClockP2</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">adr</span> <span class="p">=</span> <span class="p">(</span><span class="kt">ushort</span><span class="p">)(</span><span class="n">_registers</span><span class="p">.</span><span class="n">IR</span> <span class="p">&amp;</span> <span class="m">0xFF00</span><span class="p">);</span>
            <span class="nf">ClockP5</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">l</span> <span class="p">=</span> <span class="nf">ReadMemory</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
            <span class="nf">ClockP3</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">h</span> <span class="p">=</span> <span class="nf">ReadMemory</span><span class="p">(++</span><span class="n">adr</span><span class="p">);</span>
            <span class="nf">ClockP3</span><span class="p">();</span>
            <span class="n">_registers</span><span class="p">.</span><span class="n">MW</span> <span class="p">=</span> <span class="p">(</span><span class="kt">ushort</span><span class="p">)(</span><span class="n">h</span> <span class="p">*</span> <span class="m">0x100</span> <span class="p">+</span> <span class="n">l</span><span class="p">);</span>
            <span class="nf">ClockP6</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_registers</span><span class="p">.</span><span class="n">PC</span> <span class="p">=</span> <span class="n">_registers</span><span class="p">.</span><span class="n">MW</span><span class="p">;</span>
    <span class="n">MaskableInterruptModeEntered</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, we handle the halted state and saving the current <strong>PC</strong> address exactly as earlier. The <code class="highlighter-rouge">switch</code> statement handles the three interrupt modes (<strong>IM 0</strong>, <strong>IM 1</strong>, and <strong>IM 2</strong>), respectively. <strong>IM 1</strong> (case 1) is the simplest; it merely sets the execution address to <strong>$0038</strong>. The <strong>IM 0</strong> and <strong>IM 2</strong> cases are a bit trickier. Both read data from the peripheral device that has raised the interrupt signal. If there is no such device, or it does not put any value to the data bus, the CPU sees a <strong>$FF</strong> value. ZX Spectrum with no special devices attached works precisely this way.</p>

<p><strong>IM 0</strong> reads one byte from the device and executes the corresponding instruction. The <strong>$FF</strong> code is the <strong>RST $38</strong> instruction, and it calls the routine at the <strong>$0038</strong> address. Thus, our code handles <strong>IM 0</strong> and <strong>IM 1</strong> the same way.</p>

<p>As you remember, <strong>IM 2</strong> uses <strong>I</strong> as the higher-order byte and the value read from the device as the lower-order byte to create a 16-bit address and then uses this vector to read the interrupt handler’s routine address. In the <code class="highlighter-rouge">switch</code> statement, the default case handles <strong>IM 2</strong>. It assumes that the device did not respond with any data (and so the CPU sees <strong>$FF</strong>), and calculates the routine address accordingly.</p>

<p class="note"><strong>Note</strong>: This method sets the <code class="highlighter-rouge">MaskableInterruptModeEntered</code> flag to true to tell the debugging tool that we are executed into the maskable interrupt routine. This setting has nothing to do with Z80 emulation.</p>

<h3 id="executing-instructions">Executing Instructions</h3>

<p>When the CPU has the opcode for an entire operation, it calls one of these methods according to the operation prefix:</p>

<ul>
  <li>No prefix, <strong>$DD</strong> or <strong>$FD</strong>: <code class="highlighter-rouge">ProcessStandardOrIndexedOperations()</code></li>
  <li><strong>$ED</strong> prefix: <code class="highlighter-rouge">ProcessEDOperations()</code></li>
  <li><strong>$CB</strong> prefix; <strong>$DD</strong> or <strong>$FD</strong> followed by <strong>$CB</strong>: <code class="highlighter-rouge">ProcessCBPrefixedOperations()</code></li>
</ul>

<p>Each method uses a jump table with addresses of methods that process the operation with the opcode that matches the entry’s index. This is how <code class="highlighter-rouge">ProcessEDOperations()</code> works:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">Z80Cpu</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">Action</span><span class="p">[]</span> <span class="n">_extendedOperations</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">ProcessEDOperations</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">opMethod</span> <span class="p">=</span> <span class="n">_extendedOperations</span><span class="p">[</span><span class="n">_opCode</span><span class="p">];</span>
        <span class="n">opMethod</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">InitializeExtendedOpsExecutionTable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_extendedOperations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Action</span><span class="p">[]</span>
        <span class="p">{</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 00..07</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 08..0F</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 10..17</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 18..1F</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 20..27</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 28..2F</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 30..37</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 38..3F</span>

            <span class="n">IN_B_C</span><span class="p">,</span> <span class="n">OUT_C_B</span><span class="p">,</span> <span class="n">SBCHL_QQ</span><span class="p">,</span> <span class="n">LDNNi_QQ</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">LD_XR_A</span><span class="p">,</span> <span class="c1">// 40..47</span>
            <span class="n">IN_C_C</span><span class="p">,</span> <span class="n">OUT_C_C</span><span class="p">,</span> <span class="n">ADCHL_QQ</span><span class="p">,</span> <span class="n">LDQQ_NNi</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETI</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">LD_XR_A</span><span class="p">,</span> <span class="c1">// 48..4F</span>
            <span class="n">IN_D_C</span><span class="p">,</span> <span class="n">OUT_C_D</span><span class="p">,</span> <span class="n">SBCHL_QQ</span><span class="p">,</span> <span class="n">LDNNi_QQ</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">LD_A_XR</span><span class="p">,</span> <span class="c1">// 50..57</span>
            <span class="n">IN_E_C</span><span class="p">,</span> <span class="n">OUT_C_E</span><span class="p">,</span> <span class="n">ADCHL_QQ</span><span class="p">,</span> <span class="n">LDQQ_NNi</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">LD_A_XR</span><span class="p">,</span> <span class="c1">// 58..5F</span>
            <span class="n">IN_H_C</span><span class="p">,</span> <span class="n">OUT_C_H</span><span class="p">,</span> <span class="n">SBCHL_QQ</span><span class="p">,</span> <span class="n">LDNNi_QQ</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">RRD</span><span class="p">,</span> <span class="c1">// 60..67</span>
            <span class="n">IN_L_C</span><span class="p">,</span> <span class="n">OUT_C_L</span><span class="p">,</span> <span class="n">ADCHL_QQ</span><span class="p">,</span> <span class="n">LDQQ_NNi</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="n">RLD</span><span class="p">,</span> <span class="c1">// 60..6F</span>
            <span class="n">IN_F_C</span><span class="p">,</span> <span class="n">OUT_C_0</span><span class="p">,</span> <span class="n">SBCHL_QQ</span><span class="p">,</span> <span class="n">LDNNi_QQ</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 70..77</span>
            <span class="n">IN_A_C</span><span class="p">,</span> <span class="n">OUT_C_A</span><span class="p">,</span> <span class="n">ADCHL_QQ</span><span class="p">,</span> <span class="n">LDSP_NNi</span><span class="p">,</span> <span class="n">NEG</span><span class="p">,</span> <span class="n">RETN</span><span class="p">,</span> <span class="n">IM_N</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 78..7F</span>

            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 80..87</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 88..8F</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 90..97</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// 98..9F</span>
            <span class="n">LDI</span><span class="p">,</span> <span class="n">CPI</span><span class="p">,</span> <span class="n">INI</span><span class="p">,</span> <span class="n">OUTI</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// A0..A7</span>
            <span class="n">LDD</span><span class="p">,</span> <span class="n">CPD</span><span class="p">,</span> <span class="n">IND</span><span class="p">,</span> <span class="n">OUTD</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// A8..AF</span>
            <span class="n">LDIR</span><span class="p">,</span> <span class="n">CPIR</span><span class="p">,</span> <span class="n">INIR</span><span class="p">,</span> <span class="n">OTIR</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// B0..B7</span>
            <span class="n">LDDR</span><span class="p">,</span> <span class="n">CPDR</span><span class="p">,</span> <span class="n">INDR</span><span class="p">,</span> <span class="n">OTDR</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// B0..BF</span>

            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// C0..C7</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// C8..CF</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// D0..D7</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// D8..DF</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// E0..E7</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// E8..EF</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// F0..F7</span>
            <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="c1">// F8..FF</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The constructor of <code class="highlighter-rouge">Z80Cpu</code> invokes the methods that initialize the jump tables (in the listing, it is the <code class="highlighter-rouge">InitializeExtendedOpsExecutionTable()</code> method).</p>

<p>A <code class="highlighter-rouge">null</code> entry in the jump table is an equivalent operation with the NOP instruction. It means that the CPU does not change its state. Wherever there is an operation method, that method executes the action that represents the associated instruction. For example, this is the action method for the <strong>IM 0</strong>, <strong>IM 1</strong>, and <strong>IM 2</strong> operations:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">IM_N</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">mode</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)((</span><span class="n">_opCode</span> <span class="p">&amp;</span> <span class="m">0x18</span><span class="p">)</span> <span class="p">&gt;&gt;</span> <span class="m">3</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="n">mode</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">mode</span><span class="p">--;</span>
    <span class="n">_interruptMode</span> <span class="p">=</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The binary opcodes (after the <strong>$DE</strong> prefix) for the <strong>IM 0</strong>, <strong>IM 1</strong> and <strong>IM 2</strong> operations are these:</p>

<ul>
  <li><code class="highlighter-rouge">x1x0_0110</code></li>
  <li><code class="highlighter-rouge">x1x0_1110</code></li>
  <li><code class="highlighter-rouge">x1x1_0110</code></li>
</ul>

<p>Bit 4 and Bit 3 of the opcode define the value for the interrupt mode: <strong>00</strong>: <strong>IM 0</strong>; <strong>01</strong>: undefined (we set it to 0); <strong>10</strong>: <strong>IM 1</strong>; <strong>11</strong>: <strong>IM 2</strong>.</p>

<h3 id="indexed-instructions">Indexed Instructions</h3>

<p>Processing an indexed instruction add some twist to the story. They use separate jump tables, as this code snippet shows:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">Z80Cpu</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">Action</span><span class="p">[]</span> <span class="n">_standarOperations</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">ProcessStandardOrIndexedOperations</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">opMethod</span> <span class="p">=</span> <span class="n">_indexMode</span> <span class="p">==</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">None</span>
            <span class="p">?</span> <span class="n">_standarOperations</span><span class="p">[</span><span class="n">_opCode</span><span class="p">]</span>
            <span class="p">:</span> <span class="n">_indexedOperations</span><span class="p">[</span><span class="n">_opCode</span><span class="p">];</span>
        <span class="n">opMethod</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With the <strong>$DD</strong> or <strong>$FD</strong> prefix, the <code class="highlighter-rouge">ProcessStandardOrIndexedOperations()</code> method uses the <code class="highlighter-rouge">_indexedOperations</code> table.</p>

<p>One entry in that table is <code class="highlighter-rouge">INC_IX()</code>. Although the method name suggests it works with <strong>IX</strong>, it is responsible for processing the index register determined by the current prefix:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">INC_IX</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">SetIndexReg</span><span class="p">((</span><span class="kt">ushort</span><span class="p">)(</span><span class="nf">GetIndexReg</span><span class="p">()</span> <span class="p">+</span> <span class="m">1</span><span class="p">));</span>
    <span class="nf">ClockP2</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The helper methods, <code class="highlighter-rouge">SetIndexReg()</code> and <code class="highlighter-rouge">GetIndexReg()</code> take care of using the appropriate register:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span> <span class="kt">ushort</span> <span class="nf">GetIndexReg</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_indexMode</span> <span class="p">==</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">IY</span> <span class="p">?</span> <span class="n">_registers</span><span class="p">.</span><span class="n">IY</span> <span class="p">:</span> <span class="n">_registers</span><span class="p">.</span><span class="n">IX</span><span class="p">;</span>
<span class="p">}</span>

<span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">SetIndexReg</span><span class="p">(</span><span class="kt">ushort</span> <span class="k">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_indexMode</span> <span class="p">==</span> <span class="n">OpIndexMode</span><span class="p">.</span><span class="n">IY</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_registers</span><span class="p">.</span><span class="n">IY</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_registers</span><span class="p">.</span><span class="n">IX</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="next-instruction-details">Next: Instruction Details</h3>

<p>By now, you know the fundamentals of the Z80 CPU emulation. You understand state management with registers and other state vector elements. You also have an overview of the execution cycle, the details of processing interrupt requests.</p>

<p>Some details that can be best covered by treating the details of individual Z80 instructions. In the next post, you will read about such nitty-gritty things.</p>


              <!-- LINKS TO PREVIOUS/NEXT -->
              <div class="links-bottom">
                  <div class="link">
                    
                      <a class="prev" href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">&laquo; ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU</a>
                    
                  </div>
                  <div class="link-right">
                    
                      <a class="next" href="/zx-spectrum/2018/02/01/zxspectrum-part-5.html">ZX Spectrum IDE — Part #5: Implementing Z80 instructions (1) &raquo;</a>
                    
                  </div>
              </div>
              <div id="disqus_thread"></div>
            </section>
            <aside class="sidebar">
              <div class="sidebar-title"><a href="/">Dotneteer's BLOG</a></div>
              <div class="sidebar-title">More in this category:</div>
              <ul class="sidebar-list">
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/02/01/zxspectrum-part-5.html">ZX Spectrum IDE — Part #5: Implementing Z80 instructions (1)</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/26/zxspectrum-part-4.html">ZX Spectrum IDE — Part #4: Emulating the Z80 CPU</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/23/zxspectrum-part-2.html">ZX Spectrum IDE — Part #2: The ZX Specrum Emulator Challenge</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/03/zxspectrum-part-1.html">ZX Spectrum IDE — Part #1: How I Started SpectNetIde</a></li> 
                  
                  
              </ul>
              <div class="sidebar-title">Other categories:</div>
              <ul class="sidebar-list">
                   
                   <li class="post-list-item"><a href="/category/zx-spectrum.html">ZX-Spectrum</a></li> 
                  
              </ul>
            </aside>
          </section>
        </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>&copy; Istvan Novak, 2016-2019</p>
      </footer>
    </div>


    

    <!-- DISQUS -->
<script>

  /**
   *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
   *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

  
  var disqus_config = function () {
  this.page.url = "http://localhost:4000/zx-spectrum/2018/01/26/zxspectrum-part-4.html";  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = "/zx-spectrum/2018/01/26/zxspectrum-part-4.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };

  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://dotneteer.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </body>
</html>