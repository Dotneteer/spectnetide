{
  "Labels": {
    "0": "START",
    "4": "START_1",
    "199": "MAIN_RESET",
    "40": "ROM1_CALL",
    "56": "MASK_INT",
    "72": "MASK_INT_RET",
    "107": "SWAP",
    "127": "YOUNGER",
    "136": "ONERR",
    "195": "ONERR_CONT",
    "154": "P_IN",
    "1752": "RS232_INP",
    "162": "P_OUT_1",
    "1994": "RS232_OUT",
    "159": "P_OUT",
    "1510": "RS232_HANDLER",
    "181": "P_OUT_2",
    "201": "MAIN_RESET_1",
    "305": "FATAL_RAM_ERR",
    "311": "MAIN_RESET_2",
    "74": "ERR_128",
    "92": "ROM1_CALL_1",
    "309": "INF_LOOP",
    "7268": "PAGE_IN_RAM",
    "413": "NEW",
    "1417": "CHAN_INFO",
    "1438": "INI_STREAM_DATA",
    "1377": "COPYR_MSG",
    "698": "RET_SYN_CHECK",
    "705": "SYNTAX_OK",
    "735": "SYN_OK_1",
    "619": "EXEC_CMD",
    "8005": "WKSP_RAM",
    "756": "SYN_OK_2",
    "7968": "NORM_RAM",
    "801": "ERR_HANDLER",
    "842": "ERR_H_1",
    "846": "ERR_H_2",
    "893": "ERR_H_3",
    "895": "ERR_H_4",
    "924": "ERR_H_5",
    "1132": "ERR_MSG_VECTORS",
    "930": "ERR_H_6",
    "972": "ERR_H_7",
    "975": "ERR_H_8",
    "989": "ERR_H_9",
    "991": "ERR_H_10",
    "1007": "BASIC_ERRH",
    "1015": "PARSE_L_NUMB",
    "1034": "PARSE_LN_1",
    "1065": "PARSE_LN_2",
    "1090": "PARSE_LN_3",
    "1130": "PARES_LN_4",
    "1405": "PRINT_MSG",
    "1452": "REPORT_ERROR",
    "1480": "REPORT_ERROR_1",
    "1494": "TEST_BREAK",
    "1546": "RS232_H_1",
    "1556": "RS232_H_2",
    "1552": "RS232_H_RET",
    "1560": "RS232_NON_CHAR",
    "1563": "RS232_CHAR",
    "1581": "RS232_CR",
    "1591": "INKEY_PRINT",
    "1597": "INKEY_RET",
    "1601": "FORMAT",
    "1633": "FORMAT_SYNTAX",
    "1625": "FORMAT_STR_1",
    "1661": "FORMAT_SYNTAX_1",
    "1673": "FORMAT_CHECK_END",
    "6418": "ERROR_C",
    "1688": "FORMAT_BAUD",
    "1720": "BAUD_TABLE",
    "1711": "BAUD_FOUND",
    "1765": "RS232_READB",
    "1806": "RS232_BIT",
    "1822": "RS232_START_BIT",
    "1879": "RS232_COMPL",
    "1813": "RS232_BIT_1",
    "1846": "BAUD_DELAY",
    "1841": "RS232_NEXT_BIT",
    "1867": "RS_BIT_0_REC",
    "1876": "RS_BYTE_REC",
    "1894": "STOP_B_DELAY",
    "1919": "RS_START_BIT_2",
    "1905": "RS_WAIT_STARTB",
    "1954": "BAUD_DELAY_2",
    "1949": "RS_NEXT_BIT_2",
    "1975": "RS_BIT_0_REC_2",
    "1984": "RS_REC_COMPL",
    "2016": "RS_OUT_NO_PARS",
    "2011": "RS_OUT_2",
    "2034": "RS_OUT_NO_TOKEN",
    "2045": "RS_OUT_NO_SPC",
    "2051": "RS_OUT_NO_GR",
    "2078": "RS_OUT_CTRL",
    "2074": "RS_OUT_NO_ROW",
    "2082": "RS_OUT_CRLF",
    "2096": "RS_OUT_TEST_COM",
    "2106": "RS_OUT_3",
    "2112": "RS_OUT_4",
    "2120": "RS_OUT_5",
    "2131": "RS_OUT_TEST_AT",
    "2144": "RS_OUT_AT_TAB",
    "2153": "RS_OUT_INK",
    "2162": "RS_OUT_PARS",
    "2178": "RS_PROC_AT_TAB",
    "2186": "RS_AT_1",
    "2192": "RS_AT_2",
    "2197": "RS_AT_3",
    "2211": "RS_WR_BYTE",
    "2223": "RS_WR_ISREADY",
    "2248": "RS_WR_BIT",
    "2272": "RS_WR_BIT_3",
    "2266": "RS_WR_BIT_2",
    "2288": "COPY_TO_PRN",
    "2293": "COPY_TO_2",
    "2425": "PRINTER_CONFIG",
    "2432": "PRINTER_LF",
    "2434": "PRINTER_RESET",
    "2318": "COPY_TO_3",
    "2325": "COPY_HALF_ROW",
    "2330": "COPY_HALF_2",
    "2342": "COPY_COLUMN",
    "2362": "COPY_COL_2",
    "2372": "COPY_COL_3",
    "2389": "COPY_PIXELS",
    "2399": "PR_OUT_TABLE",
    "2401": "PR_OUT_TB_2",
    "2413": "TEST_PIXEL",
    "2420": "TEST_PIXEL_2",
    "2437": "PLAY_SOUND",
    "2445": "PLAY_SOUND_2",
    "2464": "PLAY_SOUND_3",
    "2565": "PLAY_MSTRING",
    "3708": "SET_SGREG",
    "2609": "CALC_TM_LOOP",
    "2622": "TEST_BREAK_2",
    "2634": "CD_DUR_PTR",
    "2639": "CD_PTRS",
    "2642": "CD_PTRS_2",
    "2663": "CDB_ADDR_STR",
    "2670": "NEXT_CD_PTR",
    "2685": "PLAY_SOUND_4",
    "2688": "PLAY_SOUND_5",
    "2700": "PLAY_SOUND_6",
    "2711": "PLAY_NOTES",
    "2719": "PLAY_NOTES_2",
    "2731": "PLAY_NOTES_3",
    "2743": "PLAY_CMD_TABLE",
    "2757": "GET_PLAY_CH",
    "2769": "GET_NEXT_STONE",
    "2772": "GET_NSTONE_2",
    "2783": "GET_NSTONE_3",
    "2785": "GET_NSTONE_4",
    "2796": "GET_NSTONE_5",
    "2803": "GET_NSTONE_6",
    "2810": "GET_NSTONE_7",
    "2820": "GET_NSTONE_8",
    "3874": "REPORT_k",
    "3577": "STONES_TABLE",
    "2845": "GET_PS_NUMVAL",
    "2856": "GET_PS_NV_2",
    "2882": "GET_PS_NV_3",
    "2885": "GET_PS_NV_4",
    "3866": "REPORT_l"
  },
  "Comments": {
    "0": "Ensure interrupts are disabled.",
    "2865": "Advance to the next character.",
    "7": "[There is no RST $08. No instruction fetch at $0008 hence ZX Interface 1 will not be paged in from this ROM. Credit: Paul Farrow].",
    "9": "to the main reset routine.",
    "12": "[Spare bytes]",
    "20": "[Spare bytes]",
    "28": "[Spare bytes]",
    "36": "[Spare bytes]",
    "40": "Get the address after the RST $28 into HL, saving HL on the stack.",
    "41": "saving HL on the stack.",
    "42": "Save the AF registers.",
    "43": "Point HL to the byte after",
    "44": "the required address.",
    "48": "(There is no RST $30)",
    "49": "Fetch the second address byte.",
    "50": "HL=Subroutine to call.",
    "51": "Restore AF.",
    "52": "Jump ahead to continue.",
    "55": "[Spare byte]",
    "56": "Save HL register pair.",
    "57": "Return address of $0048 (ROM 0).",
    "61": "$5B00. Address of swap ROM routine held in RAM at $5B00.",
    "65": "Maskable interrupt routine address $0038 (ROM 0).",
    "69": "$5B00. Switch to other ROM (ROM 1) via routine held in RAM at $5B00.",
    "72": "Restore the HL register pair.",
    "73": "End of interrupt routine.",
    "77": "ROM 0, Bank 0, Screen 0, 128K mode.",
    "78": "Ensure interrupts are disabled whilst paging.",
    "81": "$5B5C. Note the new paging status.",
    "84": "Re-enable interrupts.",
    "85": "A=$FF.",
    "86": "Set ERR_NR to no error ($FF).",
    "89": "Jump ahead to continue.",
    "92": "Save the address in ROM 0 to call.",
    "95": "HL='Return to ROM 0' routine held in RAM.",
    "98": "Stack HL.",
    "99": "Save previous stack address.",
    "100": "Produce error report.",
    "103": "Stack HL.",
    "104": "Switch to other ROM (ROM 1) and return to address to call.",
    "107": "Save AF and BC.",
    "115": "Select other ROM.",
    "117": "Disable interrupts whilst switching ROMs.",
    "121": "Switch to the other ROM.",
    "124": "Restore BC and AF.",
    "127": "Toggle to the other ROM.",
    "135": "Return to the address held in RETADDR.",
    "136": "Ensure interrupts are disabled whilst paging.",
    "137": "Fetch current paging configuration.",
    "140": "Select ROM 0.",
    "142": "Save the new configuration",
    "148": "Switch to ROM 0.",
    "151": "Jump to ONERR_CONT (ROM 0) to continue.",
    "154": "RS232 input routine within ROM 0.",
    "159": "RS232 output routine within ROM 0.",
    "162": "Save AF registers.",
    "166": "Fetch the current paging configuration",
    "169": "and save it.",
    "170": "Select ROM 0.",
    "172": "Ensure interrupts are disabled whilst paging.",
    "173": "Store the new paging configuration.",
    "176": "Switch to ROM 0.",
    "178": "Jump to the RS232 channel input/output handler routine.",
    "181": "Save AF registers. For a read, A holds the byte read and the flags the success status.",
    "182": "Retrieve original paging configuration.",
    "186": "Ensure interrupts are disabled whilst paging.",
    "187": "Store original paging configuration.",
    "190": "Switch back to original paging configuration.",
    "193": "Restore AF registers. For a read, A holds the byte read and the flags the success status.",
    "195": "Fetch the address to call.",
    "198": "and execute it.",
    "199": "Loop through all RAM banks.",
    "202": "Save B register.",
    "203": "RAM bank number 0 to 7. 128K mode, ROM 0, Screen 0.",
    "207": "Switch RAM bank.",
    "209": "Start of the current RAM bank.",
    "215": "All 16K of RAM bank.",
    "220": "Store $FF into RAM location.",
    "221": "Check RAM integrity.",
    "222": "Jump if RAM error found.",
    "225": "Store $00 into RAM location.",
    "226": "Check RAM integrity.",
    "227": "Jump if difference found.",
    "229": "Clear the whole page",
    "231": "Restore B registers.",
    "234": "Signal no communications in progress to the keypad.",
    "243": "BC=$FFFD, DE=$FFBF.",
    "246": "Select AY register 14.",
    "248": "BC=$BFFD.",
    "251": "Set AY register 14 to $FF. This will force a communications reset to the keypad if present.",
    "255": "[Spare byte]",
    "256": "BASIC interpreter parser.",
    "259": "'Line Run' entry point.",
    "262": "Transfer bytes to logical RAM bank 4.",
    "265": "Transfer bytes from logical RAM bank 4.",
    "268": "128K error routine.",
    "271": "Error routine. Called from patch at $3B3B in ROM 1.",
    "274": "'Statement Return' routine. Called from patch at $3B4D in ROM 1.",
    "277": "'Statement Next' routine. Called from patch at $3B5D in ROM 1.",
    "280": "Scan the keypad.",
    "283": "Play music strings.",
    "286": "MIDI byte output routine.",
    "289": "RS232 byte input routine.",
    "292": "RS232 text output routine.",
    "295": "RS232 byte output routine.",
    "298": "COPY (screen dump) routine.",
    "301": "Call keypad scan routine in ROM 1.",
    "302": "$3B01. [*BUG* - The address jumps into the middle of the keypad decode routine in ROM 1. It looks like it is supposed to deal with the keypad and so the most likely addresses are $3A42 (read keypad) or $39A0 (scan keypad). At $3C01 in ROM 1 is a vector jump command to $39A0 to scan the keypad and this is similar enough to the $3B01 to imply a simple error in one of the bytes. Credit: Paul Farrow]",
    "305": "Retrieve RAM bank number + 1 in B.",
    "306": "Indicate which RAM bank failed by",
    "307": "setting the border colour.",
    "309": "Infinite loop.",
    "311": "Complete setting up the sound chip registers.",
    "314": "Select AY register 7.",
    "317": "Disable AY-3-8912 sound channels.",
    "321": "Copy the various paging routines to the old printer buffer.",
    "324": "The source is in this ROM.",
    "327": "There are eighty eight bytes to copy.",
    "330": "Copy the block of bytes.",
    "332": "Load A with the code for the Z80 instruction 'RST $08'.",
    "334": "Insert into new System Variable RAMRST.",
    "337": "Set the stack pointer to last location of old buffer.",
    "342": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "345": "First free entry in RAM disk.",
    "368": "AHL=Free space in RAM disk.",
    "370": "$5B85. Current address.",
    "373": "$5B87. Current RAM bank.",
    "378": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "381": "Load HL with known last working byte - 65535.",
    "384": "Set physical RAM top to 65535.",
    "387": "Set DE to address of the last bitmap of 'U' in ROM 1.",
    "390": "There are 21 User Defined Graphics to copy.",
    "393": "Swap so destination is $FFFF.",
    "395": "(MAKE_ROOM+#000C) Calling this address (LDDR/RET) in the main ROM cleverly copies the 21 characters to the end of RAM.",
    "397": "Transfer DE to HL.",
    "398": "Increment to address first byte of UDG 'A'.",
    "399": "Update standard System Variable UDG.",
    "403": "Set values 0 for PIP and 64 for RASP.",
    "406": "Update standard System Variables RASP and PIP.",
    "410": "Update standard System Variable RAMTOP - the last byte of the BASIC system area. Any machine code and graphics above this address are protected from NEW.",
    "413": "(CHAR_SET-#0100) Set HL to where, in theory character zero would be.",
    "416": "Update standard System Variable CHARS.",
    "419": "Load HL with value of System Variable RAMTOP.",
    "422": "Address next location.",
    "423": "Set the Stack Pointer.",
    "424": "Select Interrupt Mode 1.",
    "426": "Set the IY register to address the standard System Variables and many of the new System Variables and even those of ZX Interface 1 in some cases.",
    "430": "FLAGS. Signal 128K mode. [This bit was unused and therefore never set by 48K BASIC]",
    "434": "With a stack and the IY register set, interrupts can be enabled.",
    "435": "Set HL to eleven, timing constant for 9600 baud.",
    "438": "Select default RS232 baud rate of 9600 baud.",
    "441": "Clear accumulator.",
    "442": "Indicate no byte waiting in RS232 receive buffer.",
    "445": "Set RS232 output column position to 0.",
    "448": "Indicate no control code parameters expected.",
    "451": "[*BUG* - Should write to RAM bank 7. Main RAM has now been corrupted. The value stored is subsequently never used. Credit: Geoff Wearmouth]",
    "454": "This is a remnant from the Spanish 128, which used this workspace variable to hold the location of the Screen Buffer, but it also suffered from this bug. In fact there was never a need to write to the value at this point since it is written again later during the initialisation process. [The 1985 Sinclair Research ESPAGNOL source code says that this instruction will write to the (previously cleared) main BASIC RAM during initialization but that a different page of RAM will be present during NEW. Stuff and Nonsense! Assemblers and other utilities present above RAMTOP will be corrupted by the BASIC NEW command since $FF24, and later $EC13, will be written to even if they are above RAMTOP.]",
    "457": "Default to a printer width of 80 columns.",
    "459": "Set RS232 printer output width.",
    "462": "Use 10 as the initial renumber line and increment.",
    "465": "Store the initial line number when renumbering.",
    "468": "Store the renumber line increment.",
    "471": "Address after the System Variables.",
    "474": "Set the default location for the channel area.",
    "477": "Point to Initial Channel Information in this ROM. This is similar to that in main ROM but channel 'P' has input and output addresses in the new $5Bxx region.",
    "480": "There are 21 bytes to copy.",
    "483": "Switch pointer so destination is CHANS.",
    "484": "Copy the block of bytes.",
    "487": "Decrement to point to channel information end-marker.",
    "488": "Set the default address of the terminator for the last DATA item.",
    "492": "Set the default address of the BASIC program area.",
    "495": "Set the default address of the BASIC variables area.",
    "498": "Insert the Variables end-marker.",
    "501": "Set the default address of the editing line area.",
    "504": "Insert a carriage return.",
    "507": "Insert the editing line end-marker.",
    "510": "Set the address of the workspace.",
    "513": "Set the address of the start of the calculator stack.",
    "516": "Set the address of the end of the calculator stack.",
    "519": "Attribute colour of black ink on white paper.",
    "521": "Set the permanent attribute colour.",
    "524": "Set the permanent attribute mask.",
    "527": "Set the default border colour.",
    "531": "Temporary P_FLAG. Clear the temporary store for P-FLAG. [*BUG* - Should write this to RAM bank 7. Main RAM has now been corrupted again. The effect of the bug can be seen by typing INVERSE 1: PRINT \"Hello\", followed by NEW, followed by PRINT \"World\", and will cause the second word to also be printed in inverse. Credit: Geoff Wearmouth]",
    "536": "Set the border white.",
    "538": "The values five and thirty five.",
    "541": "Set the default values for key delay and key repeat.",
    "544": "Set KSTATE+0 to $FF.",
    "547": "Set KSTATE+4 to $FF.",
    "550": "Address of the Initial Stream Data within this ROM (which is identical to that in main ROM).",
    "1417": "K channel output routine.",
    "1419": "K channel input routine.",
    "1421": "Channel identifier 'K'.",
    "1422": "S channel output routine.",
    "1424": "S channel input routine.",
    "1426": "Channel identifier 'S'.",
    "1427": "R channel output routine.",
    "1429": "R channel input routine.",
    "1431": "Channel identifier 'R'.",
    "1432": "P Channel output routine.",
    "1434": "P Channel input routine.",
    "1436": "Channel identifier 'P'.",
    "1437": "End marker.",
    "1438": "Stream $FD leads to channel 'K'.",
    "1440": "Stream $FE leads to channel 'S'.",
    "1442": "Stream $FF leads to channel 'R'.",
    "1444": "Stream $00 leads to channel 'K'.",
    "1446": "Stream $01 leads to channel 'K'.",
    "1448": "Stream $02 leads to channel 'S'.",
    "1450": "Stream $03 leads to channel 'P'.",
    "553": "Address of the system variable holding the channels attached to streams data.",
    "559": "Initialise the streams system variables.",
    "561": "FLAGS. Signal printer not is use.",
    "565": "ERR_NR. Signal no error.",
    "569": "DF_SZ. Set the lower screen size to two rows.",
    "576": "Attempt to display TV tuning test screen.",
    "577": "$3C04. Will return if BREAK is not being pressed.",
    "579": "Address of the Sinclair copyright message.",
    "582": "Display the copyright message.",
    "585": "DF_SZ. Set the lower screen size to two rows.",
    "589": "TV_FLAG. Signal lower screen will require clearing.",
    "596": "Use the temporary stack as the previous stack.",
    "599": "Use Workspace RAM configuration (physical RAM bank 7).",
    "602": "Set colours to black ink on white paper.",
    "604": "Temporary ATTR_T used by the 128 BASIC Editor.",
    "607": "Temporary ATTR_P used by the 128 BASIC Editor.",
    "610": "Initialise mode and cursor settings. IX will point at editing settings information.",
    "613": "Use Normal RAM Configuration (physical RAM bank 0).",
    "616": "Jump to show the Main menu.",
    "622": "Select BASIC/Calculator mode.",
    "624": "ERR_NR. Set to '0 OK' status.",
    "628": "DF_SZ. Reset the number of rows in the lower screen.",
    "632": "Return address should an error occur.",
    "635": "Stack it.",
    "636": "Save the stack pointer in ERR_SP.",
    "640": "Return address in ROM 0 after syntax checking.",
    "643": "Store it in SYNRET.",
    "646": "Point to start of typed in BASIC command.",
    "649": "Is the first character a function token, i.e. the start of a numerical expression?",
    "652": "Jump if so to evaluate it.",
    "655": "\"(\": Is the first character the start of an expression?",
    "657": "Jump if so to evaluate it.",
    "660": "\"-\": Is the first character the start of an expression?",
    "665": "\"+\": Is the first character the start of an expression?",
    "662": "Jump if so to evaluate it.",
    "667": "Jump if so to evaluate it.",
    "670": "Is text just a number or a numerical expression?",
    "673": "Jump if a numerical expression to evaluate it.",
    "676": "Use Workspace RAM configuration (physical RAM bank 7).",
    "679": "Fetch mode.",
    "682": "Use Normal RAM Configuration (physical RAM bank 0).",
    "685": "Calculator mode?",
    "687": "Jump if not to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "690": "Is it a single LET command?",
    "693": "Jump if so to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "696": "Drop ONERR return address.",
    "698": "Test ERR_NR.",
    "702": "Jump ahead if no error.",
    "705": "Point to start of editing area.",
    "704": "Simply return if an error.",
    "708": "Store in CH_ADD.",
    "712": "Call E_LINE_NO in ROM 1 to read the line number into editing area.",
    "716": "Jump ahead if there was a line number.",
    "719": "Get character.",
    "720": "End of the line reached, i.e. no BASIC statement?",
    "722": "Return if so.",
    "723": "Clear screen if it requires it.",
    "726": "TVFLAG. Clear lower screen?",
    "730": "Jump ahead if no need to clear lower screen.",
    "735": "TVFLAG. Signal to clear lower screen.",
    "739": "Use Workspace RAM configuration (physical RAM bank 7).",
    "742": "Editor flags.",
    "745": "Using lower screen area for editing?",
    "747": "Jump ahead if so.",
    "750": "Fetch the mode.",
    "751": "In Edit Menu mode?",
    "753": "If so then clear lower editing area display.",
    "756": "Use Normal RAM Configuration (physical RAM bank 0).",
    "762": "Signal mode has not changed.",
    "764": "25.",
    "766": "S_POSN+1. Subtract the current print row position.",
    "769": "Set the number of scrolls.",
    "772": "FLAGS. Not syntax checking.",
    "776": "NSPPC. Set line to be jumped to as line 1.",
    "780": "The end of GO SUB stack marker.",
    "783": "Place it on the stack.",
    "784": "The return address should an error occur.",
    "787": "Place it on the stack.",
    "788": "Store error routine address.",
    "792": "Address of error handler routine in ROM 0.",
    "795": "Store it in SYNRET.",
    "798": "Jump ahead to the main parser routine to execute the line.",
    "805": "Reset SP to top of memory map.",
    "809": "Use the temporary stack as the previous stack.",
    "812": "Trap error conditions where interrupts are disabled.",
    "813": "FLAGS. Signal no new key.",
    "820": "Editing RAM disk catalogue?",
    "822": "Jump if not.",
    "824": "Use Workspace RAM configuration (physical RAM bank 7).",
    "831": "Catalogue entry size.",
    "834": "Remove last entry.",
    "836": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "839": "Use Normal RAM Configuration (physical RAM bank 0).",
    "842": "Fetch error number from ERR_NR.",
    "845": "Increment to give true error code.",
    "846": "Save the error code.",
    "850": "FLAGX. Ensure not INPUT mode.",
    "853": "X_PTR_hi. Clear to suppress error '?' marker.",
    "856": "Clear to signal no defined function is currently being evaluated.",
    "859": "[Could have saved 2 bytes by using INC L].",
    "862": "STRMS+$0006. Ensure STRMS-00 specifies the keyboard.",
    "865": "Clears editing area and areas after it.",
    "868": "Clears editing area and areas after it.",
    "873": "Clear lower editing screen.",
    "875": "TVFLAG. Signal lower screen requires clearing.",
    "879": "Retrieve error code.",
    "880": "Store error code in B.",
    "881": "Is it a numeric error code (1-9), i.e. suitable for immediate display?",
    "883": "If so jump ahead to display it.",
    "885": "Is it one of the standard errors (A-R)?",
    "887": "If so jump ahead to convert it into an upper case letter.",
    "889": "Otherwise convert it into a lower case letter.",
    "891": "Jump ahead to display it. [Could have saved 2 bytes by using ADD A,$0C instead of these two instructions]",
    "893": "Increase code to point to upper case letters.",
    "896": "Display the character held in the A register.",
    "898": "Display a space.",
    "901": "Retrieve the error code.",
    "902": "Is it one of the standard errors (A-R)?",
    "904": "Jump if an standard error message (A-R).",
    "906": "A=Code $00 - $0E.",
    "915": "Find address in error message vector table.",
    "910": "Pass code to BC.",
    "918": "DE=Address of message to print.",
    "919": "Print error message.",
    "930": "Select the first message \", \" (a 'comma' and a 'space').",
    "922": "Jump ahead.",
    "924": "Position of the error messages in ROM 1.",
    "928": "Call message printing routine.",
    "931": "$1536. Message base address in ROM 1.",
    "935": "Print a comma followed by a space.",
    "937": "Fetch current line number.",
    "942": "Print the line number.",
    "944": "Print ':'.",
    "947": "SUBPPC. Fetch current statement number.",
    "953": "Print the statement number.",
    "956": "Clear editing and workspace areas.",
    "958": "Fetch the error code.",
    "962": "Jump ahead for \"0 OK\".",
    "966": "Jump for \"A Invalid argument\", thereby advancing to the next statement.",
    "970": "Jump unless \"M Ramtop no good\".",
    "972": "SUBPPC. Advance to the next statement.",
    "978": "Continue statement number.",
    "981": "Next statement number.",
    "984": "Is there a statement number?",
    "986": "Jump if so.",
    "988": "HL=SUBPPC. The current statement number.",
    "989": "Copy SUBPPC and PPC to OSPPC and OLDPPC, for use by CONTINUE.",
    "991": "NSPPC. Signal no current statement number.",
    "995": "FLAGS. Select K-Mode.",
    "1002": "Select 128 Editor mode.",
    "1004": "Jump ahead to return control to the Editor.",
    "1007": "Error code 'G - No room for line'.",
    "1012": "Jump to print the error code.",
    "1015": "Store the line as the current line number with the program cursor.",
    "1019": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1022": "[This test could have been performed before paging in bank 7 and hence could have benefited from a slight speed improvement.",
    "1023": "The test is redundant since BC holds a non-zero line number]",
    "1024": "Jump if no line number",
    "1026": "Current edit line number. [Redundant instruction - Line number has already been stored]",
    "1030": "Temporary E_PPC used by BASIC Editor.",
    "1034": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1037": "Point to the next character in the BASIC line.",
    "1041": "Address of error handler routine should there be no room for the line.",
    "1044": "Stack it.",
    "1049": "HL=Length of BASIC line.",
    "1051": "Stack it.",
    "1053": "Transfer edit line number to HL.",
    "1055": "Returns address of the line in HL.",
    "1057": "Jump if the line does not exist.",
    "1060": "Find the address of the next line.",
    "1063": "Delete the line.",
    "1065": "BC=Length of the BASIC line.",
    "1067": "Is it 1, i.e. just an 'Enter' character, and hence only",
    "1068": "a line number was entered?",
    "1069": "Jump if there is a BASIC statement.",
    "1071": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1074": "Save the address of the line.",
    "1075": "Fetch current edit line number.",
    "1078": "Find closest line number (or $0000 if no line).",
    "1081": "Store current edit line number. Effectively refresh E_PPC.",
    "1084": "HL=Address of the line.",
    "1085": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1088": "Jump ahead to exit.",
    "1090": "BC=Length of the BASIC line. Stack it.",
    "1094": "BC=BC+4. Allow for line number and length bytes.",
    "1095": "Point to before the current line, i.e. the location to insert bytes at.",
    "1096": "Get start address of the BASIC program.",
    "1100": "Stack it.",
    "1102": "Insert BC spaces at address HL.",
    "1104": "HL=Start address of BASIC program.",
    "1105": "Save start address of BASIC program.",
    "1108": "BC=Length of the BASIC line.",
    "1110": "Point to the first location of the newly created space.",
    "1111": "Address of end of the BASIC line in the workspace.",
    "1115": "Skip over the newline and terminator bytes.",
    "1116": "Copy the BASIC line from the workspace into the program area.",
    "1118": "Current edit line number.",
    "1122": "BC=Length of BASIC line.",
    "1123": "Store the line length.",
    "1127": "DE=line number.",
    "1129": "Store the line number.",
    "1130": "Drop item (address of error handler routine).",
    "1131": "Exit with HL=Address of the line.",
    "1132": "Error report 'a'.",
    "1134": "Error report 'b'.",
    "1136": "Error report 'c'.",
    "1138": "Error report 'd'.",
    "1140": "Error report 'e'.",
    "1142": "Error report 'f'.",
    "1144": "Error report 'g'.",
    "1146": "Error report 'h'.",
    "1148": "Error report 'i'.",
    "1150": "Error report 'j'.",
    "1152": "Error report 'k'.",
    "1154": "Error report 'l'.",
    "1156": "Error report 'm'.",
    "1158": "Error report 'n'.",
    "1160": "Error report 'o'.",
    "1162": "Error report 'p'.",
    "1164": "\"MERGE error\"",
    "1175": "\"Wrong file type\"",
    "1190": "\"CODE error\"",
    "1200": "\"Too many brackets\"",
    "1217": "\"File already exists\"",
    "1236": "\"Invalid name\"",
    "1248": "\"File does not exist\"",
    "1267": "\"Invalid device\"",
    "1281": "\"Invalid baud rate\"",
    "1298": "\"Invalid note name\"",
    "1315": "\"Number too big\"",
    "1329": "\"Note out of range\" ",
    "1346": "\"Out of range\"",
    "1358": "\"Too many tied notes\"",
    "1377": "\"(c) 1986 Sinclair Research Ltd\"",
    "1405": "Fetch next byte.",
    "1406": "Mask off top bit.",
    "1408": "Save address of current message byte.",
    "1409": "Print character.",
    "1410": "Restore message byte pointer.",
    "1413": "Carry flag will be set if byte is $FF.",
    "1414": "Else print next character.",
    "1452": "Point to the error byte.",
    "1456": "ROM 0, Screen 0, Bank 0, 128 mode.",
    "1457": "Ensure interrupts disable whilst paging.",
    "1458": "Store new state in BANK_M.",
    "1461": "Switch to ROM 0.",
    "1464": "Restore SP from ERR_SP.",
    "1468": "Fetch the error number.",
    "1469": "Store the error number.",
    "1473": "[*BUG* - This should be $1D. As such, error code 'a' will be diverted to ROM 1 for handling. Credit: Paul Farrow]",
    "1478": "Call the error handler routine in ROM 1.",
    "1481": "Store in ERR_NR.",
    "1487": "Set up the address of the character after the '?' marker.",
    "1491": "Set the calculator stack.",
    "1493": "Return to the error routine.",
    "1494": "Read keyboard row B - SPACE.",
    "1498": "Extract the SPACE key.",
    "1499": "Return if SPACE not pressed.",
    "1500": "Read keyboard row CAPS SHIFT - V.",
    "1504": "Extract the CAPS SHIFT key.",
    "1505": "Return if CAPS SHIFT not pressed.",
    "1506": "Produce an error.",
    "1509": "\"L Break into program\"",
    "1510": "Enabled interrupts.",
    "1511": "Save AF registers.",
    "1512": "Address of the RS232 exit routine held in RAM.",
    "1515": "Stack it.",
    "1516": "TVFLAG. Indicate not automatic listing.",
    "1520": "Save the input/output routine address.",
    "1521": "Fetch location of error handler routine from ERR_SP.",
    "1526": "DE=Address of error handler routine.",
    "1528": "ED_ERROR in ROM 1.",
    "1533": "Jump if error handler address is different, i.e. due to INKEY$# or PRINT#.",
    "1535": "Retrieve the input/output routine address.",
    "1540": "Discard the error handler routine address.",
    "1541": "Fetch the original address of ERR_SP (this was stacked at the beginning of the INPUT routine in ROM 1).",
    "1546": "Save the input/output routine address.",
    "1547": "Address to return to.",
    "1550": "Stack the address.",
    "1551": "Jump to the RS232 input/output routine.",
    "1552": "Jump if a character was received.",
    "1554": "Jump if a character was not received.",
    "1556": "Produce an error \"8 End of file\".",
    "1560": "Retrieve the input routine address.",
    "1561": "Jump back to await another character.",
    "1563": "Is it a carriage return?",
    "1567": "Fetch the return address.",
    "1572": "Insert the character into the INPUT line.",
    "1575": "Restore the return address.",
    "1578": "Retrieve the input routine address.",
    "1579": "Jump back to await another character.",
    "1581": "Discard the input routine address.",
    "1582": "Fetch current paging configuration.",
    "1585": "Select ROM 1.",
    "1587": "Stack the required paging configuration.",
    "1588": "Exit",
    "1591": "Retrieve the input/output routine address.",
    "1595": "Stack the return address.",
    "1596": "Jump to input or output routine.",
    "1597": "Return if a character was received.",
    "1598": "Return if a character was not received or was written.",
    "1599": "Produce error report \"8 End of file\".",
    "1601": "[Could just do RST $18]",
    "1348": "Get an expression.",
    "1604": "Get an expression.",
    "1607": "FLAGS.",
    "1611": "Jump ahead if syntax checking.",
    "1613": "Fetch the expression.",
    "1619": "Jump ahead if string is 1 character long.",
    "1621": "Produce error report.",
    "1624": "\"i Invalid device\".",
    "1625": "Get character.",
    "1626": "Convert to upper case.",
    "1628": "\"P\". Is it channel 'P'?",
    "1630": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1633": "Next character to be interpreted.",
    "1637": "Next character must be ';'.",
    "1639": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1642": "Skip past the ';' character.",
    "1645": "Get a numeric expression from the line.",
    "1648": "FLAGS. Checking syntax mode?",
    "1652": "Jump ahead if so.",
    "1654": "Get the result as an integer.",
    "1657": "Store the result temporarily for use later.",
    "1661": "[Could just do RST $18]",
    "1662": "Get the next character in the BASIC line.",
    "1664": "It should be ENTER.",
    "1666": "Jump ahead if it is.",
    "1668": "Or the character is allowed to be ':'.",
    "1670": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1673": "Check for end of line.",
    "1676": "Get the baud rate saved earlier.",
    "1681": "Is it zero?",
    "1682": "Jump if not, i.e. a numeric value was specified.",
    "1684": "Produce error report.",
    "1687": "\"j invalid baud rate\"",
    "1720": "Baud=50.",
    "1724": "Baud=110.",
    "1728": "Baud=300.",
    "1732": "Baud=600.",
    "1736": "Baud=1200.",
    "1740": "Baud=2400.",
    "1744": "Baud=4800.",
    "1748": "Baud=9600.",
    "1688": "Table of supported baud rates.",
    "1695": "HL=Supported baud rate value.",
    "1697": "Reached the last baud rate value in the table?",
    "1699": "Jump is so to use a default baud rate of 9600.",
    "1702": "Table entry matches or is higher than requested baud rate?",
    "1704": "Jump ahead if so to use this baud rate.",
    "1707": "Skip past the timing constant value",
    "1708": "for this baud rate entry.",
    "1711": "HL points to timing value for the baud rate.",
    "1714": "DE=Timing value for the baud rate.",
    "1715": "Store new value in system variable BAUD.",
    "1752": "SERFL holds second char that can be received",
    "1755": "Is the second-character received flag set?",
    "1756": "i.e. have we already received data?",
    "1757": "Jump ahead if not.",
    "1759": "Otherwise clear the flag",
    "1762": "and return the data which we received earlier.",
    "1763": "Set carry flag to indicate success",
    "1765": "Check the BREAK key, and produce error message if it is being pressed.",
    "1768": "Ensure interrupts are disabled to achieve accurate timing.",
    "1770": "Fetch the baud rate timing constant.",
    "1779": "HL=BAUD/2. So that will sync to half way point in each bit.",
    "1781": "[Redundant byte]",
    "1782": "Waiting time for start bit.",
    "1784": "Save B.",
    "1794": "Selects register 14, port I/O of AY-3-8912.",
    "1796": "Read the current state of the I/O lines.",
    "1798": "%11110000. Default all input lines to 1.",
    "1800": "%11111011. Force CTS line to 0.",
    "1802": "B=$BF.",
    "1803": "Make CTS (Clear To Send) low to indicate ready to receive.",
    "1805": "Store status of other I/O lines.",
    "1807": "Read the input line.",
    "1809": "%10000000. Test TXD (input) line.",
    "1811": "Jump if START BIT found.",
    "1813": "Fetch timeout counter",
    "1814": "and decrement it.",
    "1815": "Store it.",
    "1816": "Continue to wait for start bit if not timed out.",
    "1818": "Reset carry flag to indicate no byte read.",
    "1819": "Save the failure flag.",
    "1820": "Timed out waiting for START BIT.",
    "1822": "Second test of START BIT - it should still be 0.",
    "1824": "Test TXD (input) line.",
    "1826": "Jump back if it is no longer 0.",
    "1828": "Third test of START BIT - it should still be 0.",
    "1830": "Test TXD (input) line.",
    "1832": "Jump back if it is no longer 0.",
    "1838": "Preload A with the START BIT. It forms a shift counter used to count",
    "1840": "the number of bits to read in.",
    "1841": "HL=1.5*(BAUD).",
    "1842": "(4) Fine tune the following delay.",
    "1846": "(6) Delay for 26*BAUD.",
    "1847": "(4)",
    "1848": "(4)",
    "1849": "(12) Jump back to until delay completed.",
    "1851": "Read a bit.",
    "1853": "Test TXD (input) line.",
    "1855": "Jump if a 0 received.",
    "1867": "Fetch the bit counter.",
    "1858": "Fetch the bit counter.",
    "1859": "Set carry flag to indicate received a 1.",
    "1860": "Shift received bit into the byte (C->76543210->C).",
    "1861": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1863": "Save the bit counter.",
    "1864": "Jump back to read the next bit.",
    "1868": "Clear carry flag to indicate received a 0.",
    "1869": "Shift received bit into the byte (C->76543210->C).",
    "1870": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1872": "Save the bit counter.",
    "1873": "Jump back to read next bit.",
    "1876": "Signal success.",
    "1877": "Push success flag.",
    "1880": "A=%1111x1xx. Force CTS line to 1.",
    "1882": "B=$BF.",
    "1883": "Make CTS (Clear To Send) high to indicate not ready to receive.",
    "1887": "HL=(BAUD).",
    "1892": "HL=(BAUD)-7.",
    "1894": "Delay for the stop bit.",
    "1897": "Jump back until delay completed.",
    "1899": "HL will be $0000.",
    "1902": "DE=(BAUD).",
    "1904": "HL=3*(BAUD). This is how long to wait for the next start bit.",
    "1905": "Read the input line.",
    "1907": "%10000000. Test TXD (input) line.",
    "1909": "Jump if START BIT found.",
    "1911": "Decrement timeout counter.",
    "1914": "Jump back looping for a start bit until a timeout occurs.",
    "1916": "Return status of first byte read attempt - carry flag reset for no byte received or",
    "1917": "carry flag set and A holds the received byte.",
    "1919": "Second test of START BIT - it should still be 0.",
    "1921": "Test TXD (input) line.",
    "1923": "Jump back if it is no longer 0.",
    "1925": "Third test of START BIT - it should still be 0.",
    "1927": "Test TXD (input) line.",
    "1929": "Jump back if it is no longer 0.",
    "1932": "HL=(BAUD).",
    "1938": "HL=(BAUD)/2.",
    "1941": "HL=(BAUD)/2 - 2.",
    "1946": "Preload A with the START BIT. It forms a shift counter used to count",
    "1948": "the number of bits to read in.",
    "1949": "Fine tune the following delay.",
    "1953": "HL=1.5*(BAUD).",
    "1954": "Delay for 26*(BAUD).",
    "1957": "Jump back to until delay completed.",
    "1959": "Read a bit.",
    "1961": "Test TXD (input) line.",
    "1963": "Jump if a 0 received.",
    "1966": "Fetch the bit counter.",
    "1967": "Set carry flag to indicate received a 1.",
    "1968": "Shift received bit into the byte (C->76543210->C).",
    "1969": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1971": "Save the bit counter.",
    "1972": "Jump back to read the next bit.",
    "1975": "Fetch the bit counter.",
    "1976": "Clear carry flag to indicate received a 0.",
    "1977": "Shift received bit into the byte (C->76543210->C).",
    "1978": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1980": "Save the bit counter.",
    "1981": "Jump back to read next bit.",
    "1987": "Set the flag indicating a second byte is in the buffer.",
    "1990": "Store the second byte read in the buffer.",
    "1991": "Return the first byte.",
    "1992": "Re-enable interrupts.",
    "1994": "Save the character to print.",
    "1995": "Number of parameters expected.",
    "1999": "Jump if no parameters.",
    "2001": "Ignore the parameter.",
    "2005": "Jump ahead if we have not processed all parameters.",
    "2007": "Retrieve character to print.",
    "2008": "Jump ahead to continue.",
    "2011": "Retrieve character to print.",
    "2012": "TVDATA+1. Store it for use later.",
    "2016": "Retrieve character to print.",
    "2017": "Test against code for 'SPECTRUM'.",
    "2019": "Jump ahead if not a token.",
    "2021": "Save RETADDR temporarily.",
    "2026": "Print tokens via call to ROM 1 routine PO-T&UDG.",
    "2029": "Restore the original contents of RETADDR.",
    "2037": "Suppress printing a leading space.",
    "2039": "Is character to output a space?",
    "2043": "Signal leading space required.",
    "2041": "Jump ahead if not a space.",
    "2045": "Compare against copyright symbol.",
    "2047": "Jump ahead if not a graphic or UDG character.",
    "2049": "\"?\". Print a '?' for all graphic and UDG characters.",
    "2051": "Is it a control character?",
    "2053": "Jump ahead if so.",
    "2055": "Save the character to print.",
    "2056": "Point to the column number.",
    "2059": "Increment the column number.",
    "2060": "Fetch the number of columns.",
    "2064": "Jump if end of row not reached.",
    "2066": "Print a carriage return and line feed.",
    "2071": "Set the print position to column 1.",
    "2074": "Retrieve character to print.",
    "2075": "Jump ahead to print the character.",
    "2078": "Is it a carriage return?",
    "2080": "Jump ahead if not.",
    "2083": "Set the print position back to column 0.",
    "2088": "Print a carriage return.",
    "2093": "Print a line feed.",
    "2096": "Is it a comma?",
    "2098": "Jump ahead if not.",
    "2100": "Fetch the column position.",
    "2104": "Will count number of columns to move across to reach next comma position.",
    "2106": "Increment column counter.",
    "2107": "Increment column position.",
    "2109": "End of row reached?",
    "2110": "Jump if so.",
    "2114": "Jump if column 8, 16, 24 or 32 reached.",
    "2116": "Column position greater so subtract another 8.",
    "2118": "Jump back and increment column position again.",
    "2120": "Save column counter in E.",
    "2123": "Output a space via a recursive call.",
    "2126": "Retrieve column counter to E.",
    "2127": "More spaces to output?",
    "2128": "Return if no more to output.",
    "2129": "Repeat for the next space to output.",
    "2131": "Is it AT?",
    "2133": "Jump ahead to handle AT.",
    "2135": "Is it TAB?",
    "2137": "Jump ahead to handle TAB.",
    "2139": "Check for INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2141": "Ignore if not one of these.",
    "2142": "Jump ahead to handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2144": "Store the control code for use later, $16 (AT) or $17 (TAB).",
    "2147": "Two parameters expected (even for TAB).",
    "2152": "Return with zero flag set.",
    "2153": "Store the control code for use later.",
    "2156": "Two parameters expected. [*BUG* - Should be 1 parameter. 'LPRINT INK 4' will produce error report 'C Nonsense in BASIC'. Credit: Toni Baker, ZX Computing Monthly].",
    "2161": "[*BUG* - Should return with the carry flag reset and the zero flag set. It causes a statement such as 'LPRINT INK 1;' to produce error report '8 End of file'. It is due to the main RS232 processing loop using the state of the flags to determine the success/failure response of the RS232 output routine. Credit: Ian Collier (+3), Andrew Owen (128)] [The bug can be fixed by inserting a XOR A instruction before the RET instruction. Credit: Paul Farrow]",
    "2162": "D=Character to print.",
    "2163": "Fetch the control code.",
    "2166": "Is it AT?",
    "2170": "Is it TAB?",
    "2168": "Jump ahead to handle AT parameter.",
    "2172": "Disable interrupts to ensure accurate timing.",
    "2173": "Ignore if not TAB.",
    "2174": "TV_DATA+1. Fetch the saved parameter.",
    "2177": "Fetch parameter to D.",
    "2181": "Reached end of row?",
    "2182": "Jump ahead if so.",
    "2184": "Jump ahead if before end of row.",
    "2186": "(WIDTH).",
    "2187": "TAB/AT column position.",
    "2188": "TAB/AT position - WIDTH.",
    "2189": "The new required column position.",
    "2190": "Handle the new TAB/AT position.",
    "2192": "Fetch the desired column number.",
    "2194": "Jump to output a carriage return if column 0 required.",
    "2197": "Fetch the current column position.",
    "2200": "Compare against desired column position.",
    "2201": "Done if reached requested column.",
    "2202": "Save the number of spaces to output.",
    "2205": "Output a space via a recursive call.",
    "2208": "Retrieve number of spaces to output.",
    "2209": "Keep outputting spaces until desired column reached.",
    "2211": "Save the byte to send.",
    "2221": "Select AY register 14 to control the RS232 port.",
    "2223": "Check the BREAK key, and produce error message if it is being pressed.",
    "2226": "Read status of data register.",
    "2228": "%01000000. Test the DTR line.",
    "2230": "Jump back until device is ready for data.",
    "2232": "HL=Baud rate timing constant.",
    "2239": "DE=(BAUD)-2.",
    "2242": "Retrieve the byte to send.",
    "2243": "Invert the bits of the byte (RS232 logic is inverted).",
    "2244": "Carry is used to send START BIT.",
    "2245": "B=Number of bits to send (1 start + 8 data + 2 stop).",
    "2247": "Disable interrupts to ensure accurate timing.",
    "2248": "Save the number of bits to send.",
    "2249": "Save the data bits.",
    "2253": "HL=(BAUD)-2.",
    "2254": "AY-3-8912 data register.",
    "2257": "Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).",
    "2260": "Clear the RXD (out) line.",
    "2262": "Send out a 0 (high level).",
    "2264": "Jump ahead to continue with next bit.",
    "2266": "Set the RXD (out) line.",
    "2268": "Send out a 1 (low level).",
    "2270": "Jump ahead to continue with next bit. [We use theis unnecessary looking JR for timing]",
    "2272": "(6) Delay 26*BAUD cycles.",
    "2273": "(4)",
    "2274": "(4)",
    "2275": "(12) Jump back until delay is completed.",
    "2277": "(4) Fine tune the timing.",
    "2278": "(4)",
    "2279": "(4)",
    "2280": "Retrieve the data bits to send.",
    "2281": "Retrieve the number of bits left to send.",
    "2282": "Clear carry flag.",
    "2283": "Shift the next bit to send into the carry flag.",
    "2284": "Jump back to send next bit until all bits sent.",
    "2286": "Re-enable interrupts.",
    "2287": "Return with carry and zero flags reset.",
    "2288": "Half row counter.",
    "2291": "Set the half row counter to 43 half rows (will output 44 half rows in total).",
    "2293": "Point to printer configuration data (7/72 inch line spacing, double density bit graphics).",
    "2425": "6 characters follow.",
    "2426": "ESC '1'     - 7/72 inch line spacing.",
    "2428": "ESC 'L' 0 3 - Double density (768 bytes per row).",
    "2432": "1 character follows.",
    "2433": "Line feed.",
    "2434": "2 characters follow.",
    "2435": "ESC '2' - 1/6 inch line spacing.",
    "2296": "Send the configuration data to printer.",
    "2299": "Output a half row, at double height.",
    "2302": "Table holds a line feed only.",
    "2305": "Send a line feed to printer.",
    "2308": "The half row counter is tested to see if it is zero",
    "2311": "and if so then the line spacing is reset to its",
    "2312": "original value.",
    "2313": "Jump if done, resetting printer line spacing.",
    "2315": "Decrement half row counter.",
    "2316": "Repeat for the next half row.",
    "2318": "Point to printer configuration data (1/6 inch line spacing).",
    "2321": "Send the configuration data to printer.",
    "2324": "[Could have saved 1 byte by using JP $095F (ROM 0)]",
    "2325": "Pixel column counter.",
    "2328": "Set pixel column counter to 255 pixels.",
    "2330": "Output a column of pixels, at double height.",
    "2333": "Pixel column counter.",
    "2337": "Check if all pixels in this row have been output.",
    "2338": "Return if so.",
    "2339": "Decrement pixel column counter.",
    "2340": "Repeat for all pixels in this row.",
    "2342": "D=%11000000. Used to hold the double height pixel.",
    "2345": "C=Pixel column counter, B=Half row counter.",
    "2350": "B=2xB+1",
    "2353": "B=4xB+3. The pixel row coordinate.",
    "2355": "Pixel column counter.",
    "2357": "C=255-C. The pixel column coordinate.",
    "2358": "Clear A. Used to generate double height nibble of pixels to output.",
    "2361": "Save registers.",
    "2362": "Test whether pixel (B,C) is set",
    "2366": "Restore registers.",
    "2367": "Set double height pixel = 0.",
    "2369": "Jump if pixel is reset.",
    "2371": "The double height pixel to output (%11000000, %00110000, %00001100 or %00000011).",
    "2375": "Decrement half row coordinate.",
    "2373": "Add the double height pixel value to the byte to output.",
    "2378": "Create next double height pixel value (%00110000, %00001100 or %00000011).",
    "2382": "Repeat for all four pixels in the half row.",
    "2385": "Unload the stack.",
    "2387": "Send double height nibble of pixels output 3 times.",
    "2391": "Send byte to RS232 port.",
    "2399": "Get number of bytes to send.",
    "2400": "Point to the data to send.",
    "2401": "Retrieve value.",
    "2404": "Send byte to RS232 port.",
    "2409": "Point to next data byte to send.",
    "2410": "Repeat for all bytes.",
    "2414": "Get address of (B,C) pixel into HL and pixel position within byte into A.",
    "2416": "B=Pixel position within byte (0-7).",
    "2418": "Pixel mask.",
    "2419": "Carry flag holds bit to be rotated into the mask.",
    "2420": "Shift the mask bit into the required bit position.",
    "2423": "Isolate this pixel from A.",
    "2437": "Disable interrupts to ensure accurate timing.",
    "2445": "Calculate HL=$003C + ($0037 * B).",
    "2449": "BC=Space required (maximum = $01F4).",
    "2451": "Make BC bytes of space in the workspace.",
    "2453": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2455": "IY=Points at first new byte - the command data block.",
    "2458": "IX=Points at last new byte - byte after all channel information blocks.",
    "2460": "Initial channel bitmap with value meaning 'zero strings'",
    "2464": "$-37 ($37 bytes is the size of a play channel string information block).",
    "2467": "IX points to start of space for the last channel.",
    "2469": "Default octave is 5.",
    "2473": "No MIDI channel assigned.",
    "2477": "Default volume is 15.",
    "2481": "Default note duration.",
    "2485": "Count of the number of tied notes.",
    "2489": "Signal not to repeat the string indefinitely.",
    "2493": "No opening bracket nesting level.",
    "2497": "No closing bracket nesting level.",
    "2501": "Return address for closing bracket nesting level 0.",
    "2505": "[No need to initialise this since it is written to before it is ever tested]",
    "2510": "Get the details of the string from the stack.",
    "2512": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2513": "Store the current position within in the string, i.e. the beginning of it.",
    "2519": "Store the return position within the string for a closing bracket,",
    "2522": "which is initially the start of the string in case a single closing bracket is found.",
    "2525": "HL=Points to start of string. BC=Length of string.",
    "2526": "HL=Points to address of byte after the string.",
    "2527": "Store the address of the character just",
    "2530": "after the string.",
    "2533": "B=String index number (range 1 to 8).",
    "2534": "Save it on the stack again.",
    "2535": "Reduce the index so it ranges from 0 to 7.",
    "2539": "BC=String index*2.",
    "2543": "HL=Address of the command data block.",
    "2544": "Skip 8 channel data pointer words.",
    "2547": "BC=Address of current channel information block.",
    "2548": "Store the pointer to the channel information block.",
    "2551": "Clear the carry flag.",
    "2552": "Rotate one zero-bit into the least significant bit of the channel bitmap. This initially holds $FF but once this loop is over, this byte has a zero bit for each string parameter of the PLAY command.",
    "2556": "B=Current string index.",
    "2557": "Decrement string index so it ranges from 0 to 7.",
    "2558": "Save it for future use on the next iteration.",
    "2559": "Store the channel number.",
    "2562": "Jump back while more channel strings to process.",
    "2564": "Drop item left on the stack.",
    "2565": "Set the initial tempo timing value.",
    "2569": "Corresponds to a 'T' command value of 120, and gives two crotchets per second.",
    "2575": "HL=Points to the command data block.",
    "2580": "DE=Address to store RAM routine.",
    "2581": "HL=Address of the RAM routine bytes.",
    "2587": "Copy the calculator routine to RAM.",
    "2589": "Register 7 - Mixer.",
    "2591": "I/O ports are inputs, noise output off, tone output on.",
    "2593": "Write to sound generator register.",
    "2596": "Register 11 - Envelope Period (Fine).",
    "2598": "Set period to maximum.",
    "2600": "Write to sound generator register.",
    "2603": "Register 12 - Envelope Period (Coarse).",
    "2604": "Write to sound generator register.",
    "2607": "Jump ahead to continue. [Could have saved these 2 bytes by having the code at $0A7D (ROM 0) immediately follow]",
    "2609": "Invoke the floating point calculator.",
    "2610": "x, 10",
    "2611": "10, x",
    "2612": "10/x",
    "2619": "(10/x)/7.33e-6",
    "2627": "Return with carry flag set if SPACE not pressed.",
    "2633": "Return with carry flag set if CAPS not pressed.",
    "2634": "Offset to the channel data block duration pointers table.",
    "2637": "Jump ahead to continue.",
    "2639": "Offset to the channel data block pointers table.",
    "2644": "HL=Point to the command data block.",
    "2645": "Point to the desired channel pointers table.",
    "2649": "Store the start address of channels pointer table.",
    "2652": "Fetch the channel bitmap.",
    "2655": "Initialise the working copy.",
    "2658": "Channel selector. Set the shift register to indicate the first channel.",
    "2665": "Fetch the address of the current channel data block.",
    "2667": "Return it in IX.",
    "2670": "The address of current channel data pointer.",
    "2677": "Advance to the next channel data pointer.",
    "2681": "The address of new channel data pointer.",
    "2685": "Select channel data block pointers.",
    "2688": "Working copy of channel bitmap. Test if next string present.",
    "2692": "Jump ahead if there is no string for this channel.",
    "2694": "Get address of channel data block for the current string into IX.",
    "2697": "Find the first note to play for this channel from its play string.",
    "2700": "Have all channels been processed?",
    "2704": "Jump ahead if so.",
    "2706": "Advance to the next channel data block pointer.",
    "2709": "Jump back to process the next channel.",
    "2711": "Find smallest duration length of the current notes across all channels.",
    "2714": "Save the smallest duration length.",
    "2715": "Play a note on each channel.",
    "2718": "DE=The smallest duration length.",
    "2719": "Channel bitmap.",
    "2722": "Is there anything to play?",
    "2724": "Jump if there is.",
    "2726": "Turn off all sound and restore IY.",
    "2729": "Re-enable interrupts.",
    "2730": "End of play command.",
    "2731": "DE=Smallest channel duration length, i.e. duration until the next channel state change.",
    "2732": "Perform a wait.",
    "2735": "Play a note on each channel and update the channel duration lengths.",
    "2738": "Find smallest duration length of the current notes across all channels.",
    "2741": "Jump back to see if there is more to process.",
    "2743": "\"HZYXWUVMT)(NO!\"",
    "2757": "Get the current character from the play string for this channel.",
    "2760": "Return if no more characters.",
    "2761": "Increment the low byte of the string pointer.",
    "2764": "Return if it has not overflowed.",
    "2765": "Else increment the high byte of the string pointer.",
    "2768": "Returns with carry flag reset.",
    "2769": "Save HL.",
    "2770": "Default is for a 'natural' note, i.e. no adjustment.",
    "2772": "Get the current character from the PLAY string, and advance the position pointer.",
    "2775": "Jump if at the end of the string.",
    "2777": "\"&\". Is it a rest?",
    "2779": "Jump ahead if not.",
    "2781": "Signal that it is a rest.",
    "2783": "Restore HL.",
    "2785": "Fetch the channel selector.",
    "2788": "Clear the channel flag for this string.",
    "2791": "Store the new channel bitmap.",
    "2794": "Jump back to return.",
    "2796": "\"#\". Is it a sharpen?",
    "2798": "Jump ahead if not.",
    "2800": "Increment by a semitone.",
    "2801": "Jump back to get the next character.",
    "2803": "\"$\". Is it a flatten?",
    "2805": "Jump ahead if not.",
    "2807": "Decrement by a semitone.",
    "2808": "Jump back to get the next character.",
    "2810": "Is it a lower case letter?",
    "2812": "Jump ahead if lower case.",
    "2814": "It is an upper case letter so",
    "2815": "increase an octave",
    "2817": "by adding 12 semitones.",
    "2822": "Reduce to range 'A'->0 .. 'G'->6.",
    "2820": "Convert to upper case.",
    "2824": "Jump if below 'A' to produce error report \"k Invalid note name\".",
    "2827": "Is it 7 or above?",
    "2829": "Jump if so to produce error report \"k Invalid note name\".",
    "2832": "C=Number of semitones.",
    "2835": "BC holds 0..6 for 'a'..'g'.",
    "2836": "Look up the number of semitones above note C for the note.",
    "2840": "A=Number of semitones above note C.",
    "2841": "C=Number of semitones due to sharpen/flatten characters.",
    "2842": "Adjust number of semitones above note C for the sharpen/flatten characters.",
    "2843": "Restore HL.",
    "3577": "'A,', 'B', 'C', 'D', 'E', 'F', 'G'",
    "2845": "Save registers.",
    "2847": "Get the pointer into the PLAY string.",
    "2853": "Initialise result to 0.",
    "2857": "\"0\". Is character numeric?",
    "2859": "Jump ahead if not.",
    "2861": "\":\". Is character numeric?",
    "2863": "Jump ahead if not.",
    "2866": "Save the pointer into the string.",
    "2867": "Multiply result so far by 10.",
    "2870": "\"0\". Convert ASCII digit to numeric value.",
    "2874": "HL=Numeric digit value.",
    "2875": "Add the numeric value to the result so far.",
    "2876": "Jump ahead if an overflow to produce error report \"l number too big\".",
    "2878": "Transfer the result into DE.",
    "2879": "Retrieve the pointer into the string.",
    "2880": "Loop back to handle any further numeric digits.",
    "2882": "Jump to produce error report \"l number too big\".",
    "2885": "Store the new pointer position into the string.",
    "2892": "Return the result in BC.",
    "2893": "Restore registers."
  },
  "PrefixComments": {
    "0": "RST $00 - Reset Machine",
    "16": "RST $10 - Print A Character",
    "24": "RST $18 - Collect A Character",
    "40": "RST 28 calls a routine in ROM 1 (or alternatively a routine in RAM while ROM 1 is paged in). Call as follows: RST 28 / DEFW address.",
    "56": "This routine preserves the HL register pair. It then performs the following: 1) Execute the ROM switching code held in RAM to switch to ROM 1; 2) Execute the maskable interrupt routine in ROM 1; 3) Execute the ROM switching code held in RAM to return to ROM 0; Return to address $0048 (ROM 0)",
    "74": "ERROR HANDLER ROUTINES - PART 1 - 128K Error Routine",
    "92": "RESTART ROUTINES - PART 2 -Call ROM 1 Routine (RST $28 Continuation); Continuation from routine at $0028 (ROM 0).",
    "107": "RAM ROUTINES: The following code will be copied to locations $5B00 to $5B57, within the old ZX Printer buffer.",
    "127": "Return to Other ROM Routine (copied to $5B14)",
    "136": "Error Handler Routine (copied to $5B1D)",
    "154": "'P' Channel Input Routine (copied to $5B2F)",
    "159": "'P' Channel Output Routine (copied to $5B34)",
    "181": "'P' Channel Exit Routine (copied to $5B4A)",
    "195": "ERROR HANDLER ROUTINES - PART 2: Called from ONERR ($5B1D) to execute the routine pointed to by system variable SYNRET.",
    "199": "Reset Routine (RST $00 Continuation, Part 1): Continuation from routine at $0000 (ROM 0). It performs a test on all RAM banks. This test is crude and can fail to detect a variety of RAM errors.",
    "256": "ROUTINE VECTOR TABLE",
    "305": "INITIALISATION ROUTINES - PART 2: Fatal RAM Error -- Set the border colour to indicate which RAM bank was found faulty.",
    "311": "Reset Routine (RST $00 Continuation, Part 2): Continuation from routine at $00C7 (ROM 0).",
    "413": "Entry point for NEW with interrupts disabled and physical RAM bank 0 occupying the upper RAM region $C000 - $FFFF, i.e. the normal BASIC memory configuration.",
    "1417": "The 'Initial Channel Information': Initially there are four channels ('K', 'S', 'R', & 'P') for communicating with the 'keyboard', 'screen', 'work space' and 'printer'. For each channel the output routine address comes before the input routine address and the channel's code. This table is almost identical to that in ROM 1 at $15AF but with changes to the channel P routines to use the RS232 port instead of the ZX Printer. Used at $01DD (ROM 0).",
    "1438": "The 'Initial Stream Data': Initially there are seven streams - $FD to $03. This table is identical to that in ROM 1 at $15C6. Used at $0226 (ROM 0).",
    "610": "[Note this is where $EC13 (temporary P_FLAG) and $FF24 should be set]",
    "619": "COMMAND EXECUTION ROUTINES - PART 1: Execute Command Line - A typed in command resides in the editing workspace. Execute it.  The command could either be a new line to insert, or a line number to delete, or a numerical expression to evaluate.",
    "690": "Calculator mode",
    "696": "Otherwise ignore the command",
    "698": "Return from BASIC Line Syntax Check: This routine is returned to when a BASIC line has been syntax checked.",
    "705": "The syntax check was successful, so now proceed to parse the line for insertion or execution",
    "719": "Parse a BASIC Line with No Line Number",
    "780": "[*BUG* - Whenever a typed in command is executed directly from the editing workspace, a new GO SUB marker is set up on the stack. Any existing GO SUB calls that were on the stack are lost and as a result attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. However, the stack marker will already have been lost due to the error handler routine at $0321. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. This is why it is necessary for a new GO SUB marker needs to be set up. Credit: Michal Skrzypek]",
    "801": "ERROR HANDLER ROUTINES - PART 3: Error Handler Routine - [*BUG* - Upon terminating a BASIC program, either via reaching the end of the program or due to an error occurring, execution is passed to this routine. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. However, this means that any existing GO SUB calls that were on the stack are lost and so attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. When a new typed in command is executed, the code at $030C sets up a new GO SUB marker on the stack. Credit: Michal Skrzypek]",
    "842": "Display error code held in ERR_NR",
    "906": "Display a new error message - [Note that there is no test to range check the error code value and therefore whether a message exists for it. Poking directly to system variable ERR_NR with an invalid code (43 or above) will more than likely cause a crash]",
    "924": "Display a standard error message.",
    "1007": "Error Handler Routine When Parsing BASIC Line",
    "1015": "COMMAND EXECUTION ROUTINES - PART 2: Parse a BASIC Line with a Line Number - This routine handles insertion of a BASIC line specified with a line number, or just a line number specified on its own, i.e. delete the line.",
    "1059": "The line already exists so delete it",
    "1071": "Just a line number entered. The requested line has already been deleted so move the program cursor to the next line",
    "1132": "ERROR HANDLER ROUTINES - PART 4: New Error Message Vector Table",
    "1164": "New Error Message Table",
    "1405": "Print a message which is terminated by having bit 7 set, pointed at by DE.",
    "1452": "ERROR HANDLER ROUTINES - PART 5: Produce Error Report",
    "1477": "Handle a standard error code",
    "1480": "Handle a new error code",
    "1494": "Check for BREAK into Program",
    "1510": "RS232 PRINTER ROUTINES: RS232 Channel Handler Routines - This routine handles input and output RS232 requested. It is similar to the routine in the ZX Interface 1 ROM at $0D5A, but in that ROM the routine is only used for input.",
    "1535": "Handle INPUT#",
    "1552": "Return here from the input/output routine",
    "1560": "A character was not received",
    "1563": "A character was received",
    "1581": "Enter was received so end reading the stream",
    "1591": "Handle INKEY$# and PRINT#",
    "1597": "Return here from the input/output routine. When returning from the output routine, either the carry or zero flags should always be set to avoid the false generation of error report \"8 End of file\" [though this is not always the case - see bugs starting at $086C (ROM 0)].",
    "1601": "FORMAT Routine: The format command sets the RS232 baud rate, e.g. FORMAT \"P\"; 9600. It attempts to match against one of the supported baud rates, or uses the next higher baud rate if a non-standard value is requested. The maximum baud rate supported is 9600, and this is used for any rates specified that are higher than this.",
    "1688": "Lookup the timing constant to use for the specified baud rate",
    "1720": "Baud Rate Table: Consists of entries of baud rate value followed by timing constant to use in the RS232 routines.",
    "1711": "The baud rate has been matched",
    "1752": "RS232 Input Routine - Exit: Carry flag set if a byte was read with the byte in A. Carry flag reset upon error.",
    "1765": "Read Byte from RS232 Port: The timing of the routine is achieved using the timing constant held in system variable BAUD. Exit: Carry flag set if a byte was read, or reset upon error. A=Byte read in.",
    "1806": "Look for the start bit",
    "1834": "A start bit has been found, so the 8 data bits are now read in. As each bit is read in, it is shifted into the msb of A. Bit 7 of A is preloaded with a 1 to represent the start bit and when this is shifted into the carry flag it signifies that 8 data bits have been read in.",
    "1858": "Received one 1",
    "1867": "Received one 0",
    "1876": "After looping 8 times to read the 8 data bits, the start bit in the bit counter will be shifted out and hence A will contain a received byte.",
    "1879": "The success and failure paths converge here",
    "1905": "The device at the other end of the cable may send a second byte even though CTS is low. So repeat the procedure to read another byte.",
    "1916": "No second byte incoming so return status of the first byte read attempt",
    "1931": "A second byte is on its way and is received exactly as before",
    "1966": "Received one 1",
    "1975": "Received one 0",
    "1984": "Exit with the byte that was read in",
    "1994": "RS232 Output Routine: This routine handles control codes, token expansion, graphics and UDGs. It therefore cannot send binary data and hence cannot support EPSON format ESC control codes [Credit: Andrew Owen]. The routine suffers from a number of bugs as described in the comments below. It also suffers from a minor flaw in the design, which prevents interlacing screen and printer control codes and their parameters. Entry: A=character to output. Exit : Carry flag reset indicates success.",
    "2007": "All parameters processed",
    "2021": "Process tokens",
    "2055": "Printable character",
    "2082": "Handle a carriage return",
    "2078": "Process control codes",
    "2100": "Handle a comma",
    "2120": "Column 8, 16, 24 or 32 reached. Output multiple spaces until the desired column position is reached.",
    "2144": "Handle AT and TAB",
    "2153": "Handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER",
    "2162": "All parameters processed",
    "2174": "Handle TAB parameter",
    "2178": "Process AT and TAB",
    "2186": "Column position equal or greater than length of row requested",
    "2211": "Write Byte to RS232 Port - The timing of the routine is achieved using the timing constant held in system variable BAUD. Entry: A holds character to send. Exit:  Carry and zero flags reset.",
    "2248": "Transmit each bit",
    "2260": "Transmit a 0",
    "2266": "Transmit a 1",
    "2288": "COPY Command Routine - This routine copies 22 rows of the screen, outputting them to the printer a half row at a time. It is designed for EPSON compatible printers supporting double density bit graphics and 7/72 inch line spacing. Only the pixel information is processed; the attributes are ignored.",
    "2425": "EPSON Printer Control Code Tables",
    "2318": "Copy done so reset printer line spacing before exiting",
    "2325": "Output Half Row",
    "2342": "Output a column of pixels (at double height)",
    "2389": "Output Nibble of Pixels: Send each nibble of pixels (i.e. column of 4 pixels) output 3 times so that the width of a pixel is the same size as its height.",
    "2399": "Output Characters from Table: This routine is used to send a sequence of EPSON printer control codes out to the RS232 port. It sends (HL) characters starting from HL+1.",
    "2413": "Test Whether Pixel (B,C) is Set",
    "2509": "[*BUG* - At this point interrupts are disabled and IY is now being used as a pointer to the master PLAY information block. Unfortunately, interrupts are enabled during the STK_FETCH call and IY is left containing the wrong value. This means that if an interrupt were to occur during execution of the subroutine then there would be a one in 65536 chance that (IY+$40) will be corrupted - this corresponds to the volume setting for music channel A. Rewriting the SWAP routine to only re-enable interrupts if they were originally enabled would cure this bug (see end of file for description of her suggested fix). Credit: Toni Baker, ZX Computing Monthly]",
    "2437": "PLAY COMMAND ROUTINES - Up to 3 channels of music/noise are supported by the AY-3-8912 sound generator. Up to 8 channels of music can be sent to support synthesisers, drum machines or sequencers via the MIDI interface, with the first 3 channels also played by the AY-3-8912 sound generator. For each channel of music, a MIDI channel can be assigned to it using the 'Y' command. Entry: B=The number of strings in the PLAY command (1..8).",
    "2565": "Entry point here from the vector table at $011B",
    "2609": "Calculate Timing Loop Counter <<< RAM Routine >>> - This routine is copied into the command data block (offset $2B..$37) by the routine at $0A05 (ROM 0). It uses the floating point calculator found in ROM 1, which is usually invoked via a RST $28 instruction. Since ROM 0 uses RST $28 to call a routine in ROM 1, it is unable to invoke the floating point calculator this way. It therefore copies the following routine to RAM and calls it with ROM 1 paged in.",
    "2622": "Test BREAK Key: Test for BREAK being pressed. Exit: Carry flag reset if BREAK is being pressed.",
    "2634": "Select Channel Data Block Duration Pointers: Point to the start of the channel data block duration pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2639": "Select Channel Data Block Pointers: Point to the start of the channel data block pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2663": "Get Channel Data Block Address for Current String: Entry: HL=Address of channel data block pointer. Exit : IX=Address of current channel data block.",
    "2670": "Next Channel Data Pointer",
    "2685": "PLAY Command (Continuation): This section is responsible for processing the PLAY command and is a continuation of the routine at $0985 (ROM 0). It begins by determining the first note to play on each channel and then enters a loop to play these notes, fetching the subsequent notes to play at the appropriate times.",
    "2694": "HL=Address of channel data pointer.",
    "2711": "The first notes to play for each channel have now been determined. A loop is entered that coordinates playing the notes and fetching subsequent notes when required. Notes across channels may be of different lengths and so the shortest one is determined, the tones for all channels set and then a waiting delay entered for the shortest note delay. This delay length is then subtracted from all channel note lengths to leave the remaining lengths that each note needs to be played for. For the channel with the smallest note length, this will now have completely played and so a new note is fetched for it. The smallest length of the current notes is then determined again and the process described above repeated. A test is made on each iteration to see if all channels have run out of data to play, and if so this ends the PLAY command.",
    "2743": "PLAY Command Character Table: Recognised characters in PLAY commands.",
    "2757": "Get Play Character: Get the current character from the PLAY string and then increment the character pointer within the string. Exit: Carry flag set if string has been fully processed. Carry flag reset if character is available. A=Character available.",
    "2769": "Get Next Note in Semitones: Finds the number of semitones above C for the next note in the string, Entry: IX=Address of the channel data block. Exit : A=Number of semitones above C, or $80 for a rest.",
    "3577": "Semitones Table: This table contains an entry for each note of the scale, A to G, and is the number of semitones above the note C.",
    "2845": "Get Numeric Value from Play String: Get a numeric value from a PLAY string, returning 0 if no numeric value present. Entry: IX=Address of the channel data block. Exit : BC=Numeric value, or 0 if no numeric value found.",
    "2885": "The end of the numeric value was reached"
  },
  "Literals": {
    "23386": [
      "RETADDR"
    ],
    "23296": [
      "SWAP",
      "SWAP_RAM"
    ],
    "23388": [
      "BANK_M"
    ],
    "23384": [
      "TARGET"
    ],
    "23316": [
      "YOUNGER",
      "YOUNGER_RAM"
    ],
    "23435": [
      "SYNRET"
    ],
    "23432": [
      "ROW01"
    ],
    "23389": [
      "RAMRST"
    ],
    "23551": [
      "TSTACK"
    ],
    "23427": [
      "SFNEXT"
    ],
    "23429": [
      "SPSPACE",
      "SFSPACE"
    ],
    "23431": [
      "SFSPACE_P2"
    ],
    "23732": [
      "P_RAMT"
    ],
    "23675": [
      "UDG"
    ],
    "23608": [
      "RASP"
    ],
    "23730": [
      "RAMTOP"
    ],
    "23606": [
      "CHARS"
    ],
    "23393": [
      "SERFL"
    ],
    "23391": [
      "BAUD"
    ],
    "23395": [
      "COL"
    ],
    "23397": [
      "TVPARS"
    ],
    "23396": [
      "WIDTH"
    ],
    "23444": [
      "RNFIRST"
    ],
    "23446": [
      "RNSTEP"
    ],
    "23631": [
      "CHANS"
    ],
    "23639": [
      "DATADD"
    ],
    "23635": [
      "PROG"
    ],
    "23627": [
      "VARS"
    ],
    "23641": [
      "E_LINE"
    ],
    "23649": [
      "WORKSP"
    ],
    "23651": [
      "STKBOT"
    ],
    "23653": [
      "STKEND"
    ],
    "23693": [
      "ATTR_P"
    ],
    "23695": [
      "MASK_P"
    ],
    "23624": [
      "BORDCR"
    ],
    "23561": [
      "REPDEL"
    ],
    "23568": [
      "STRMS"
    ],
    "23425": [
      "OLDSP"
    ],
    "23398": [
      "FLAGS3"
    ],
    "23325": [
      "ONERR"
    ],
    "23613": [
      "ERR_SP"
    ],
    "23645": [
      "CH_ADD"
    ],
    "23612": [
      "TVFLAG"
    ],
    "23692": [
      "SCR_CT"
    ],
    "23610": [
      "ERR_NR"
    ],
    "23563": [
      "DEFADD"
    ],
    "5009": [
      "ERR_MSGS"
    ],
    "23621": [
      "PPC"
    ],
    "23664": [
      "OSPPC"
    ],
    "23620": [
      "NSPPC"
    ],
    "23625": [
      "E_PPC"
    ],
    "23390": [
      "RAMERR"
    ],
    "23647": [
      "X_PTR"
    ],
    "23370": [
      "POUT2"
    ],
    "23409": [
      "HD_00"
    ],
    "23611": [
      "FLAGS"
    ],
    "23566": [
      "TD_DATA"
    ],
    "23410": [
      "HD_0B"
    ]
  },
  "LiteralReplacements": {
    "45": "RETADDR",
    "61": "SWAP_RAM",
    "65": "MASK_INT",
    "57": "MASK_INT_RET",
    "81": "BANK_M",
    "92": "TARGET",
    "95": "YOUNGER_RAM",
    "100": "TARGET",
    "112": "BANK_M",
    "118": "BANK_M",
    "131": "RETADDR",
    "137": "BANK_M",
    "142": "BANK_M",
    "154": "RS232_INP",
    "159": "RS232_OUT",
    "166": "BANK_M",
    "173": "BANK_M",
    "187": "BANK_M",
    "195": "SYNRET",
    "234": "ROW01",
    "321": "SWAP_RAM",
    "324": "SWAP",
    "334": "RAMRST",
    "337": "TSTACK",
    "349": "SFNEXT",
    "370": "SFSPACE",
    "373": "SFSPACE_P2",
    "384": "P_RAMT",
    "399": "UDG",
    "406": "RASP",
    "410": "RAMTOP",
    "416": "CHARS",
    "419": "RAMTOP",
    "442": "SERFL",
    "438": "BAUD",
    "445": "COL",
    "448": "TVPARS",
    "459": "WIDTH",
    "465": "RNFIRST",
    "468": "RNSTEP",
    "474": "CHANS",
    "477": "CHAN_INFO",
    "488": "DATADD",
    "492": "PROG",
    "495": "VARS",
    "501": "E_LINE",
    "510": "WORKSP",
    "513": "STKBOT",
    "516": "STKEND",
    "521": "ATTR_P",
    "524": "MASK_P",
    "527": "BORDCR",
    "541": "REPDEL",
    "553": "STRMS",
    "579": "COPYR_MSG",
    "593": "TSTACK",
    "596": "OLDSP",
    "619": "FLAGS3",
    "632": "ONERR",
    "636": "ERR_SP",
    "640": "RET_SYN_CHECK",
    "643": "SYNRET",
    "705": "E_LINE",
    "708": "CH_ADD",
    "759": "TVFLAG",
    "769": "SCR_CT",
    "784": "ONERR",
    "788": "ERR_SP",
    "792": "ERR_HANDLER",
    "795": "SYNRET",
    "801": "RAMTOP",
    "806": "TSTACK",
    "809": "OLDSP",
    "817": "FLAGS3",
    "827": "SFNEXT",
    "842": "ERR_NR",
    "856": "DEFADD",
    "924": "ERR_MSGS",
    "937": "PPC",
    "958": "ERR_NR",
    "978": "OSPPC",
    "981": "NSPPC",
    "999": "FLAGS3",
    "1015": "E_PPC",
    "1026": "E_PPC",
    "1037": "CH_ADD",
    "1041": "BASIC_ERRH",
    "1045": "WORKSP",
    "1075": "E_PPC",
    "1081": "E_PPC",
    "1096": "PROG",
    "1105": "PROG",
    "1111": "WORKSP",
    "1118": "E_PPC",
    "1458": "BANK_M",
    "1464": "ERR_SP",
    "1469": "RAMERR",
    "1484": "CH_ADD",
    "1487": "X_PTR",
    "1512": "POUT2",
    "1521": "ERR_SP",
    "1536": "ERR_SP",
    "1542": "ERR_SP",
    "1547": "RS232_H_RET",
    "1567": "RETADDR",
    "1575": "RETADDR",
    "1582": "BANK_M",
    "1592": "INKEY_RET",
    "1633": "CH_ADD",
    "1657": "HD_00",
    "1676": "HD_00",
    "1688": "BAUD_TABLE",
    "1715": "BAUD",
    "1752": "SERFL",
    "1770": "BAUD",
    "1774": "BAUD",
    "1984": "SERFL",
    "1995": "TVPARS",
    "2002": "TVPARS",
    "2021": "RETADDR",
    "2029": "RETADDR",
    "2034": "FLAGS",
    "2056": "COL",
    "2060": "WIDTH",
    "2071": "COL",
    "2100": "COL",
    "2144": "TD_DATA",
    "2149": "TVPARS",
    "2153": "TD_DATA",
    "2158": "TVPARS",
    "2163": "TD_DATA",
    "2178": "WIDTH",
    "2197": "COL",
    "2232": "BAUD",
    "2288": "HD_0B",
    "2293": "PRINTER_CC_TABLE",
    "2302": "PRINTER_LF",
    "2308": "HD_0B",
    "2318": "PRINTER_RESET",
    "2325": "HD_00",
    "2333": "HD_00",
    "2345": "HD_00",
    "2836": "STONES_TABLE"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 11,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 12,
      "EndAddress": 15,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 16,
      "EndAddress": 19,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 20,
      "EndAddress": 23,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 24,
      "EndAddress": 27,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 28,
      "EndAddress": 31,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 32,
      "EndAddress": 35,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 36,
      "EndAddress": 39,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 40,
      "EndAddress": 54,
      "SectionType": 1,
      "Lenght": 15
    },
    {
      "StartAddress": 55,
      "EndAddress": 55,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 56,
      "EndAddress": 254,
      "SectionType": 1,
      "Lenght": 199
    },
    {
      "StartAddress": 255,
      "EndAddress": 255,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 256,
      "EndAddress": 1131,
      "SectionType": 1,
      "Lenght": 876
    },
    {
      "StartAddress": 1132,
      "EndAddress": 1133,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1134,
      "EndAddress": 1135,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1136,
      "EndAddress": 1137,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1138,
      "EndAddress": 1139,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1140,
      "EndAddress": 1141,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1142,
      "EndAddress": 1143,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1144,
      "EndAddress": 1145,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1146,
      "EndAddress": 1147,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1148,
      "EndAddress": 1149,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1150,
      "EndAddress": 1151,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1152,
      "EndAddress": 1153,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1154,
      "EndAddress": 1155,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1156,
      "EndAddress": 1157,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1158,
      "EndAddress": 1159,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1160,
      "EndAddress": 1161,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1162,
      "EndAddress": 1163,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1164,
      "EndAddress": 1174,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 1175,
      "EndAddress": 1189,
      "SectionType": 2,
      "Lenght": 15
    },
    {
      "StartAddress": 1190,
      "EndAddress": 1199,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1200,
      "EndAddress": 1216,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1217,
      "EndAddress": 1235,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1236,
      "EndAddress": 1247,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1248,
      "EndAddress": 1266,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1267,
      "EndAddress": 1280,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1281,
      "EndAddress": 1297,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1298,
      "EndAddress": 1314,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1315,
      "EndAddress": 1328,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1329,
      "EndAddress": 1345,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1346,
      "EndAddress": 1357,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1358,
      "EndAddress": 1376,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1377,
      "EndAddress": 1404,
      "SectionType": 2,
      "Lenght": 28
    },
    {
      "StartAddress": 1405,
      "EndAddress": 1416,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 1417,
      "EndAddress": 1418,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1419,
      "EndAddress": 1420,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1421,
      "EndAddress": 1421,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1422,
      "EndAddress": 1423,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1424,
      "EndAddress": 1425,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1426,
      "EndAddress": 1426,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1427,
      "EndAddress": 1428,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1429,
      "EndAddress": 1430,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1431,
      "EndAddress": 1431,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1432,
      "EndAddress": 1433,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1434,
      "EndAddress": 1435,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1436,
      "EndAddress": 1436,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1437,
      "EndAddress": 1437,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1438,
      "EndAddress": 1439,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1440,
      "EndAddress": 1441,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1442,
      "EndAddress": 1443,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1444,
      "EndAddress": 1445,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1446,
      "EndAddress": 1447,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1448,
      "EndAddress": 1449,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1450,
      "EndAddress": 1451,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1452,
      "EndAddress": 1508,
      "SectionType": 1,
      "Lenght": 57
    },
    {
      "StartAddress": 1509,
      "EndAddress": 1509,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1510,
      "EndAddress": 1558,
      "SectionType": 1,
      "Lenght": 49
    },
    {
      "StartAddress": 1559,
      "EndAddress": 1559,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1560,
      "EndAddress": 1623,
      "SectionType": 1,
      "Lenght": 64
    },
    {
      "StartAddress": 1624,
      "EndAddress": 1624,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1625,
      "EndAddress": 1686,
      "SectionType": 1,
      "Lenght": 62
    },
    {
      "StartAddress": 1687,
      "EndAddress": 1687,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1688,
      "EndAddress": 1719,
      "SectionType": 1,
      "Lenght": 32
    },
    {
      "StartAddress": 1720,
      "EndAddress": 1723,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1724,
      "EndAddress": 1727,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1728,
      "EndAddress": 1731,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1732,
      "EndAddress": 1735,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1736,
      "EndAddress": 1739,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1740,
      "EndAddress": 1743,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1744,
      "EndAddress": 1747,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1748,
      "EndAddress": 1751,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1752,
      "EndAddress": 2424,
      "SectionType": 1,
      "Lenght": 673
    },
    {
      "StartAddress": 2425,
      "EndAddress": 2425,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2426,
      "EndAddress": 2427,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2428,
      "EndAddress": 2431,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 2432,
      "EndAddress": 2432,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2433,
      "EndAddress": 2433,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2434,
      "EndAddress": 2434,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2435,
      "EndAddress": 2436,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2437,
      "EndAddress": 2609,
      "SectionType": 1,
      "Lenght": 173
    },
    {
      "StartAddress": 2610,
      "EndAddress": 2620,
      "SectionType": 4,
      "Lenght": 11
    },
    {
      "StartAddress": 2621,
      "EndAddress": 2742,
      "SectionType": 1,
      "Lenght": 122
    },
    {
      "StartAddress": 2743,
      "EndAddress": 2756,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 2757,
      "EndAddress": 3576,
      "SectionType": 1,
      "Lenght": 820
    },
    {
      "StartAddress": 3577,
      "EndAddress": 3583,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 3584,
      "EndAddress": 16383,
      "SectionType": 1,
      "Lenght": 12800
    },
    {
      "StartAddress": 16384,
      "EndAddress": 23551,
      "SectionType": 2,
      "Lenght": 7168
    },
    {
      "StartAddress": 23552,
      "EndAddress": 49151,
      "SectionType": 1,
      "Lenght": 25600
    },
    {
      "StartAddress": 49152,
      "EndAddress": 65535,
      "SectionType": 2,
      "Lenght": 16384
    }
  ],
  "DisassemblyFlags": 4
}