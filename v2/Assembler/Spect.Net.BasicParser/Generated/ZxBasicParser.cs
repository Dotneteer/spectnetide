//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\dotne\source\repos\spectnetide\v2\Assembler\AntlrZxBasicParserGenerator\AntlrZxBasicParserGenerator\ZxBasic.g4 by ANTLR 4.6.4

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Spect.Net.BasicParser.Generated {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.4")]
[System.CLSCompliant(false)]
public partial class ZxBasicParser : Parser {
	public const int
		WS=1, ASM_SECTION=2, COLON=3, UNDERSCORE=4, SINGLE_QUOTE=5, SLASH=6, DOLLAR=7, 
		SCOLON=8, COMSEP=9, COMMA=10, ASSIGN=11, LPAR=12, RPAR=13, LSBRAC=14, 
		RSBRAC=15, QMARK=16, PLUS=17, MINUS=18, VBAR=19, UPARR=20, AMP=21, EQOP=22, 
		CIEQOP=23, NEQOP=24, CINEQOP=25, LTOP=26, LTEOP=27, GTOP=28, GTEOP=29, 
		LSHOP=30, RSHOP=31, MULOP=32, DIVOP=33, DOT=34, DECNUM=35, REALNUM=36, 
		BLOCK_COMMENT=37, LINE_COMMENT=38, NOTEQ=39, ABS=40, ACS=41, AND=42, ALIGN=43, 
		ASC=44, ASN=45, AS=46, AT=47, ATN=48, ATTR=49, BAND=50, BNOT=51, BOR=52, 
		BXOR=53, BEEP=54, BOLD=55, BORDER=56, BRIGHT=57, BYREF=58, BYTE=59, BYVAL=60, 
		CAST=61, CHR=62, CIRCLE=63, CLS=64, CODE=65, CONST=66, CONTINUE=67, COS=68, 
		CSRLIN=69, DECLARE=70, DIM=71, DO=72, DATA=73, DRAW=74, ELSE=75, ELSEIF=76, 
		END=77, EXIT=78, EXP=79, FASTCALL=80, FLASH=81, FLOAT=82, FOR=83, FUNCTION=84, 
		GETKEY=85, GETKEYSCANCODE=86, GO=87, GOTO=88, GOSUB=89, HEX=90, HEX16=91, 
		IF=92, IN=93, INK=94, INKEY=95, INPUT=96, INT=97, INTEGER=98, INVERSE=99, 
		ITALIC=100, LBOUND=101, LCASE=102, LET=103, LEN=104, LN=105, LOAD=106, 
		LONG=107, LOOP=108, MOD=109, MULTIKEYS=110, NEXT=111, NOT=112, OR=113, 
		OVER=114, OUT=115, PAPER=116, PAUSE=117, PEEK=118, PI=119, PLOT=120, POINT=121, 
		POKE=122, POS=123, PRINT=124, PRINT42=125, PRINTAT42=126, PRINT64=127, 
		PRINTAT64=128, RANDOMIZE=129, READ=130, REM=131, RESTORE=132, RETURN=133, 
		RND=134, SAVE=135, SCREEN=136, SGN=137, SHL=138, SHR=139, SIN=140, SQR=141, 
		STDCALL=142, STEP=143, STOP=144, STR=145, STRING=146, SUB=147, TAB=148, 
		TAN=149, THEN=150, TO=151, UBOUND=152, UBYTE=153, UCASE=154, UINTEGER=155, 
		ULONG=156, UNTIL=157, VAL=158, VERIFY=159, WEND=160, WHILE=161, XOR=162, 
		HEXNUM=163, BINNUM=164, IDENTIFIER=165, IDSTART=166, IDCONT=167, ZXB_STRING=168, 
		LINE_END=169, ErrorCharacter=170;
	public const int
		RULE_compileUnit = 0, RULE_label = 1, RULE_line = 2, RULE_line_item = 3, 
		RULE_asm_section = 4, RULE_console = 5, RULE_keyword = 6, RULE_function = 7, 
		RULE_operator = 8, RULE_special = 9, RULE_number = 10, RULE_identifier = 11, 
		RULE_string = 12, RULE_type = 13, RULE_comment = 14, RULE_block_comment = 15, 
		RULE_line_comment = 16;
	public static readonly string[] ruleNames = {
		"compileUnit", "label", "line", "line_item", "asm_section", "console", 
		"keyword", "function", "operator", "special", "number", "identifier", 
		"string", "type", "comment", "block_comment", "line_comment"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "':'", "'_'", "'''", null, "'$'", "';'", "'//'", "','", 
		"'='", "'('", "')'", "'['", "']'", "'?'", "'+'", "'-'", "'|'", "'^'", 
		"'&'", "'=='", "'==='", "'!='", "'!=='", "'<'", "'<='", "'>'", "'>='", 
		"'<<'", "'>>'", "'*'", null, "'.'", null, null, null, null, "'<>'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WS", "ASM_SECTION", "COLON", "UNDERSCORE", "SINGLE_QUOTE", "SLASH", 
		"DOLLAR", "SCOLON", "COMSEP", "COMMA", "ASSIGN", "LPAR", "RPAR", "LSBRAC", 
		"RSBRAC", "QMARK", "PLUS", "MINUS", "VBAR", "UPARR", "AMP", "EQOP", "CIEQOP", 
		"NEQOP", "CINEQOP", "LTOP", "LTEOP", "GTOP", "GTEOP", "LSHOP", "RSHOP", 
		"MULOP", "DIVOP", "DOT", "DECNUM", "REALNUM", "BLOCK_COMMENT", "LINE_COMMENT", 
		"NOTEQ", "ABS", "ACS", "AND", "ALIGN", "ASC", "ASN", "AS", "AT", "ATN", 
		"ATTR", "BAND", "BNOT", "BOR", "BXOR", "BEEP", "BOLD", "BORDER", "BRIGHT", 
		"BYREF", "BYTE", "BYVAL", "CAST", "CHR", "CIRCLE", "CLS", "CODE", "CONST", 
		"CONTINUE", "COS", "CSRLIN", "DECLARE", "DIM", "DO", "DATA", "DRAW", "ELSE", 
		"ELSEIF", "END", "EXIT", "EXP", "FASTCALL", "FLASH", "FLOAT", "FOR", "FUNCTION", 
		"GETKEY", "GETKEYSCANCODE", "GO", "GOTO", "GOSUB", "HEX", "HEX16", "IF", 
		"IN", "INK", "INKEY", "INPUT", "INT", "INTEGER", "INVERSE", "ITALIC", 
		"LBOUND", "LCASE", "LET", "LEN", "LN", "LOAD", "LONG", "LOOP", "MOD", 
		"MULTIKEYS", "NEXT", "NOT", "OR", "OVER", "OUT", "PAPER", "PAUSE", "PEEK", 
		"PI", "PLOT", "POINT", "POKE", "POS", "PRINT", "PRINT42", "PRINTAT42", 
		"PRINT64", "PRINTAT64", "RANDOMIZE", "READ", "REM", "RESTORE", "RETURN", 
		"RND", "SAVE", "SCREEN", "SGN", "SHL", "SHR", "SIN", "SQR", "STDCALL", 
		"STEP", "STOP", "STR", "STRING", "SUB", "TAB", "TAN", "THEN", "TO", "UBOUND", 
		"UBYTE", "UCASE", "UINTEGER", "ULONG", "UNTIL", "VAL", "VERIFY", "WEND", 
		"WHILE", "XOR", "HEXNUM", "BINNUM", "IDENTIFIER", "IDSTART", "IDCONT", 
		"ZXB_STRING", "LINE_END", "ErrorCharacter"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ZxBasic.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public ZxBasicParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompileUnitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(ZxBasicParser.Eof, 0); }
		public Asm_sectionContext[] asm_section() {
			return GetRuleContexts<Asm_sectionContext>();
		}
		public Asm_sectionContext asm_section(int i) {
			return GetRuleContext<Asm_sectionContext>(i);
		}
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public LabelContext[] label() {
			return GetRuleContexts<LabelContext>();
		}
		public LabelContext label(int i) {
			return GetRuleContext<LabelContext>(i);
		}
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compileUnit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 41;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASM_SECTION) | (1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << DECNUM) | (1L << REALNUM) | (1L << BLOCK_COMMENT) | (1L << LINE_COMMENT) | (1L << NOTEQ) | (1L << ABS) | (1L << ACS) | (1L << AND) | (1L << ALIGN) | (1L << ASC) | (1L << ASN) | (1L << AT) | (1L << ATN) | (1L << ATTR) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR) | (1L << BEEP) | (1L << BOLD) | (1L << BORDER) | (1L << BRIGHT) | (1L << BYREF) | (1L << BYVAL) | (1L << CAST) | (1L << CHR) | (1L << CIRCLE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLS - 64)) | (1L << (CODE - 64)) | (1L << (CONST - 64)) | (1L << (CONTINUE - 64)) | (1L << (COS - 64)) | (1L << (CSRLIN - 64)) | (1L << (DECLARE - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DATA - 64)) | (1L << (DRAW - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (END - 64)) | (1L << (EXIT - 64)) | (1L << (EXP - 64)) | (1L << (FASTCALL - 64)) | (1L << (FLASH - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GETKEY - 64)) | (1L << (GETKEYSCANCODE - 64)) | (1L << (GOTO - 64)) | (1L << (GOSUB - 64)) | (1L << (HEX - 64)) | (1L << (HEX16 - 64)) | (1L << (IF - 64)) | (1L << (IN - 64)) | (1L << (INK - 64)) | (1L << (INKEY - 64)) | (1L << (INPUT - 64)) | (1L << (INT - 64)) | (1L << (INVERSE - 64)) | (1L << (ITALIC - 64)) | (1L << (LBOUND - 64)) | (1L << (LCASE - 64)) | (1L << (LET - 64)) | (1L << (LEN - 64)) | (1L << (LN - 64)) | (1L << (LOAD - 64)) | (1L << (LOOP - 64)) | (1L << (MOD - 64)) | (1L << (MULTIKEYS - 64)) | (1L << (NEXT - 64)) | (1L << (NOT - 64)) | (1L << (OR - 64)) | (1L << (OVER - 64)) | (1L << (OUT - 64)) | (1L << (PAPER - 64)) | (1L << (PAUSE - 64)) | (1L << (PEEK - 64)) | (1L << (PI - 64)) | (1L << (PLOT - 64)) | (1L << (POINT - 64)) | (1L << (POKE - 64)) | (1L << (POS - 64)) | (1L << (PRINT - 64)) | (1L << (PRINT42 - 64)) | (1L << (PRINTAT42 - 64)) | (1L << (PRINT64 - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (PRINTAT64 - 128)) | (1L << (RANDOMIZE - 128)) | (1L << (READ - 128)) | (1L << (REM - 128)) | (1L << (RESTORE - 128)) | (1L << (RETURN - 128)) | (1L << (RND - 128)) | (1L << (SAVE - 128)) | (1L << (SCREEN - 128)) | (1L << (SGN - 128)) | (1L << (SHL - 128)) | (1L << (SHR - 128)) | (1L << (SIN - 128)) | (1L << (SQR - 128)) | (1L << (STDCALL - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STR - 128)) | (1L << (SUB - 128)) | (1L << (TAB - 128)) | (1L << (TAN - 128)) | (1L << (THEN - 128)) | (1L << (TO - 128)) | (1L << (UBOUND - 128)) | (1L << (UCASE - 128)) | (1L << (UNTIL - 128)) | (1L << (VAL - 128)) | (1L << (VERIFY - 128)) | (1L << (WEND - 128)) | (1L << (WHILE - 128)) | (1L << (XOR - 128)) | (1L << (HEXNUM - 128)) | (1L << (BINNUM - 128)) | (1L << (IDENTIFIER - 128)) | (1L << (ZXB_STRING - 128)) | (1L << (LINE_END - 128)) | (1L << (ErrorCharacter - 128)))) != 0)) {
				{
				State = 39;
				_errHandler.Sync(this);
				switch (_input.La(1)) {
				case ASM_SECTION:
					{
					State = 34; asm_section();
					}
					break;
				case ASSIGN:
				case PLUS:
				case MINUS:
				case UPARR:
				case AMP:
				case LTOP:
				case LTEOP:
				case GTOP:
				case GTEOP:
				case LSHOP:
				case RSHOP:
				case MULOP:
				case DIVOP:
				case DECNUM:
				case REALNUM:
				case BLOCK_COMMENT:
				case LINE_COMMENT:
				case NOTEQ:
				case ABS:
				case ACS:
				case AND:
				case ALIGN:
				case ASC:
				case ASN:
				case AT:
				case ATN:
				case ATTR:
				case BAND:
				case BNOT:
				case BOR:
				case BXOR:
				case BEEP:
				case BOLD:
				case BORDER:
				case BRIGHT:
				case BYREF:
				case BYVAL:
				case CAST:
				case CHR:
				case CIRCLE:
				case CLS:
				case CODE:
				case CONST:
				case CONTINUE:
				case COS:
				case CSRLIN:
				case DECLARE:
				case DIM:
				case DO:
				case DATA:
				case DRAW:
				case ELSE:
				case ELSEIF:
				case END:
				case EXIT:
				case EXP:
				case FASTCALL:
				case FLASH:
				case FOR:
				case FUNCTION:
				case GETKEY:
				case GETKEYSCANCODE:
				case GOTO:
				case GOSUB:
				case HEX:
				case HEX16:
				case IF:
				case IN:
				case INK:
				case INKEY:
				case INPUT:
				case INT:
				case INVERSE:
				case ITALIC:
				case LBOUND:
				case LCASE:
				case LET:
				case LEN:
				case LN:
				case LOAD:
				case LOOP:
				case MOD:
				case MULTIKEYS:
				case NEXT:
				case NOT:
				case OR:
				case OVER:
				case OUT:
				case PAPER:
				case PAUSE:
				case PEEK:
				case PI:
				case PLOT:
				case POINT:
				case POKE:
				case POS:
				case PRINT:
				case PRINT42:
				case PRINTAT42:
				case PRINT64:
				case PRINTAT64:
				case RANDOMIZE:
				case READ:
				case REM:
				case RESTORE:
				case RETURN:
				case RND:
				case SAVE:
				case SCREEN:
				case SGN:
				case SHL:
				case SHR:
				case SIN:
				case SQR:
				case STDCALL:
				case STEP:
				case STOP:
				case STR:
				case SUB:
				case TAB:
				case TAN:
				case THEN:
				case TO:
				case UBOUND:
				case UCASE:
				case UNTIL:
				case VAL:
				case VERIFY:
				case WEND:
				case WHILE:
				case XOR:
				case HEXNUM:
				case BINNUM:
				case IDENTIFIER:
				case ZXB_STRING:
				case LINE_END:
				case ErrorCharacter:
					{
					State = 36;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
					case 1:
						{
						State = 35; label();
						}
						break;
					}
					State = 38; line();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 43;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 44; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(ZxBasicParser.IDENTIFIER, 0); }
		public ITerminalNode COLON() { return GetToken(ZxBasicParser.COLON, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_label);
		try {
			State = 49;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case DECNUM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 46; Match(DECNUM);
				}
				break;
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 47; Match(IDENTIFIER);
				State = 48; Match(COLON);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext {
		public ITerminalNode LINE_END() { return GetToken(ZxBasicParser.LINE_END, 0); }
		public Line_itemContext[] line_item() {
			return GetRuleContexts<Line_itemContext>();
		}
		public Line_itemContext line_item(int i) {
			return GetRuleContext<Line_itemContext>(i);
		}
		public LineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LineContext line() {
		LineContext _localctx = new LineContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_line);
		int _la;
		try {
			int _alt;
			State = 63;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 54;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << DECNUM) | (1L << REALNUM) | (1L << BLOCK_COMMENT) | (1L << LINE_COMMENT) | (1L << NOTEQ) | (1L << ABS) | (1L << ACS) | (1L << AND) | (1L << ALIGN) | (1L << ASC) | (1L << ASN) | (1L << AT) | (1L << ATN) | (1L << ATTR) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR) | (1L << BEEP) | (1L << BOLD) | (1L << BORDER) | (1L << BRIGHT) | (1L << BYREF) | (1L << BYVAL) | (1L << CAST) | (1L << CHR) | (1L << CIRCLE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLS - 64)) | (1L << (CODE - 64)) | (1L << (CONST - 64)) | (1L << (CONTINUE - 64)) | (1L << (COS - 64)) | (1L << (CSRLIN - 64)) | (1L << (DECLARE - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DATA - 64)) | (1L << (DRAW - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (END - 64)) | (1L << (EXIT - 64)) | (1L << (EXP - 64)) | (1L << (FASTCALL - 64)) | (1L << (FLASH - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GETKEY - 64)) | (1L << (GETKEYSCANCODE - 64)) | (1L << (GOTO - 64)) | (1L << (GOSUB - 64)) | (1L << (HEX - 64)) | (1L << (HEX16 - 64)) | (1L << (IF - 64)) | (1L << (IN - 64)) | (1L << (INK - 64)) | (1L << (INKEY - 64)) | (1L << (INPUT - 64)) | (1L << (INT - 64)) | (1L << (INVERSE - 64)) | (1L << (ITALIC - 64)) | (1L << (LBOUND - 64)) | (1L << (LCASE - 64)) | (1L << (LET - 64)) | (1L << (LEN - 64)) | (1L << (LN - 64)) | (1L << (LOAD - 64)) | (1L << (LOOP - 64)) | (1L << (MOD - 64)) | (1L << (MULTIKEYS - 64)) | (1L << (NEXT - 64)) | (1L << (NOT - 64)) | (1L << (OR - 64)) | (1L << (OVER - 64)) | (1L << (OUT - 64)) | (1L << (PAPER - 64)) | (1L << (PAUSE - 64)) | (1L << (PEEK - 64)) | (1L << (PI - 64)) | (1L << (PLOT - 64)) | (1L << (POINT - 64)) | (1L << (POKE - 64)) | (1L << (POS - 64)) | (1L << (PRINT - 64)) | (1L << (PRINT42 - 64)) | (1L << (PRINTAT42 - 64)) | (1L << (PRINT64 - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (PRINTAT64 - 128)) | (1L << (RANDOMIZE - 128)) | (1L << (READ - 128)) | (1L << (REM - 128)) | (1L << (RESTORE - 128)) | (1L << (RETURN - 128)) | (1L << (RND - 128)) | (1L << (SAVE - 128)) | (1L << (SCREEN - 128)) | (1L << (SGN - 128)) | (1L << (SHL - 128)) | (1L << (SHR - 128)) | (1L << (SIN - 128)) | (1L << (SQR - 128)) | (1L << (STDCALL - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STR - 128)) | (1L << (SUB - 128)) | (1L << (TAB - 128)) | (1L << (TAN - 128)) | (1L << (THEN - 128)) | (1L << (TO - 128)) | (1L << (UBOUND - 128)) | (1L << (UCASE - 128)) | (1L << (UNTIL - 128)) | (1L << (VAL - 128)) | (1L << (VERIFY - 128)) | (1L << (WEND - 128)) | (1L << (WHILE - 128)) | (1L << (XOR - 128)) | (1L << (HEXNUM - 128)) | (1L << (BINNUM - 128)) | (1L << (IDENTIFIER - 128)) | (1L << (ZXB_STRING - 128)) | (1L << (ErrorCharacter - 128)))) != 0)) {
					{
					{
					State = 51; line_item();
					}
					}
					State = 56;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 57; Match(LINE_END);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 59;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 58; line_item();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 61;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,5,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Line_itemContext : ParserRuleContext {
		public ConsoleContext console() {
			return GetRuleContext<ConsoleContext>(0);
		}
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		public OperatorContext @operator() {
			return GetRuleContext<OperatorContext>(0);
		}
		public SpecialContext special() {
			return GetRuleContext<SpecialContext>(0);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public ITerminalNode ErrorCharacter() { return GetToken(ZxBasicParser.ErrorCharacter, 0); }
		public Line_itemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line_item; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine_item(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine_item(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine_item(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Line_itemContext line_item() {
		Line_itemContext _localctx = new Line_itemContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_line_item);
		try {
			State = 75;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case AT:
			case BOLD:
			case BORDER:
			case BRIGHT:
			case CLS:
			case FLASH:
			case INK:
			case INVERSE:
			case ITALIC:
			case OVER:
			case PAPER:
			case TAB:
				EnterOuterAlt(_localctx, 1);
				{
				State = 65; console();
				}
				break;
			case BEEP:
			case BYREF:
			case BYVAL:
			case CIRCLE:
			case CONST:
			case CONTINUE:
			case DECLARE:
			case DIM:
			case DO:
			case DATA:
			case DRAW:
			case ELSE:
			case ELSEIF:
			case END:
			case EXIT:
			case FASTCALL:
			case FOR:
			case FUNCTION:
			case GOTO:
			case GOSUB:
			case IF:
			case LET:
			case LOAD:
			case LOOP:
			case NEXT:
			case OUT:
			case PAUSE:
			case PI:
			case PLOT:
			case POKE:
			case PRINT:
			case RANDOMIZE:
			case READ:
			case REM:
			case RESTORE:
			case RETURN:
			case SAVE:
			case STDCALL:
			case STEP:
			case STOP:
			case SUB:
			case THEN:
			case TO:
			case UNTIL:
			case VERIFY:
			case WEND:
			case WHILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 66; keyword();
				}
				break;
			case ABS:
			case ACS:
			case ASC:
			case ASN:
			case ATN:
			case ATTR:
			case CAST:
			case CHR:
			case CODE:
			case COS:
			case CSRLIN:
			case EXP:
			case GETKEY:
			case GETKEYSCANCODE:
			case HEX:
			case HEX16:
			case IN:
			case INKEY:
			case INPUT:
			case INT:
			case LBOUND:
			case LCASE:
			case LEN:
			case LN:
			case MULTIKEYS:
			case PEEK:
			case POINT:
			case POS:
			case PRINT42:
			case PRINTAT42:
			case PRINT64:
			case PRINTAT64:
			case RND:
			case SCREEN:
			case SGN:
			case STR:
			case TAN:
			case UBOUND:
			case UCASE:
			case VAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 67; function();
				}
				break;
			case ASSIGN:
			case PLUS:
			case MINUS:
			case UPARR:
			case AMP:
			case LTOP:
			case LTEOP:
			case GTOP:
			case GTEOP:
			case LSHOP:
			case RSHOP:
			case MULOP:
			case DIVOP:
			case NOTEQ:
			case AND:
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case MOD:
			case NOT:
			case OR:
			case SHL:
			case SHR:
			case SIN:
			case SQR:
			case XOR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 68; @operator();
				}
				break;
			case ALIGN:
				EnterOuterAlt(_localctx, 5);
				{
				State = 69; special();
				}
				break;
			case DECNUM:
			case REALNUM:
			case HEXNUM:
			case BINNUM:
				EnterOuterAlt(_localctx, 6);
				{
				State = 70; number();
				}
				break;
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 7);
				{
				State = 71; identifier();
				}
				break;
			case ZXB_STRING:
				EnterOuterAlt(_localctx, 8);
				{
				State = 72; @string();
				}
				break;
			case BLOCK_COMMENT:
			case LINE_COMMENT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 73; comment();
				}
				break;
			case ErrorCharacter:
				EnterOuterAlt(_localctx, 10);
				{
				State = 74; Match(ErrorCharacter);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_sectionContext : ParserRuleContext {
		public ITerminalNode ASM_SECTION() { return GetToken(ZxBasicParser.ASM_SECTION, 0); }
		public Asm_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterAsm_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitAsm_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsm_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Asm_sectionContext asm_section() {
		Asm_sectionContext _localctx = new Asm_sectionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_asm_section);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77; Match(ASM_SECTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConsoleContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(ZxBasicParser.AT, 0); }
		public ITerminalNode BOLD() { return GetToken(ZxBasicParser.BOLD, 0); }
		public ITerminalNode BORDER() { return GetToken(ZxBasicParser.BORDER, 0); }
		public ITerminalNode BRIGHT() { return GetToken(ZxBasicParser.BRIGHT, 0); }
		public ITerminalNode CLS() { return GetToken(ZxBasicParser.CLS, 0); }
		public ITerminalNode FLASH() { return GetToken(ZxBasicParser.FLASH, 0); }
		public ITerminalNode INK() { return GetToken(ZxBasicParser.INK, 0); }
		public ITerminalNode INVERSE() { return GetToken(ZxBasicParser.INVERSE, 0); }
		public ITerminalNode ITALIC() { return GetToken(ZxBasicParser.ITALIC, 0); }
		public ITerminalNode OVER() { return GetToken(ZxBasicParser.OVER, 0); }
		public ITerminalNode PAPER() { return GetToken(ZxBasicParser.PAPER, 0); }
		public ITerminalNode TAB() { return GetToken(ZxBasicParser.TAB, 0); }
		public ConsoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_console; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterConsole(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitConsole(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConsole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConsoleContext console() {
		ConsoleContext _localctx = new ConsoleContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_console);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			_la = _input.La(1);
			if ( !(((((_la - 47)) & ~0x3f) == 0 && ((1L << (_la - 47)) & ((1L << (AT - 47)) | (1L << (BOLD - 47)) | (1L << (BORDER - 47)) | (1L << (BRIGHT - 47)) | (1L << (CLS - 47)) | (1L << (FLASH - 47)) | (1L << (INK - 47)) | (1L << (INVERSE - 47)) | (1L << (ITALIC - 47)))) != 0) || ((((_la - 114)) & ~0x3f) == 0 && ((1L << (_la - 114)) & ((1L << (OVER - 114)) | (1L << (PAPER - 114)) | (1L << (TAB - 114)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public ITerminalNode BEEP() { return GetToken(ZxBasicParser.BEEP, 0); }
		public ITerminalNode BYREF() { return GetToken(ZxBasicParser.BYREF, 0); }
		public ITerminalNode BYVAL() { return GetToken(ZxBasicParser.BYVAL, 0); }
		public ITerminalNode CIRCLE() { return GetToken(ZxBasicParser.CIRCLE, 0); }
		public ITerminalNode CONST() { return GetToken(ZxBasicParser.CONST, 0); }
		public ITerminalNode CONTINUE() { return GetToken(ZxBasicParser.CONTINUE, 0); }
		public ITerminalNode DECLARE() { return GetToken(ZxBasicParser.DECLARE, 0); }
		public ITerminalNode DIM() { return GetToken(ZxBasicParser.DIM, 0); }
		public ITerminalNode DO() { return GetToken(ZxBasicParser.DO, 0); }
		public ITerminalNode DATA() { return GetToken(ZxBasicParser.DATA, 0); }
		public ITerminalNode DRAW() { return GetToken(ZxBasicParser.DRAW, 0); }
		public ITerminalNode ELSE() { return GetToken(ZxBasicParser.ELSE, 0); }
		public ITerminalNode ELSEIF() { return GetToken(ZxBasicParser.ELSEIF, 0); }
		public ITerminalNode END() { return GetToken(ZxBasicParser.END, 0); }
		public ITerminalNode EXIT() { return GetToken(ZxBasicParser.EXIT, 0); }
		public ITerminalNode FASTCALL() { return GetToken(ZxBasicParser.FASTCALL, 0); }
		public ITerminalNode FOR() { return GetToken(ZxBasicParser.FOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(ZxBasicParser.FUNCTION, 0); }
		public ITerminalNode GOTO() { return GetToken(ZxBasicParser.GOTO, 0); }
		public ITerminalNode GOSUB() { return GetToken(ZxBasicParser.GOSUB, 0); }
		public ITerminalNode IF() { return GetToken(ZxBasicParser.IF, 0); }
		public ITerminalNode LET() { return GetToken(ZxBasicParser.LET, 0); }
		public ITerminalNode LOAD() { return GetToken(ZxBasicParser.LOAD, 0); }
		public ITerminalNode LOOP() { return GetToken(ZxBasicParser.LOOP, 0); }
		public ITerminalNode NEXT() { return GetToken(ZxBasicParser.NEXT, 0); }
		public ITerminalNode OUT() { return GetToken(ZxBasicParser.OUT, 0); }
		public ITerminalNode PAUSE() { return GetToken(ZxBasicParser.PAUSE, 0); }
		public ITerminalNode PI() { return GetToken(ZxBasicParser.PI, 0); }
		public ITerminalNode PLOT() { return GetToken(ZxBasicParser.PLOT, 0); }
		public ITerminalNode POKE() { return GetToken(ZxBasicParser.POKE, 0); }
		public ITerminalNode PRINT() { return GetToken(ZxBasicParser.PRINT, 0); }
		public ITerminalNode RANDOMIZE() { return GetToken(ZxBasicParser.RANDOMIZE, 0); }
		public ITerminalNode READ() { return GetToken(ZxBasicParser.READ, 0); }
		public ITerminalNode REM() { return GetToken(ZxBasicParser.REM, 0); }
		public ITerminalNode RESTORE() { return GetToken(ZxBasicParser.RESTORE, 0); }
		public ITerminalNode RETURN() { return GetToken(ZxBasicParser.RETURN, 0); }
		public ITerminalNode SAVE() { return GetToken(ZxBasicParser.SAVE, 0); }
		public ITerminalNode STDCALL() { return GetToken(ZxBasicParser.STDCALL, 0); }
		public ITerminalNode STEP() { return GetToken(ZxBasicParser.STEP, 0); }
		public ITerminalNode STOP() { return GetToken(ZxBasicParser.STOP, 0); }
		public ITerminalNode SUB() { return GetToken(ZxBasicParser.SUB, 0); }
		public ITerminalNode THEN() { return GetToken(ZxBasicParser.THEN, 0); }
		public ITerminalNode TO() { return GetToken(ZxBasicParser.TO, 0); }
		public ITerminalNode UNTIL() { return GetToken(ZxBasicParser.UNTIL, 0); }
		public ITerminalNode VERIFY() { return GetToken(ZxBasicParser.VERIFY, 0); }
		public ITerminalNode WEND() { return GetToken(ZxBasicParser.WEND, 0); }
		public ITerminalNode WHILE() { return GetToken(ZxBasicParser.WHILE, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81;
			_la = _input.La(1);
			if ( !(((((_la - 54)) & ~0x3f) == 0 && ((1L << (_la - 54)) & ((1L << (BEEP - 54)) | (1L << (BYREF - 54)) | (1L << (BYVAL - 54)) | (1L << (CIRCLE - 54)) | (1L << (CONST - 54)) | (1L << (CONTINUE - 54)) | (1L << (DECLARE - 54)) | (1L << (DIM - 54)) | (1L << (DO - 54)) | (1L << (DATA - 54)) | (1L << (DRAW - 54)) | (1L << (ELSE - 54)) | (1L << (ELSEIF - 54)) | (1L << (END - 54)) | (1L << (EXIT - 54)) | (1L << (FASTCALL - 54)) | (1L << (FOR - 54)) | (1L << (FUNCTION - 54)) | (1L << (GOTO - 54)) | (1L << (GOSUB - 54)) | (1L << (IF - 54)) | (1L << (LET - 54)) | (1L << (LOAD - 54)) | (1L << (LOOP - 54)) | (1L << (NEXT - 54)) | (1L << (OUT - 54)) | (1L << (PAUSE - 54)))) != 0) || ((((_la - 119)) & ~0x3f) == 0 && ((1L << (_la - 119)) & ((1L << (PI - 119)) | (1L << (PLOT - 119)) | (1L << (POKE - 119)) | (1L << (PRINT - 119)) | (1L << (RANDOMIZE - 119)) | (1L << (READ - 119)) | (1L << (REM - 119)) | (1L << (RESTORE - 119)) | (1L << (RETURN - 119)) | (1L << (SAVE - 119)) | (1L << (STDCALL - 119)) | (1L << (STEP - 119)) | (1L << (STOP - 119)) | (1L << (SUB - 119)) | (1L << (THEN - 119)) | (1L << (TO - 119)) | (1L << (UNTIL - 119)) | (1L << (VERIFY - 119)) | (1L << (WEND - 119)) | (1L << (WHILE - 119)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		public ITerminalNode ABS() { return GetToken(ZxBasicParser.ABS, 0); }
		public ITerminalNode ACS() { return GetToken(ZxBasicParser.ACS, 0); }
		public ITerminalNode ASC() { return GetToken(ZxBasicParser.ASC, 0); }
		public ITerminalNode ASN() { return GetToken(ZxBasicParser.ASN, 0); }
		public ITerminalNode ATN() { return GetToken(ZxBasicParser.ATN, 0); }
		public ITerminalNode ATTR() { return GetToken(ZxBasicParser.ATTR, 0); }
		public ITerminalNode CAST() { return GetToken(ZxBasicParser.CAST, 0); }
		public ITerminalNode CHR() { return GetToken(ZxBasicParser.CHR, 0); }
		public ITerminalNode CODE() { return GetToken(ZxBasicParser.CODE, 0); }
		public ITerminalNode COS() { return GetToken(ZxBasicParser.COS, 0); }
		public ITerminalNode CSRLIN() { return GetToken(ZxBasicParser.CSRLIN, 0); }
		public ITerminalNode EXP() { return GetToken(ZxBasicParser.EXP, 0); }
		public ITerminalNode GETKEY() { return GetToken(ZxBasicParser.GETKEY, 0); }
		public ITerminalNode GETKEYSCANCODE() { return GetToken(ZxBasicParser.GETKEYSCANCODE, 0); }
		public ITerminalNode HEX() { return GetToken(ZxBasicParser.HEX, 0); }
		public ITerminalNode HEX16() { return GetToken(ZxBasicParser.HEX16, 0); }
		public ITerminalNode IN() { return GetToken(ZxBasicParser.IN, 0); }
		public ITerminalNode INKEY() { return GetToken(ZxBasicParser.INKEY, 0); }
		public ITerminalNode INPUT() { return GetToken(ZxBasicParser.INPUT, 0); }
		public ITerminalNode INT() { return GetToken(ZxBasicParser.INT, 0); }
		public ITerminalNode LBOUND() { return GetToken(ZxBasicParser.LBOUND, 0); }
		public ITerminalNode LCASE() { return GetToken(ZxBasicParser.LCASE, 0); }
		public ITerminalNode LEN() { return GetToken(ZxBasicParser.LEN, 0); }
		public ITerminalNode LN() { return GetToken(ZxBasicParser.LN, 0); }
		public ITerminalNode MULTIKEYS() { return GetToken(ZxBasicParser.MULTIKEYS, 0); }
		public ITerminalNode PEEK() { return GetToken(ZxBasicParser.PEEK, 0); }
		public ITerminalNode POINT() { return GetToken(ZxBasicParser.POINT, 0); }
		public ITerminalNode POS() { return GetToken(ZxBasicParser.POS, 0); }
		public ITerminalNode PRINT42() { return GetToken(ZxBasicParser.PRINT42, 0); }
		public ITerminalNode PRINTAT42() { return GetToken(ZxBasicParser.PRINTAT42, 0); }
		public ITerminalNode PRINT64() { return GetToken(ZxBasicParser.PRINT64, 0); }
		public ITerminalNode PRINTAT64() { return GetToken(ZxBasicParser.PRINTAT64, 0); }
		public ITerminalNode RND() { return GetToken(ZxBasicParser.RND, 0); }
		public ITerminalNode SCREEN() { return GetToken(ZxBasicParser.SCREEN, 0); }
		public ITerminalNode SGN() { return GetToken(ZxBasicParser.SGN, 0); }
		public ITerminalNode STR() { return GetToken(ZxBasicParser.STR, 0); }
		public ITerminalNode TAN() { return GetToken(ZxBasicParser.TAN, 0); }
		public ITerminalNode UBOUND() { return GetToken(ZxBasicParser.UBOUND, 0); }
		public ITerminalNode UCASE() { return GetToken(ZxBasicParser.UCASE, 0); }
		public ITerminalNode VAL() { return GetToken(ZxBasicParser.VAL, 0); }
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_function);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83;
			_la = _input.La(1);
			if ( !(((((_la - 40)) & ~0x3f) == 0 && ((1L << (_la - 40)) & ((1L << (ABS - 40)) | (1L << (ACS - 40)) | (1L << (ASC - 40)) | (1L << (ASN - 40)) | (1L << (ATN - 40)) | (1L << (ATTR - 40)) | (1L << (CAST - 40)) | (1L << (CHR - 40)) | (1L << (CODE - 40)) | (1L << (COS - 40)) | (1L << (CSRLIN - 40)) | (1L << (EXP - 40)) | (1L << (GETKEY - 40)) | (1L << (GETKEYSCANCODE - 40)) | (1L << (HEX - 40)) | (1L << (HEX16 - 40)) | (1L << (IN - 40)) | (1L << (INKEY - 40)) | (1L << (INPUT - 40)) | (1L << (INT - 40)) | (1L << (LBOUND - 40)) | (1L << (LCASE - 40)))) != 0) || ((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (LEN - 104)) | (1L << (LN - 104)) | (1L << (MULTIKEYS - 104)) | (1L << (PEEK - 104)) | (1L << (POINT - 104)) | (1L << (POS - 104)) | (1L << (PRINT42 - 104)) | (1L << (PRINTAT42 - 104)) | (1L << (PRINT64 - 104)) | (1L << (PRINTAT64 - 104)) | (1L << (RND - 104)) | (1L << (SCREEN - 104)) | (1L << (SGN - 104)) | (1L << (STR - 104)) | (1L << (TAN - 104)) | (1L << (UBOUND - 104)) | (1L << (UCASE - 104)) | (1L << (VAL - 104)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(ZxBasicParser.AND, 0); }
		public ITerminalNode BAND() { return GetToken(ZxBasicParser.BAND, 0); }
		public ITerminalNode BNOT() { return GetToken(ZxBasicParser.BNOT, 0); }
		public ITerminalNode BOR() { return GetToken(ZxBasicParser.BOR, 0); }
		public ITerminalNode BXOR() { return GetToken(ZxBasicParser.BXOR, 0); }
		public ITerminalNode MOD() { return GetToken(ZxBasicParser.MOD, 0); }
		public ITerminalNode NOT() { return GetToken(ZxBasicParser.NOT, 0); }
		public ITerminalNode OR() { return GetToken(ZxBasicParser.OR, 0); }
		public ITerminalNode SHL() { return GetToken(ZxBasicParser.SHL, 0); }
		public ITerminalNode SHR() { return GetToken(ZxBasicParser.SHR, 0); }
		public ITerminalNode SIN() { return GetToken(ZxBasicParser.SIN, 0); }
		public ITerminalNode SQR() { return GetToken(ZxBasicParser.SQR, 0); }
		public ITerminalNode XOR() { return GetToken(ZxBasicParser.XOR, 0); }
		public ITerminalNode ASSIGN() { return GetToken(ZxBasicParser.ASSIGN, 0); }
		public ITerminalNode PLUS() { return GetToken(ZxBasicParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(ZxBasicParser.MINUS, 0); }
		public ITerminalNode UPARR() { return GetToken(ZxBasicParser.UPARR, 0); }
		public ITerminalNode AMP() { return GetToken(ZxBasicParser.AMP, 0); }
		public ITerminalNode NOTEQ() { return GetToken(ZxBasicParser.NOTEQ, 0); }
		public ITerminalNode LTOP() { return GetToken(ZxBasicParser.LTOP, 0); }
		public ITerminalNode LTEOP() { return GetToken(ZxBasicParser.LTEOP, 0); }
		public ITerminalNode GTOP() { return GetToken(ZxBasicParser.GTOP, 0); }
		public ITerminalNode GTEOP() { return GetToken(ZxBasicParser.GTEOP, 0); }
		public ITerminalNode MULOP() { return GetToken(ZxBasicParser.MULOP, 0); }
		public ITerminalNode DIVOP() { return GetToken(ZxBasicParser.DIVOP, 0); }
		public ITerminalNode LSHOP() { return GetToken(ZxBasicParser.LSHOP, 0); }
		public ITerminalNode RSHOP() { return GetToken(ZxBasicParser.RSHOP, 0); }
		public OperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorContext @operator() {
		OperatorContext _localctx = new OperatorContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 85;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << NOTEQ) | (1L << AND) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR))) != 0) || ((((_la - 109)) & ~0x3f) == 0 && ((1L << (_la - 109)) & ((1L << (MOD - 109)) | (1L << (NOT - 109)) | (1L << (OR - 109)) | (1L << (SHL - 109)) | (1L << (SHR - 109)) | (1L << (SIN - 109)) | (1L << (SQR - 109)) | (1L << (XOR - 109)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialContext : ParserRuleContext {
		public ITerminalNode ALIGN() { return GetToken(ZxBasicParser.ALIGN, 0); }
		public SpecialContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_special; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterSpecial(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitSpecial(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecial(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialContext special() {
		SpecialContext _localctx = new SpecialContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_special);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87; Match(ALIGN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode BINNUM() { return GetToken(ZxBasicParser.BINNUM, 0); }
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode HEXNUM() { return GetToken(ZxBasicParser.HEXNUM, 0); }
		public ITerminalNode REALNUM() { return GetToken(ZxBasicParser.REALNUM, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 89;
			_la = _input.La(1);
			if ( !(_la==DECNUM || _la==REALNUM || _la==HEXNUM || _la==BINNUM) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(ZxBasicParser.IDENTIFIER, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 91; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringContext : ParserRuleContext {
		public ITerminalNode ZXB_STRING() { return GetToken(ZxBasicParser.ZXB_STRING, 0); }
		public StringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterString(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitString(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringContext @string() {
		StringContext _localctx = new StringContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 93; Match(ZXB_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_type);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentContext : ParserRuleContext {
		public Block_commentContext block_comment() {
			return GetRuleContext<Block_commentContext>(0);
		}
		public Line_commentContext line_comment() {
			return GetRuleContext<Line_commentContext>(0);
		}
		public CommentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentContext comment() {
		CommentContext _localctx = new CommentContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_comment);
		try {
			State = 99;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case BLOCK_COMMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 97; block_comment();
				}
				break;
			case LINE_COMMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 98; line_comment();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Block_commentContext : ParserRuleContext {
		public ITerminalNode BLOCK_COMMENT() { return GetToken(ZxBasicParser.BLOCK_COMMENT, 0); }
		public Block_commentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterBlock_comment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitBlock_comment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock_comment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Block_commentContext block_comment() {
		Block_commentContext _localctx = new Block_commentContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_block_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101; Match(BLOCK_COMMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Line_commentContext : ParserRuleContext {
		public ITerminalNode LINE_COMMENT() { return GetToken(ZxBasicParser.LINE_COMMENT, 0); }
		public Line_commentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine_comment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine_comment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine_comment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Line_commentContext line_comment() {
		Line_commentContext _localctx = new Line_commentContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_line_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 103; Match(LINE_COMMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xACl\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x3\x2\x3\x2\x5\x2\'\n\x2\x3\x2\a\x2*\n"+
		"\x2\f\x2\xE\x2-\v\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5\x3\x34\n\x3\x3\x4"+
		"\a\x4\x37\n\x4\f\x4\xE\x4:\v\x4\x3\x4\x3\x4\x6\x4>\n\x4\r\x4\xE\x4?\x5"+
		"\x4\x42\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x5\x5N\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3"+
		"\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3\xF\x3\xF\x3\x10\x3\x10\x5\x10"+
		"\x66\n\x10\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x2\x2\x2\x13\x2\x2\x4\x2"+
		"\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2"+
		"\x1C\x2\x1E\x2 \x2\"\x2\x2\a\v\x2\x31\x31\x39;\x42\x42SS``\x65\x66ttv"+
		"v\x96\x96\x1C\x2\x38\x38<<>>\x41\x41\x44\x45HPRRUVZ[^^iillnnqquuwwyz|"+
		"|~~\x83\x87\x89\x89\x90\x92\x95\x95\x98\x99\x9F\x9F\xA1\xA3\x1B\x2*+."+
		"/\x32\x33?@\x43\x43\x46GQQWX\\]__\x61\x63ghjkppxx{{}}\x7F\x82\x88\x88"+
		"\x8A\x8B\x93\x93\x97\x97\x9A\x9A\x9C\x9C\xA0\xA0\r\x2\r\r\x13\x14\x16"+
		"\x17\x1C#)),,\x34\x37oors\x8C\x8F\xA4\xA4\x4\x2%&\xA5\xA6k\x2+\x3\x2\x2"+
		"\x2\x4\x33\x3\x2\x2\x2\x6\x41\x3\x2\x2\x2\bM\x3\x2\x2\x2\nO\x3\x2\x2\x2"+
		"\fQ\x3\x2\x2\x2\xES\x3\x2\x2\x2\x10U\x3\x2\x2\x2\x12W\x3\x2\x2\x2\x14"+
		"Y\x3\x2\x2\x2\x16[\x3\x2\x2\x2\x18]\x3\x2\x2\x2\x1A_\x3\x2\x2\x2\x1C\x61"+
		"\x3\x2\x2\x2\x1E\x65\x3\x2\x2\x2 g\x3\x2\x2\x2\"i\x3\x2\x2\x2$*\x5\n\x6"+
		"\x2%\'\x5\x4\x3\x2&%\x3\x2\x2\x2&\'\x3\x2\x2\x2\'(\x3\x2\x2\x2(*\x5\x6"+
		"\x4\x2)$\x3\x2\x2\x2)&\x3\x2\x2\x2*-\x3\x2\x2\x2+)\x3\x2\x2\x2+,\x3\x2"+
		"\x2\x2,.\x3\x2\x2\x2-+\x3\x2\x2\x2./\a\x2\x2\x3/\x3\x3\x2\x2\x2\x30\x34"+
		"\a%\x2\x2\x31\x32\a\xA7\x2\x2\x32\x34\a\x5\x2\x2\x33\x30\x3\x2\x2\x2\x33"+
		"\x31\x3\x2\x2\x2\x34\x5\x3\x2\x2\x2\x35\x37\x5\b\x5\x2\x36\x35\x3\x2\x2"+
		"\x2\x37:\x3\x2\x2\x2\x38\x36\x3\x2\x2\x2\x38\x39\x3\x2\x2\x2\x39;\x3\x2"+
		"\x2\x2:\x38\x3\x2\x2\x2;\x42\a\xAB\x2\x2<>\x5\b\x5\x2=<\x3\x2\x2\x2>?"+
		"\x3\x2\x2\x2?=\x3\x2\x2\x2?@\x3\x2\x2\x2@\x42\x3\x2\x2\x2\x41\x38\x3\x2"+
		"\x2\x2\x41=\x3\x2\x2\x2\x42\a\x3\x2\x2\x2\x43N\x5\f\a\x2\x44N\x5\xE\b"+
		"\x2\x45N\x5\x10\t\x2\x46N\x5\x12\n\x2GN\x5\x14\v\x2HN\x5\x16\f\x2IN\x5"+
		"\x18\r\x2JN\x5\x1A\xE\x2KN\x5\x1E\x10\x2LN\a\xAC\x2\x2M\x43\x3\x2\x2\x2"+
		"M\x44\x3\x2\x2\x2M\x45\x3\x2\x2\x2M\x46\x3\x2\x2\x2MG\x3\x2\x2\x2MH\x3"+
		"\x2\x2\x2MI\x3\x2\x2\x2MJ\x3\x2\x2\x2MK\x3\x2\x2\x2ML\x3\x2\x2\x2N\t\x3"+
		"\x2\x2\x2OP\a\x4\x2\x2P\v\x3\x2\x2\x2QR\t\x2\x2\x2R\r\x3\x2\x2\x2ST\t"+
		"\x3\x2\x2T\xF\x3\x2\x2\x2UV\t\x4\x2\x2V\x11\x3\x2\x2\x2WX\t\x5\x2\x2X"+
		"\x13\x3\x2\x2\x2YZ\a-\x2\x2Z\x15\x3\x2\x2\x2[\\\t\x6\x2\x2\\\x17\x3\x2"+
		"\x2\x2]^\a\xA7\x2\x2^\x19\x3\x2\x2\x2_`\a\xAA\x2\x2`\x1B\x3\x2\x2\x2\x61"+
		"\x62\x3\x2\x2\x2\x62\x1D\x3\x2\x2\x2\x63\x66\x5 \x11\x2\x64\x66\x5\"\x12"+
		"\x2\x65\x63\x3\x2\x2\x2\x65\x64\x3\x2\x2\x2\x66\x1F\x3\x2\x2\x2gh\a\'"+
		"\x2\x2h!\x3\x2\x2\x2ij\a(\x2\x2j#\x3\x2\x2\x2\v&)+\x33\x38?\x41M\x65";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Spect.Net.BasicParser.Generated
