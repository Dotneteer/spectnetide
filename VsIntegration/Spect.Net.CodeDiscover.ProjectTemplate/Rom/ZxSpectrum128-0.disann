{
  "Labels": {
    "0": "START",
    "4": "START_1",
    "199": "MAIN_RESET",
    "40": "ROM1_CALL",
    "56": "MASK_INT",
    "72": "MASK_INT_RET",
    "107": "SWAP",
    "127": "YOUNGER",
    "136": "ONERR",
    "195": "ONERR_CONT",
    "154": "P_IN",
    "1752": "RS232_INP",
    "162": "P_OUT_1",
    "1994": "RS232_OUT",
    "159": "P_OUT",
    "1510": "RS232_HANDLER",
    "181": "P_OUT_2",
    "201": "MAIN_RESET_1",
    "305": "FATAL_RAM_ERR",
    "311": "MAIN_RESET_2",
    "74": "ERR_128",
    "92": "ROM1_CALL_1",
    "309": "INF_LOOP",
    "7268": "PAGE_IN_RAM",
    "413": "NEW",
    "1417": "CHAN_INFO",
    "1438": "INI_STREAM_DATA",
    "1377": "COPYR_MSG",
    "698": "RET_SYN_CHECK",
    "705": "SYNTAX_OK",
    "735": "SYN_OK_1",
    "619": "EXEC_CMD",
    "8005": "WKSP_RAM",
    "756": "SYN_OK_2",
    "7968": "NORM_RAM",
    "801": "ERR_HANDLER",
    "842": "ERR_H_1",
    "846": "ERR_H_2",
    "893": "ERR_H_3",
    "895": "ERR_H_4",
    "924": "ERR_H_5",
    "1132": "ERR_MSG_VECTORS",
    "930": "ERR_H_6",
    "972": "ERR_H_7",
    "975": "ERR_H_8",
    "989": "ERR_H_9",
    "991": "ERR_H_10",
    "1007": "BASIC_ERRH",
    "1015": "PARSE_L_NUMB",
    "1034": "PARSE_LN_1",
    "1065": "PARSE_LN_2",
    "1090": "PARSE_LN_3",
    "1130": "PARES_LN_4",
    "1405": "PRINT_MSG",
    "1452": "REPORT_ERROR",
    "1480": "REPORT_ERROR_1",
    "1494": "TEST_BREAK",
    "1546": "RS232_H_1",
    "1556": "RS232_H_2",
    "1552": "RS232_H_RET",
    "1560": "RS232_NON_CHAR",
    "1563": "RS232_CHAR",
    "1581": "RS232_CR",
    "1591": "INKEY_PRINT",
    "1597": "INKEY_RET",
    "1601": "FORMAT",
    "1633": "FORMAT_SYNTAX",
    "1625": "FORMAT_STR_1",
    "1661": "FORMAT_SYNTAX_1",
    "1673": "FORMAT_CHECK_END",
    "6418": "ERROR_C",
    "1688": "FORMAT_BAUD",
    "1720": "BAUD_TABLE",
    "1711": "BAUD_FOUND",
    "1765": "RS232_READB",
    "1806": "RS232_BIT",
    "1822": "RS232_START_BIT",
    "1879": "RS232_COMPL",
    "1813": "RS232_BIT_1",
    "1846": "BAUD_DELAY",
    "1841": "RS232_NEXT_BIT",
    "1867": "RS_BIT_0_REC",
    "1876": "RS_BYTE_REC",
    "1894": "STOP_B_DELAY",
    "1919": "RS_START_BIT_2",
    "1905": "RS_WAIT_STARTB",
    "1954": "BAUD_DELAY_2",
    "1949": "RS_NEXT_BIT_2",
    "1975": "RS_BIT_0_REC_2",
    "1984": "RS_REC_COMPL",
    "2016": "RS_OUT_NO_PARS",
    "2011": "RS_OUT_2",
    "2034": "RS_OUT_NO_TOKEN",
    "2045": "RS_OUT_NO_SPC",
    "2051": "RS_OUT_NO_GR",
    "2078": "RS_OUT_CTRL",
    "2074": "RS_OUT_NO_ROW",
    "2082": "RS_OUT_CRLF",
    "2096": "RS_OUT_TEST_COM",
    "2106": "RS_OUT_3",
    "2112": "RS_OUT_4",
    "2120": "RS_OUT_5",
    "2131": "RS_OUT_TEST_AT",
    "2144": "RS_OUT_AT_TAB",
    "2153": "RS_OUT_INK",
    "2162": "RS_OUT_PARS",
    "2178": "RS_PROC_AT_TAB",
    "2186": "RS_AT_1",
    "2192": "RS_AT_2",
    "2197": "RS_AT_3",
    "2211": "RS_WR_BYTE",
    "2223": "RS_WR_ISREADY",
    "2248": "RS_WR_BIT",
    "2272": "RS_WR_BIT_3",
    "2266": "RS_WR_BIT_2",
    "2288": "COPY_TO_PRN",
    "2293": "COPY_TO_2",
    "2425": "PRINTER_CONFIG",
    "2432": "PRINTER_LF",
    "2434": "PRINTER_RESET",
    "2318": "COPY_TO_3",
    "2325": "COPY_HALF_ROW",
    "2330": "COPY_HALF_2",
    "2342": "COPY_COLUMN",
    "2362": "COPY_COL_2",
    "2372": "COPY_COL_3",
    "2389": "COPY_PIXELS",
    "2399": "PR_OUT_TABLE",
    "2401": "PR_OUT_TB_2",
    "2413": "TEST_PIXEL",
    "2420": "TEST_PIXEL_2",
    "2437": "PLAY_SOUND",
    "2445": "PLAY_SOUND_2",
    "2464": "PLAY_SOUND_3",
    "2565": "PLAY_MSTRING",
    "3708": "SET_SGREG",
    "2609": "CALC_TM_LOOP",
    "2622": "TEST_BREAK_2",
    "2634": "CD_DUR_PTR",
    "2639": "CD_PTRS",
    "2642": "CD_PTRS_2",
    "2663": "CDB_ADDR_STR",
    "2670": "NEXT_CD_PTR",
    "2685": "PLAY_SOUND_4",
    "2688": "PLAY_SOUND_5",
    "2700": "PLAY_SOUND_6",
    "2711": "PLAY_NOTES",
    "2719": "PLAY_NOTES_2",
    "2731": "PLAY_NOTES_3",
    "2743": "PLAY_CMD_TABLE",
    "2757": "GET_PLAY_CH",
    "2769": "GET_NEXT_STONE",
    "2772": "GET_NSTONE_2",
    "2783": "GET_NSTONE_3",
    "2785": "GET_NSTONE_4",
    "2796": "GET_NSTONE_5",
    "2803": "GET_NSTONE_6",
    "2810": "GET_NSTONE_7",
    "2820": "GET_NSTONE_8",
    "3874": "REPORT_k",
    "3577": "STONES_TABLE",
    "2845": "GET_PS_NUMVAL",
    "2856": "GET_PS_NV_2",
    "2882": "GET_PS_NV_3",
    "2885": "GET_PS_NV_4",
    "3866": "REPORT_l",
    "2896": "MUL_DE_BY10",
    "2901": "MUL_DE_2",
    "2908": "FIND_NOTE_CHSTR",
    "2921": "FINDN_CHSTR_2",
    "2948": "FINDN_CHSTR_3",
    "2949": "NCMD_EXCL",
    "3530": "CMD_JUMP_TABLE",
    "2960": "NCMD_OCTAVE",
    "3858": "ERROR_n",
    "2981": "NCMD_SEPARATOR",
    "2982": "NCMD_SREPEAT",
    "3882": "REPORT_d",
    "3010": "NCMD_EREPEAT",
    "3056": "NCMD_EREP_2",
    "3083": "NCMD_EREP_3",
    "3111": "GET_ADDR_BRCK",
    "3122": "NCMD_TEMPO",
    "3190": "NCMD_TEMPO_RET",
    "3204": "NCMD_MIXER",
    "3221": "NCMD_VOLUME",
    "3245": "NCMD_VOLEFF",
    "3258": "NCMD_VOLSPEC",
    "3560": "ENV_WAVE_TABLE",
    "3278": "NCMD_VOLDUR",
    "3293": "NCMD_MIDICH",
    "3310": "NCMD_MIDI_PC",
    "3318": "NCMD_STOP",
    "3323": "NCMD_OTHERS",
    "3368": "NCMD_O_2",
    "3378": "NCMD_O_3",
    "3384": "NCMD_O_4",
    "3387": "NCMD_O_5",
    "3423": "NCMD_O_6",
    "3438": "NCMD_O_7",
    "3444": "INC_NOTE_COUNT",
    "3457": "NCMD_NO_DIGIT",
    "3484": "NCMD_O_RET",
    "3898": "REPORT_o",
    "3489": "NCDM_EOS",
    "3490": "NCMD_EOS_2",
    "3500": "CDB_POINT_DUR",
    "3508": "STORE_DUR_LEN",
    "3584": "FINDN_DUR_LEN",
    "3596": "NOTE_DUR_TABLE",
    "3609": "IS_NUM_DIGIT",
    "3616": "PLAY_NOTE_SCC",
    "3890": "REPORT_m",
    "3647": "PLAY_N_2",
    "4246": "NOTE_LOOKUP_TBL",
    "3671": "PLAY_N_3",
    "3678": "PLAY_N_4",
    "3721": "GET_SGREG",
    "3731": "SOUND_OFF",
    "3756": "RESET_MIDI_CH",
    "3768": "RESET_MIDI_C_2",
    "3779": "RESET_MIDI_C_3",
    "3784": "GET_PR_PLAY_CH",
    "3792": "GET_PR_PLCH_2",
    "3811": "GET_PLAY_CURR",
    "3820": "GET_PLAY_CUR_2",
    "3835": "GET_PLAY_CUR_3",
    "3845": "GET_PLAY_CUR_4",
    "3849": "GET_PLAY_CUR_5",
    "3906": "PLAYN_EACH_CH",
    "3909": "PLAYN_ECH_2",
    "3945": "PLAYN_ECH_3",
    "3948": "PLAYN_ECH_4",
    "3958": "WAIT_NOTE_DUR",
    "3974": "WAIT_NDUR_2",
    "3985": "SMALLEST_DUR",
    "3991": "SMALL_DUR_2",
    "4015": "SMALL_DUR_3",
    "4026": "SMALL_DUR_4",
    "4033": "PLAY_UPD_DUR",
    "4040": "PLAY_UPD_2",
    "4092": "PLAY_UPD_3",
    "4108": "PLAY_UPD_4",
    "4134": "PLAY_UPD_5",
    "4157": "PLAY_UPD_6",
    "4186": "PLAY_UPD_7",
    "4198": "PLAY_UPD_8",
    "4207": "PLAY_UPD_9",
    "4233": "PLAY_UPD_10",
    "4236": "PLAY_UPD_11",
    "4462": "PLAYN_MIDI",
    "4493": "MIDI_OFF",
    "4515": "MIDI_SEND_BYTE",
    "4532": "MIDI_SENDB_2",
    "4542": "MIDI_SENDB_3",
    "4553": "MIDI_SENDB_4",
    "4559": "MIDI_SEND_5",
    "4561": "MIDI_SENDB_6",
    "4583": "MIDI_SENDB_7",
    "4587": "SAVE_ROUT",
    "4594": "LOAD_ROUT",
    "4601": "VERIFY_ROUT",
    "4608": "MERGE_ROUT",
    "4613": "MERGE_ROUT_2",
    "4633": "REPORT_C",
    "4637": "RAM_DISK_CMD",
    "4686": "RAMD_CMD_2",
    "4736": "RAMD_CMD_3",
    "4740": "RAMD_CMD_4",
    "4752": "RAMD_CMD_5",
    "4763": "RAMD_VERIFY",
    "4805": "RAMD_MERGE",
    "4827": "RAMD_LOAD",
    "4782": "RAMD_VER_2",
    "4792": "RAMD_VER_3",
    "4801": "RAMD_VER_4",
    "4845": "RAMD_LOAD_2",
    "4854": "RAMD_LOAD_3",
    "4863": "RAMD_LOAD_4",
    "4885": "RAMD_LOAD_5",
    "4913": "RAMD_LOAD_6",
    "4917": "RAMD_LPROG",
    "4976": "RAMD_LPROG_2",
    "4990": "RAMD_LOAD_BYTES",
    "4997": "GET_EXPR",
    "5011": "CHECK_FNAME_COPY",
    "5037": "CHECK_FNAME_2",
    "5050": "CHECK_FNAME_3",
    "5054": "CAS_RAM_CMD",
    "5074": "CAS_RAM_2",
    "5084": "CAS_RAM_3",
    "5113": "CAS_RAM_4",
    "5120": "CAS_RAM_5",
    "5127": "CAS_RAM_6",
    "5157": "CAS_RAM_7",
    "5167": "CAS_RAM_8",
    "5188": "CAS_RAM_9",
    "5198": "CAS_RAM_10",
    "5201": "CAS_RAM_11",
    "5215": "CAS_RAMSC",
    "5250": "CAS_RAMS_2",
    "5280": "CAS_RAMSC_3",
    "5295": "CAS_RAMSC_4",
    "5300": "CAS_RAMSC_5",
    "5304": "CAS_RAMSC_6",
    "5327": "CAS_RAMSC_7",
    "5333": "CAS_RAM_SL",
    "5346": "CAS_RAM_SL_2",
    "5369": "CAS_RAM_SL_3",
    "5401": "CAS_RAM_RET",
    "5419": "CAS_RAM_RER_2",
    "5423": "RELIST",
    "5430": "RELIST_2",
    "5440": "RELIST_3",
    "5460": "RELIST_4",
    "5475": "RELIST_5",
    "5487": "RELIST_6",
    "5524": "RELIST_7",
    "5526": "RELIST_8",
    "5547": "RELIST_9",
    "5568": "RELIST_10",
    "5579": "RELIST_11",
    "5587": "RELIST_12",
    "5620": "RELIST_13",
    "5629": "RELIST_14",
    "5634": "RELIST_15",
    "5637": "DISP_BUFF",
    "5644": "DISP_BUFF_2",
    "5662": "DISP_BUFF_3",
    "5680": "CLEAR_EDIT_DISP",
    "5689": "ED_SHIFT_UP",
    "5704": "ED_SHIFT_UP_2",
    "5718": "ED_SHIFT_UP_3",
    "5731": "ED_SHIFT_UP_4",
    "5743": "ED_SHIFT_DW",
    "5749": "ED_SHIFT_DW_2",
    "5774": "ED_SHIFT_DW_3",
    "5786": "ED_SHIFT_DW_4",
    "5801": "ED_SHIFT_DW_5",
    "5804": "CHINS_SHLEFT",
    "5811": "CHINS_SHLEFT_2",
    "5825": "CHINS_SHRIGHT",
    "5836": "CHINS_SHRIG_2",
    "5843": "CHINS_SHRIG_3",
    "5846": "CHINS_SHRIG_4",
    "5852": "SYN_OFFS_TABLE",
    "5902": "SYN_PAR_TABLE",
    "6063": "MAIN_PARSER",
    "6080": "STMT_LOOP",
    "6081": "STMT_LOOP_2",
    "6177": "STMT_RET",
    "6057": "SPECTRUM_PARS",
    "6060": "PLAY_PARS",
    "6132": "STMT_LOOP_3",
    "6144": "STMT_LOOP_4",
    "6141": "STMT_LOOP_RET",
    "6325": "CMD_CLASS_TABLE",
    "6170": "P_SEPARATOR",
    "6186": "STMT_RET_2",
    "6200": "LINE_RUN",
    "6220": "LINE_NEW",
    "6242": "LINE_REM",
    "6243": "LINE_END",
    "6256": "LINE_USE",
    "6274": "LINE_NEXT",
    "6301": "REPORT_N",
    "6305": "CHECK_END",
    "6312": "STMT_NEXT",
    "6340": "CLASS_CDE",
    "6358": "CLASS_000305",
    "6392": "CLASS_035_RET",
    "6393": "CLASS_01",
    "6397": "CLASS_02",
    "6405": "CLASS_04",
    "6409": "CLASS_08",
    "6414": "CLASS_06",
    "6422": "CLASS_0A",
    "6426": "CLASS_07",
    "6439": "CLASS_07_2",
    "6468": "CLASS_09",
    "6472": "CLASS_0B",
    "6503": "IF_ROUT",
    "6526": "IF_ROUT_2",
    "6529": "FOR_ROUT",
    "6542": "FOR_ROUT_2",
    "6566": "FOR_ROUT_3",
    "6570": "READ_ROUT",
    "6603": "READ_ROUT_2",
    "6626": "READ_ROUT_3",
    "6635": "DATA_ROUT",
    "6641": "DATA_ROUT_2",
    "6652": "DATA_ROUT_3",
    "6654": "PASS_BY",
    "6658": "RUN_ROUT",
    "6669": "CLEAR_ROUT",
    "6672": "CLEAR_ROUT_2",
    "6680": "CLEAR_ROUT_3",
    "6715": "CLEAR_ROUT_4",
    "6719": "CLEAR_ROUT_5",
    "6739": "GOSUB_ROUT",
    "6767": "RETURN_ROUT",
    "6790": "RETURN_ROUT_2",
    "6796": "DEFFN_ROUT",
    "6807": "DEFFN_ROUT_2",
    "6826": "DEFFN_ROUT_3",
    "6835": "DEFFN_ROUT_4",
    "6838": "DEFFN_ROUT_5",
    "6849": "DEFFN_ROUT_6",
    "6867": "DEFFN_ROUT_7",
    "6890": "DEFFN_ROUT_8",
    "6897": "RUN_TAP_LOADER",
    "6896": "MOVE_ROUT",
    "6932": "RUN_LLIST",
    "6955": "SPECTRUM_ROUT",
    "6983": "BASIC_48",
    "6995": "SET_P_CHDATA",
    "7022": "LOAD_CMD_BYTES",
    "7025": "LLIST_ROUT",
    "7029": "LIST_ROUT",
    "7031": "LIST_ROUT_2",
    "7043": "LIST_ROUT_3",
    "7062": "LIST_ROUT_4",
    "7070": "LIST_ROUT_5",
    "7075": "LIST_ROUT_6",
    "7078": "LIST_ROUT_7",
    "7085": "RAMD_SAVE",
    "7141": "CAT_ROUT",
    "7180": "ERASE_ROUT",
    "7214": "RAMD_LOAD_HEAD",
    "7297": "RAMBANK_MAPPINGS",
    "7303": "CMP_FILENAMES",
    "7306": "CMP_FN_2",
    "7311": "CMP_FN_3",
    "7319": "NEW_CAT_ENTRY",
    "7328": "NEW_CATE_2",
    "7411": "ADJ_RAMD_SPACE",
    "7427": "ADJ_RAMDS_2",
    "7434": "ADJ_RAMDS_3",
    "7438": "ADJ_RAMDS_4",
    "7442": "FIND_CATE",
    "7451": "FIND_CATE_2",
    "7470": "FIND_CATE_3",
    "7477": "FIND_RAMD_FILE",
    "7486": "FIND_RAMDF_2",
    "7510": "UPD_CATE",
    "7596": "SAVEB_RAMD",
    "7628": "SAVEB_RAMD_2",
    "7637": "SAVEB_RAMD_3",
    "7652": "SAVEB_RAMD_4",
    "7657": "SAVEB_RAMD_5",
    "7668": "SAVEB_RAMD_6",
    "7685": "SAVEB_RAMD_7",
    "7691": "SAVEB_RAMD_8",
    "7716": "SAVEB_RAMD_9",
    "7735": "LOADB_RAMD",
    "7772": "LOADB_RAMD_2",
    "7783": "LOADB_RAMD_3",
    "7798": "LOADB_RAMD_4",
    "7803": "LOADB_RAMD_5",
    "7808": "LOADB_RAMD_6",
    "7825": "LOADB_RAMD_7",
    "7831": "LOADB_RAMD_8",
    "7863": "LOADB_RAMD_9",
    "7868": "LOADB_RAMD_10",
    "7887": "TO_RAM4",
    "7912": "TO_RAM4_2",
    "7940": "FROM_RAM4",
    "7994": "SEL_RAMB",
    "8031": "ERASE_FILE",
    "8040": "ERASEF_2",
    "8170": "ERASEF_3",
    "8205": "ERASEF_4",
    "8228": "ERASEF_5",
    "8251": "ERASEF_6",
    "8254": "ERASEF_7",
    "8289": "ERASEF_8",
    "8316": "ERASEF_9",
    "8345": "ERASEF_10",
    "8402": "PRINT_CAT",
    "8481": "LOWEST_NAME",
    "8491": "HIGHEST_NAME",
    "8410": "PRCAT_2",
    "8417": "PRCAT_3",
    "8458": "PRCAT_4",
    "8465": "PRCAT_5",
    "8501": "PRINT_CAT_ENTRY",
    "8530": "PRCATE_2",
    "8564": "LPRINT_ROUT",
    "8568": "PRINT_ROUT",
    "8570": "PRINT_ROUT_2",
    "8578": "PRINT_ROUT_3",
    "8588": "INPUT_ROUT",
    "8601": "INPUT_ROUT_2",
    "8615": "COPY_ROUT",
    "8618": "NEW_ROUT",
    "8638": "DRAW_ROUT",
    "8650": "DRAW_ROUT_2",
    "8661": "DIM_ROUT",
    "8679": "DIM_ROUT_2",
    "8683": "REPORT_C_2",
    "8687": "CLS_ROUT",
    "8696": "EV_NUM_EXPR",
    "8762": "EVNUMEX_2",
    "8766": "EVNUMEX_3",
    "8804": "EVNUMEX_4",
    "8815": "PREC_KEY_PRESS",
    "8846": "FIND_SBASIC",
    "8855": "IS_LET_CMD",
    "8864": "ISLET_2",
    "8875": "IS_OPER",
    "8879": "IS_OPER_2",
    "8889": "IS_OPER_3",
    "8893": "OP_TOKENS_TABLE",
    "8907": "IS_FUNC_CHAR",
    "8925": "ISFUNC_2",
    "8928": "IS_NUM_OR_FUNC",
    "8941": "ISNOF_2",
    "8950": "ISNOF_3",
    "8967": "ISNOF_4",
    "8970": "IS_NUM_CHAR",
    "8980": "ISNUM_2",
    "8983": "PLAY_ROUT",
    "8986": "PLAY_ROUT_2",
    "8999": "PLAY_ROUT_3",
    "9008": "PLAY_ROUT_4",
    "9527": "ED_KEYS_TABLE",
    "9591": "MENU_KEYS_TABLE",
    "9604": "INIT_MSETTINGS",
    "9631": "SHOW_MENU",
    "10052": "MENU_JUMP_TABLE",
    "10068": "MENU_TEXT_TABLE",
    "10128": "EDIT_MENU_TABLE",
    "10144": "EDIT_TEXT_TABLE",
    "9645": "SMENU_2",
    "9675": "RET_MENU_ERR",
    "9699": "RETMERR_2",
    "9729": "CALC_MODE",
    "9732": "RET_EDIT",
    "9770": "RET_EDIT_2",
    "9773": "RET_EDIT_3",
    "9811": "MAIN_WAIT_LOOP",
    "9833": "PROCESS_KEY",
    "9847": "PROCKEY_2",
    "9857": "PROCKEY_3",
    "9865": "PROCKEY_4",
    "9876": "PROCKEY_5",
    "9883": "TOGGLE_KH",
    "9910": "TOGGLE_KH_2",
    "9913": "TOGGLE_KH_3",
    "9915": "SEL_LOW_SCREEN",
    "9934": "SEL_UPP_SCREEN",
    "9945": "SELUPP_2",
    "9959": "ERR_BEEP",
    "9964": "ERR_BEEP_2",
    "9972": "ERR_BEEP_3",
    "9978": "SUCCESS_BEEP",
    "9988": "MENU_KH",
    "10007": "SELECT_KH",
    "10030": "CURSOR_UP_KH",
    "10033": "CURSOR_DW_KH",
    "10034": "CURSOR_DW_KH_2",
    "10187": "CALC_MENU_TABLE",
    "10194": "CALC_MENU_TEXT",
    "10219": "TAPE_LDR_TEXT",
    "10257": "EDT_OPT",
    "10262": "TAPE_TEST_OPT",
    "10268": "EXIT_OPT",
    "10289": "TAPE_LOAD_OPT",
    "10321": "RENUM_OPT",
    "10338": "PRINT_OPT",
    "10341": "EDIT_OPT_2",
    "10356": "EDIT_OPT_3",
    "10373": "CALC_OPT",
    "10417": "ED_OPT_4",
    "10430": "RES_CURPOS",
    "10439": "RET_MAIN_MENU",
    "10449": "MS_ERR_CURS_SET",
    "10463": "INIT_LWS_SET",
    "10456": "MS_LW_CURS_SET",
    "10472": "INIT_UPS_SET",
    "10481": "HANDLE_KEY_CODE",
    "10523": "DELRIGHT_KH",
    "10539": "DEL_KH",
    "10564": "ENTER_KH",
    "10590": "ENTER_KH_2",
    "10602": "ENTER_KH_3",
    "10618": "ENTER_KH_4",
    "10623": "ENTER_KH_5",
    "10627": "TOP_OF_PR_KH",
    "10667": "END_OF_PR_KH",
    "10708": "WLEFT_KH",
    "10732": "REMOVE_CURS",
    "10738": "SHOW_CURS",
    "10759": "FETCH_CURS",
    "10769": "STORE_CURS",
    "10778": "GETC_EDITBUF",
    "10789": "DW_10L_KH",
    "10795": "DW_10L0_KH_2",
    "10818": "DW_10L_KH_3",
    "10831": "UP_10L_KH",
    "10837": "UP_10L_KH_2",
    "10861": "UP_10L_KH_3",
    "10874": "EOL_KH",
    "10887": "SOL_KH",
    "10900": "CUR_UP_KH",
    "10933": "CUR_DOWN_KH",
    "10967": "CUR_LEFT_KH",
    "10979": "CUR_RIGHT_KH",
    "10744": "DISP_CURS",
    "11001": "FCL_EDPOS_RTHL",
    "11010": "FCL_EDPOS_LTHR",
    "11019": "INS_BASIC_SHDW",
    "11053": "INSB_SHDW_2",
    "11055": "INSB_SHDW_3",
    "11056": "INS_BASIC_SHUP",
    "11071": "INSB_SHUP_2",
    "11096": "INSB_SHUP_3",
    "11098": "INSB_SHUP_4",
    "11099": "FN_EDPOS_LWA",
    "11110": "FN_LWA_2",
    "11128": "FN_EDPOS_RWA",
    "11141": "FN_RWA_2",
    "11200": "FN_RWA_3",
    "11220": "FN_EDPOS_PCR",
    "11231": "FN_EDPOS_L",
    "11242": "FN_STW_L",
    "11244": "FN_STW_L_2",
    "11256": "FN_STW_L_3",
    "11271": "FN_STW_L_4",
    "11273": "FN_STW_R",
    "11275": "FN_STW_R_2",
    "11287": "FN_STW_R_3",
    "11307": "FN_STW_R_4",
    "11313": "FN_SBLINE",
    "11315": "FN_SBLINE_2",
    "11333": "FN_SBLINE_3",
    "11340": "FN_EBLINE",
    "11342": "FN_EBLINE_2",
    "11360": "FN_EBLINE_3",
    "11365": "FN_LINE_RET",
    "11368": "INS_BLINE_ALT",
    "11388": "INS_BLINE_ALTFRS",
    "11406": "INS_BLINE",
    "11408": "INS_BLINE_2",
    "11427": "INS_BLINE_3",
    "11503": "INS_BLINE_SYN",
    "11530": "INS_BLINE_SYN_2",
    "11547": "INS_BLINE_SYN_3",
    "11562": "INS_BLINE_SYN_4",
    "11576": "INS_BLINE_SYN_5",
    "11589": "INS_BLINE_SYN_6",
    "11604": "FE_NC_INS",
    "11618": "FE_NC_INS_2",
    "11653": "NEXT_CHAR_TABLE",
    "11641": "FE_NC_INS_3",
    "11663": "FE_CH_CUR",
    "11666": "FE_CH_CUR_2",
    "11678": "FE_CH_CUR_3",
    "11692": "FE_CH_CUR_4",
    "11710": "FE_CH_CUR_5",
    "11711": "FE_CH_CUR_6",
    "11726": "FE_CH_CUR_7",
    "11739": "FE_CH_CUR_8",
    "11753": "FE_CH_CUR_9",
    "11756": "FE_CH_CUR_10",
    "11768": "FE_CH_CUR_11",
    "11785": "FE_CH_CUR_12",
    "11790": "FE_CH_BUF",
    "11803": "UPP_SCR_ROWS",
    "11805": "LOW_SCR_ROWS",
    "11807": "RES_TO_MAIN_SCR",
    "11821": "RES_TO_LOW_SCR",
    "11841": "FI_EP_RIGHT",
    "11862": "FI_EP_RIGHT_2",
    "11867": "FI_EP_RIGHT_3",
    "11875": "FI_EP_LEFT",
    "11884": "FI_EP_LEFT_2",
    "11896": "FI_EP_LEFT_3",
    "11899": "FE_BUFROW_CH",
    "11905": "INS_CH_BUF",
    "11918": "INS_CH_ROW",
    "11970": "INS_CH_ROW_2",
    "11976": "INS_CH_ROW_3",
    "11980": "INS_CH_ROW_4",
    "11982": "INS_BLANK_ROW",
    "11987": "INS_BLANK_ROW_2",
    "12015": "EMPTY_ROW_DATA",
    "12050": "DEL_CH_BUF",
    "12055": "DEL_CH_BUF_2",
    "12081": "DEL_CH_BUF_3",
    "12082": "DEL_CH_BUF_4",
    "12097": "DEL_CH_BUF_5",
    "12106": "DEL_CH_BUF_6",
    "12116": "DEL_CH_BUF_7",
    "12143": "DEL_CH_BUF_8",
    "12148": "DEL_CH_BUF_9",
    "12160": "SHFT_UP_CL",
    "12196": "SHFT_UP_CL_2",
    "12200": "SHFT_UP_CL_3",
    "12210": "SHFT_UP_CL_4",
    "12220": "DELW_LEFT_KH",
    "12223": "DELW_LEFT_KH_2",
    "12249": "DELW_LEFT_KH_3",
    "12275": "DELW_LEFT_KH_4",
    "12279": "DELW_LEFT_KH_5",
    "12280": "DELW_LEFT_KH_6",
    "12314": "DELW_RGHT_KH_2",
    "12311": "DELW_RGHT_KH",
    "12335": "DELW_RGHT_KH_3",
    "12350": "DEL_SOFLN_KH",
    "12353": "DEL_SOFLN_KH_2",
    "12377": "DEL_SOFLN_KH_3",
    "12397": "DEL_SOFLN_KH_4",
    "12398": "DEL_SOFLN_KH_5",
    "12402": "DEL_EOL_KH",
    "12405": "DEL_EOL_KH_2",
    "12420": "REM_CATT_DIS",
    "12437": "TPREV_CH_EXTS",
    "12462": "TPREV_CH_EXTS_2",
    "12466": "TPREV_CH_EXTS_3",
    "12468": "FN_ROW_ADDR",
    "12471": "FN_ROW_ADDR_2",
    "12476": "FN_ROW_ADDR_3",
    "12483": "FN_ROW_ADDR_4",
    "12486": "FN_POS_ADDR",
    "12496": "BSCR_BUFF_SETS",
    "12502": "SET_BSCR_BUFF",
    "12511": "SHFT_UP_ROWS",
    "12536": "SHFT_UP_ROWS_2",
    "12545": "SHFT_UP_ROWS_3",
    "12566": "SHFT_UP_ROWS_4",
    "12574": "SHFT_DW_ROWS",
    "12605": "SHFT_DW_ROWS_2",
    "12607": "SHFT_DW_ROWS_3",
    "12620": "SHFT_DW_ROWS_4",
    "12654": "INS_CH_BSCR",
    "12672": "INS_CH_BSCR_2",
    "12676": "INS_CH_BSCR_3",
    "12704": "INS_CH_BSCR_4",
    "12730": "INS_CH_BSCR_5",
    "12739": "FN_BROW_ADDR",
    "12745": "DEL_CH_BSCR",
    "12761": "DEL_CH_BSCR_2",
    "12786": "DEL_CH_BSCR_3",
    "12804": "DEL_CH_BSCR_4",
    "12808": "DEL_CH_BSCR_5",
    "12822": "DEL_CH_BSCR_6",
    "12827": "DEL_CH_BSCR_7",
    "12830": "ASCR_BUFF_SETS",
    "12834": "SET_ASCR_BUFF",
    "12843": "SHFT_DW_ASCR",
    "12868": "SHFT_DW_ASCR_2",
    "12883": "SHFT_DW_ASCR_3",
    "12893": "SHFT_DW_ASCR_4",
    "12898": "SHFT_DW_ASCR_5",
    "12906": "SHFT_UP_ASCR",
    "12930": "SHFT_UP_ASCR_2",
    "12960": "SHFT_UP_ASCR_3",
    "12979": "SHFT_UP_ASCR_4",
    "12983": "FN_AROW_ADDR",
    "12989": "BASIC_CH_ACTIONS",
    "13014": "COPY_BLINE_BUFF",
    "13034": "CP_BLINE_BUFF_2",
    "13063": "CP_BLINE_BUFF_3",
    "13091": "CP_BLINE_BUFF_4",
    "13094": "CP_BLINE_BUFF_5",
    "13100": "CP_BLINE_BUFF_6",
    "13105": "SET_CONT_ROW",
    "13130": "FIND_BLINE_ADDR",
    "13138": "CRE_NEXT_LINE",
    "13146": "FE_NXT_DETOKEN",
    "13151": "CPY_INSKW_TO_RAM",
    "13172": "INS_KW_REPR",
    "13205": "INS_KW_2",
    "13212": "INS_KW_3",
    "13219": "INS_KW_4",
    "13226": "INS_KW_5",
    "13233": "INS_KW_6",
    "13238": "INS_KW_7",
    "13240": "INS_KW_8",
    "13242": "INS_KW_9",
    "13251": "COPY_KW_CHS",
    "13273": "COPY_KW_CHS_2",
    "13300": "IDENT_TOKEN",
    "13313": "IDENT_TOKEN_2",
    "13316": "IDENT_TOKEN_3",
    "13326": "IDENT_TOKEN_4",
    "13338": "IDENT_TOKEN_5",
    "13341": "IDENT_TOKEN_6",
    "13349": "IDENT_TOKEN_7",
    "13350": "IDENT_TOKEN_8",
    "13360": "CRE_NEXT_LN",
    "13389": "CRE_NEXT_LN_2",
    "13457": "CRE_NEXT_LN_3",
    "13461": "INS_NUM_DIGIT",
    "13462": "INS_NUM_DIGIT_2",
    "13489": "INS_NUM_DIGIT_3",
    "13491": "INS_NUM_DIGIT_4",
    "13494": "FN_LINE_ADDR",
    "13519": "MOVETO_NEXT_LN",
    "13529": "CHK_BASIC_END",
    "13536": "CMP_LN_NUMS",
    "13546": "CLR_CONST_PTRS",
    "13558": "FIND_BAS_ADDR",
    "13578": "FIND_BAS_ADDR_2",
    "13591": "FE_DETOK_CH",
    "13609": "FE_DETOK_CH_2",
    "13620": "FE_DETOK_CH_3",
    "13628": "FE_DETOK_CH_4",
    "13639": "FE_DETOK_CH_5",
    "13652": "FE_DETOK_CH_6",
    "13671": "FE_DETOK_CH_7",
    "13682": "FE_DETOK_CH_8",
    "13685": "FE_DETOK_CH_9",
    "13716": "SPECTRUM_STR",
    "13753": "IND_SETS",
    "13724": "PLAY_STR",
    "13691": "FE_DETOK_CH_10",
    "13711": "FE_DETOK_CH_11",
    "13713": "FE_DETOK_CH_12",
    "13756": "SET_IND_SETS",
    "13765": "STR_CH_EDBUF",
    "13772": "ENTER_AH",
    "13786": "NULLCOL_AH",
    "13798": "NULL_COLPOS",
    "13804": "NULL_COLPOS_2",
    "13812": "IND_BUFF_ROW",
    "13817": "IND_BUFF_ROW_2",
    "13828": "PR_BUF_ROW",
    "13844": "PR_BUF_ROW_3",
    "13848": "SHFT_UP_EDROW",
    "13864": "SHFT_UP_EDROW_2",
    "13868": "SHFT_DW_EDROW",
    "13884": "SHFT_DW_EDROW_2",
    "13888": "SET_CURATTR",
    "13903": "RES_CURATTR",
    "13918": "RES_L_MODE",
    "13928": "RES_L_MODE_2",
    "13948": "RES_L_MODE_3",
    "13951": "WAIT_KPRESS",
    "13952": "WAIT_KPRESS_2",
    "13955": "WAIT_KPRESS_3",
    "13986": "WAIT_KPRESS_4",
    "13988": "WAIT_KPRESS_5",
    "14316": "TITLE_COLORS",
    "14330": "TITLE_SPC_COLORS",
    "14338": "SINCLAIR_STRIPES",
    "13992": "DISP_MENU",
    "14033": "DISP_MENU_2",
    "14039": "DISP_MENU_3",
    "14048": "DISP_MENU_4",
    "14051": "DISP_MENU_5",
    "14105": "PLOT_LINE",
    "14123": "PRINT_AT_BC",
    "14131": "PRINT_STRING",
    "14139": "ST_MENU_AREA",
    "14142": "RES_MENU_AREA",
    "14143": "RES_AREA_2",
    "14152": "RES_AREA_3",
    "14157": "RES_AREA_4",
    "14163": "RES_AREA_5",
    "14171": "RES_AREA_6",
    "14185": "RES_AREA_7",
    "14206": "STRRES_ROW",
    "14209": "STRRES_ROW_2",
    "14217": "STRRES_ROW_3",
    "14222": "STRRES_ROW_4",
    "14240": "STRRES_ROW_5",
    "14245": "STRRES_ROW_6",
    "14247": "MOVEUP_MENU",
    "14257": "MOVEUP_MENU_2",
    "14262": "MOVEDW_MENU",
    "14277": "MOVEDW_MENU_2",
    "14282": "TOGG_MENU_OPT",
    "14294": "TOGG_MENU_OPT_2",
    "14298": "TOGG_MENU_OPT_3",
    "14305": "TOGG_MENU_OPT_4",
    "14307": "TOGG_MENU_OPT_5",
    "14370": "PRINT_STRIPES",
    "14354": "STRIP_TEXT",
    "14408": "PRINT_128_BAN",
    "14413": "PRINT_CALC_BAN",
    "14418": "PRINT_TAPEL_BAN",
    "14423": "PRINT_TESTER_BAN",
    "14426": "PRINT_BANNER",
    "14437": "PRINT_BAN_2",
    "14465": "CLR_LOW_DISP",
    "14472": "RENUMBER",
    "14506": "RENUM_OK",
    "14520": "RENUM_OK_2",
    "14533": "RENUM_OK_3",
    "14557": "RENUM_LINES",
    "14599": "LNUM_TOKENS",
    "14606": "PARSE_FOR_RENUM",
    "14623": "PARSE_FRN_2",
    "14651": "PARSE_FRN_3",
    "14655": "PARSE_FRN_4",
    "14659": "PARSE_FRN_5",
    "14679": "PARSE_FRN_6",
    "14703": "PARSE_FRN_7",
    "14720": "PARSE_FRN_8",
    "14782": "PARSE_FRN_9",
    "14784": "PARSE_FRN_NOROOM",
    "14789": "PARSE_FRN_10",
    "14799": "PARSE_FRN_11",
    "14853": "COUNT_BLINES",
    "14859": "COUNT_BLINES_2",
    "14877": "COUNT_BLINES_3",
    "14894": "COUNT_BLINES_4",
    "14897": "COUNT_BLINES_5",
    "14901": "SKIP_SPACES",
    "14902": "SKIP_SPACES_2",
    "14908": "CRE_ASCII_LN",
    "14934": "CRE_ASCII_LN_2",
    "14944": "INS_LNUM_DIGIT",
    "14945": "INS_LNUM_DIGIT_2",
    "14957": "LOWSCR_CUR_SETS",
    "14966": "MSCR_CUR_SETS",
    "14975": "SET_MSCR_CUR",
    "14984": "SET_LSCR_CUR",
    "14987": "SET_LSCR_CUR_2",
    "14998": "STR_CURCOL",
    "15005": "SET_CPOS_ATTR",
    "15026": "RES_CPOS_ATTR",
    "15039": "SHFT_UP_DF",
    "15046": "SHFT_DW_DF",
    "15053": "SHIFT_DF",
    "15062": "SHIFT_DF_2",
    "15075": "SHIFT_DF_3",
    "15076": "SHIFT_DF_4",
    "15086": "SHIFT_DF_5",
    "15126": "SHIFT_DF_6",
    "15127": "SHIFT_DF_7",
    "15133": "SHIFT_DF_8",
    "15134": "PRINT_EBROW",
    "15153": "PRINT_EBROW_2",
    "15164": "PRINT_EBROW_3",
    "15170": "PRINT_EBROW_4",
    "15177": "PRINT_EBROW_5",
    "15189": "PRINT_EBROW_6",
    "15198": "CLR_DISP_ROW",
    "15208": "CLR_DISP_ROW_2",
    "15214": "CLR_DISP_ROW_3",
    "15218": "CLR_DISP_ROW_4",
    "15238": "CLR_DISP_ROW_5",
    "15252": "FN_ROWCOL_TE",
    "15256": "FN_ROW_TE",
    "15264": "GET_ATTR_ADDR",
    "15288": "EXCH_COLORS",
    "15337": "TAPE_TESTER",
    "15354": "TAPE_TESTER_2",
    "15358": "TAPE_TESTER_3",
    "15389": "TAPE_TESTER_4",
    "15403": "TAPE_TESTER_5",
    "15421": "TAPE_TESTER_6",
    "15423": "TAPE_TESTER_7",
    "15435": "TAPE_TESTER_8",
    "15446": "TAPE_TESTER_9",
    "15449": "TAPE_TESTER_10",
    "15459": "SEARCH_ERRPOS",
    "15463": "TOKENIZE",
    "15465": "TOKENIZE_2",
    "15521": "TOKENIZE_3",
    "15539": "TOKENIZE_4",
    "15544": "TOKENIZE_5",
    "15556": "TOKENIZE_6",
    "15564": "TOKENIZE_7",
    "15574": "TOKENIZE_8",
    "15597": "TOKENIZE_9",
    "15604": "TOKENIZE_10",
    "15614": "TOKENIZE_11",
    "15646": "TOKENIZE_12",
    "15663": "TOKENIZE_13",
    "15666": "TOKENIZE_14",
    "15667": "TOKENIZE_15",
    "15728": "TOKENIZE_16",
    "15741": "TOKENIZE_17",
    "15759": "TOKENIZE_18",
    "15764": "TOKENIZE_19",
    "15773": "FE_NC_STATUS",
    "15788": "FE_NC_STAT_2",
    "15791": "FE_NC_STAT_3",
    "15805": "FE_NC_STAT_4",
    "15808": "FE_NC_STAT_5",
    "15811": "FE_NC_STAT_6",
    "15814": "TEST_LOWERC",
    "15821": "COPY_KEYWCBUFF",
    "15834": "COPY_KEYWBUFF_2",
    "15849": "INS_CH_KCBUF",
    "15864": "INS_CH_KCBUF_2",
    "15875": "INS_CH_KCBUF_3",
    "15881": "INS_CH_KCBUF_4",
    "15891": "INS_CH_KCBUF_5",
    "15894": "TOK_LT_GT",
    "15910": "TOK_LT_GT_2",
    "15914": "TOK_LT_GT_3",
    "15919": "TOK_LT_GT_4",
    "15937": "TOK_LT_GT_5",
    "15945": "TOK_LT_GT_6",
    "15954": "TOK_LT_GT_7",
    "15963": "TOK_LT_GT_8",
    "15972": "INS_CH_SPEC",
    "15988": "INS_CH_SPEC_2",
    "16002": "INS_CH_SPEC_3",
    "16008": "INS_CH_SPEC_4",
    "16025": "INS_CH_SPEC_5",
    "16028": "INS_SUPSPC",
    "16055": "INS_SUPSPC_2",
    "16063": "INS_SUPSPC_3",
    "16070": "INS_SUPSPC_4",
    "16090": "INS_SUPSPC_5",
    "16110": "INS_SUPSPC_6",
    "16123": "INS_CH_BWKS",
    "16170": "INS_CH_BWKS_2",
    "16176": "INS_CH_BWKS_3",
    "16179": "INS_CH_BWKS_4",
    "16181": "INS_CH_BWKS_5",
    "16199": "INS_CH_BWKS_6",
    "16221": "INS_CH_BWKS_7",
    "16230": "TEST_ROOM_BC",
    "16246": "TEST_ROOM_BC_2",
    "16254": "IDENT_KW",
    "16278": "IDENT_KW_2",
    "16286": "IDENT_KW_3",
    "16294": "IDENT_KW_4",
    "16302": "IDENT_KW_5",
    "16310": "IDENT_KW_6",
    "16312": "IDENT_KW_7",
    "16314": "COPY_DATA_BLK",
    "16316": "COPY_DATA_BLK_2",
    "16334": "CALL_AH",
    "16338": "CALL_AH_2",
    "16353": "CALL_AH_3",
    "16363": "CALL_AH_4",
    "16366": "CALL_AH_5"
  },
  "Comments": {
    "0": "Ensure interrupts are disabled.",
    "2865": "Advance to the next character.",
    "7": "[There is no RST $08. No instruction fetch at $0008 hence ZX Interface 1 will not be paged in from this ROM. Credit: Paul Farrow].",
    "9": "to the main reset routine.",
    "12": "[Spare bytes]",
    "20": "[Spare bytes]",
    "28": "[Spare bytes]",
    "36": "[Spare bytes]",
    "40": "Get the address after the RST $28 into HL, saving HL on the stack.",
    "41": "saving HL on the stack.",
    "42": "Save the AF registers.",
    "43": "Point HL to the byte after",
    "44": "the required address.",
    "48": "(There is no RST $30)",
    "49": "Fetch the second address byte.",
    "50": "HL=Subroutine to call.",
    "51": "Restore AF.",
    "52": "Jump ahead to continue.",
    "55": "[Spare byte]",
    "56": "Save HL register pair.",
    "57": "Return address of $0048 (ROM 0).",
    "61": "$5B00. Address of swap ROM routine held in RAM at $5B00.",
    "65": "Maskable interrupt routine address $0038 (ROM 0).",
    "69": "$5B00. Switch to other ROM (ROM 1) via routine held in RAM at $5B00.",
    "72": "Restore the HL register pair.",
    "73": "End of interrupt routine.",
    "77": "ROM 0, Bank 0, Screen 0, 128K mode.",
    "78": "Ensure interrupts are disabled whilst paging.",
    "81": "$5B5C. Note the new paging status.",
    "84": "Re-enable interrupts.",
    "85": "A=$FF.",
    "86": "Set ERR_NR to no error ($FF).",
    "89": "Jump ahead to continue.",
    "92": "Save the address in ROM 0 to call.",
    "95": "HL='Return to ROM 0' routine held in RAM.",
    "98": "Stack HL.",
    "99": "Save previous stack address.",
    "100": "Produce error report.",
    "103": "Stack HL.",
    "104": "Switch to other ROM (ROM 1) and return to address to call.",
    "107": "Save AF and BC.",
    "115": "Select other ROM.",
    "117": "Disable interrupts whilst switching ROMs.",
    "121": "Switch to the other ROM.",
    "124": "Restore BC and AF.",
    "127": "Toggle to the other ROM.",
    "135": "Return to the address held in RETADDR.",
    "136": "Ensure interrupts are disabled whilst paging.",
    "137": "Fetch current paging configuration.",
    "140": "Select ROM 0.",
    "142": "Save the new configuration",
    "148": "Switch to ROM 0.",
    "151": "Jump to ONERR_CONT (ROM 0) to continue.",
    "154": "RS232 input routine within ROM 0.",
    "159": "RS232 output routine within ROM 0.",
    "162": "Save AF registers.",
    "166": "Fetch the current paging configuration",
    "169": "and save it.",
    "170": "Select ROM 0.",
    "172": "Ensure interrupts are disabled whilst paging.",
    "173": "Store the new paging configuration.",
    "176": "Switch to ROM 0.",
    "178": "Jump to the RS232 channel input/output handler routine.",
    "181": "Save AF registers. For a read, A holds the byte read and the flags the success status.",
    "182": "Retrieve original paging configuration.",
    "186": "Ensure interrupts are disabled whilst paging.",
    "187": "Store original paging configuration.",
    "190": "Switch back to original paging configuration.",
    "193": "Restore AF registers. For a read, A holds the byte read and the flags the success status.",
    "195": "Fetch the address to call.",
    "198": "and execute it.",
    "199": "Loop through all RAM banks.",
    "202": "Save B register.",
    "203": "RAM bank number 0 to 7. 128K mode, ROM 0, Screen 0.",
    "207": "Switch RAM bank.",
    "209": "Start of the current RAM bank.",
    "215": "All 16K of RAM bank.",
    "220": "Store $FF into RAM location.",
    "221": "Check RAM integrity.",
    "222": "Jump if RAM error found.",
    "225": "Store $00 into RAM location.",
    "226": "Check RAM integrity.",
    "227": "Jump if difference found.",
    "229": "Clear the whole page",
    "231": "Restore B registers.",
    "234": "Signal no communications in progress to the keypad.",
    "243": "BC=$FFFD, DE=$FFBF.",
    "246": "Select AY register 14.",
    "248": "BC=$BFFD.",
    "251": "Set AY register 14 to $FF. This will force a communications reset to the keypad if present.",
    "255": "[Spare byte]",
    "256": "BASIC interpreter parser.",
    "259": "'Line Run' entry point.",
    "262": "Transfer bytes to logical RAM bank 4.",
    "265": "Transfer bytes from logical RAM bank 4.",
    "268": "128K error routine.",
    "271": "Error routine. Called from patch at $3B3B in ROM 1.",
    "274": "'Statement Return' routine. Called from patch at $3B4D in ROM 1.",
    "277": "'Statement Next' routine. Called from patch at $3B5D in ROM 1.",
    "280": "Scan the keypad.",
    "283": "Play music strings.",
    "286": "MIDI byte output routine.",
    "289": "RS232 byte input routine.",
    "292": "RS232 text output routine.",
    "295": "RS232 byte output routine.",
    "298": "COPY (screen dump) routine.",
    "301": "Call keypad scan routine in ROM 1.",
    "302": "$3B01. [*BUG* - The address jumps into the middle of the keypad decode routine in ROM 1. It looks like it is supposed to deal with the keypad and so the most likely addresses are $3A42 (read keypad) or $39A0 (scan keypad). At $3C01 in ROM 1 is a vector jump command to $39A0 to scan the keypad and this is similar enough to the $3B01 to imply a simple error in one of the bytes. Credit: Paul Farrow]",
    "305": "Retrieve RAM bank number + 1 in B.",
    "306": "Indicate which RAM bank failed by",
    "307": "setting the border colour.",
    "309": "Infinite loop.",
    "311": "Complete setting up the sound chip registers.",
    "314": "Select AY register 7.",
    "317": "Disable AY-3-8912 sound channels.",
    "321": "Copy the various paging routines to the old printer buffer.",
    "324": "The source is in this ROM.",
    "327": "There are eighty eight bytes to copy.",
    "330": "Copy the block of bytes.",
    "332": "Load A with the code for the Z80 instruction 'RST $08'.",
    "334": "Insert into new System Variable RAMRST.",
    "337": "Set the stack pointer to last location of old buffer.",
    "342": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "345": "First free entry in RAM disk.",
    "368": "AHL=Free space in RAM disk.",
    "370": "$5B85. Current address.",
    "373": "$5B87. Current RAM bank.",
    "378": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "381": "Load HL with known last working byte - 65535.",
    "384": "Set physical RAM top to 65535.",
    "387": "Set DE to address of the last bitmap of 'U' in ROM 1.",
    "390": "There are 21 User Defined Graphics to copy.",
    "393": "Swap so destination is $FFFF.",
    "395": "(MAKE_ROOM+#000C) Calling this address (LDDR/RET) in the main ROM cleverly copies the 21 characters to the end of RAM.",
    "397": "Transfer DE to HL.",
    "398": "Increment to address first byte of UDG 'A'.",
    "399": "Update standard System Variable UDG.",
    "403": "Set values 0 for PIP and 64 for RASP.",
    "406": "Update standard System Variables RASP and PIP.",
    "410": "Update standard System Variable RAMTOP - the last byte of the BASIC system area. Any machine code and graphics above this address are protected from NEW.",
    "413": "(CHAR_SET-#0100) Set HL to where, in theory character zero would be.",
    "416": "Update standard System Variable CHARS.",
    "419": "Load HL with value of System Variable RAMTOP.",
    "422": "Address next location.",
    "423": "Set the Stack Pointer.",
    "424": "Select Interrupt Mode 1.",
    "426": "Set the IY register to address the standard System Variables and many of the new System Variables and even those of ZX Interface 1 in some cases.",
    "430": "FLAGS. Signal 128K mode. [This bit was unused and therefore never set by 48K BASIC]",
    "434": "With a stack and the IY register set, interrupts can be enabled.",
    "435": "Set HL to eleven, timing constant for 9600 baud.",
    "438": "Select default RS232 baud rate of 9600 baud.",
    "441": "Clear accumulator.",
    "442": "Indicate no byte waiting in RS232 receive buffer.",
    "445": "Set RS232 output column position to 0.",
    "448": "Indicate no control code parameters expected.",
    "451": "[*BUG* - Should write to RAM bank 7. Main RAM has now been corrupted. The value stored is subsequently never used. Credit: Geoff Wearmouth]",
    "454": "This is a remnant from the Spanish 128, which used this workspace variable to hold the location of the Screen Buffer, but it also suffered from this bug. In fact there was never a need to write to the value at this point since it is written again later during the initialisation process. [The 1985 Sinclair Research ESPAGNOL source code says that this instruction will write to the (previously cleared) main BASIC RAM during initialization but that a different page of RAM will be present during NEW. Stuff and Nonsense! Assemblers and other utilities present above RAMTOP will be corrupted by the BASIC NEW command since $FF24, and later $EC13, will be written to even if they are above RAMTOP.]",
    "457": "Default to a printer width of 80 columns.",
    "459": "Set RS232 printer output width.",
    "462": "Use 10 as the initial renumber line and increment.",
    "465": "Store the initial line number when renumbering.",
    "468": "Store the renumber line increment.",
    "471": "Address after the System Variables.",
    "474": "Set the default location for the channel area.",
    "477": "Point to Initial Channel Information in this ROM. This is similar to that in main ROM but channel 'P' has input and output addresses in the new $5Bxx region.",
    "480": "There are 21 bytes to copy.",
    "483": "Switch pointer so destination is CHANS.",
    "484": "Copy the block of bytes.",
    "487": "Decrement to point to channel information end-marker.",
    "488": "Set the default address of the terminator for the last DATA item.",
    "492": "Set the default address of the BASIC program area.",
    "495": "Set the default address of the BASIC variables area.",
    "498": "Insert the Variables end-marker.",
    "501": "Set the default address of the editing line area.",
    "504": "Insert a carriage return.",
    "507": "Insert the editing line end-marker.",
    "510": "Set the address of the workspace.",
    "513": "Set the address of the start of the calculator stack.",
    "516": "Set the address of the end of the calculator stack.",
    "519": "Attribute colour of black ink on white paper.",
    "521": "Set the permanent attribute colour.",
    "524": "Set the permanent attribute mask.",
    "527": "Set the default border colour.",
    "531": "Temporary P_FLAG. Clear the temporary store for P-FLAG. [*BUG* - Should write this to RAM bank 7. Main RAM has now been corrupted again. The effect of the bug can be seen by typing INVERSE 1: PRINT \"Hello\", followed by NEW, followed by PRINT \"World\", and will cause the second word to also be printed in inverse. Credit: Geoff Wearmouth]",
    "536": "Set the border white.",
    "538": "The values five and thirty five.",
    "541": "Set the default values for key delay and key repeat.",
    "544": "Set KSTATE+0 to $FF.",
    "547": "Set KSTATE+4 to $FF.",
    "550": "Address of the Initial Stream Data within this ROM (which is identical to that in main ROM).",
    "1417": "K channel output routine.",
    "1419": "K channel input routine.",
    "1421": "Channel identifier 'K'.",
    "1422": "S channel output routine.",
    "1424": "S channel input routine.",
    "1426": "Channel identifier 'S'.",
    "1427": "R channel output routine.",
    "1429": "R channel input routine.",
    "1431": "Channel identifier 'R'.",
    "1432": "P Channel output routine.",
    "1434": "P Channel input routine.",
    "1436": "Channel identifier 'P'.",
    "1437": "End marker.",
    "1438": "Stream $FD leads to channel 'K'.",
    "1440": "Stream $FE leads to channel 'S'.",
    "1442": "Stream $FF leads to channel 'R'.",
    "1444": "Stream $00 leads to channel 'K'.",
    "1446": "Stream $01 leads to channel 'K'.",
    "1448": "Stream $02 leads to channel 'S'.",
    "1450": "Stream $03 leads to channel 'P'.",
    "553": "Address of the system variable holding the channels attached to streams data.",
    "559": "Initialise the streams system variables.",
    "561": "FLAGS. Signal printer not is use.",
    "565": "ERR_NR. Signal no error.",
    "569": "DF_SZ. Set the lower screen size to two rows.",
    "576": "Attempt to display TV tuning test screen.",
    "577": "$3C04. Will return if BREAK is not being pressed.",
    "579": "Address of the Sinclair copyright message.",
    "582": "Display the copyright message.",
    "585": "DF_SZ. Set the lower screen size to two rows.",
    "589": "TV_FLAG. Signal lower screen will require clearing.",
    "596": "Use the temporary stack as the previous stack.",
    "599": "Use Workspace RAM configuration (physical RAM bank 7).",
    "602": "Set colours to black ink on white paper.",
    "604": "Temporary ATTR_T used by the 128 BASIC Editor.",
    "607": "Temporary ATTR_P used by the 128 BASIC Editor.",
    "610": "Initialise mode and cursor settings. IX will point at editing settings information.",
    "613": "Use Normal RAM Configuration (physical RAM bank 0).",
    "616": "Jump to show the Main menu.",
    "622": "Select BASIC/Calculator mode.",
    "624": "ERR_NR. Set to '0 OK' status.",
    "628": "DF_SZ. Reset the number of rows in the lower screen.",
    "632": "Return address should an error occur.",
    "635": "Stack it.",
    "636": "Save the stack pointer in ERR_SP.",
    "640": "Return address in ROM 0 after syntax checking.",
    "643": "Store it in SYNRET.",
    "646": "Point to start of typed in BASIC command.",
    "649": "Is the first character a function token, i.e. the start of a numerical expression?",
    "652": "Jump if so to evaluate it.",
    "655": "\"(\": Is the first character the start of an expression?",
    "657": "Jump if so to evaluate it.",
    "660": "\"-\": Is the first character the start of an expression?",
    "665": "\"+\": Is the first character the start of an expression?",
    "662": "Jump if so to evaluate it.",
    "667": "Jump if so to evaluate it.",
    "670": "Is text just a number or a numerical expression?",
    "673": "Jump if a numerical expression to evaluate it.",
    "676": "Use Workspace RAM configuration (physical RAM bank 7).",
    "679": "Fetch mode.",
    "682": "Use Normal RAM Configuration (physical RAM bank 0).",
    "685": "Calculator mode?",
    "687": "Jump if not to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "690": "Is it a single LET command?",
    "693": "Jump if so to parse and execute the BASIC command line, returning to $02BA (ROM 0).",
    "696": "Drop ONERR return address.",
    "698": "Test ERR_NR.",
    "702": "Jump ahead if no error.",
    "705": "Point to start of editing area.",
    "704": "Simply return if an error.",
    "708": "Store in CH_ADD.",
    "712": "Call E_LINE_NO in ROM 1 to read the line number into editing area.",
    "716": "Jump ahead if there was a line number.",
    "719": "Get character.",
    "720": "End of the line reached, i.e. no BASIC statement?",
    "722": "Return if so.",
    "723": "Clear screen if it requires it.",
    "726": "TVFLAG. Clear lower screen?",
    "730": "Jump ahead if no need to clear lower screen.",
    "735": "TVFLAG. Signal to clear lower screen.",
    "739": "Use Workspace RAM configuration (physical RAM bank 7).",
    "742": "Editor flags.",
    "745": "Using lower screen area for editing?",
    "747": "Jump ahead if so.",
    "750": "Fetch the mode.",
    "751": "In Edit Menu mode?",
    "753": "If so then clear lower editing area display.",
    "756": "Use Normal RAM Configuration (physical RAM bank 0).",
    "762": "Signal mode has not changed.",
    "764": "25.",
    "766": "S_POSN+1. Subtract the current print row position.",
    "769": "Set the number of scrolls.",
    "772": "FLAGS. Not syntax checking.",
    "776": "NSPPC. Set line to be jumped to as line 1.",
    "780": "The end of GO SUB stack marker.",
    "783": "Place it on the stack.",
    "784": "The return address should an error occur.",
    "787": "Place it on the stack.",
    "788": "Store error routine address.",
    "792": "Address of error handler routine in ROM 0.",
    "795": "Store it in SYNRET.",
    "798": "Jump ahead to the main parser routine to execute the line.",
    "805": "Reset SP to top of memory map.",
    "809": "Use the temporary stack as the previous stack.",
    "812": "Trap error conditions where interrupts are disabled.",
    "813": "FLAGS. Signal no new key.",
    "820": "Editing RAM disk catalogue?",
    "822": "Jump if not.",
    "824": "Use Workspace RAM configuration (physical RAM bank 7).",
    "831": "Catalogue entry size.",
    "834": "Remove last entry.",
    "836": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "839": "Use Normal RAM Configuration (physical RAM bank 0).",
    "842": "Fetch error number from ERR_NR.",
    "845": "Increment to give true error code.",
    "846": "Save the error code.",
    "850": "FLAGX. Ensure not INPUT mode.",
    "853": "X_PTR_hi. Clear to suppress error '?' marker.",
    "856": "Clear to signal no defined function is currently being evaluated.",
    "859": "[Could have saved 2 bytes by using INC L].",
    "862": "STRMS+$0006. Ensure STRMS-00 specifies the keyboard.",
    "865": "Clears editing area and areas after it.",
    "868": "Clears editing area and areas after it.",
    "873": "Clear lower editing screen.",
    "875": "TVFLAG. Signal lower screen requires clearing.",
    "879": "Retrieve error code.",
    "880": "Store error code in B.",
    "881": "Is it a numeric error code (1-9), i.e. suitable for immediate display?",
    "883": "If so jump ahead to display it.",
    "885": "Is it one of the standard errors (A-R)?",
    "887": "If so jump ahead to convert it into an upper case letter.",
    "889": "Otherwise convert it into a lower case letter.",
    "891": "Jump ahead to display it. [Could have saved 2 bytes by using ADD A,$0C instead of these two instructions]",
    "893": "Increase code to point to upper case letters.",
    "896": "Display the character held in the A register.",
    "898": "Display a space.",
    "901": "Retrieve the error code.",
    "902": "Is it one of the standard errors (A-R)?",
    "904": "Jump if an standard error message (A-R).",
    "906": "A=Code $00 - $0E.",
    "915": "Find address in error message vector table.",
    "910": "Pass code to BC.",
    "918": "DE=Address of message to print.",
    "919": "Print error message.",
    "930": "Select the first message \", \" (a 'comma' and a 'space').",
    "922": "Jump ahead.",
    "924": "Position of the error messages in ROM 1.",
    "928": "Call message printing routine.",
    "931": "$1536. Message base address in ROM 1.",
    "935": "Print a comma followed by a space.",
    "937": "Fetch current line number.",
    "942": "Print the line number.",
    "944": "Print ':'.",
    "947": "SUBPPC. Fetch current statement number.",
    "953": "Print the statement number.",
    "956": "Clear editing and workspace areas.",
    "958": "Fetch the error code.",
    "962": "Jump ahead for \"0 OK\".",
    "966": "Jump for \"A Invalid argument\", thereby advancing to the next statement.",
    "970": "Jump unless \"M Ramtop no good\".",
    "972": "SUBPPC. Advance to the next statement.",
    "978": "Continue statement number.",
    "981": "Next statement number.",
    "984": "Is there a statement number?",
    "986": "Jump if so.",
    "988": "HL=SUBPPC. The current statement number.",
    "989": "Copy SUBPPC and PPC to OSPPC and OLDPPC, for use by CONTINUE.",
    "991": "NSPPC. Signal no current statement number.",
    "995": "FLAGS. Select K-Mode.",
    "1002": "Select 128 Editor mode.",
    "1004": "Jump ahead to return control to the Editor.",
    "1007": "Error code 'G - No room for line'.",
    "1012": "Jump to print the error code.",
    "1015": "Store the line as the current line number with the program cursor.",
    "1019": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1022": "[This test could have been performed before paging in bank 7 and hence could have benefited from a slight speed improvement.",
    "1023": "The test is redundant since BC holds a non-zero line number]",
    "1024": "Jump if no line number",
    "1026": "Current edit line number. [Redundant instruction - Line number has already been stored]",
    "1030": "Temporary E_PPC used by BASIC Editor.",
    "1034": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1037": "Point to the next character in the BASIC line.",
    "1041": "Address of error handler routine should there be no room for the line.",
    "1044": "Stack it.",
    "1049": "HL=Length of BASIC line.",
    "1051": "Stack it.",
    "1053": "Transfer edit line number to HL.",
    "1055": "Returns address of the line in HL.",
    "1057": "Jump if the line does not exist.",
    "1060": "Find the address of the next line.",
    "1063": "Delete the line.",
    "1065": "BC=Length of the BASIC line.",
    "1067": "Is it 1, i.e. just an 'Enter' character, and hence only",
    "1068": "a line number was entered?",
    "1069": "Jump if there is a BASIC statement.",
    "1071": "Use Workspace RAM configuration (physical RAM bank 7).",
    "1074": "Save the address of the line.",
    "1075": "Fetch current edit line number.",
    "1078": "Find closest line number (or $0000 if no line).",
    "1081": "Store current edit line number. Effectively refresh E_PPC.",
    "1084": "HL=Address of the line.",
    "1085": "Use Normal RAM Configuration (physical RAM bank 0).",
    "1088": "Jump ahead to exit.",
    "1090": "BC=Length of the BASIC line. Stack it.",
    "1094": "BC=BC+4. Allow for line number and length bytes.",
    "1095": "Point to before the current line, i.e. the location to insert bytes at.",
    "1096": "Get start address of the BASIC program.",
    "1100": "Stack it.",
    "1102": "Insert BC spaces at address HL.",
    "1104": "HL=Start address of BASIC program.",
    "1105": "Save start address of BASIC program.",
    "1108": "BC=Length of the BASIC line.",
    "1110": "Point to the first location of the newly created space.",
    "1111": "Address of end of the BASIC line in the workspace.",
    "1115": "Skip over the newline and terminator bytes.",
    "1116": "Copy the BASIC line from the workspace into the program area.",
    "1118": "Current edit line number.",
    "1122": "BC=Length of BASIC line.",
    "1123": "Store the line length.",
    "1127": "DE=line number.",
    "1129": "Store the line number.",
    "1130": "Drop item (address of error handler routine).",
    "1131": "Exit with HL=Address of the line.",
    "1132": "Error report 'a'.",
    "1134": "Error report 'b'.",
    "1136": "Error report 'c'.",
    "1138": "Error report 'd'.",
    "1140": "Error report 'e'.",
    "1142": "Error report 'f'.",
    "1144": "Error report 'g'.",
    "1146": "Error report 'h'.",
    "1148": "Error report 'i'.",
    "1150": "Error report 'j'.",
    "1152": "Error report 'k'.",
    "1154": "Error report 'l'.",
    "1156": "Error report 'm'.",
    "1158": "Error report 'n'.",
    "1160": "Error report 'o'.",
    "1162": "Error report 'p'.",
    "1164": "\"MERGE error\"",
    "1175": "\"Wrong file type\"",
    "1190": "\"CODE error\"",
    "1200": "\"Too many brackets\"",
    "1217": "\"File already exists\"",
    "1236": "\"Invalid name\"",
    "1248": "\"File does not exist\"",
    "1267": "\"Invalid device\"",
    "1281": "\"Invalid baud rate\"",
    "1298": "\"Invalid note name\"",
    "1315": "\"Number too big\"",
    "1329": "\"Note out of range\" ",
    "1346": "\"Out of range\"",
    "1358": "\"Too many tied notes\"",
    "1377": "\"(c) 1986 Sinclair Research Ltd\"",
    "1405": "Fetch next byte.",
    "1406": "Mask off top bit.",
    "1408": "Save address of current message byte.",
    "1409": "Print character.",
    "1410": "Restore message byte pointer.",
    "1413": "Carry flag will be set if byte is $FF.",
    "1414": "Else print next character.",
    "1452": "Point to the error byte.",
    "1456": "ROM 0, Screen 0, Bank 0, 128 mode.",
    "1457": "Ensure interrupts disable whilst paging.",
    "1458": "Store new state in BANK_M.",
    "1461": "Switch to ROM 0.",
    "1464": "Restore SP from ERR_SP.",
    "1468": "Fetch the error number.",
    "1469": "Store the error number.",
    "1473": "[*BUG* - This should be $1D. As such, error code 'a' will be diverted to ROM 1 for handling. Credit: Paul Farrow]",
    "1478": "Call the error handler routine in ROM 1.",
    "1481": "Store in ERR_NR.",
    "1487": "Set up the address of the character after the '?' marker.",
    "1491": "Set the calculator stack.",
    "1493": "Return to the error routine.",
    "1494": "Read keyboard row B - SPACE.",
    "1498": "Extract the SPACE key.",
    "1499": "Return if SPACE not pressed.",
    "1500": "Read keyboard row CAPS SHIFT - V.",
    "1504": "Extract the CAPS SHIFT key.",
    "1505": "Return if CAPS SHIFT not pressed.",
    "1506": "Produce an error.",
    "1509": "\"L Break into program\"",
    "1510": "Enabled interrupts.",
    "1511": "Save AF registers.",
    "1512": "Address of the RS232 exit routine held in RAM.",
    "1515": "Stack it.",
    "1516": "TVFLAG. Indicate not automatic listing.",
    "1520": "Save the input/output routine address.",
    "1521": "Fetch location of error handler routine from ERR_SP.",
    "1526": "DE=Address of error handler routine.",
    "1528": "ED_ERROR in ROM 1.",
    "1533": "Jump if error handler address is different, i.e. due to INKEY$# or PRINT#.",
    "1535": "Retrieve the input/output routine address.",
    "1540": "Discard the error handler routine address.",
    "1541": "Fetch the original address of ERR_SP (this was stacked at the beginning of the INPUT routine in ROM 1).",
    "1546": "Save the input/output routine address.",
    "1547": "Address to return to.",
    "1550": "Stack the address.",
    "1551": "Jump to the RS232 input/output routine.",
    "1552": "Jump if a character was received.",
    "1554": "Jump if a character was not received.",
    "1556": "Produce an error \"8 End of file\".",
    "1560": "Retrieve the input routine address.",
    "1561": "Jump back to await another character.",
    "1563": "Is it a carriage return?",
    "1567": "Fetch the return address.",
    "1572": "Insert the character into the INPUT line.",
    "1575": "Restore the return address.",
    "1578": "Retrieve the input routine address.",
    "1579": "Jump back to await another character.",
    "1581": "Discard the input routine address.",
    "1582": "Fetch current paging configuration.",
    "1585": "Select ROM 1.",
    "1587": "Stack the required paging configuration.",
    "1588": "Exit",
    "1591": "Retrieve the input/output routine address.",
    "1595": "Stack the return address.",
    "1596": "Jump to input or output routine.",
    "1597": "Return if a character was received.",
    "1598": "Return if a character was not received or was written.",
    "1599": "Produce error report \"8 End of file\".",
    "1601": "[Could just do RST $18]",
    "1348": "Get an expression.",
    "1604": "Get an expression.",
    "1607": "FLAGS.",
    "1611": "Jump ahead if syntax checking.",
    "1613": "Fetch the expression.",
    "1619": "Jump ahead if string is 1 character long.",
    "1621": "Produce error report.",
    "1624": "\"i Invalid device\".",
    "1625": "Get character.",
    "1626": "Convert to upper case.",
    "1628": "\"P\". Is it channel 'P'?",
    "1630": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1633": "Next character to be interpreted.",
    "1637": "Next character must be ';'.",
    "1639": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1642": "Skip past the ';' character.",
    "1645": "Get a numeric expression from the line.",
    "1648": "FLAGS. Checking syntax mode?",
    "1652": "Jump ahead if so.",
    "1654": "Get the result as an integer.",
    "1657": "Store the result temporarily for use later.",
    "1661": "[Could just do RST $18]",
    "1662": "Get the next character in the BASIC line.",
    "1664": "It should be ENTER.",
    "1666": "Jump ahead if it is.",
    "1668": "Or the character is allowed to be ':'.",
    "1670": "Jump if not to produce error report \"C Nonsense in BASIC\".",
    "1673": "Check for end of line.",
    "1676": "Get the baud rate saved earlier.",
    "1681": "Is it zero?",
    "1682": "Jump if not, i.e. a numeric value was specified.",
    "1684": "Produce error report.",
    "1687": "\"j invalid baud rate\"",
    "1720": "Baud=50.",
    "1724": "Baud=110.",
    "1728": "Baud=300.",
    "1732": "Baud=600.",
    "1736": "Baud=1200.",
    "1740": "Baud=2400.",
    "1744": "Baud=4800.",
    "1748": "Baud=9600.",
    "1688": "Table of supported baud rates.",
    "1695": "HL=Supported baud rate value.",
    "1697": "Reached the last baud rate value in the table?",
    "1699": "Jump is so to use a default baud rate of 9600.",
    "1702": "Table entry matches or is higher than requested baud rate?",
    "1704": "Jump ahead if so to use this baud rate.",
    "1707": "Skip past the timing constant value",
    "1708": "for this baud rate entry.",
    "1711": "HL points to timing value for the baud rate.",
    "1714": "DE=Timing value for the baud rate.",
    "1715": "Store new value in system variable BAUD.",
    "1752": "SERFL holds second char that can be received",
    "1755": "Is the second-character received flag set?",
    "1756": "i.e. have we already received data?",
    "1757": "Jump ahead if not.",
    "1759": "Otherwise clear the flag",
    "1762": "and return the data which we received earlier.",
    "1763": "Set carry flag to indicate success",
    "1765": "Check the BREAK key, and produce error message if it is being pressed.",
    "1768": "Ensure interrupts are disabled to achieve accurate timing.",
    "1770": "Fetch the baud rate timing constant.",
    "1779": "HL=BAUD/2. So that will sync to half way point in each bit.",
    "1781": "[Redundant byte]",
    "1782": "Waiting time for start bit.",
    "1784": "Save B.",
    "1794": "Selects register 14, port I/O of AY-3-8912.",
    "1796": "Read the current state of the I/O lines.",
    "1798": "%11110000. Default all input lines to 1.",
    "1800": "%11111011. Force CTS line to 0.",
    "1802": "B=$BF.",
    "1803": "Make CTS (Clear To Send) low to indicate ready to receive.",
    "1805": "Store status of other I/O lines.",
    "1807": "Read the input line.",
    "1809": "%10000000. Test TXD (input) line.",
    "1811": "Jump if START BIT found.",
    "1813": "Fetch timeout counter",
    "1814": "and decrement it.",
    "1815": "Store it.",
    "1816": "Continue to wait for start bit if not timed out.",
    "1818": "Reset carry flag to indicate no byte read.",
    "1819": "Save the failure flag.",
    "1820": "Timed out waiting for START BIT.",
    "1822": "Second test of START BIT - it should still be 0.",
    "1824": "Test TXD (input) line.",
    "1826": "Jump back if it is no longer 0.",
    "1828": "Third test of START BIT - it should still be 0.",
    "1830": "Test TXD (input) line.",
    "1832": "Jump back if it is no longer 0.",
    "1838": "Preload A with the START BIT. It forms a shift counter used to count",
    "1840": "the number of bits to read in.",
    "1841": "HL=1.5*(BAUD).",
    "1842": "(4) Fine tune the following delay.",
    "1846": "(6) Delay for 26*BAUD.",
    "1847": "(4)",
    "1848": "(4)",
    "1849": "(12) Jump back to until delay completed.",
    "1851": "Read a bit.",
    "1853": "Test TXD (input) line.",
    "1855": "Jump if a 0 received.",
    "1867": "Fetch the bit counter.",
    "1858": "Fetch the bit counter.",
    "1859": "Set carry flag to indicate received a 1.",
    "1860": "Shift received bit into the byte (C->76543210->C).",
    "1861": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1863": "Save the bit counter.",
    "1864": "Jump back to read the next bit.",
    "1868": "Clear carry flag to indicate received a 0.",
    "1869": "Shift received bit into the byte (C->76543210->C).",
    "1870": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1872": "Save the bit counter.",
    "1873": "Jump back to read next bit.",
    "1876": "Signal success.",
    "1877": "Push success flag.",
    "1880": "A=%1111x1xx. Force CTS line to 1.",
    "1882": "B=$BF.",
    "1883": "Make CTS (Clear To Send) high to indicate not ready to receive.",
    "1887": "HL=(BAUD).",
    "1892": "HL=(BAUD)-7.",
    "1894": "Delay for the stop bit.",
    "1897": "Jump back until delay completed.",
    "1899": "HL will be $0000.",
    "1902": "DE=(BAUD).",
    "1904": "HL=3*(BAUD). This is how long to wait for the next start bit.",
    "1905": "Read the input line.",
    "1907": "%10000000. Test TXD (input) line.",
    "1909": "Jump if START BIT found.",
    "1911": "Decrement timeout counter.",
    "1914": "Jump back looping for a start bit until a timeout occurs.",
    "1916": "Return status of first byte read attempt - carry flag reset for no byte received or",
    "1917": "carry flag set and A holds the received byte.",
    "1919": "Second test of START BIT - it should still be 0.",
    "1921": "Test TXD (input) line.",
    "1923": "Jump back if it is no longer 0.",
    "1925": "Third test of START BIT - it should still be 0.",
    "1927": "Test TXD (input) line.",
    "1929": "Jump back if it is no longer 0.",
    "1932": "HL=(BAUD).",
    "1938": "HL=(BAUD)/2.",
    "1941": "HL=(BAUD)/2 - 2.",
    "1946": "Preload A with the START BIT. It forms a shift counter used to count",
    "1948": "the number of bits to read in.",
    "1949": "Fine tune the following delay.",
    "1953": "HL=1.5*(BAUD).",
    "1954": "Delay for 26*(BAUD).",
    "1957": "Jump back to until delay completed.",
    "1959": "Read a bit.",
    "1961": "Test TXD (input) line.",
    "1963": "Jump if a 0 received.",
    "1966": "Fetch the bit counter.",
    "1967": "Set carry flag to indicate received a 1.",
    "1968": "Shift received bit into the byte (C->76543210->C).",
    "1969": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1971": "Save the bit counter.",
    "1972": "Jump back to read the next bit.",
    "1975": "Fetch the bit counter.",
    "1976": "Clear carry flag to indicate received a 0.",
    "1977": "Shift received bit into the byte (C->76543210->C).",
    "1978": "Jump if START BIT has been shifted out indicating all data bits have been received.",
    "1980": "Save the bit counter.",
    "1981": "Jump back to read next bit.",
    "1987": "Set the flag indicating a second byte is in the buffer.",
    "1990": "Store the second byte read in the buffer.",
    "1991": "Return the first byte.",
    "1992": "Re-enable interrupts.",
    "1994": "Save the character to print.",
    "1995": "Number of parameters expected.",
    "1999": "Jump if no parameters.",
    "2001": "Ignore the parameter.",
    "2005": "Jump ahead if we have not processed all parameters.",
    "2007": "Retrieve character to print.",
    "2008": "Jump ahead to continue.",
    "2011": "Retrieve character to print.",
    "2012": "TVDATA+1. Store it for use later.",
    "2016": "Retrieve character to print.",
    "2017": "Test against code for 'SPECTRUM'.",
    "2019": "Jump ahead if not a token.",
    "2021": "Save RETADDR temporarily.",
    "2026": "Print tokens via call to ROM 1 routine PO-T&UDG.",
    "2029": "Restore the original contents of RETADDR.",
    "2037": "Suppress printing a leading space.",
    "2039": "Is character to output a space?",
    "2043": "Signal leading space required.",
    "2041": "Jump ahead if not a space.",
    "2045": "Compare against copyright symbol.",
    "2047": "Jump ahead if not a graphic or UDG character.",
    "2049": "\"?\". Print a '?' for all graphic and UDG characters.",
    "2051": "Is it a control character?",
    "2053": "Jump ahead if so.",
    "2055": "Save the character to print.",
    "2056": "Point to the column number.",
    "2059": "Increment the column number.",
    "2060": "Fetch the number of columns.",
    "2064": "Jump if end of row not reached.",
    "2066": "Print a carriage return and line feed.",
    "2071": "Set the print position to column 1.",
    "2074": "Retrieve character to print.",
    "2075": "Jump ahead to print the character.",
    "2078": "Is it a carriage return?",
    "2080": "Jump ahead if not.",
    "2083": "Set the print position back to column 0.",
    "2088": "Print a carriage return.",
    "2093": "Print a line feed.",
    "2096": "Is it a comma?",
    "2098": "Jump ahead if not.",
    "2100": "Fetch the column position.",
    "2104": "Will count number of columns to move across to reach next comma position.",
    "2106": "Increment column counter.",
    "2107": "Increment column position.",
    "2109": "End of row reached?",
    "2110": "Jump if so.",
    "2114": "Jump if column 8, 16, 24 or 32 reached.",
    "2116": "Column position greater so subtract another 8.",
    "2118": "Jump back and increment column position again.",
    "2120": "Save column counter in E.",
    "2123": "Output a space via a recursive call.",
    "2126": "Retrieve column counter to E.",
    "2127": "More spaces to output?",
    "2128": "Return if no more to output.",
    "2129": "Repeat for the next space to output.",
    "2131": "Is it AT?",
    "2133": "Jump ahead to handle AT.",
    "2135": "Is it TAB?",
    "2137": "Jump ahead to handle TAB.",
    "2139": "Check for INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2141": "Ignore if not one of these.",
    "2142": "Jump ahead to handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.",
    "2144": "Store the control code for use later, $16 (AT) or $17 (TAB).",
    "2147": "Two parameters expected (even for TAB).",
    "2152": "Return with zero flag set.",
    "2153": "Store the control code for use later.",
    "2156": "Two parameters expected. [*BUG* - Should be 1 parameter. 'LPRINT INK 4' will produce error report 'C Nonsense in BASIC'. Credit: Toni Baker, ZX Computing Monthly].",
    "2161": "[*BUG* - Should return with the carry flag reset and the zero flag set. It causes a statement such as 'LPRINT INK 1;' to produce error report '8 End of file'. It is due to the main RS232 processing loop using the state of the flags to determine the success/failure response of the RS232 output routine. Credit: Ian Collier (+3), Andrew Owen (128)] [The bug can be fixed by inserting a XOR A instruction before the RET instruction. Credit: Paul Farrow]",
    "2162": "D=Character to print.",
    "2163": "Fetch the control code.",
    "2166": "Is it AT?",
    "2170": "Is it TAB?",
    "2168": "Jump ahead to handle AT parameter.",
    "2172": "Disable interrupts to ensure accurate timing.",
    "2173": "Ignore if not TAB.",
    "2174": "TV_DATA+1. Fetch the saved parameter.",
    "2177": "Fetch parameter to D.",
    "2181": "Reached end of row?",
    "2182": "Jump ahead if so.",
    "2184": "Jump ahead if before end of row.",
    "2186": "(WIDTH).",
    "2187": "TAB/AT column position.",
    "2188": "TAB/AT position - WIDTH.",
    "2189": "The new required column position.",
    "2190": "Handle the new TAB/AT position.",
    "2192": "Fetch the desired column number.",
    "2194": "Jump to output a carriage return if column 0 required.",
    "2197": "Fetch the current column position.",
    "2200": "Compare against desired column position.",
    "2201": "Done if reached requested column.",
    "2202": "Save the number of spaces to output.",
    "2205": "Output a space via a recursive call.",
    "2208": "Retrieve number of spaces to output.",
    "2209": "Keep outputting spaces until desired column reached.",
    "2211": "Save the byte to send.",
    "2221": "Select AY register 14 to control the RS232 port.",
    "2223": "Check the BREAK key, and produce error message if it is being pressed.",
    "2226": "Read status of data register.",
    "2228": "%01000000. Test the DTR line.",
    "2230": "Jump back until device is ready for data.",
    "2232": "HL=Baud rate timing constant.",
    "2239": "DE=(BAUD)-2.",
    "2242": "Retrieve the byte to send.",
    "2243": "Invert the bits of the byte (RS232 logic is inverted).",
    "2244": "Carry is used to send START BIT.",
    "2245": "B=Number of bits to send (1 start + 8 data + 2 stop).",
    "2247": "Disable interrupts to ensure accurate timing.",
    "2248": "Save the number of bits to send.",
    "2249": "Save the data bits.",
    "2253": "HL=(BAUD)-2.",
    "2254": "AY-3-8912 data register.",
    "2257": "Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).",
    "2260": "Clear the RXD (out) line.",
    "2262": "Send out a 0 (high level).",
    "2264": "Jump ahead to continue with next bit.",
    "2266": "Set the RXD (out) line.",
    "2268": "Send out a 1 (low level).",
    "2270": "Jump ahead to continue with next bit. [We use theis unnecessary looking JR for timing]",
    "2272": "(6) Delay 26*BAUD cycles.",
    "2273": "(4)",
    "2274": "(4)",
    "2275": "(12) Jump back until delay is completed.",
    "2277": "(4) Fine tune the timing.",
    "2278": "(4)",
    "2279": "(4)",
    "2280": "Retrieve the data bits to send.",
    "2281": "Retrieve the number of bits left to send.",
    "2282": "Clear carry flag.",
    "2283": "Shift the next bit to send into the carry flag.",
    "2284": "Jump back to send next bit until all bits sent.",
    "2286": "Re-enable interrupts.",
    "2287": "Return with carry and zero flags reset.",
    "2288": "Half row counter.",
    "2291": "Set the half row counter to 43 half rows (will output 44 half rows in total).",
    "2293": "Point to printer configuration data (7/72 inch line spacing, double density bit graphics).",
    "2425": "6 characters follow.",
    "2426": "ESC '1'     - 7/72 inch line spacing.",
    "2428": "ESC 'L' 0 3 - Double density (768 bytes per row).",
    "2432": "1 character follows.",
    "2433": "Line feed.",
    "2434": "2 characters follow.",
    "2435": "ESC '2' - 1/6 inch line spacing.",
    "2296": "Send the configuration data to printer.",
    "2299": "Output a half row, at double height.",
    "2302": "Table holds a line feed only.",
    "2305": "Send a line feed to printer.",
    "2308": "The half row counter is tested to see if it is zero",
    "2311": "and if so then the line spacing is reset to its",
    "2312": "original value.",
    "2313": "Jump if done, resetting printer line spacing.",
    "2315": "Decrement half row counter.",
    "2316": "Repeat for the next half row.",
    "2318": "Point to printer configuration data (1/6 inch line spacing).",
    "2321": "Send the configuration data to printer.",
    "2324": "[Could have saved 1 byte by using JP $095F (ROM 0)]",
    "2325": "Pixel column counter.",
    "2328": "Set pixel column counter to 255 pixels.",
    "2330": "Output a column of pixels, at double height.",
    "2333": "Pixel column counter.",
    "2337": "Check if all pixels in this row have been output.",
    "2338": "Return if so.",
    "2339": "Decrement pixel column counter.",
    "2340": "Repeat for all pixels in this row.",
    "2342": "D=%11000000. Used to hold the double height pixel.",
    "2345": "C=Pixel column counter, B=Half row counter.",
    "2350": "B=2xB+1",
    "2353": "B=4xB+3. The pixel row coordinate.",
    "2355": "Pixel column counter.",
    "2357": "C=255-C. The pixel column coordinate.",
    "2358": "Clear A. Used to generate double height nibble of pixels to output.",
    "2361": "Save registers.",
    "2362": "Test whether pixel (B,C) is set",
    "2366": "Restore registers.",
    "2367": "Set double height pixel = 0.",
    "2369": "Jump if pixel is reset.",
    "2371": "The double height pixel to output (%11000000, %00110000, %00001100 or %00000011).",
    "2375": "Decrement half row coordinate.",
    "2373": "Add the double height pixel value to the byte to output.",
    "2378": "Create next double height pixel value (%00110000, %00001100 or %00000011).",
    "2382": "Repeat for all four pixels in the half row.",
    "2385": "Unload the stack.",
    "2387": "Send double height nibble of pixels output 3 times.",
    "2391": "Send byte to RS232 port.",
    "2399": "Get number of bytes to send.",
    "2400": "Point to the data to send.",
    "2401": "Retrieve value.",
    "2404": "Send byte to RS232 port.",
    "2409": "Point to next data byte to send.",
    "2410": "Repeat for all bytes.",
    "2414": "Get address of (B,C) pixel into HL and pixel position within byte into A.",
    "2416": "B=Pixel position within byte (0-7).",
    "2418": "Pixel mask.",
    "2419": "Carry flag holds bit to be rotated into the mask.",
    "2420": "Shift the mask bit into the required bit position.",
    "2423": "Isolate this pixel from A.",
    "2437": "Disable interrupts to ensure accurate timing.",
    "2445": "Calculate HL=$003C + ($0037 * B).",
    "2449": "BC=Space required (maximum = $01F4).",
    "2451": "Make BC bytes of space in the workspace.",
    "2453": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2455": "IY=Points at first new byte - the command data block.",
    "2458": "IX=Points at last new byte - byte after all channel information blocks.",
    "2460": "Initial channel bitmap with value meaning 'zero strings'",
    "2464": "$-37 ($37 bytes is the size of a play channel string information block).",
    "2467": "IX points to start of space for the last channel.",
    "2469": "Default octave is 5.",
    "2473": "No MIDI channel assigned.",
    "2477": "Default volume is 15.",
    "2481": "Default note duration.",
    "2485": "Count of the number of tied notes.",
    "2489": "Signal not to repeat the string indefinitely.",
    "2493": "No opening bracket nesting level.",
    "2497": "No closing bracket nesting level.",
    "2501": "Return address for closing bracket nesting level 0.",
    "2505": "[No need to initialise this since it is written to before it is ever tested]",
    "2510": "Get the details of the string from the stack.",
    "2512": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "2513": "Store the current position within in the string, i.e. the beginning of it.",
    "2519": "Store the return position within the string for a closing bracket,",
    "2522": "which is initially the start of the string in case a single closing bracket is found.",
    "2525": "HL=Points to start of string. BC=Length of string.",
    "2526": "HL=Points to address of byte after the string.",
    "2527": "Store the address of the character just",
    "2530": "after the string.",
    "2533": "B=String index number (range 1 to 8).",
    "2534": "Save it on the stack again.",
    "2535": "Reduce the index so it ranges from 0 to 7.",
    "2539": "BC=String index*2.",
    "2543": "HL=Address of the command data block.",
    "2544": "Skip 8 channel data pointer words.",
    "2547": "BC=Address of current channel information block.",
    "2548": "Store the pointer to the channel information block.",
    "2551": "Clear the carry flag.",
    "2552": "Rotate one zero-bit into the least significant bit of the channel bitmap. This initially holds $FF but once this loop is over, this byte has a zero bit for each string parameter of the PLAY command.",
    "2556": "B=Current string index.",
    "2557": "Decrement string index so it ranges from 0 to 7.",
    "2558": "Save it for future use on the next iteration.",
    "2559": "Store the channel number.",
    "2562": "Jump back while more channel strings to process.",
    "2564": "Drop item left on the stack.",
    "2565": "Set the initial tempo timing value.",
    "2569": "Corresponds to a 'T' command value of 120, and gives two crotchets per second.",
    "2575": "HL=Points to the command data block.",
    "2580": "DE=Address to store RAM routine.",
    "2581": "HL=Address of the RAM routine bytes.",
    "2587": "Copy the calculator routine to RAM.",
    "2589": "Register 7 - Mixer.",
    "2591": "I/O ports are inputs, noise output off, tone output on.",
    "2593": "Write to sound generator register.",
    "2596": "Register 11 - Envelope Period (Fine).",
    "2598": "Set period to maximum.",
    "2600": "Write to sound generator register.",
    "2603": "Register 12 - Envelope Period (Coarse).",
    "2604": "Write to sound generator register.",
    "2607": "Jump ahead to continue. [Could have saved these 2 bytes by having the code at $0A7D (ROM 0) immediately follow]",
    "2609": "Invoke the floating point calculator.",
    "2610": "x, 10",
    "2611": "10, x",
    "2612": "10/x",
    "2619": "(10/x)/7.33e-6",
    "2627": "Return with carry flag set if SPACE not pressed.",
    "2633": "Return with carry flag set if CAPS not pressed.",
    "2634": "Offset to the channel data block duration pointers table.",
    "2637": "Jump ahead to continue.",
    "2639": "Offset to the channel data block pointers table.",
    "2644": "HL=Point to the command data block.",
    "2645": "Point to the desired channel pointers table.",
    "2649": "Store the start address of channels pointer table.",
    "2652": "Fetch the channel bitmap.",
    "2655": "Initialise the working copy.",
    "2658": "Channel selector. Set the shift register to indicate the first channel.",
    "2665": "Fetch the address of the current channel data block.",
    "2667": "Return it in IX.",
    "2670": "The address of current channel data pointer.",
    "2677": "Advance to the next channel data pointer.",
    "2681": "The address of new channel data pointer.",
    "2685": "Select channel data block pointers.",
    "2688": "Working copy of channel bitmap. Test if next string present.",
    "2692": "Jump ahead if there is no string for this channel.",
    "2694": "Get address of channel data block for the current string into IX.",
    "2697": "Find the first note to play for this channel from its play string.",
    "2700": "Have all channels been processed?",
    "2704": "Jump ahead if so.",
    "2706": "Advance to the next channel data block pointer.",
    "2709": "Jump back to process the next channel.",
    "2711": "Find smallest duration length of the current notes across all channels.",
    "2714": "Save the smallest duration length.",
    "2715": "Play a note on each channel.",
    "2718": "DE=The smallest duration length.",
    "2719": "Channel bitmap.",
    "2722": "Is there anything to play?",
    "2724": "Jump if there is.",
    "2726": "Turn off all sound and restore IY.",
    "2729": "Re-enable interrupts.",
    "2730": "End of play command.",
    "2731": "DE=Smallest channel duration length, i.e. duration until the next channel state change.",
    "2732": "Perform a wait.",
    "2735": "Play a note on each channel and update the channel duration lengths.",
    "2738": "Find smallest duration length of the current notes across all channels.",
    "2741": "Jump back to see if there is more to process.",
    "2743": "\"HZYXWUVMT)(NO!\"",
    "2757": "Get the current character from the play string for this channel.",
    "2760": "Return if no more characters.",
    "2761": "Increment the low byte of the string pointer.",
    "2764": "Return if it has not overflowed.",
    "2765": "Else increment the high byte of the string pointer.",
    "2768": "Returns with carry flag reset.",
    "2769": "Save HL.",
    "2770": "Default is for a 'natural' note, i.e. no adjustment.",
    "2772": "Get the current character from the PLAY string, and advance the position pointer.",
    "2775": "Jump if at the end of the string.",
    "2777": "\"&\". Is it a rest?",
    "2779": "Jump ahead if not.",
    "2781": "Signal that it is a rest.",
    "2783": "Restore HL.",
    "2785": "Fetch the channel selector.",
    "2788": "Clear the channel flag for this string.",
    "2791": "Store the new channel bitmap.",
    "2794": "Jump back to return.",
    "2796": "\"#\". Is it a sharpen?",
    "2798": "Jump ahead if not.",
    "2800": "Increment by a semitone.",
    "2801": "Jump back to get the next character.",
    "2803": "\"$\". Is it a flatten?",
    "2805": "Jump ahead if not.",
    "2807": "Decrement by a semitone.",
    "2808": "Jump back to get the next character.",
    "2810": "Is it a lower case letter?",
    "2812": "Jump ahead if lower case.",
    "2814": "It is an upper case letter so",
    "2815": "increase an octave",
    "2817": "by adding 12 semitones.",
    "2822": "Reduce to range 'A'->0 .. 'G'->6.",
    "2820": "Convert to upper case.",
    "2824": "Jump if below 'A' to produce error report \"k Invalid note name\".",
    "2827": "Is it 7 or above?",
    "2829": "Jump if so to produce error report \"k Invalid note name\".",
    "2832": "C=Number of semitones.",
    "2835": "BC holds 0..6 for 'a'..'g'.",
    "2836": "Look up the number of semitones above note C for the note.",
    "2840": "A=Number of semitones above note C.",
    "2841": "C=Number of semitones due to sharpen/flatten characters.",
    "2842": "Adjust number of semitones above note C for the sharpen/flatten characters.",
    "2843": "Restore HL.",
    "3577": "'A,', 'B', 'C', 'D', 'E', 'F', 'G'",
    "2845": "Save registers.",
    "2847": "Get the pointer into the PLAY string.",
    "2853": "Initialise result to 0.",
    "2857": "\"0\". Is character numeric?",
    "2859": "Jump ahead if not.",
    "2861": "\":\". Is character numeric?",
    "2863": "Jump ahead if not.",
    "2866": "Save the pointer into the string.",
    "2867": "Multiply result so far by 10.",
    "2870": "\"0\". Convert ASCII digit to numeric value.",
    "2874": "HL=Numeric digit value.",
    "2875": "Add the numeric value to the result so far.",
    "2876": "Jump ahead if an overflow to produce error report \"l number too big\".",
    "2878": "Transfer the result into DE.",
    "2879": "Retrieve the pointer into the string.",
    "2880": "Loop back to handle any further numeric digits.",
    "2882": "Jump to produce error report \"l number too big\".",
    "2885": "Store the new pointer position into the string.",
    "2892": "Return the result in BC.",
    "2893": "Restore registers.",
    "2899": "Add DE to HL ten times.",
    "2902": "Jump ahead if an overflow to produce error report \"l number too big\".",
    "2906": "Transfer the result into DE.",
    "2908": "Test for BREAK being pressed.",
    "2911": "Jump ahead if not pressed.",
    "2913": "Turn off all sound and restore IY.",
    "2916": "Re-enable interrupts.",
    "2917": "Produce error report. [Could have saved 1 byte by using JP $05D6 (ROM 0)]",
    "2920": "\"L Break into program\"",
    "2921": "Get the current character from the PLAY string, and advance the position pointer.",
    "2924": "Jump if at the end of the string.",
    "2927": "Find the handler routine for the PLAY command character.",
    "2932": "Generate the offset into the",
    "2934": "command vector table.",
    "2937": "HL points to handler routine for this command character.",
    "2940": "Fetch the handler routine address.",
    "2941": "HL=Handler routine address for this command character.",
    "2942": "Make an indirect call to the handler routine.",
    "2945": "Jump back to handle the next character in the string.",
    "2949": "Get the current character from the PLAY string, and advance the position pointer.",
    "2952": "Jump if at the end of the string.",
    "2955": "\"!\". Is it the end-of-comment character?",
    "2957": "Return if it is.",
    "2958": "Jump back to test the next character.",
    "3530": "Command handler routine for all other characters.",
    "3532": "'!' command handler routine.",
    "3534": "'O' command handler routine.",
    "3536": "'N' command handler routine.",
    "3538": "'(' command handler routine.",
    "3540": "')' command handler routine.",
    "3542": "'T' command handler routine.",
    "3544": "'M' command handler routine.",
    "3546": "'V' command handler routine.",
    "3548": "'U' command handler routine.",
    "3550": "'W' command handler routine.",
    "3552": "'X' command handler routine.",
    "3554": "'Y' command handler routine.",
    "3556": "'Z' command handler routine.",
    "3558": "'H' command handler routine.",
    "2960": "Get following numeric value from the string into BC.",
    "2963": "Is it between 0 and 8?",
    "2966": "Jump if above 8 to produce error report \"n Out of range\".",
    "2969": "Multiply A by 12.",
    "2977": "Store the octave value.",
    "2981": "Nothing to do so make an immediate return.",
    "2982": "A=Current level of open bracket nesting.",
    "2985": "Increment the count.",
    "2986": "Only 4 levels supported.",
    "2988": "Jump if this is the fifth to produce error report \"d Too many brackets\".",
    "2991": "Store the new open bracket nesting level.",
    "2994": "Offset to the bracket level return position stores.",
    "2997": "HL=Address of the pointer in which to store the return location of the bracket.",
    "3000": "Store the current string position as the return address of the open bracket.",
    "3010": "Fetch the nesting level of closing brackets.",
    "3013": "Offset to the closing bracket return address store.",
    "3016": "Is there any bracket nesting so far?",
    "3017": "Jump if none. [Could have been faster by jumping to $0BF3 (ROM 0)]",
    "3020": "HL=Address of the pointer to the corresponding closing bracket return address store.",
    "3023": "Fetch the low byte of the current address.",
    "3026": "Re-reached the closing bracket?",
    "3027": "Jump ahead if not.Jump ahead if not.",
    "3029": "Point to the high byte.",
    "3030": "Fetch the high byte address of the current address.",
    "3033": "Re-reached the closing bracket?",
    "3034": "Jump ahead if not.",
    "3036": "Decrement the closing bracket nesting level since this level has been repeated.",
    "3039": "[There is no need for the LD A,(IX+$16) and OR A instructions since the DEC (IX+$16) already set the flags]",
    "3042": "Reached the outer bracket nesting level?",
    "3043": "Return if not the outer bracket nesting level such that the character after the closing bracket is processed next.",
    "3044": "Was this a single closing bracket?",
    "3048": "Return if it was not.",
    "3049": "Restore one level of closing bracket nesting.",
    "3053": "Select closing bracket nesting level 0.",
    "3054": "Jump ahead to continue.",
    "3056": "Fetch the nesting level of closing brackets.",
    "3059": "Increment the count.",
    "3060": "Only 5 levels supported (4 to match up with opening brackets and a 5th to repeat indefinitely).",
    "3062": "Jump if this is the fifth to produce error report \"d Too many brackets\".",
    "3065": "Store the new closing bracket nesting level.",
    "3068": "HL=Address of the pointer to the appropriate closing bracket return address store.",
    "3071": "Store the current string position as the return address for the closing bracket.",
    "3080": "Fetch the nesting level of opening brackets.",
    "3086": "HL=Address of the pointer to the opening bracket nesting level return address store.",
    "3089": "Set the return address of the nesting level's opening bracket",
    "3090": "as new current position within the string.",
    "3094": "For a single closing bracket only, this will be the start address of the string.",
    "3098": "Decrement level of open bracket nesting.",
    "3101": "Return if the closing bracket matched an open bracket.",
    "3102": "Set the opening brackets nesting level to 0.",
    "3106": "Signal a single closing bracket only, i.e. to repeat the string indefinitely.",
    "3113": "HL=IX.",
    "3114": "HL=IX+DE.",
    "3120": "HL=IX+DE+2*A.",
    "3122": "Get following numeric value from the string into BC.",
    "3127": "Jump if 256 or above to produce error report \"n Out of range\".",
    "3133": "Jump if 59 or below to produce error report \"n Out of range\".",
    "3138": "Jump if 241 or above to produce error report \"n Out of range\".",
    "3141": "Fetch the channel number.",
    "3144": "Tempo 'T' commands have to be specified in the first string.",
    "3145": "If it is in a later string then ignore it.",
    "3146": "[Redundant instruction - B is already zero]",
    "3148": "C=Tempo value.",
    "3151": "HL=Tempo*4.",
    "3153": "BC=Tempo*4. [Would have been quicker to use the combination LD B,H and LD C,L]",
    "3154": "Save the pointer to the play command data block.",
    "3157": "Place the contents of BC onto the stack. The call restores IY to $5C3A.",
    "3159": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3160": "Restore IY to point at the play command data block.",
    "3162": "Save the pointer to the play command data block.",
    "3166": "HL=pointer to the play command data block.",
    "3170": "HL =IY+$002B.",
    "3171": "Reset IY to $5C3A since this is required by the floating point calculator.",
    "3175": "HL=Points to the calculator RAM routine.",
    "3176": "Set up the return address.",
    "3179": "Set up the return address.",
    "3185": "Stack the address of the swap routine used when returning to this ROM.",
    "3186": "Re-stack the address of the calculator RAM routine.",
    "3187": "Toggle to other ROM and make a return to the calculator RAM routine.",
    "3190": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3192": "Fetch the value on the top of the calculator stack.",
    "3194": "Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.",
    "3195": "Restore IY to point at the play command data block.",
    "3197": "Store tempo timing value.",
    "3204": "Get following numeric value from the string into BC.",
    "3207": "A=Mixer value.",
    "3208": "Is it 64 or above?",
    "3210": "Jump if so to produce error report \"n Out of range\".",
    "3213": "Invert the bits since the sound generator's mixer register uses active low enable. This also sets bit 6 1, which selects the I/O port as an output.",
    "3214": "E=Mixer value.",
    "3215": "D=Register 7 - Mixer.",
    "3217": "Write to sound generator register to set the mixer.",
    "3220": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3221": "Get following numeric value from the string into BC.",
    "3225": "Is it 16 or above?",
    "3227": "Jump if so to produce error report \"n Out of range\".",
    "3230": "Store the volume level.",
    "3233": "E=Channel number.",
    "3236": "Offset by 8.",
    "3238": "A=8+index.",
    "3239": "D=Sound generator register number for the channel.",
    "3240": "E=Volume level.",
    "3241": "Write to sound generator register to set the volume for the channel.",
    "3244": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3245": "Get the channel number.",
    "3248": "Offset by 8.",
    "3250": "A=8+index.",
    "3251": "D=Sound generator register number for the channel. [This is not used and so there is no need to generate it. It was probably a left over from copying and modifying the 'V' command routine. Deleting it would save 7 bytes. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "3252": "E=Select envelope defined by register 13, and reset volume bits to maximum (though these are not used with the envelope).",
    "3254": "Store that the envelope is being used (along with the reset volume level).",
    "3258": "Get following numeric value from the string into BC.",
    "3262": "Is it 8 or above?",
    "3264": "Jump if so to produce error report \"n Out of range\".",
    "3272": "HL points to the corresponding value in the table.",
    "3269": "Envelope waveform lookup table.",
    "3274": "Store new effect waveform value.",
    "3560": "W0 - Single decay then off.   (Continue off, attack off, alternate off, hold off)",
    "3561": "W1 - Single attack then off.  (Continue off, attack on,  alternate off, hold off)",
    "3562": "W2 - Single decay then hold.  (Continue on,  attack off, alternate on,  hold on)",
    "3278": "Get following numeric value from the string into BC.",
    "3281": "Register 11 - Envelope Period Fine.",
    "3284": "Write to sound generator register to set the envelope period (low byte).",
    "3287": "Register 12 - Envelope Period Coarse.",
    "3289": "Write to sound generator register to set the envelope period (high byte).",
    "3292": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3293": "Get following numeric value from the string into BC.",
    "3297": "Is it 0?",
    "3298": "Jump if so to produce error report \"n Out of range\".",
    "3301": "Is it 10 or above?",
    "3303": "Jump if so to produce error report \"n Out of range\".",
    "3306": "Store MIDI channel number that this string is assigned to.",
    "3310": "Get following numeric value from the string into BC.",
    "3313": "A=(low byte of) the value.",
    "3314": "Write byte to MIDI device.",
    "3317": "[Could have saved 1 byte by using JP $0E7C (ROM 0)]",
    "3318": "Indicate no channels to play, thereby causing",
    "3322": "the play command to terminate.",
    "3323": "Is the current character a number?",
    "3326": "Jump if not number digit.",
    "3329": "HL=Address of the duration length within the channel data block.",
    "3332": "Store address of duration length in command data block's channel duration length pointer table.",
    "3336": "Set no tied notes.",
    "3339": "Get the previous character in the string, the note duration.",
    "3342": "Get following numeric value from the string into BC.",
    "3346": "Is the value 0?",
    "3347": "Jump if so to produce error report \"n Out of range\".",
    "3350": "Is it 13 or above?",
    "3352": "Jump if so to produce error report \"n Out of range\".",
    "3355": "Is it below 10?",
    "3357": "Jump if so.",
    "3359": "DE=Note duration length for the duration value.",
    "3362": "Increment the tied notes counter.",
    "3365": "HL=Address of the duration length within the channel data block.",
    "3367": "Store the duration length.",
    "3368": "Increment the counter of tied notes.",
    "3373": "Store the subsequent note duration length in the channel data block.",
    "3376": "Jump ahead to continue.",
    "3378": "C=Note duration value (1..9).",
    "3381": "DE=Duration length for this duration value.",
    "3384": "Increment the tied notes counter.",
    "3387": "Get the current character from the play string for this channel.",
    "3390": "\"_\". Is it a tied note?",
    "3392": "Jump ahead if not.",
    "3394": "Get the current character from the PLAY string, and advance the position pointer.",
    "3397": "Get following numeric value from the string into BC.",
    "3400": "Place the value into A.",
    "3401": "Is it below 10?",
    "3403": "Jump ahead for 1 to 9 (semiquaver ... semibreve).",
    "3405": "HL=Address of the duration length within the channel data block.",
    "3406": "DE=First tied note duration length.",
    "3407": "DE=Note duration length for this new duration value.",
    "3410": "HL=Current tied note duration length.",
    "3411": "HL=Current+new tied note duration lengths.",
    "3413": "BC=Note duration length for the duration value.",
    "3414": "DE=Current+new tied note duration lengths.",
    "3415": "HL=Address of the duration length within the channel data block.",
    "3418": "Store the combined note duration length in the channel data block.",
    "3420": "DE=Note duration length for the second duration value.",
    "3421": "Jump back.",
    "3423": "Store the note duration value.",
    "3426": "HL=Address of the duration length within the channel data block.",
    "3427": "DE=First tied note duration length.",
    "3428": "DE=Note duration length for this new duration value.",
    "3431": "HL=Current tied note duration length.",
    "3432": "HL=Current+new tied not duration lengths.",
    "3433": "DE=Current+new tied not duration lengths.",
    "3434": "HL=Address of the duration length within the channel data block.",
    "3435": "Jump back to process the next character in case it is also part of a tied note.",
    "3438": "HL=Address of the duration length within the channel data block.",
    "3439": "(For triplet notes this could be the address of the subsequent note duration length)",
    "3440": "Store the duration length.",
    "3441": "Jump forward to make a return.",
    "3444": "Increment counter of tied notes.",
    "3448": "Has it reached 11?",
    "3450": "Jump if so to produce to error report \"o too many tied notes\".",
    "3453": "Store the new tied notes counter.",
    "3457": "Get the previous character from the string.",
    "3460": "Set the number of tied notes to 1.",
    "3464": "HL=Address of the duration length within the channel data block.",
    "3467": "Store address of duration length in command data block's channel duration length pointer table.",
    "3470": "C=The duration value of the note (1 to 9).",
    "3473": "[Not necessary]",
    "3477": "[Not necessary]",
    "3474": "Find the duration length for the note duration value.",
    "3478": "Store it in the channel data block.",
    "3481": "Jump to the instruction below. [Redundant instruction]",
    "3486": "Modify the return address to point to the RET instruction at $0B83 (ROM 0).",
    "3488": "[Over elaborate when a simple POP followed by RET would have sufficed, saving 3 bytes]",
    "3490": "Fetch the channel selector.",
    "3493": "Clear the channel flag for this string.",
    "3496": "Store the new channel bitmap.",
    "3502": "HL=Address of the channel data block.",
    "3506": "HL=Address of the store for the duration length.",
    "3508": "Save the address of the duration length within the channel data block.",
    "3511": "HL=Address of the command data block.",
    "3515": "HL=Address within the command data block of the channel duration length pointer table.",
    "3518": "BC=Channel number.",
    "3521": "BC=2*Index number.",
    "3523": "HL=Address within the command data block of the pointer to the current channel's data block duration length.",
    "3524": "DE=Address of the duration length within the channel data block.",
    "3525": "Store the pointer to the channel duration length in the command data block's channel duration pointer table.",
    "3563": "W3 - Single attack then hold. (Continue on,  attack on,  alternate off, hold on)",
    "3564": "W4 - Repeated decay.          (Continue on,  attack off, alternate off, hold off)",
    "3565": "W5 - Repeated attack.         (Continue on,  attack on,  alternate off, hold off)",
    "3566": "W6 - Repeated attack-decay.   (Continue on,  attack on,  alternate on,  hold off)",
    "3567": "W7 - Repeated decay-attack.   (Continue on,  attack off, alternate on,  hold off)",
    "3568": "Number of characters + 1 in command table.",
    "3571": "Start of command table.",
    "3574": "Search for a match.",
    "3584": "Save HL.",
    "3587": "Note duration table.",
    "3590": "Index into the table.Index into the table.",
    "3593": "Fetch the length from the table.",
    "3594": "Restore HL.",
    "3596": "Rest [Not used since table is always indexed into with a value of 1 or more]",
    "3597": "Semi-quaver (sixteenth note).",
    "3598": "Dotted semi-quaver (3/32th note).",
    "3599": "Quaver (eighth note).",
    "3600": "Dotted quaver (3/16th note).",
    "3601": "Crotchet (quarter note).",
    "3602": "Dotted crotchet (3/8th note).",
    "3603": "Minim (half note).",
    "3604": "Dotted minim (3/4th note).",
    "3605": "Semi-breve (whole note).",
    "3606": "Triplet semi-quaver (1/24th note).",
    "3607": "Triplet quaver (1/12th note).",
    "3608": "Triplet crochet (1/6th note).",
    "3609": "\"0\". Is it '0' or less?",
    "3611": "Return with carry flag set if so.",
    "3612": "\":\". Is it more than '9'?",
    "3615": "Return with carry flag set if so.",
    "3616": "C=The note value.",
    "3617": "Octave number * 12.",
    "3620": "Add the octave number and the note value to form the note number.",
    "3621": "Is note within range?",
    "3623": "Jump if not to produce error report \"m Note out of range\".",
    "3626": "C=Note number.",
    "3627": "Get the channel number.",
    "3630": "Is it the first channel?",
    "3631": "Jump ahead if not.",
    "3633": "A=Note number (0..107), in ascending audio frequency.",
    "3634": "Invert since noise register value is in descending audio frequency.",
    "3635": "Mask off bit 7.",
    "3639": "Divide by 4 to reduce range to 0..31.",
    "3641": "Register 6 - Noise pitch.",
    "3644": "Write to sound generator register.",
    "3647": "Store the note number.",
    "3650": "Get the channel number.",
    "3653": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "3655": "Do not output anything for play strings 4 to 8.",
    "3656": "Start of note lookup table.",
    "3659": "BC=Note number.",
    "3661": "A=Note number.",
    "3662": "A=Note number - 21.",
    "3664": "Jump if note number was 21 or above.",
    "3666": "Note numbers $00 to $14 use the lowest note value.",
    "3669": "[Could have saved 4 bytes by using XOR A and dropping through to $0E57 (ROM 0)]",
    "3672": "Generate offset into the table.",
    "3674": "Point to the entry in the table.",
    "3677": "DE=Word to write to the sound chip registers to produce this note.",
    "3678": "HL=Register word value to produce the note.",
    "3679": "Get the channel number.",
    "3682": "D=2*Channel number, to give the tone channel register (fine control) number 0, 2, or 4.",
    "3684": "E=The low value byte.",
    "3685": "Write to sound generator register.",
    "3688": "D=Tone channel register (coarse control) number 1, 3, or 5.",
    "3689": "E=The high value byte.",
    "3690": "Write to sound generator register.",
    "3693": "Is the envelope waveform being used?",
    "3697": "Return if it is not.",
    "3698": "Register 13 - Envelope Shape.",
    "3700": "Get the effect waveform value.",
    "3704": "Write to sound generator register.",
    "3707": "[Could have saved 4 bytes by dropping down into the routine below.]",
    "3712": "Select the register.",
    "3717": "Write out the value.",
    "3725": "Select the register.",
    "3727": "Read the register's value.",
    "3731": "Register 7 - Mixer.",
    "3733": "I/O ports are inputs, noise output off, tone output off.",
    "3735": "Write to sound generator register.",
    "3738": "Register 8 - Channel A volume.",
    "3740": "Volume of 0.",
    "3742": "Write to sound generator register to set the volume to 0.",
    "3745": "Register 9 - Channel B volume.",
    "3746": "Write to sound generator register to set the volume to 0.",
    "3750": "Write to sound generator register to set the volume to 0.",
    "3749": "Register 10 - Channel C volume.",
    "3753": "Select channel data block pointers.",
    "3756": "Working copy of channel bitmap. Test if next string present.",
    "3760": "Jump ahead if there is no string for this channel.",
    "3762": "Get address of channel data block for the current string into IX.",
    "3765": "Turn off the MIDI channel sound assigned to this play string.",
    "3768": "Have all channels been processed?",
    "3772": "Jump ahead if so.",
    "3774": "Advance to the next channel data block pointer.",
    "3777": "Jump back to process the next channel.",
    "3779": "Restore IY.",
    "3784": "Save registers.",
    "3786": "Get the current pointer into the PLAY string.",
    "3792": "Point to previous character.",
    "3793": "Fetch the character.",
    "3794": "Is it a space?",
    "3796": "Jump back if a space.",
    "3798": "Is it an 'Enter'?",
    "3800": "Jump back if an 'Enter'.",
    "3802": "Store this as the new current pointer into the PLAY string.",
    "3808": "Restore registers.",
    "3811": "Save registers.",
    "3814": "HL=Pointer to next character to process within the PLAY string.",
    "3821": "Reached end-of-string address high byte?",
    "3824": "Jump forward if not.",
    "3827": "Reached end-of-string address low byte?",
    "3830": "Jump forward if not.",
    "3832": "Indicate string all processed.",
    "3833": "Jump forward to return.",
    "3835": "Get the next play character.",
    "3836": "Is it a space?",
    "3838": "Ignore the space by jumping ahead to process the next character.",
    "3840": "Is it 'Enter'?",
    "3842": "Ignore the 'Enter' by jumping ahead to process the next character.",
    "3844": "Clear the carry flag to indicate a new character has been returned.",
    "3845": "Restore registers.",
    "3849": "Point to the next character.",
    "3853": "Update the pointer to the next character to process with the PLAY string.",
    "3856": "Jump back to get the next character.",
    "3858": "Turn off all sound and restore IY.",
    "3866": "Turn off all sound and restore IY.",
    "3874": "Turn off all sound and restore IY.",
    "3890": "Turn off all sound and restore IY.",
    "3882": "Turn off all sound and restore IY.",
    "3862": "Produce error report.",
    "3870": "Produce error report.",
    "3878": "Produce error report.",
    "3886": "Produce error report.",
    "3894": "Produce error report.",
    "3902": "Produce error report.",
    "3898": "Turn off all sound and restore IY.",
    "3865": "\"n Out of range\"",
    "3873": "\"l Number too big\"",
    "3881": "\"k Invalid note name\"",
    "3889": "\"d Too many brackets\"",
    "3897": "\"m Note out of range\"",
    "3905": "\"o Too many tied notes\"",
    "3906": "Select channel data block pointers.",
    "3909": "Working copy of channel bitmap. Test if next string present.",
    "3913": "Jump ahead if there is no string for this channel.",
    "3915": "Get address of channel data block for the current string into IX.",
    "3921": "Is it a rest?",
    "3923": "Jump ahead if so and do nothing to the channel.",
    "3925": "Play the note if a sound chip channel.",
    "3928": "Get channel number.",
    "3931": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "3933": "Jump if not to skip setting the volume.",
    "3937": "A=0 to 2.",
    "3938": "D=Register (8 + string index), i.e. channel A, B or C volume register.",
    "3939": "E=Volume for the current channel.",
    "3942": "Write to sound generator register to set the output volume.",
    "3945": "Play a note and set the volume on the assigned MIDI channel.",
    "3948": "Have all channels been processed?",
    "3952": "Return if so.",
    "3953": "Advance to the next channel data block pointer.",
    "3956": "Jump back to process the next channel.",
    "3958": "(11) Save HL.",
    "3959": "(19) Get the tempo timing value.",
    "3962": "(19)",
    "3965": "(10) BC=100",
    "3968": "(4)",
    "3969": "(15) HL=tempo timing value - 100.",
    "3971": "(11)",
    "3972": "(10) BC=tempo timing value - 100.",
    "3973": "(10) Restore HL.",
    "3974": "(6)  Wait for tempo-100 loops.",
    "3975": "(4)",
    "3976": "(4)",
    "3977": "(12/7)",
    "3979": "(6) Repeat DE times",
    "3980": "(4)",
    "3981": "(4)",
    "3982": "(12/7)",
    "3984": "(10)",
    "3985": "Set smallest duration length to 'maximum'.",
    "3988": "Select channel data block duration pointers.",
    "3991": "Working copy of channel bitmap. Test if next string present.",
    "3995": "Jump ahead if there is no string for this channel.",
    "3997": "Save the smallest duration length.",
    "4001": "DE=Channel data block duration length.",
    "4004": "DE=Channel duration length.",
    "4006": "HL=Channel duration length.",
    "4007": "Last channel duration length.",
    "4009": "Is current channel's duration length smaller than the smallest so far?",
    "4011": "Jump ahead if so, with the new smallest value in DE.",
    "4014": "DE=Smallest duration length.",
    "4015": "Have all channel strings been processed?",
    "4019": "Jump ahead if so.",
    "4021": "Advance to the next channel data block duration pointer.",
    "4024": "Jump back to process the next channel.",
    "4029": "Store the smallest channel duration length.",
    "4034": "Holds a temporary channel bitmap.",
    "4037": "Select channel data block pointers.",
    "4040": "Working copy of channel bitmap. Test if next string present.",
    "4044": "Jump ahead if there is no string for this channel.",
    "4047": "Get address of channel data block for the current string into IX.",
    "4052": "HL=Address of the command data block.",
    "4056": "HL=Address of channel data block duration pointers.",
    "4059": "BC=Channel number.",
    "4062": "BC=2*Channel number.",
    "4064": "HL=Address of channel data block duration pointer for this channel.",
    "4067": "DE=Address of duration length within the channel data block.",
    "4068": "HL=Address of duration length within the channel data block.",
    "4069": "Save it.",
    "4072": "DE=Duration length for this channel.",
    "4073": "HL=Duration length for this channel.",
    "4077": "DE=Smallest duration length of all current channel notes.",
    "4081": "HL=Duration length - smallest duration length.",
    "4083": "DE=Duration length - smallest duration length.",
    "4084": "HL=Address of duration length within the channel data block.",
    "4085": "Jump if this channel uses the smallest found duration length.",
    "4089": "Update the duration length for this channel with the remaining length.",
    "4090": "Jump ahead to update the next channel.",
    "4092": "Get the channel number.",
    "4095": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "4097": "Jump ahead if not a sound generator channel.",
    "4102": "D=Register (8+channel number) - Channel volume.",
    "4103": "E=Volume level of 0.",
    "4105": "Write to sound generator register to turn the volume off.",
    "4108": "Turn off the assigned MIDI channel sound.",
    "4113": "HL=Address of channel data block.",
    "4117": "HL=Points to the tied notes counter.",
    "4118": "Decrement the tied notes counter. [This contains a value of 1 for a single note]",
    "4119": "Jump ahead if there are more tied notes.",
    "4121": "Find the next note to play for this channel from its play string.",
    "4124": "Fetch the channel selector.",
    "4127": "Test whether this channel has further data in its play string.",
    "4130": "Jump to process the next channel if this channel does not have a play string.",
    "4132": "The channel has more data in its play string so jump ahead.",
    "4136": "HL=Address of the command data block.",
    "4140": "HL=Address of channel data block duration pointers.",
    "4143": "BC=Channel number.",
    "4146": "BC=2*Channel number.",
    "4148": "HL=Address of channel data block duration pointer for this channel.",
    "4151": "DE=Address of duration length within the channel data block.",
    "4153": "Point to the subsequent note duration length.",
    "4156": "Store the new duration length.",
    "4157": "Get next note in the string as number of semitones above note C.",
    "4160": "C=Number of semitones.",
    "4161": "Fetch the channel selector.",
    "4164": "Test whether this channel has a play string.",
    "4167": "Jump to process the next channel if this channel does not have a play string.",
    "4169": "A=Number of semitones.",
    "4170": "Is it a rest?",
    "4172": "Jump to process the next channel if it is.",
    "4174": "Play the new note on this channel at the current volume if a sound chip channel, or simply store the note for play strings 4 to 8.",
    "4177": "Fetch the channel selector.",
    "4180": "Insert a bit in the temporary channel bitmap to indicate this channel has more to play.",
    "4183": "Store it.",
    "4186": "Have all channel strings been processed?",
    "4190": "Jump ahead if so.",
    "4192": "Advance to the next channel data pointer.",
    "4195": "Jump back to update the duration length for the next channel.",
    "4198": "Delay for 1/96th of a note.",
    "4204": "Select channel data block pointers.",
    "4207": "Temporary channel bitmap. Test if next string present.",
    "4211": "Jump ahead if there is no string for this channel.",
    "4213": "Get address of channel data block for the current string into IX.",
    "4216": "Get the channel number.",
    "4219": "Is it channel 0, 1 or 2, i.e. a sound chip channel?",
    "4221": "Jump ahead if so to process the next channel.",
    "4226": "D=Register (8+channel number) - Channel volume.",
    "4227": "Get the current volume.",
    "4230": "Write to sound generator register to set the volume of the channel.",
    "4233": "Play a note and set the volume on the assigned MIDI channel.",
    "4236": "Have all channels been processed?",
    "4240": "Return if so.",
    "4241": "Advance to the next channel data pointer.",
    "4244": "Jump back to process the next channel.",
    "4246": "Octave  1, Note  21 - A  (27.50 Hz, Ideal=27.50 Hz, Error=-0.01%) C0",
    "4248": "Octave  1, Note  22 - A# (29.14 Hz, Ideal=29.16 Hz, Error=-0.08%)",
    "4250": "Octave  1, Note  23 - B  (30.87 Hz, Ideal=30.87 Hz, Error=-0.00%)",
    "4252": "Octave  2, Note  24 - C  (32.71 Hz, Ideal=32.70 Hz, Error=+0.01%) C1",
    "4254": "Octave  2, Note  25 - C# (34.65 Hz, Ideal=34.65 Hz, Error=-0.00%)",
    "4256": "Octave  2, Note  26 - D  (36.70 Hz, Ideal=36.71 Hz, Error=-0.01%)",
    "4258": "Octave  2, Note  27 - D# (38.89 Hz, Ideal=38.89 Hz, Error=+0.01%)",
    "4260": "Octave  2, Note  28 - E  (41.20 Hz, Ideal=41.20 Hz, Error=+0.00%)",
    "4262": "Octave  2, Note  29 - F  (43.66 Hz, Ideal=43.65 Hz, Error=+0.00%)",
    "4264": "Octave  2, Note  30 - F# (46.24 Hz, Ideal=46.25 Hz, Error=-0.02%)",
    "4266": "Octave  2, Note  31 - G  (49.00 Hz, Ideal=49.00 Hz, Error=+0.00%)",
    "4268": "Octave  2, Note  32 - G# (51.92 Hz, Ideal=51.91 Hz, Error=+0.01%)",
    "4270": "Octave  2, Note  33 - A  (55.01 Hz, Ideal=55.00 Hz, Error=+0.01%)",
    "4272": "Octave  2, Note  34 - A# (58.28 Hz, Ideal=58.33 Hz, Error=-0.08%)",
    "4274": "Octave  2, Note  35 - B  (61.75 Hz, Ideal=61.74 Hz, Error=+0.02%)",
    "4276": "Octave  3, Note  36 - C  ( 65.39 Hz, Ideal= 65.41 Hz, Error=-0.02%) C2",
    "4278": "Octave  3, Note  37 - C# ( 69.28 Hz, Ideal= 69.30 Hz, Error=-0.04%)",
    "4280": "Octave  3, Note  38 - D  ( 73.40 Hz, Ideal= 73.42 Hz, Error=-0.01%)",
    "4282": "Octave  3, Note  39 - D# ( 77.78 Hz, Ideal= 77.78 Hz, Error=+0.01%)",
    "4284": "Octave  3, Note  40 - E  ( 82.41 Hz, Ideal= 82.41 Hz, Error=+0.00%)",
    "4286": "Octave  3, Note  41 - F  ( 87.28 Hz, Ideal= 87.31 Hz, Error=-0.04%)",
    "4288": "Octave  3, Note  42 - F# ( 92.52 Hz, Ideal= 92.50 Hz, Error=+0.02%)",
    "4290": "Octave  3, Note  43 - G  ( 98.00 Hz, Ideal= 98.00 Hz, Error=+0.00%)",
    "4292": "Octave  3, Note  44 - G# (103.78 Hz, Ideal=103.83 Hz, Error=-0.04%)",
    "4294": "Octave  3, Note  45 - A  (109.96 Hz, Ideal=110.00 Hz, Error=-0.04%)",
    "4296": "Octave  3, Note  46 - A# (116.55 Hz, Ideal=116.65 Hz, Error=-0.08%)",
    "4298": "Octave  3, Note  47 - B  (123.43 Hz, Ideal=123.47 Hz, Error=-0.03%)",
    "4300": "Octave  4, Note  48 - C  (130.86 Hz, Ideal=130.82 Hz, Error=+0.04%) C3",
    "4302": "Octave  4, Note  49 - C# (138.55 Hz, Ideal=138.60 Hz, Error=-0.04%)",
    "4304": "Octave  4, Note  50 - D  (146.81 Hz, Ideal=146.83 Hz, Error=-0.01%)",
    "4306": "Octave  4, Note  51 - D# (155.68 Hz, Ideal=155.55 Hz, Error=+0.08%)",
    "4308": "Octave  4, Note  52 - E  (164.70 Hz, Ideal=164.82 Hz, Error=-0.07%)",
    "4310": "Octave  4, Note  53 - F  (174.55 Hz, Ideal=174.62 Hz, Error=-0.04%)",
    "4312": "Octave  4, Note  54 - F# (185.04 Hz, Ideal=185.00 Hz, Error=+0.02%)",
    "4314": "Octave  4, Note  55 - G  (195.83 Hz, Ideal=196.00 Hz, Error=-0.09%)",
    "4316": "Octave  4, Note  56 - G# (207.57 Hz, Ideal=207.65 Hz, Error=-0.04%)",
    "4318": "Octave  4, Note  57 - A  (219.92 Hz, Ideal=220.00 Hz, Error=-0.04%)",
    "4320": "Octave  4, Note  58 - A# (232.86 Hz, Ideal=233.30 Hz, Error=-0.19%)",
    "4322": "Octave  4, Note  59 - B  (246.86 Hz, Ideal=246.94 Hz, Error=-0.03%)",
    "4324": "Octave  5, Note  60 - C  (261.42 Hz, Ideal=261.63 Hz, Error=-0.08%) C4 Middle C",
    "4326": "Octave  5, Note  61 - C# (277.10 Hz, Ideal=277.20 Hz, Error=-0.04%)",
    "4328": "Octave  5, Note  62 - D  (294.01 Hz, Ideal=293.66 Hz, Error=+0.12%)",
    "4330": "Octave  5, Note  63 - D# (311.35 Hz, Ideal=311.10 Hz, Error=+0.08%)",
    "4332": "Octave  5, Note  64 - E  (329.88 Hz, Ideal=329.63 Hz, Error=+0.08%)",
    "4334": "Octave  5, Note  65 - F  (349.65 Hz, Ideal=349.23 Hz, Error=+0.12%)",
    "4336": "Octave  5, Note  66 - F# (369.47 Hz, Ideal=370.00 Hz, Error=-0.14%)",
    "4338": "Octave  5, Note  67 - G  (391.66 Hz, Ideal=392.00 Hz, Error=-0.09%)",
    "4340": "Octave  5, Note  68 - G# (415.13 Hz, Ideal=415.30 Hz, Error=-0.04%)",
    "4342": "Octave  5, Note  69 - A  (439.84 Hz, Ideal=440.00 Hz, Error=-0.04%)",
    "4344": "Octave  5, Note  70 - A# (465.72 Hz, Ideal=466.60 Hz, Error=-0.19%)",
    "4346": "Octave  5, Note  71 - B  (494.82 Hz, Ideal=493.88 Hz, Error=+0.19%)",
    "4348": "Octave  6, Note  72 - C  (522.83 Hz, Ideal=523.26 Hz, Error=-0.08%) C5",
    "4350": "Octave  6, Note  73 - C# (554.20 Hz, Ideal=554.40 Hz, Error=-0.04%)",
    "4352": "Octave  6, Note  74 - D  (586.46 Hz, Ideal=587.32 Hz, Error=-0.15%)",
    "4354": "Octave  6, Note  75 - D# (622.70 Hz, Ideal=622.20 Hz, Error=+0.08%)",
    "4356": "Octave  6, Note  76 - E  (659.77 Hz, Ideal=659.26 Hz, Error=+0.08%)",
    "4358": "Octave  6, Note  77 - F  (697.11 Hz, Ideal=698.46 Hz, Error=-0.19%)",
    "4360": "Octave  6, Note  78 - F# (738.94 Hz, Ideal=740.00 Hz, Error=-0.14%)",
    "4362": "Octave  6, Note  79 - G  (786.10 Hz, Ideal=784.00 Hz, Error=+0.27%)",
    "4364": "Octave  6, Note  80 - G# (833.39 Hz, Ideal=830.60 Hz, Error=+0.34%)",
    "4366": "Octave  6, Note  81 - A  (879.69 Hz, Ideal=880.00 Hz, Error=-0.04%)",
    "4368": "Octave  6, Note  82 - A# (931.43 Hz, Ideal=933.20 Hz, Error=-0.19%)",
    "4370": "Octave  6, Note  83 - B  (989.65 Hz, Ideal=987.76 Hz, Error=+0.19%)",
    "4372": "Octave  7, Note  84 - C  (1045.67 Hz, Ideal=1046.52 Hz, Error=-0.08%) C6",
    "4374": "Octave  7, Note  85 - C# (1108.41 Hz, Ideal=1108.80 Hz, Error=-0.04%)",
    "4376": "Octave  7, Note  86 - D  (1179.16 Hz, Ideal=1174.64 Hz, Error=+0.38%)",
    "4378": "Octave  7, Note  87 - D# (1245.40 Hz, Ideal=1244.40 Hz, Error=+0.08%)",
    "4380": "Octave  7, Note  88 - E  (1319.53 Hz, Ideal=1318.52 Hz, Error=+0.08%)",
    "4382": "Octave  7, Note  89 - F  (1403.05 Hz, Ideal=1396.92 Hz, Error=+0.44%)",
    "4384": "Octave  7, Note  90 - F# (1477.88 Hz, Ideal=1480.00 Hz, Error=-0.14%)",
    "4386": "Octave  7, Note  91 - G  (1561.14 Hz, Ideal=1568.00 Hz, Error=-0.44%)",
    "4388": "Octave  7, Note  92 - G# (1654.34 Hz, Ideal=1661.20 Hz, Error=-0.41%)",
    "4390": "Octave  7, Note  93 - A  (1759.38 Hz, Ideal=1760.00 Hz, Error=-0.04%)",
    "4392": "Octave  7, Note  94 - A# (1878.65 Hz, Ideal=1866.40 Hz, Error=+0.66%)",
    "4394": "Octave  7, Note  95 - B  (1979.30 Hz, Ideal=1975.52 Hz, Error=+0.19%)",
    "4396": "Octave  8, Note  96 - C  (2091.33 Hz, Ideal=2093.04 Hz, Error=-0.08%) C7",
    "4398": "Octave  8, Note  97 - C# (2216.81 Hz, Ideal=2217.60 Hz, Error=-0.04%)",
    "4400": "Octave  8, Note  98 - D  (2358.31 Hz, Ideal=2349.28 Hz, Error=+0.38%)",
    "4402": "Octave  8, Note  99 - D# (2463.13 Hz, Ideal=2488.80 Hz, Error=-1.03%)",
    "4404": "Octave  8, Note 100 - E  (2639.06 Hz, Ideal=2637.04 Hz, Error=+0.08%)",
    "4406": "Octave  8, Note 101 - F  (2771.02 Hz, Ideal=2793.84 Hz, Error=-0.82%)",
    "4408": "Octave  8, Note 102 - F# (2995.69 Hz, Ideal=2960.00 Hz, Error=+1.21%)",
    "4410": "Octave  8, Note 103 - G  (3166.88 Hz, Ideal=3136.00 Hz, Error=+0.98%)",
    "4412": "Octave  8, Note 104 - G# (3358.81 Hz, Ideal=3322.40 Hz, Error=+1.10%)",
    "4414": "Octave  8, Note 105 - A  (3575.50 Hz, Ideal=3520.00 Hz, Error=+1.58%)",
    "4416": "Octave  8, Note 106 - A# (3694.69 Hz, Ideal=3732.80 Hz, Error=-1.02%)",
    "4418": "Octave  8, Note 107 - B  (3958.59 Hz, Ideal=3951.04 Hz, Error=+0.19%)",
    "4420": "Octave  9, Note 108 - C  (4263.10 Hz, Ideal=4186.08 Hz, Error=+1.84%) C8",
    "4422": "Octave  9, Note 109 - C# (4433.63 Hz, Ideal=4435.20 Hz, Error=-0.04%)",
    "4424": "Octave  9, Note 110 - D  (4618.36 Hz, Ideal=4698.56 Hz, Error=-1.71%)",
    "4426": "Octave  9, Note 111 - D# (5038.21 Hz, Ideal=4977.60 Hz, Error=+1.22%)",
    "4428": "Octave  9, Note 112 - E  (5278.13 Hz, Ideal=5274.08 Hz, Error=+0.08%)",
    "4430": "Octave  9, Note 113 - F  (5542.03 Hz, Ideal=5587.68 Hz, Error=-0.82%)",
    "4432": "Octave  9, Note 114 - F# (5833.72 Hz, Ideal=5920.00 Hz, Error=-1.46%)",
    "4434": "Octave  9, Note 115 - G  (6157.81 Hz, Ideal=6272.00 Hz, Error=-1.82%)",
    "4436": "Octave  9, Note 116 - G# (6520.04 Hz, Ideal=6644.80 Hz, Error=-1.88%)",
    "4438": "Octave  9, Note 117 - A  (6927.54 Hz, Ideal=7040.00 Hz, Error=-1.60%)",
    "4440": "Octave  9, Note 118 - A# (7389.38 Hz, Ideal=7465.60 Hz, Error=-1.02%)",
    "4442": "Octave  9, Note 119 - B  (7917.19 Hz, Ideal=7902.08 Hz, Error=+0.19%)",
    "4444": "Octave 10, Note 120 - C  ( 8526.20 Hz, Ideal= 8372.16 Hz, Error=+1.84%) C9",
    "4446": "Octave 10, Note 121 - C# ( 9236.72 Hz, Ideal= 8870.40 Hz, Error=+4.13%)",
    "4448": "Octave 10, Note 122 - D  ( 9236.72 Hz, Ideal= 9397.12 Hz, Error=-1.71%)",
    "4450": "Octave 10, Note 123 - D# (10076.42 Hz, Ideal= 9955.20 Hz, Error=+1.22%)",
    "4452": "Octave 10, Note 124 - E  (10076.42 Hz, Ideal=10548.16 Hz, Error=-4.47%)",
    "4454": "Octave 10, Note 125 - F  (11084.06 Hz, Ideal=11175.36 Hz, Error=-0.82%)",
    "4456": "Octave 10, Note 126 - F# (12315.63 Hz, Ideal=11840.00 Hz, Error=+4.02%)",
    "4458": "Octave 10, Note 127 - G  (12315.63 Hz, Ideal=12544.00 Hz, Error=-1.82%)",
    "4460": "Octave 10, Note 128 - G# (13855.08 Hz, Ideal=13289.60 Hz, Error=+4.26%)",
    "4462": "Is a MIDI channel assigned to this string?",
    "4466": "Return if not.",
    "4467": "Set bits 4 and 7 of the channel number. A=$90..$9F.",
    "4469": "Write byte to MIDI device.",
    "4472": "The note number.",
    "4475": "Write byte to MIDI device.",
    "4478": "Fetch the channel's volume.",
    "4481": "Ensure the 'using envelope' bit is reset so",
    "4483": "that A holds a value between $00 and $0F.",
    "4485": "Multiply by 8 to increase the range to $00..$78.",
    "4487": "A=Note velocity.",
    "4489": "Write byte to MIDI device.",
    "4492": "[Could have saved 1 byte by using JP $11A3 (ROM 0)]",
    "4493": "Is a MIDI channel assigned to this string?",
    "4497": "Return if not.",
    "4498": "Set bit 7 of the channel number. A=$80..$8F.",
    "4500": "Write byte to MIDI device.",
    "4503": "The note number.",
    "4506": "Write byte to MIDI device.",
    "4511": "Write byte to MIDI device.",
    "4509": "The note velocity.",
    "4514": "[Could have saved 1 byte by using JP $11A3 (ROM 0)]",
    "4515": "Store the byte to send.",
    "4521": "Select register 14 - I/O port.",
    "4526": "Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4528": "Send out the START bit.",
    "4530": "(7) Introduce delays such that the next bit is output 113 T-states from now.",
    "4532": "(4)",
    "4535": "(4)",
    "4536": "(4)",
    "4537": "(4)",
    "4538": "(4)",
    "4539": "(4) Retrieve the byte to send.",
    "4542": "(4) Rotate the next bit to send into the carry.",
    "4543": "(4) Store the remaining bits.",
    "4533": "(12/7)",
    "4540": "(7) There are 8 bits to send.",
    "4544": "(10) Jump if it is a 0 bit.",
    "4547": "(7) Set RS232 'RXD' transmit line to 1. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4549": "(11)",
    "4551": "(12) Jump forward to process the next bit.",
    "4553": "(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4555": "(11)",
    "4557": "(12) Jump forward to process the next bit.",
    "4559": "(7) Introduce delays such that the next data bit is output 113 T-states from now.",
    "4561": "(4)",
    "4564": "(4)",
    "4571": "(4) Introduce delays such that the stop bit is output 113 T-states from now.",
    "4572": "(4)",
    "4575": "(4)",
    "4576": "(4)",
    "4562": "(12/7)",
    "4565": "(7)",
    "4567": "(4) Retrieve the remaining bits to send.",
    "4568": "(4) Decrement the bit counter.",
    "4569": "(12/7) Jump back if there are further bits to send.",
    "4573": "(7)",
    "4577": "(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)",
    "4579": "(11) Send out the STOP bit.",
    "4581": "(7) Delay for 101 T-states (28.5us).",
    "4583": "(4)",
    "4584": "(12/7)",
    "4586": "(10)",
    "4590": "Indicate SAVE.",
    "4597": "Indicate LOAD.",
    "4604": "Indicate VERIFY.",
    "4611": "Indicate MERGE.",
    "4616": "Indicate using cassette.",
    "4618": "Get current character.",
    "4619": "'!'",
    "4621": "Jump ahead to handle cassette command.",
    "4627": "Indicate using RAM disk.",
    "4629": "Move on to next character.",
    "4630": "Jump ahead to handle RAM disk command.",
    "4633": "Produce error report.",
    "4636": "\"C Nonsense in BASIC\"",
    "4637": "Save start address.",
    "4640": "Transfer header file information",
    "4643": "from IX to HD_00 onwards.",
    "4673": "Test file type.",
    "4674": "Jump ahead for a program file.",
    "4678": "Jump ahead for a CODE/SCREEN$ file.",
    "4683": "Store array name.",
    "4686": "IX points to file header.",
    "4688": "Retrieve into HL.",
    "4689": "HL points to filename.",
    "4696": "Copy the filename.",
    "4701": "SAVE operation?",
    "4703": "Jump ahead if SAVE.",
    "4715": "Transfer requested details from HD_00 onwards into SC_00 onwards.",
    "4717": "Find and load requested file header into HD_00 ($5B71).",
    "4720": "Requested file type.",
    "4724": "Loaded file type.",
    "4728": "Error 'b' if file types do not match.",
    "4730": "Is it a CODE file type?",
    "4732": "Jump ahead to avoid MERGE program/array check.",
    "4734": "Only file types 0, 1 and 2 are OK.",
    "4736": "Produce error report.",
    "4739": "\"b Wrong file type\"",
    "4743": "Is it a MERGE program/array operation?",
    "4745": "Jump ahead if so.",
    "4747": "Is it a VERIFY program/array operation?",
    "4749": "Jump ahead if LOAD.",
    "4755": "MERGE operation?",
    "4757": "Jump ahead if VERIFY.",
    "4759": "Produce error report.",
    "4762": "\"a MERGE error\"",
    "4763": "Length requested.",
    "4766": "File length.",
    "4772": "Jump ahead if requested length is 0, i.e. not specified.",
    "4774": "Is file length <= requested length?",
    "4776": "Jump ahead if so; requested length is OK.",
    "4778": "Produce error report.",
    "4781": "\"c CODE error\"",
    "4782": "Fetch start address.",
    "4787": "Jump ahead if start address was provided.",
    "4789": "Not provided so use file's start address.",
    "4792": "File type.",
    "4795": "Is it a program?",
    "4796": "Jump ahead if not.",
    "4798": "Set start address as start of program area.",
    "4801": "Load DE bytes at address pointed to by HL. [The Spectrum 128 manual states that the VERIFY keyword is not used with the RAM disk yet it clearly is, although verifying a RAM disk file simply loads it in just as LOAD would do. To support verifying, the routine at $1E37 (ROM 0) which loads blocks of data would need to be able to load or verify a block. The success status would then need to be propagated back to here via routines at $137E (ROM 0), $1C4B (ROM 0) and $1E37 (ROM 0)]",
    "4804": "[Could have saved 1 byte by using JP $137E (ROM 0), although could have saved a lot more by not supporting the VERIFY keyword at all]",
    "4805": "File length.",
    "4809": "Save the length.",
    "4810": "Increment for terminator $80 (added later).",
    "4812": "Create room in the workspace for the file.",
    "4814": "Insert terminator.",
    "4816": "HL=Start address.",
    "4817": "DE=File length.",
    "4818": "Save start address.",
    "4819": "Load DE bytes to address pointed to by HL.",
    "4822": "Retrieve start address.",
    "4824": "Delegate actual merge handling to ROM 1.",
    "4827": "File length.",
    "4831": "Requested start address.",
    "4834": "Save requested start address.",
    "4836": "Was start address specified? (0 if not).",
    "4837": "Jump ahead if start address specified.",
    "4839": "Allow for variable overhead.",
    "4842": "HL=File Length+3.",
    "4843": "Jump ahead to test if there is room.",
    "4845": "Requested length.",
    "4848": "DE=Requested length. HL=File length.",
    "4850": "File length-Requested Length-1",
    "4852": "Jump if file is smaller than requested.",
    "4859": "Space required in BC.",
    "4861": "Will automatically produce error '4' if out of memory.",
    "4863": "Requested start address.",
    "4864": "Get requested file type.",
    "4867": "Test file type.",
    "4868": "Jump if program file type.",
    "4871": "Was start address of existing array specified?",
    "4872": "Jump ahead if not.",
    "4877": "Fetch array length.",
    "4881": "Allow for variable header.",
    "4883": "Delete old array.",
    "4888": "Point to end",
    "4889": "Array length.",
    "4893": "Save array length.",
    "4894": "Allow for variable header.",
    "4897": "Get array name.",
    "4900": "Save array name.",
    "4902": "Create room for new array.",
    "4906": "Store array name.",
    "4911": "Store array length.",
    "4913": "Load DE bytes to address pointed to by HL.",
    "4916": "[Could have saved 1 byte by using JP $137E (ROM 0)]",
    "4920": "Signal do not auto-run BASIC program.",
    "4922": "Address of start of BASIC program.",
    "4926": "Address of end of program area.",
    "4929": "Point before terminator.",
    "4931": "Delete current BASIC program.",
    "4933": "Fetch file length.",
    "4937": "Address of start of BASIC program.",
    "4941": "Create room for the file.",
    "4943": "Allow for terminator.",
    "4944": "Length of variables.",
    "4948": "Determine new address of variables.",
    "4952": "Fetch high byte of auto-run line number.",
    "4958": "If holds $80 then no auto-run line number specified.",
    "4960": "Low byte of auto-run line number.",
    "4964": "Set line number to run.",
    "4967": "NSPPC. Statement 0.",
    "4974": "Signal auto-run BASIC program.",
    "4976": "Address of start of BASIC program.",
    "4979": "Program length.",
    "4984": "Set the address of next line to the end of the program.",
    "4988": "Jump back to load program bytes.",
    "4992": "Return if length is zero.",
    "4993": "Load bytes",
    "4996": "[Could have used JP $1C4B (ROM 0) to save 1 byte]",
    "4998": "Expect an expression on the BASIC line.",
    "5000": "Return early if syntax checking.",
    "5005": "Get the item off the calculator stack",
    "5011": "Advance the pointer into the BASIC line.",
    "5012": "Get expression from BASIC line.",
    "5015": "Return if syntax checking.",
    "5016": "[No need to save AF - see comment below]",
    "5017": "Check for zero length.",
    "5019": "Jump if so to produce error report \"f Invalid name\".",
    "5021": "Check for length greater than 10.",
    "5026": "Jump if so to produce error report \"f Invalid name\".",
    "5028": "Save the filename start address.",
    "5029": "Save the filename length.",
    "5030": "HL points to filename buffer.",
    "5037": "Fill it with 10 spaces.",
    "5041": "Restore filename length.",
    "5042": "Restore filename start address.",
    "5043": "DE points to where to store the filename.",
    "5046": "Perform the copy.",
    "5048": "[No need to have saved AF as not subsequently used]",
    "5050": "Produce error report.",
    "5053": "\"f Invalid name\"",
    "5055": "Pass the parameters of the 'name' to the calculator stack.",
    "5061": "Jump ahead if checking syntax.",
    "5063": "Size of save header, 17 bytes.",
    "5066": "Indicates which BASIC command.",
    "5069": "Is it SAVE?",
    "5070": "Jump ahead if so.",
    "5072": "Otherwise need 34d bytes for LOAD, MERGE and VERIFY commands. 17 bytes for the header of the requested file, and 17 bytes for the files tested from tape.",
    "5075": "Create space in workspace.",
    "5077": "Get start of the created space into IX.",
    "5080": "Clear the filename.",
    "5084": "Set all characters to spaces.",
    "5088": "Indicate a null name.",
    "5093": "The parameters of the name are fetched.",
    "5095": "= -10.",
    "5101": "Jump ahead if filename length within 10 characters.",
    "5103": "Indicates which BASIC command.",
    "5106": "Is it SAVE?",
    "5107": "Jump ahead if not since LOAD, MERGE and VERIFY can have null filenames.",
    "5109": "Produce error report.",
    "5112": "\"F Invalid file name\"",
    "5115": "Jump forward if the name has a null length.",
    "5117": "Truncate longer filenames.",
    "5122": "Transfer address of the workspace to HL.",
    "5123": "Step to the second location.",
    "5125": "Copy the filename.",
    "5127": "Get character from BASIC line.",
    "5128": "Is it 'DATA'?",
    "5130": "Jump if not DATA.",
    "5132": "Check the BASIC command.",
    "5135": "Is it MERGE?",
    "5137": "\"C Nonsense in BASIC\" if so.",
    "5140": "Get next character from BASIC line.",
    "5142": "Look in the variables area for the array.",
    "5144": "Jump if handling an existing array.",
    "5146": "Signal 'using a new array'.",
    "5149": "FLAGS. Is it a string Variable?",
    "5153": "Jump forward if so.",
    "5155": "Set bit 7 of the array's name.",
    "5160": "Give an error if trying to",
    "5161": "SAVE or VERIFY a new array.",
    "5163": "Produce error report.",
    "5166": "\"2 Variable not found\"",
    "5167": "Jump if not an array to produce \"C Nonsense in BASIC\".",
    "5170": "FLAGS.",
    "5174": "Jump forward if checking syntax.",
    "5177": "Point to the 'low length' of the variable.",
    "5178": "The low length byte goes into",
    "5179": "the work space.",
    "5183": "The high length byte goes into",
    "5184": "the work space.",
    "5187": "Step past the length bytes.",
    "5188": "Copy the array's name.",
    "5191": "Assume an array of numbers - Code $01.",
    "5195": "Jump if it is so.",
    "5197": "Indicate it is an array of characters - Code $02.",
    "5198": "Save the 'type' in the first location of the header area.",
    "5201": "Save the pointer in DE.",
    "5203": "Is the next character a ')'?",
    "5205": "Give report C if it is not.",
    "5207": "Advance to next character.",
    "5208": "Move on to the next statement if checking syntax.",
    "5211": "Return the pointer to the HL. (The pointer indicates the start of an existing array's contents).",
    "5212": "Jump forward.",
    "5215": "Is the present code the token 'SCREEN$'?",
    "5217": "Jump ahead if not.",
    "5219": "Check the BASIC command.",
    "5222": "Is it MERGE?",
    "5224": "Jump to \"C Nonsense in BASIC\" if so since it is not possible to have 'MERGE name SCREEN$'.",
    "5227": "Advance pointer into BASIC line.",
    "5228": "Move on to the next statement if checking syntax.",
    "5231": "Length of the block.",
    "5235": "The display area and the attribute area occupy $1800 locations.",
    "5239": "Start of the block, beginning of the display file $4000.",
    "5245": "Store in the workspace.",
    "5248": "Jump forward.",
    "5250": "Is the present code the token 'CODE'?",
    "5252": "Jump ahead if not.",
    "5254": "Check the BASIC command.",
    "5257": "Is it MERGE?",
    "5259": "Jump to \"C Nonsense in BASIC\" if so since it is not possible to have 'MERGE name CODE'.",
    "5262": "Advance pointer into BASIC line.",
    "5266": "Jump forward if the statement has not finished",
    "5271": "It is not possible to have 'SAVE name CODE' by itself.",
    "5272": "Jump if so to produce \"C Nonsense in BASIC\".",
    "5276": "Put a zero on the calculator stack - for the 'start'.",
    "5278": "Jump forward.",
    "5281": "Fetch the first number.",
    "5284": "Is the present character a ','?",
    "5286": "Jump if it is - the number was a 'starting address'",
    "5291": "Refuse 'SAVE name CODE' that does not have a 'start' and a 'length'.",
    "5292": "Jump if so to produce \"C Nonsense in BASIC\".",
    "5296": "Put a zero on the calculator stack - for the 'length'.",
    "5298": "Jump forward.",
    "5300": "Advance to next character.",
    "5302": "Fetch the 'length'.",
    "5304": "But move on to the next statement now if checking syntax.",
    "5308": "Compress the 'length' into BC.",
    "5317": "Compress the 'starting address' into BC.",
    "5310": "Store the length of the CODE block.",
    "5319": "Store the start address of the CODE block.",
    "5325": "Transfer start address pointer to HL.",
    "5327": "Store file type = $03 (CODE).",
    "5331": "Rejoin the other pathways.",
    "5333": "Is the present code the token 'LINE'?",
    "5335": "Jump ahead if so.",
    "5337": "Move on to the next statement if checking syntax.",
    "5340": "Indicate no LINE number.",
    "5344": "Jump forward.",
    "5346": "Only allow 'SAVE name LINE number'.",
    "5349": "Is it SAVE?",
    "5350": "Produce \"C Nonsense in BASIC\" if not.",
    "5353": "Advance pointer into BASIC line.",
    "5355": "Get LINE number onto calculator stack",
    "5357": "Move on to the next statement if checking syntax.",
    "5361": "Compress the 'line number' into BC.",
    "5363": "Store the LINE number.",
    "5369": "Store file type = $00 (program).",
    "5373": "The pointer to the end of the variables area.",
    "5376": "The pointer to the start of the BASIC program.",
    "5381": "Perform the subtraction to find the length of the 'program + variables'.",
    "5386": "Store the length.",
    "5389": "Repeat the operation but this",
    "5392": "time storing the length of the",
    "5394": "'program' only.",
    "5400": "Transfer pointer to HL.",
    "5404": "Using RAM disk?",
    "5406": "Jump if the operation is on the RAM disk.",
    "5409": "Get the BASIC command.",
    "5412": "Is it SAVE?",
    "5413": "Jump ahead if not.",
    "5416": "Run the save routine in ROM 1.",
    "5420": "Run the load/merge/verify routine in ROM 1.",
    "5423": "Flags.",
    "5426": "Signal this is not the current line.",
    "5428": "Signal not yet located the current line.",
    "5430": "Fetch current line number.",
    "5434": "Is there a currently selected line?",
    "5435": "Jump ahead if so.",
    "5437": "Set to $0000 to indicate no editable characters before the cursor.",
    "5440": "Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer,",
    "5443": "i.e. that are off the top of the screen.",
    "5444": "Line number of the BASIC line at the top of the screen (or 0 for the first line).",
    "5447": "Find closest line number (or $0000 if no subsequent line exists).",
    "5450": "Store the line number of the BASIC line being edited in the buffer.",
    "5453": "Set default Above-Screen Line Edit Buffer settings.",
    "5456": "Set default Below-Screen Line Edit Buffer settings.",
    "5459": "A=Number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer.",
    "5460": "Are there any rows off the top of the screen?",
    "5461": "Jump ahead if not.",
    "5463": "Save the number of rows off the top of the screen.",
    "5464": "Copy a BASIC line from the program area into the Below-Screen Line Edit Buffer.",
    "5467": "DE=Address of the Below-Screen Line Edit Buffer.",
    "5468": "Shift up a row into the Above-Screen Line Edit Buffer.",
    "5471": "Retrieve the number of rows off the top of the screen.",
    "5472": "Decrement the number of rows.",
    "5473": "Jump back to shift up another row if required.",
    "5475": "C=Row 0.",
    "5477": "DE=Start address in Screen Line Edit Buffer of the first row, as specified in C.",
    "5480": "B=Row 0.",
    "5481": "The number of editing rows on screen.",
    "5484": "C=Number of editing rows on screen.",
    "5485": "B=Row number, C=Number of editing rows on screen.",
    "5486": "DE=Start address in Screen Line Edit Buffer of the first row.",
    "5487": "Shift up all rows of the BASIC line in the Below-Screen Line Edit Buffer, or if empty then copy a BASIC line from the program area into it. If no BASIC line available then empty the first row of the Below-Screen Line Edit Buffer.",
    "5490": "Listing flags.",
    "5493": "Has the current line been previously found?",
    "5495": "Jump if so.",
    "5497": "DE=Start address in Screen Line Edit Buffer of the current row.",
    "5498": "HL=Address of the first row in the Below-Screen Line Edit Buffer.",
    "5502": "Point to the flag byte for the first row.",
    "5503": "Is it the first row of a BASIC line?",
    "5505": "Jump if not.",
    "5508": "Get line number into DE.",
    "5512": "Current line number.",
    "5517": "Jump ahead unless this is the current line.",
    "5522": "Signal this is the current line.",
    "5524": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5525": "DE=Start address in Screen Line Edit Buffer of the current row.",
    "5526": "B=Row number, C=Number of editing rows on screen.",
    "5527": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5531": "Copy the first row of the BASIC line in the Below-Screen Line Edit Buffer into the next row of the Screen Line Edit Buffer.",
    "5533": "HL=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5534": "B=Row number, C=Number of editing rows on screen.",
    "5535": "DE=Start address in Screen Line Edit Buffer of the next row.",
    "5536": "B=Row number, C=Number of editing rows on screen.",
    "5537": "DE=Address of the current row in the Below-Screen Line Edit Buffer.",
    "5538": "Flags.",
    "5541": "Is this the current line?",
    "5543": "Jump if not.",
    "5545": "Column 0.",
    "5547": "HL=Count of the number of editable characters in the BASIC line up to the cursor within the Screen Line Edit Buffer.",
    "5551": "Are there any editable characters in this row prior to the cursor?",
    "5552": "Jump if there are none, i.e. cursor at start of the row.",
    "5554": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "5559": "Jump if no editable character found on this row, i.e. there must be more characters on the next row.",
    "5561": "Decrement the count of characters prior to the cursor.",
    "5562": "Advance to next column.",
    "5563": "Update the count of the number of editable characters up to the cursor.",
    "5566": "Jump back to test next column.",
    "5568": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "5571": "If no editable character found then find editable position to the left, returning column number in B.",
    "5574": "Flags.",
    "5577": "Signal 'not the current line', 'current line has previously been found' and 'update display file enabled'.",
    "5579": "A=Column number. This will be the preferred column number.",
    "5580": "B=Row number, C=Number of editing rows on screen.",
    "5582": "C=Row number.",
    "5583": "B=Column number.",
    "5584": "Store this as the current cursor editing position.",
    "5587": "B=Row number, C=Number of editing rows on screen.",
    "5588": "DE=Start address in Screen Line Edit Buffer of the next row.",
    "5589": "A=Number of editing rows on screen.",
    "5590": "Next row.",
    "5591": "Reached the bottom screen row?",
    "5592": "Jump back if not to display the next row.",
    "5594": "Listing flags.",
    "5597": "Has the current line been previously found?",
    "5599": "Jump if so.",
    "5601": "Is this the current line?",
    "5603": "Jump if so.",
    "5605": "Current line number.",
    "5610": "Jump if there is no current line number.",
    "5612": "Store it as the line number at top of the screen.",
    "5615": "Set default Above-Screen Line Edit Buffer settings to clear the count of the number of rows it contains.",
    "5618": "Jump forward.",
    "5623": "Create line number representation in the Keyword Construction Buffer of the next BASIC line.",
    "5620": "Set the line number at top of the screen to $0000, i.e. first available.",
    "5626": "Current line number is the first in the BASIC program.",
    "5629": "DE=Start address in Screen Line Edit Buffer of the first row.",
    "5630": "B=Row number, C=Number of editing rows on screen.",
    "5631": "Jump back to continue listing the program until the current line is found.",
    "5634": "Save the zero flag.",
    "5635": "Save the number of editing rows on screen.",
    "5636": "Set the zero flag if current line has yet to be found, hence signal do not update cursor position settings.",
    "5637": "Save the zero flag.",
    "5638": "Save the number of editing rows on screen.",
    "5639": "C=Row number.",
    "5640": "DE=Start address in Screen Line Edit Buffer of row held in C",
    "5643": "and transfer into HL.",
    "5644": "A=Number of editing rows on screen.",
    "5645": "Print a row of the edit buffer to the screen.",
    "5649": "Point to the start of the next row.",
    "5655": "Jump back if not to print next row.",
    "5654": "All rows printed?",
    "5653": "Advance to the next row.",
    "5657": "Retrieve the zero flag.",
    "5658": "Return if 'not the current line' and 'current line has previously been found'.",
    "5659": "Get current cursor position (C=row, B=column, A=preferred column).",
    "5662": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary. Returns column number in B.",
    "5665": "Fetch the number of editable characters on this row prior to the cursor.",
    "5668": "Decrement the count.",
    "5669": "Are there any characters?",
    "5671": "Store the new count.",
    "5674": "Jump if there are some characters prior to the cursor.",
    "5676": "Store cursor editing position, with preferred column of 0.",
    "5679": "[Redundant byte]",
    "5680": "Top row of editing area.",
    "5682": "The number of editing rows on screen.",
    "5685": "D=Number of rows in editing area.",
    "5686": "Clear specified display rows.",
    "5689": "Row number to start shifting from.",
    "5691": "Save the address of the 'Bottom Row Scroll Threshold' within the editing area information.",
    "5692": "Find the address of row 0.",
    "5693": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "5696": "Attempt to shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer.",
    "5699": "Retrieve the address of the 'Bottom Row Scroll Threshold' within the editing area information.",
    "5700": "Return if the Above-Screen Line Edit Buffer is full, i.e. no edit buffer rows shifted.",
    "5701": "Shift up rows of the BASIC line in Below-Screen Line Edit Buffer, inserting the next line BASIC line if the buffer becomes empty. Returns with HL holding the address of the first row in the Below-Screen Line Edit Buffer.",
    "5704": "B=Row counter.",
    "5705": "HL=Address of first row in the Below-Screen Line Edit Buffer.",
    "5706": "DE=Address of the current row in the Screen Line Edit Buffer.",
    "5709": "HL=Address of the next row in the Screen Line Edit Buffer.",
    "5713": "C=Number of editing rows on screen.",
    "5714": "Any rows to shift?",
    "5715": "Jump if not.",
    "5717": "C=Number of editing rows on screen.",
    "5718": "C=Number of editing rows on screen.",
    "5719": "DE=Current Screen Line Edit Buffer row, HL=Next Screen Line Edit Buffer row.",
    "5722": "Shift one row of the Screen Line Edit Buffer up.",
    "5724": "C=Number of editing rows on screen.",
    "5725": "Fetch the number of editing rows on screen.",
    "5726": "Next row.",
    "5727": "All rows shifted?",
    "5728": "Repeat for all edit buffer rows to shift.",
    "5730": "C=Number of editing rows on screen, B=Row number, i.e. 0.",
    "5731": "HL=Address of the first row in the Below-Screen Line Edit Buffer.",
    "5732": "Shift up all edit rows in the display file if updating required.",
    "5735": "HL=Address of the first row in the Below-Screen Line Edit Buffer, DE=Address of last row in Screen Line Edit Buffer.",
    "5738": "Copy the first row of the Below-Screen Line Edit Buffer into the last row of the Screen Line Edit Buffer.",
    "5740": "Signal that edit buffer rows were shifted.",
    "5741": "B=Row counter.",
    "5743": "Last row number to shift.",
    "5745": "Attempt to shift down the Above-Screen Line Edit Buffer, loading in a new BASIC line if it is empty.",
    "5748": "Return if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.",
    "5749": "B=Last row number to shift.",
    "5750": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "5751": "A=Number of editing rows on screen.",
    "5754": "C=Number of editing rows on screen.",
    "5755": "DE=Start address in Screen Line Edit Buffer of the last editing row.",
    "5758": "Shift down all rows in the Below-Screen Line Edit Buffer, or empty the buffer a row does not straggle off the bottom of the screen.",
    "5761": "Jump if the Below-Screen Line Edit Buffer is full.",
    "5763": "DE=Address of the last flag byte of the penultimate editing row in the Screen Line Edit Buffer.",
    "5764": "Length of an edit buffer row.",
    "5767": "HL=Address of the last flag byte of the last editing row in the Screen Line Edit Buffer.",
    "5768": "DE=Address of last flag byte of last editing row in Screen Line Edit Buffer, HL=Address of last flag byte of penultimate editing row in Screen Line Edit Buffer.",
    "5769": "C=Number of editing rows on screen, B=Last row number to shift.",
    "5771": "Any rows to shift?",
    "5772": "Jump if not.",
    "5774": "C=Row number to shift, B=Last row number to shift.",
    "5778": "Copy one row of the Screen Line Edit Buffer down.",
    "5780": "C=Number of editing rows on screen, B=Row shift counter.",
    "5781": "A=Row shift counter.",
    "5784": "Repeat for all edit buffer rows to shift.",
    "5786": "HL=Address of last flag byte of first editing row in Screen Line Edit Buffer, DE=Address of byte before start of first editing row in Screen Line Edit Buffer.",
    "5787": "DE=Start of first row in Screen Line Edit Buffer.",
    "5788": "C=Number of editing rows on screen, B=Last row number to shift.",
    "5789": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "5790": "Shift down all edit rows in the display file if updating required.",
    "5796": "Copy the next row of the Above-Screen Line Edit Buffer into the first row of the Screen Line Edit Buffer.",
    "5798": "Signal Below-Screen Line Edit Buffer is not full.",
    "5799": "B=Last row number to shift.",
    "5801": "Restore registers.",
    "5802": "B=Last row number to shift.",
    "5804": "Save DE.",
    "5807": "HL=Start column number.",
    "5808": "HL=Address of the starting column.",
    "5809": "Store the character to shift in.",
    "5810": "A=Start column number.",
    "5811": "Fetch a character from the row.",
    "5812": "Replace it with the character to shift in.",
    "5813": "Store the old character for use next time.",
    "5814": "Point to the next column.",
    "5816": "End of row reached?",
    "5818": "Jump if not to shift the next character.",
    "5820": "A=Character that was shifted out.",
    "5821": "Return with zero flag set if the character was $00.",
    "5823": "Restore DE",
    "5825": "Save DE.",
    "5826": "32 columns.",
    "5829": "Point to the flag byte for this row.",
    "5830": "Save it.",
    "5831": "Store the character to shift in.",
    "5832": "Maximum of 31 shifts.",
    "5834": "Jump ahead to start shifting.",
    "5836": "Fetch a character from the row.",
    "5837": "Replace it with the character to shift in.",
    "5838": "Store the old character for use next time.",
    "5839": "End column reached?",
    "5840": "Jump if so to exit.",
    "5842": "Decrement column counter.",
    "5843": "Point back a column.",
    "5844": "Loop back to shift the next character.",
    "5846": "A=Character that was shifted out.",
    "5847": "Return with zero flag set if the character was $00.",
    "5849": "Fetch address of next flag byte for the row.",
    "5850": "Restore DE.",
    "5852": "DEF FN    -> $178D (ROM 0)",
    "5853": "CAT       -> $17A6 (ROM 0)",
    "5854": "FORMAT    -> $179A (ROM 0)",
    "5855": "MOVE      -> $179D (ROM 0)",
    "5856": "ERASE     -> $17A3 (ROM 0)",
    "5857": "OPEN #    -> $1790 (ROM 0)",
    "5858": "CLOSE #   -> $1796 (ROM 0)",
    "5859": "MERGE     -> $1776 (ROM 0)",
    "5860": "VERIFY    -> $1775 (ROM 0)",
    "5861": "BEEP      -> $1777 (ROM 0)",
    "5862": "CIRCLE    -> $177B (ROM 0)",
    "5863": "INK       -> $177F (ROM 0)",
    "5864": "PAPER     -> $1780 (ROM 0)",
    "5865": "FLASH     -> $1781 (ROM 0)",
    "5866": "BRIGHT    -> $1782 (ROM 0)",
    "5867": "INVERSE   -> $1783 (ROM 0)",
    "5868": "OVER      -> $1784 (ROM 0)",
    "5869": "OUT       -> $1785 (ROM 0)",
    "5870": "LPRINT    -> $176D (ROM 0)",
    "5871": "LLIST     -> $1770 (ROM 0)",
    "5872": "STOP      -> $171E (ROM 0)",
    "5873": "READ      -> $175D (ROM 0)",
    "5874": "DATA      -> $1760 (ROM 0)",
    "5875": "RESTORE   -> $1763 (ROM 0)",
    "5876": "NEW       -> $173C (ROM 0)",
    "5877": "BORDER    -> $1789 (ROM 0)",
    "5878": "CONTINUE  -> $174C (ROM 0)",
    "5879": "DIM       -> $1736 (ROM 0)",
    "5880": "REM       -> $1739 (ROM 0)",
    "5881": "FOR       -> $1724 (ROM 0)",
    "5882": "GO TO     -> $1711 (ROM 0)",
    "5883": "GO SUB    -> $171A (ROM 0)",
    "5884": "INPUT     -> $1733 (ROM 0)",
    "5885": "LOAD      -> $1774 (ROM 0)",
    "5886": "LIST      -> $1742 (ROM 0)",
    "5887": "LET       -> $170E (ROM 0)",
    "5888": "PAUSE     -> $1759 (ROM 0)",
    "5889": "NEXT      -> $172C (ROM 0)",
    "5890": "POKE      -> $1745 (ROM 0)",
    "5891": "PRINT     -> $1730 (ROM 0)",
    "5892": "PLOT      -> $1755 (ROM 0)",
    "5893": "RUN       -> $173F (ROM 0)",
    "5894": "SAVE      -> $1773 (ROM 0)",
    "5895": "RANDOMIZE -> $1749 (ROM 0)",
    "5896": "IF        -> $1715 (ROM 0)",
    "5897": "CLS       -> $1752 (ROM 0)",
    "5898": "DRAW      -> $1766 (ROM 0)",
    "5899": "CLEAR     -> $174F (ROM 0)",
    "5900": "RETURN    -> $1721 (ROM 0)",
    "5901": "COPY      -> $176A (ROM 0)",
    "5902": "LET: CLASS-01, \"=\", CLASS-02",
    "5905": "GOTO: CLASS-06, CLASS-00",
    "5909": "IF: CLASS-06, \"THEN\", CLASS-0E",
    "5914": "GO SUB: CLASS-06, CLASS-0C",
    "5918": "STOP: CLASS-00",
    "5921": "RETURN: CLASS-0C",
    "5924": "FOR: CLASS-04, \"=\", CLASS-06, \"TO\", CLASS-06, CLASS-0E",
    "5932": "NEXT: CLASS-04",
    "5936": "PRINT: CLASS-0E",
    "5939": "INPUT: CLASS-0E",
    "5942": "DIM: CLASS-0E",
    "5945": "REM: CLASS-0E",
    "5948": "NEW: CLASS-0C",
    "5951": "RUN: CLASS-0D",
    "5954": "LIST: CLASS-0E",
    "5957": "POKE: CLASS-08, CLASS-00",
    "5961": "RANDOMIZE: CLASS-03",
    "5964": "CONTINUE: CLASS-00",
    "5967": "CLEAR: CLASS-0D",
    "5970": "CLS: CLASS-00",
    "5973": "PLOT: CLASS-09, CLASS-00",
    "5977": "PAUSE: CLASS-06, CLASS-00",
    "5981": "READ: CLASS-0E",
    "5984": "DATA: CLASS-0E",
    "5987": "RESTORE: CLASS-03",
    "5990": "DRAW: CLASS-09, CLASS-0E",
    "5994": "COPY: CLASS-0C",
    "5997": "LPRINT: CLASS-0E",
    "6000": "LLIST: CLASS-0E",
    "6003": "SAVE: CLASS-0B",
    "6004": "LOAD: CLASS-0B",
    "6005": "VIRIFY: CLASS-0B",
    "6006": "MERGE: CLASS-0B",
    "6007": "BEEP: CLASS-08, CLASS-00",
    "6011": "CIRCLE: CLASS-09, CLASS-0E",
    "6015": "INK: CLASS-07",
    "6016": "PAPER: CLASS-07",
    "6017": "FLASH: CLASS-07",
    "6018": "BRIGHT: CLASS-07",
    "6019": "INVERSE: CLASS-07",
    "6020": "OVER: CLASS-07",
    "6021": "OUT: CLASS-08, CLASS-00",
    "6025": "BORDER: CLASS-06, CLASS-00",
    "6029": "DEF FN: CLASS-0E",
    "6032": "OPEN #: CLASS-06, \",\", CLASS-0A, CLASS-00",
    "6038": "CLOSE #: CLASS-06, CLASS-00",
    "6042": "FORMAT: CLASS-0E",
    "6045": "MOVE: CLASS-0A, \",\" CLASS-0A, CLASS-0C",
    "6051": "ERASE: CLASS-0E",
    "6054": "CAT: CLASS-0E",
    "6057": "SPECTRUM: CLASS-0C",
    "6060": "PLAY: CLASS-0E",
    "6063": "Signal 'syntax checking'.",
    "6068": "CH-ADD is made to point to the first code after any line number",
    "6071": "Set to $00.",
    "6075": "Set to $FF.",
    "6078": "Jump forward to consider the first statement of the line.",
    "6080": "Advance CH-ADD along the line.",
    "6082": "The work space is cleared.",
    "6084": "Increase SUBPPC on each passage around the loop.",
    "6087": "Only '127' statements are allowed in a single line. Jump to report \"C Nonsense in BASIC\".",
    "6090": "Fetch a character.",
    "6091": "Clear the register for later.",
    "6093": "Is the character a 'carriage return'?",
    "6095": "jump if it is.",
    "6098": "Go around the loop again if it is a ':'.",
    "6102": "Pre-load the machine stack with the return address.",
    "6106": "Save the command temporarily",
    "6107": "in the C register whilst CH-ADD is advanced again.",
    "6109": "Reduce the command's code by $CE giving the range indexed from $00.",
    "6111": "Jump for DEF FN and above.",
    "6118": "Is it 'SPECTRUM'?",
    "6120": "Jump if so into the scanning loop with this address.",
    "6125": "Is it 'PLAY'?",
    "6127": "Jump if so into the scanning loop with this address.",
    "6129": "Produce error report \"C Nonsense in BASIC\".",
    "6132": "Move the command code to BC (B holds $00).",
    "6133": "The base address of the syntax offset table.",
    "6138": "Find address for the command's entries in the parameter table.",
    "6139": "Jump forward into the scanning loop with this address.",
    "6144": "Fetch each entry in turn.",
    "6145": "Update the pointer to the entries for the next pass.",
    "6149": "Pre-load the machine stack with the return address.",
    "6153": "Copy the entry to the C register for later.",
    "6156": "Jump forward if the entry is a 'separator'.",
    "6163": "Index into the table.",
    "6165": "HL=base + code + (base + code).",
    "6166": "HL=The starting address of the required command class routine.",
    "6167": "Before making an indirect jump to the command class routine pass the command code",
    "6168": "to the A register and set the B register to $FF.",
    "6169": "Return to the stacked address.",
    "6170": "The current character is",
    "6171": "fetched and compared to the entry in the parameter table.",
    "6172": "Give the error report if there is not a match.",
    "6175": "Step past a correct character",
    "6176": "and return.",
    "6177": "Check for BREAK",
    "6180": "Jump if not pressed.",
    "6182": "Produce error report.",
    "6185": "\"L Break into program\"",
    "6186": "NSPPC - statement number in line to be jumped to",
    "6190": "Jump forward if there is not a 'jump' to be made.",
    "6193": "NEWPPC, line number to be jumped to.",
    "6198": "Jump forward unless dealing with a further statement in the editing area.",
    "6200": "A line in the editing area is considered as line '-2'.",
    "6206": "Make HL point to the end marker of the editing area.",
    "6210": "Make DE point to the location before the end marker of the editing area.",
    "6215": "Fetch the number of the next statement to be handled.",
    "6218": "Jump forward.",
    "6221": "The starting address of the line, or the 'first line after' is found.",
    "6223": "Collect the statement number.",
    "6226": "Jump forward if the required line was found.",
    "6228": "Check the validity of the statement number - must be zero.",
    "6229": "Jump if not to produce error report \"N Statement lost\".",
    "6231": "Also check that the 'first",
    "6232": "line after' is not after the",
    "6233": "actual 'end of program'.",
    "6236": "Jump forward with valid addresses; otherwise signal the error 'OK'.",
    "6238": "Produce error report.",
    "6241": "\"0 OK\"",
    "6242": "Drop the statement return address.",
    "6247": "Return if syntax is being checked.",
    "6255": "Signal 'statement zero' before proceeding.",
    "6251": "Return if the address is after the end of the program - the 'run' is finished.",
    "6256": "Statement zero becomes statement 1.",
    "6260": "The line number of the line to be used is collected and",
    "6261": "passed to PPC.",
    "6268": "Now find the 'length' of the line.",
    "6271": "Switch over the values.",
    "6272": "Form the address of the start of the line after in HL and the",
    "6273": "location before the 'next' line's first character in DE.",
    "6274": "Set NXTLIN for use once the current line has been completed.",
    "6278": "CH_ADD points to the location before the first character to be considered.",
    "6281": "The statement number is fetched.",
    "6282": "The E register is cleared in case the 'Each Statement' routine is used.",
    "6284": "Signal 'no jump'.",
    "6289": "SUB_PPC. Statement number-1.",
    "6292": "Jump if the first statement.",
    "6295": "For later statements the 'starting address' has to be found.",
    "6299": "Jump forward unless the statement does not exist.",
    "6301": "Produce error report.",
    "6304": "\"N Statement lost\"",
    "6305": "Very like CHECK-END at 1BEE in ROM 1",
    "6309": "Return unless checking syntax.",
    "6310": "Drop scan loop and statement return addresses.",
    "6312": "Fetch the present character.",
    "6313": "Consider the 'next line' if",
    "6315": "it is a 'carriage return'.",
    "6317": "\":\". Consider the 'next statement'",
    "6319": "if it is a ':'.",
    "6322": "Otherwise there has been a syntax error so produce \"C Nonsense in BASIC\".",
    "6325": "CLASS-00 -> L18D9 = $24",
    "6326": "CLASS-01 -> L18F9 = $43",
    "6327": "CLASS-02 -> L18FD = $46",
    "6328": "CLASS-03 -> L18D6 = $1E",
    "6329": "CLASS-04 -> L1905 = $4C",
    "6330": "CLASS-05 -> L18DA = $20",
    "6331": "CLASS-06 -> L190E = $53",
    "6332": "CLASS-07 -> L191A = $5E",
    "6333": "CLASS-08 -> L190A = $4D",
    "6334": "CLASS-09 -> L1944 = $86",
    "6335": "CLASS-0A -> L1916 = $57",
    "6336": "CLASS-0B -> L1948 = $88",
    "6337": "CLASS-0C -> L18C7 = $06",
    "6338": "CLASS-0D -> L18C4 = $02",
    "6339": "CLASS-0E -> L18C8 = $05",
    "6340": "Code 0D enters here.",
    "6343": "Code 0C enters here. Set zero flag.",
    "6344": "Code 0E enters here. Retrieve return address.",
    "6345": "If handling commands of classes 0C & 0D and syntax is being checked move on now to consider the next statement.",
    "6348": "Save the line pointer in DE.",
    "6352": "Fetch the pointer to the entries in the parameter table",
    "6353": "and fetch the address of the",
    "6354": "required command routine.",
    "6355": "Exchange the pointers back.",
    "6356": "Make an indirect jump to the command routine.",
    "6358": "Code 03 enters here.",
    "6359": "A number is fetched but zero is used in cases of default.",
    "6361": "Code 00 enters here. Set the zero flag.",
    "6362": "Code 05 enters here. Drop return address.",
    "6363": "If handling commands of classes 00 & 03 and syntax is being checked move on now to consider the next statement.",
    "6366": "Save the line pointer in DE.",
    "6367": "Fetch the pointer to the entries in the parameter table.",
    "6372": "Fetch the address of the required command routine.",
    "6373": "Exchange the pointers back.",
    "6374": "Save command routine address.",
    "6375": "The address to return to (the RET below).",
    "6378": "Store the return address.",
    "6381": "Paging subroutine.",
    "6384": "Replace the return address with the address of the YOUNGER routine.",
    "6385": "Save the original top stack item.",
    "6387": "HL=Address of command routine.",
    "6388": "Put onto the stack so that an indirect jump will be made to it.",
    "6389": "Switch to other ROM and 'return' to the command routine.",
    "6393": "Delegate handling to ROM 1.",
    "6397": "Code 02 enters here. Delegate handling to ROM 1.",
    "6399": "\"... used by LET, READ and INPUT statements to first evaluate and then assign values to the previously designated variable\" (Logan/O'Hara)",
    "6401": "Move on to the next statement if checking syntax",
    "6404": "else return here.",
    "6405": "Code 04 enters here. Delegate handling to ROM 1.",
    "6409": "[Redundant byte]",
    "6410": "Delegate handling to ROM 1.",
    "6414": "Code 06 enters here. Delegate handling to ROM 1.",
    "6418": "Produce error report. [Could have saved 4 bytes by using the identical routine at $1219 (ROM 0) instead]",
    "6421": "\"C Nonsense in BASIC\"",
    "6422": "Code 0A enters here. Delegate handling to ROM 1.",
    "6426": "The syntax/run flag is read.",
    "6430": "TV_FLAG. Signal 'main screen'.",
    "6434": "Jump ahead if syntax checking.",
    "6436": "Only during a 'run' call TEMPS to ensure the temporary",
    "6437": "colours are the main screen colours.",
    "6439": "Drop the return address.",
    "6443": "Reduce to range $D9-$DE which are the token codes for INK to OVER.",
    "6446": "Change the temporary colours as directed by the BASIC statement.",
    "6448": "Move on to the next statement if checking syntax.",
    "6451": "Now the temporary colour",
    "6454": "values are made permanent",
    "6460": "Value of P_FLAG also has to be considered.",
    "6461": "Move the mask leftwards.",
    "6462": "Impress onto the mask",
    "6463": "only the even bits of the",
    "6465": "other byte.",
    "6466": "Restore the result.",
    "6469": "Code 09 enters here. Delegate handling to ROM 1.",
    "6472": "Drop the return address.",
    "6476": "Clear LOAD/SAVE/VERIFY/MERGE indication bits.",
    "6484": "Correct by $74 so that SAVE = $00, LOAD = $01, VERIFY = $02, MERGE = $03.",
    "6489": "Jump to handle SAVE.",
    "6493": "Jump to handle LOAD.",
    "6497": "Jump to handle VERIFY.",
    "6500": "Jump to handle MERGE.",
    "6503": "Drop the return address.",
    "6508": "Jump forward if checking syntax.",
    "6516": "The present 'last value' is deleted.",
    "6513": "-5",
    "6517": "HL point to the first byte of the value.",
    "6521": "Is the value zero?",
    "6523": "If the value was 'FALSE' jump to the next line.",
    "6526": "But if 'TRUE' jump to the next statement (after the THEN).",
    "6529": "Jump forward unless a 'STEP' is given.",
    "6533": "Advance pointer",
    "6534": "Indirectly call EXPT_1NUM in ROM 1 to get the value of the STEP.",
    "6537": "Move on to the next statement if checking syntax.",
    "6540": "Otherwise jump forward.",
    "6542": "Move on to the next statement if checking syntax.",
    "6560": "Place a value of 1 on the calculator stack.",
    "6570": "Come here on each pass, after the first, to move along the READ statement.",
    "6571": "Indirectly call CLASS_01 in ROM 1 to consider whether the variable has been used before, and find the existing entry if it has.",
    "6578": "Jump forward if checking syntax.",
    "6581": "Save the current pointer CH_ADD in X_PTR.",
    "6584": "Fetch the current DATA list pointer",
    "6587": "and jump forward unless a new",
    "6590": "DATA statement has to be found.",
    "6592": "The search is for 'DATA'.",
    "6597": "Jump forward if the search is successful.",
    "6599": "Produce error report.",
    "6602": "\"E Out of Data\"",
    "6603": "Advance the pointer along the DATA list.",
    "6609": "Fetch the value and assign it to the variable.",
    "6615": "Fetch the current value of CH_ADD and store it in DATADD.",
    "6618": "X_PTR_hi. Clear the address of the character after the '?' marker.",
    "6622": "Make CH-ADD once again point to the READ statement.",
    "6626": "GET the present character",
    "6627": "Check if it is a ','.",
    "6629": "If it is then jump back as there are further items.",
    "6631": "Return if checking syntax",
    "6634": "or here if not checking syntax.",
    "6635": "Jump forward unless checking syntax.",
    "6642": "Scan the next expression.",
    "6644": "Check for the correct separator ','.",
    "6646": "but move on to the next statement if not matched.",
    "6649": "Whilst there are still expressions to be checked",
    "6650": "go around again.",
    "6652": "It is a 'DATA' statement that is to be passed-by.",
    "6655": "Delegate handling to ROM 1.",
    "6661": "Now perform a 'RESTORE 0'.",
    "6667": "Exit via the CLEAR command routine.",
    "6670": "Fetch the operand - using zero by default.",
    "6672": "Jump forward if the operand is",
    "6673": "other than zero. When called",
    "6674": "from RUN there is no jump.",
    "6676": "Use RAMTOP if the parameter is 0.",
    "6680": "BC = Address to clear to. Save it.",
    "6689": "Delete the variables area.",
    "6692": "Clear the screen",
    "6695": "The current value of STKEND",
    "6698": "is increased by 50 before",
    "6701": "being tested. This forms the",
    "6702": "ADE = address to clear to lower limit.",
    "6705": "Ramtop no good.",
    "6707": "For the upper test the value",
    "6710": "for RAMTOP is tested against P_RAMT.",
    "6713": "Jump forward if acceptable.",
    "6715": "Produce error report.",
    "6718": "\"M Ramtop no good\"",
    "6723": "Retrieve interpreter return address from stack",
    "6724": "Retrieve 'error address' from stack",
    "6725": "Retrieve the GO SUB stack end marker. [*BUG* - It is assumed that the top of the GO SUB stack will be empty and hence only contain the end marker. This will not be the case if CLEAR is used within a subroutine, in which case BC will now hold the calling line number and this will be stacked in place of the end marker. When a RETURN command is encountered, the GO SUB stack appears to contain an entry since the end marker was not the top item. An attempt to return is therefore made. The CLEAR command handler within the 48K Spectrum ROM does not make any assumption about the contents of the GO SUB stack and instead always re-inserts the end marker. The bug could be fixed by inserting the line LD BC,$3E00 after the POP BC. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "6731": "Stack the GO SUB stack end marker.",
    "6732": "Stack 'error address'.",
    "6737": "Stack the interpreter return address.",
    "6739": "Save the return address.",
    "6740": "SUBPPC. Fetch the statement number and increment it.",
    "6744": "Exchange the 'error address' with the statement number.",
    "6745": "Reclaim the use of a location.",
    "6750": "Next save the present line number.",
    "6751": "Return the 'error address' to the machine stack",
    "6752": "and reset ERR-SP to point to it.",
    "6756": "Stack the return address.",
    "6758": "Now set NEWPPC & NSPPC to the required values.",
    "6760": "But before making the jump make a test for room.",
    "6764": "Will automatically produce error '4' if out of memory.",
    "6767": "Fetch the return address.",
    "6768": "Fetch the 'error address'.",
    "6769": "Fetch the last entry on the GO SUB stack.",
    "6770": "The entry is tested to see if",
    "6771": "it is the GO SUB stack end marker.",
    "6773": "Jump if it is.",
    "6775": "The full entry uses three locations only.",
    "6776": "Exchange the statement number with the 'error address'.",
    "6777": "Move the statement number.",
    "6778": "Reset the error pointer.",
    "6782": "Replace the return address.",
    "6783": "Enter the line number.",
    "6786": "Enter the statement number.",
    "6790": "Replace the end marker and",
    "6791": "the 'error address'.",
    "6792": "Produce error report.",
    "6795": "\"7 RETURN without GO SUB\"",
    "6800": "Jump forward if checking syntax.",
    "6802": "Otherwise bass-by the",
    "6804": "'DEF FN' statement.",
    "6807": "Signal 'a numeric variable'.",
    "6812": "Check that the present code is a letter.",
    "6814": "Jump forward if not.",
    "6816": "Fetch the next character.",
    "6819": "Jump forward unless it is a '$'.",
    "6821": "Change bit 6 as it is a string variable.",
    "6825": "Fetch the next character.",
    "6826": "A '(' must follow the variable's name.",
    "6828": "Jump forward if not.",
    "6830": "Fetch the next character",
    "6833": "as there are no parameters of the function.",
    "6831": "Jump forward if it is a ')'",
    "6838": "The present code must be a letter.",
    "6841": "Save the pointer in DE.",
    "6842": "Fetch the next character.",
    "6847": "Otherwise save the new pointer in DE instead.",
    "6845": "Jump forward unless it is a '$'.",
    "6848": "Fetch the next character.",
    "6849": "Move the pointer to the last character of the name to HL.",
    "6850": "Now make six locations after that last character.",
    "6858": "Enter a 'number marker' into the first of the new locations.",
    "6860": "If the present character is a ',' then jump back as",
    "6862": "there should be a further parameter.",
    "6865": "Otherwise jump out of the loop.",
    "6867": "Check that the ')' does exist.",
    "6869": "Jump if not.",
    "6871": "The next character is fetched.",
    "6872": "It must be an '='.",
    "6874": "Jump if not.",
    "6876": "Fetch the next character.",
    "6880": "Save the nature (numeric or string) of the variable",
    "6881": "Now consider the definition as an expression.",
    "6884": "Fetch the nature of the variable.",
    "6885": "FLAGS. Check that it is of the same type",
    "6888": "as found for the definition.",
    "6890": "Give an error report if required.",
    "6893": "Move on to consider the next statement in the line.",
    "6896": "Simply return.",
    "6897": "Fetch mode.",
    "6900": "Set Tape Loader mode.",
    "6902": "Use Normal RAM Configuration (physical RAM bank 0).",
    "6906": "Clear out editing area.",
    "6911": "Create 3 bytes of space for the LOAD \"\" command.",
    "6917": "Address of command bytes for LOAD \"\".",
    "6927": "Copy LOAD \"\" into the line editing area.",
    "6929": "Parse and execute the BASIC line. [Will not return here but will exit via the error handler routine]",
    "6932": "Use Normal RAM Configuration (physical RAM bank 0).",
    "6936": "Clear out editing area.",
    "6941": "Create 1 byte of space.",
    "6950": "Copy LLIST into the line editing area.",
    "6952": "Parse and execute the BASIC line. [Will not return here but will exit via the error handler routine]",
    "6955": "Overwrite 'P' channel data to use the ZX Printer.",
    "6958": "Purge the stack.",
    "6963": "The main execution loop within ROM 1.",
    "6967": "Address of a $FF byte within ROM 1, used to generate error report \"0 OK\".",
    "6971": "The address of the error handler within ROM 1.",
    "6975": "Force 48K mode.",
    "6980": "Swap to ROM 1 and return via a RST $08 / DEFB $FF.",
    "6983": "Stack a $0000 address to return to.",
    "6987": "Force 48 mode.",
    "6992": "Swap to ROM 1, return to $0000.",
    "7005": "HL=$000A, DE=Address 'S' channel data.",
    "7001": "HL=Address 'S' channel data.",
    "7006": "HL=Address 'P' channel data.",
    "7007": "DE=Address 'P' channel data, HL=Address 'S' channel data.",
    "7011": "Copy the 'S' channel data over the 'P' channel data.",
    "7013": "FLAGS2. Signal caps lock unset. [Not really necessary for switching back to 48 BASIC mode]",
    "7017": "FLAGS. Signal not 128K mode.",
    "7022": "LOAD \"\"",
    "7025": "Printer channel.",
    "7027": "Jump ahead to join LIST.",
    "7029": "Main screen channel.",
    "7031": "TV_FLAG. Signal 'an ordinary listing in the main part of the screen'.",
    "7044": "[Could just do RST $18]",
    "7041": "Open the channel.",
    "7038": "Do not open the channel if checking syntax.",
    "7047": "See if the stream is to be changed.",
    "7052": "Get current character.",
    "7054": "Is it a ';'?",
    "7056": "Jump if it is.",
    "7058": "Is it a ','?",
    "7060": "Jump if it is not.",
    "7063": "Get the next character.",
    "7065": "Indirectly call EXPT-1NUM in ROM 1 to check that",
    "7068": "a numeric expression follows, e.g. LIST #5,20.",
    "7071": "Otherwise use zero and",
    "7073": "jump forward.",
    "7076": "Fetch any line or use zero if none supplied.",
    "7078": "If checking the syntax of the edit-line move on to the next statement.",
    "7082": "Delegate handling to ROM 1.",
    "7085": "Save SP.",
    "7089": "Use temporary stack.",
    "7092": "Create new catalogue entry.",
    "7095": "Get the length of the file.",
    "7099": "-9 (9 is the length of the file header).",
    "7102": "Extend the negative number into the high byte.",
    "7104": "AHL=-(length of file + 9).",
    "7106": "Check for space in RAM disk (produce \"4 Out of memory\" if no room).",
    "7109": "File header length.",
    "7112": "Address of file header.",
    "7115": "Store file header to RAM disk.",
    "7118": "Start address of file data.",
    "7121": "Length of file data.",
    "7125": "Store bytes to RAM disk.",
    "7128": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "7131": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7136": "Use original stack.",
    "7142": "Get the current character.",
    "7144": "Is it '!'?",
    "7146": "Jump to \"C Nonsense in BASIC\" if not.",
    "7150": "Get the next character.",
    "7152": "Check for end of statement.",
    "7155": "Select main screen.",
    "7160": "Store SP.",
    "7164": "Use temporary stack.",
    "7167": "Print out the catalogue.",
    "7170": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7175": "Use original stack.",
    "7181": "Get character from BASIC line.",
    "7183": "Is it '!'?",
    "7185": "Jump to \"C Nonsense in BASIC\" if not.",
    "7188": "Get the filename into N_STR1.",
    "7191": "Make sure we've reached the end of the BASIC statement.",
    "7194": "Store SP.",
    "7198": "Use temporary stack.",
    "7201": "Do the actual erasing (leaves logical RAM bank 4 paged in).",
    "7204": "Restore RAM configuration.",
    "7206": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7209": "Use original stack.",
    "7214": "Store SP.",
    "7218": "Use temporary stack.",
    "7221": "Find file (return details pointed to by IX). Leaves logical RAM bank 4 paged in.",
    "7224": "Load 9 header bytes.",
    "7230": "Load bytes from RAM disk.",
    "7233": "Restore RAM configuration.",
    "7235": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7238": "Use original stack.",
    "7243": "Store SP",
    "7247": "Use temporary stack.",
    "7251": "BC=Length.",
    "7252": "Load bytes from RAM disk.",
    "7255": "Update catalogue entry (leaves logical RAM bank 4 paged in).",
    "7258": "Restore RAM configuration.",
    "7260": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7263": "Use original stack.",
    "7268": "Save BC and HL.",
    "7270": "Physical banks used by RAM disk.",
    "7275": "BC=Logical RAM bank.",
    "7276": "Point to table entry.",
    "7277": "Look up physical page.",
    "7278": "Disable interrupts whilst paging.",
    "7279": "Fetch the current configuration.",
    "7282": "Mask off current RAM bank.",
    "7284": "Include new RAM bank.",
    "7285": "Store the new configuration.",
    "7291": "Perform the page.",
    "7293": "Re-enable interrupts.",
    "7294": "Restore BC and HL.",
    "7297": "Logical bank $00, $01, $02, $03, $04, $05",
    "7309": "Maximum of 10 characters.",
    "7313": "compare each character.",
    "7315": "Return if characters are different.",
    "7316": "Repeat for all characters of the filename.",
    "7319": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "7322": "Jump ahead if does not exist.",
    "7324": "Produce error report.",
    "7327": "\"e File already exists\"",
    "7330": "16384-20 (maximum size of RAM disk catalogue).",
    "7333": "IX grows downwards as new RAM disk catalogue entries added. If adding the maximum size to IX does not result in the carry flag being set then the catalogue is full, so issue an error report \"4 Out of Memory\".",
    "7337": "Jump if out of memory.",
    "7339": "-20 (20 bytes is the size of a RAM disk catalogue entry).",
    "7342": "Extend the negative number into the high byte.",
    "7344": "Ensure space in RAM disk area.",
    "7350": "Signal editing RAM disk catalogue.",
    "7354": "DE=Address of new catalogue entry.",
    "7355": "Filename.",
    "7358": "10 characters in the filename.",
    "7361": "Copy the filename.",
    "7363": "Indicate catalogue entry requires updating.",
    "7367": "Set the file access address to be the",
    "7370": "start address of the file.",
    "7385": "Set the fill length to zero.",
    "7397": "Logical RAM bank 5 (physical RAM bank 0).",
    "7402": "HL=Address of new catalogue entry.",
    "7403": "-20 (20 bytes is the size of a catalogue entry).",
    "7407": "Store address of next free catalogue entry.",
    "7415": "A'HL=Requested space.",
    "7416": "ADE=Free space on RAM disk.",
    "7419": "CDE=Free space.",
    "7420": "AHL=Requested space.",
    "7421": "A negative adjustment, i.e. adding data?",
    "7423": "Jump ahead if so.",
    "7426": "AHL=Free space left.",
    "7427": "Store free space.",
    "7436": "Jump back to store free space if space left.",
    "7438": "Produce error report.",
    "7441": "\"4 Out of memory\"",
    "7444": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7447": "Point to first catalogue entry.",
    "7451": "Pointer to last catalogue entry.",
    "7455": "Clear carry flag.",
    "7458": "HL=First catalogue entry.",
    "7461": "Return with zero flag set if end of catalogue reached and hence filename not found.",
    "7462": "Test filename match with N_STR1 ($5B67).",
    "7465": "Jump ahead if names did not match.",
    "7467": "Reset zero flag to indicate filename exists.",
    "7470": "-20 bytes (20 bytes is the size of a catalogue entry).",
    "7473": "Point to the next directory entry.",
    "7475": "Test the next name.",
    "7477": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "7480": "Jump ahead if it exists.",
    "7485": "\"h File does not exist\"",
    "7482": "Produce error report.",
    "7486": "Take the current start address (bank + location)",
    "7489": "and store it as the current working address.",
    "7504": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7509": "[Could have saved 1 byte by using JP $1C64 (ROM 0)]",
    "7510": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7519": "Ignore if catalogue entry does not require updating.",
    "7520": "Indicate catalogue entry updated.",
    "7527": "Signal not editing RAM disk catalogue.",
    "7529": "Points to end address within logical RAM bank.",
    "7535": "Points to end logical RAM bank.",
    "7538": "Start address within logical RAM bank.",
    "7544": "Start logical RAM bank.",
    "7547": "Clear carry flag.",
    "7548": "HL=End address-Start address. Maximum difference fits within 14 bits.",
    "7550": "A=End logical RAM bank-Start logical RAM bank - 1 if addresses overlap.",
    "7551": "Work out how many full banks of 16K are being used.",
    "7555": "Place this in the upper two bits of H.",
    "7561": "HL=Total length.",
    "7563": "Length within logical RAM bank.",
    "7572": "End address within logical RAM bank.",
    "7578": "End logical RAM bank.",
    "7581": "-20 bytes (20 bytes is the size of a catalogue entry).",
    "7584": "Address of next catalogue entry.",
    "7586": "Start address within logical RAM bank.",
    "7592": "Start logical RAM bank.",
    "7597": "Check whether a data length of zero was requested.",
    "7598": "Ignore if so since all bytes already saved.",
    "7599": "Save the source address.",
    "7600": "DE=The start of the upper RAM bank.",
    "7603": "HL=The start of the RAM bank. DE=Source address.",
    "7604": "HL=RAM bank start - Source address.",
    "7606": "Jump ahead if saving bytes from $C000.",
    "7608": "Jump ahead if saving bytes from an address above $C000.",
    "7610": "HL=Distance below $C000 (RAM bank start - Source address).",
    "7613": "Jump if requested bytes are all below $C000.",
    "7616": "HL=Requested length.",
    "7617": "BC=Distance below $C000.",
    "7619": "HL=Bytes occupying upper RAM bank.",
    "7621": "Stack it. HL=Source address.",
    "7622": "Start of upper RAM bank.",
    "7626": "Jump forward.",
    "7628": "Forget the 'distance below $C000' count.",
    "7629": "HL=Source address.",
    "7630": "Remaining bytes to transfer.",
    "7634": "Stack dummy Start of upper RAM bank.",
    "7635": "Jump forward.",
    "7638": "HL=Requested length.",
    "7639": "DE=Length of buffer.",
    "7643": "HL=Requested length-Length of buffer = Buffer overspill.",
    "7645": "Jump if requested length will fit within the buffer.",
    "7647": "Stack buffer overspill. HL=$0000.",
    "7649": "BC=Buffer length.",
    "7650": "Jump forward.",
    "7652": "HL=Destination address.",
    "7653": "Remaining bytes to transfer.",
    "7656": "Stack 'transfer buffer in use' flag.",
    "7657": "Stack the length.",
    "7658": "Transfer buffer",
    "7661": "Transfer bytes.",
    "7663": "BC=Length.",
    "7664": "HL=New source address.",
    "7665": "Transfer buffer.",
    "7668": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7676": "Fetch the address from the current logical RAM bank.",
    "7679": "Logical RAM bank.",
    "7682": "Page in appropriate logical RAM bank.",
    "7685": "Transfer a byte from the file to the required RAM disk location or transfer buffer.",
    "7688": "Has DE been incremented to $0000?",
    "7689": "Jump if end of RAM bank reached.",
    "7693": "Repeat until all bytes transferred.",
    "7698": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7704": "Store the next RAM bank source address.",
    "7709": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7712": "HL=Source address.",
    "7713": "BC=Length.",
    "7714": "Re-enter this routine to transfer another block.",
    "7718": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7721": "Increment to the new logical RAM bank.",
    "7724": "Fetch the new logical RAM bank.",
    "7727": "The start of the RAM disk",
    "7730": "Page in next RAM bank.",
    "7733": "Jump back to transfer another block.",
    "7735": "Check whether a data length of zero was requested.",
    "7737": "Ignore if so since all bytes already loaded.",
    "7738": "Save the destination address.",
    "7739": "DE=The start of the upper RAM bank.",
    "7742": "HL=The start of the RAM bank. DE=Destination address.",
    "7743": "HL=RAM bank start - Destination address.",
    "7745": "Jump if destination is $C000.",
    "7747": "Jump if destination is above $C000.",
    "7749": "HL=Distance below $C000 (RAM bank start - Destination address).",
    "7752": "Jump if requested bytes all fit below $C000.",
    "7755": "HL=Requested length.",
    "7756": "BC=Distance below $C000.",
    "7758": "HL=Bytes destined for upper RAM bank.",
    "7760": "Stack it. HL=Destination address.",
    "7761": "Remaining bytes to transfer.",
    "7765": "Start of upper RAM bank.",
    "7769": "HL=Start of upper RAM bank.",
    "7770": "Jump forward.",
    "7772": "Forget the 'distance below $C000' count.",
    "7773": "HL=Destination address.",
    "7774": "Remaining bytes to transfer.",
    "7778": "Stack dummy Start of upper RAM bank.",
    "7780": "HL=$0000, DE=Destination address.",
    "7781": "Jump forward.",
    "7784": "HL=Requested length.",
    "7785": "DE=Length of buffer.",
    "7789": "HL=Requested length-Length of buffer = Buffer overspill.",
    "7791": "Jump if requested length will fit within the buffer.",
    "7793": "Stack buffer overspill. HL=$0000.",
    "7795": "BC=Buffer length.",
    "7796": "Jump forward.",
    "7798": "HL=Destination address.",
    "7799": "Remaining bytes to transfer.",
    "7802": "Stack 'transfer buffer in use' flag.",
    "7803": "Stack the length.",
    "7804": "Stack destination address.",
    "7805": "Transfer buffer.",
    "7808": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7813": "RAM bank address.",
    "7819": "Logical RAM bank.",
    "7822": "Page in appropriate logical RAM bank.",
    "7825": "Transfer a byte from the file to the required location or transfer buffer.",
    "7828": "Has HL been incremented to $0000?",
    "7829": "Jump if end of RAM bank reached.",
    "7833": "Repeat until all bytes transferred.",
    "7836": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7844": "Store the next RAM bank destination address.",
    "7847": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7852": "DE=Destination address.",
    "7853": "BC=Length.",
    "7854": "Transfer buffer.",
    "7858": "All bytes transferred?",
    "7859": "Jump forward if so.",
    "7861": "Transfer code in buffer to the required address.",
    "7863": "HL=New destination address.",
    "7864": "BC=Remaining bytes to transfer.",
    "7865": "Re-enter this routine to transfer another block.",
    "7868": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "7873": "Increment to the new logical RAM bank.",
    "7876": "Fetch the new logical RAM bank.",
    "7879": "The start of the RAM disk.",
    "7882": "Page in next logical RAM bank.",
    "7885": "Jump back to transfer another block.",
    "7887": "Save AF.",
    "7888": "Fetch current physical RAM bank configuration.",
    "7891": "Save it.",
    "7892": "Save source address.",
    "7893": "Save destination address.",
    "7894": "Save length.",
    "7899": "Store destination address as the current address pointer.",
    "7905": "Destination is in logical RAM bank 4 (physical RAM bank 7).",
    "7909": "Store bytes to RAM disk.",
    "7912": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "7917": "Get length.",
    "7918": "Get destination address.",
    "7919": "Get source address.",
    "7920": "HL=Address after end of source.",
    "7921": "DE=Address after end of source. HL=Destination address.",
    "7922": "HL=Address after end of destination.",
    "7923": "HL=Address after end of source. DE=Address after end of destination.",
    "7924": "Get original RAM bank configuration.",
    "7928": "Disable interrupts whilst paging.",
    "7934": "Re-enable interrupts.",
    "7935": "Signal all bytes loaded/saved.",
    "7938": "Restore AF.",
    "7940": "Save AF.",
    "7941": "Fetch current physical RAM bank configuration.",
    "7944": "Save it.",
    "7945": "Save source address.",
    "7946": "Save destination address.",
    "7947": "Save length.",
    "7952": "Store source address as the current address pointer.",
    "7958": "Source is in logical RAM bank 4 (physical RAM bank 7).",
    "7962": "HL=Destination address.",
    "7963": "Load bytes from RAM disk.",
    "7966": "Join the save vector routine above.",
    "7968": "Save AF.",
    "7969": "Physical RAM bank 0.",
    "7971": "Disable interrupts whilst paging.",
    "7972": "Page in physical RAM bank 0.",
    "7975": "AF=Address on stack when CALLed.",
    "7976": "Store HL.",
    "7979": "Fetch the old stack.",
    "7982": "Save the current stack.",
    "7986": "Use the old stack.",
    "7987": "Re-enable interrupts.",
    "7988": "Restore HL.",
    "7991": "Get AF back.",
    "7994": "Save BC",
    "7998": "Perform requested paging.",
    "8003": "Restore BC.",
    "8005": "Save A.",
    "8006": "Disable interrupts whilst paging.",
    "8007": "Fetch return address.",
    "8008": "Store HL.",
    "8011": "Fetch the old stack.",
    "8014": "Save the current stack.",
    "8018": "Use the old stack.",
    "8019": "Restore HL.",
    "8022": "Stack return address.",
    "8023": "RAM bank 7.",
    "8025": "Page in RAM bank 7.",
    "8028": "Re-enable interrupts.",
    "8029": "Restore A.",
    "8031": "Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).",
    "8034": "Jump ahead if it was found. [Could have saved 3 bytes by using JP Z,$1D3E (ROM 0)]",
    "8036": "Produce error report.",
    "8039": "\"h File does not exist\"",
    "8040": "AHL=Length of file.",
    "8046": "Bit 7 of A will be 0 indicating to delete rather than add.",
    "8049": "Free up this amount of space.",
    "8052": "Preserve current value of IY.",
    "8054": "IY points to next free catalogue entry.",
    "8058": "BC=-20 (20 bytes is the size of a catalogue entry).",
    "8061": "IX points to the next catalogue entry",
    "8063": "AHL=First spare byte in RAM disk file area.",
    "8072": "Restore IY to normal value.",
    "8074": "BDE=Start of address of next RAM disk file entry.",
    "8097": "HL=Length of all files to be moved.",
    "8099": "20 bytes is the size of a catalogue entry.",
    "8102": "IX=Catalogue entry to delete.",
    "8104": "Store file length in the 'deleted' catalogue entry.",
    "8113": "-20 (20 bytes is the size of a catalogue entry).",
    "8116": "IX=Next catalogue entry.",
    "8118": "DHL=Start address of next RAM disk file entry.",
    "8127": "20 bytes is the size of a catalogue entry.",
    "8130": "IX points to catalogue entry to delete.",
    "8132": "Page in logical RAM bank for start address of entry to delete.",
    "8139": "Save current RAM bank configuration in E.",
    "8143": "Select physical RAM bank 7.",
    "8145": "Disable interrupts whilst performing paging operations.",
    "8146": "Page in selected RAM bank.",
    "8148": "DHL'=Start address of next RAM disk file entry.",
    "8149": "DHL=Start of address of RAM disk file entry to delete.",
    "8159": "Page in logical RAM bank for file entry (will update BANK_M).",
    "8165": "Get RAM bank configuration for the file in E.",
    "8169": "DHL=Start address of next RAM disk file entry.",
    "8170": "Select physical RAM bank 7.",
    "8172": "Disable interrupts whilst performing paging operations.",
    "8173": "Page in selected RAM bank.",
    "8175": "Decrement end address.",
    "8183": "If no carry then the decrement is finished.",
    "8185": "Otherwise decrement the middle byte.",
    "8193": "If no carry then the decrement is finished.",
    "8195": "Otherwise decrement the highest byte.",
    "8203": "Jump forward if finished moving the file.",
    "8205": "Page in RAM bank containing the next file.",
    "8207": "Get the byte from the next file.",
    "8208": "Increment DHL.",
    "8209": "If not zero then the increment is finished.",
    "8212": "If not zero then the increment is finished.",
    "8211": "Otherwise increment the middle byte.",
    "8214": "Save the byte read from the next file.",
    "8215": "Advance to next logical RAM bank for the next file.",
    "8217": "Page in next logical RAM bank for next file entry (will update BANK_M).",
    "8223": "Get RAM bank configuration for the next file in E.",
    "8224": "The next file continues at the beginning of the next RAM bank.",
    "8227": "Retrieve the byte read from the next file.",
    "8228": "DHL=Address of file being deleted.",
    "8229": "Disable interrupts whilst performing paging operations.",
    "8230": "Page in next RAM bank containing the next file.",
    "8232": "Store the byte taken from the next file.",
    "8233": "Increment DHL.",
    "8234": "If not zero then the increment is finished.",
    "8237": "If not zero then the increment is finished.",
    "8236": "Otherwise increment the middle byte.",
    "8239": "Advance to next logical RAM bank for the file being deleted.",
    "8241": "Page in next logical RAM bank for file being deleted entry (will update BANK_M).",
    "8247": "Get RAM bank configuration for the file being deleted in E.",
    "8248": "The file being deleted continues at the beginning of the next RAM bank.",
    "8251": "DHL'=Address of byte in file being deleted. DHL'=Address of byte in file being deleted.",
    "8254": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "8261": "AHL=20 bytes is the size of a catalogue entry.",
    "8264": "Delete a catalogue entry.",
    "8273": "CDE=File length of file entry to delete.",
    "8281": "C=RAM bank.",
    "8284": "Mask off upper bits to leave length in this bank (range 0-16383).",
    "8286": "DE=Length in this bank.",
    "8287": "Save address of catalogue entry to delete.",
    "8290": "-20 (20 bytes is the size of a catalogue entry).",
    "8293": "Point to next catalogue entry.",
    "8295": "DE=Length in this bank.",
    "8302": "AHL=File start address.",
    "8306": "Will move into next RAM bank?",
    "8311": "Jump if same RAM bank.",
    "8313": "New address in next RAM bank.",
    "8315": "Next RAM bank.",
    "8322": "Save new start address of file.",
    "8331": "Fetch end address of file.",
    "8335": "Will move into next RAM bank?",
    "8340": "Jump if same RAM bank.",
    "8342": "New address in next RAM bank.",
    "8344": "Next RAM bank.",
    "8351": "Save new end address of file.",
    "8356": "HL=Address of next catalogue entry.",
    "8363": "End of catalogue reached?",
    "8365": "DE=Length in this bank.",
    "8366": "Jump if not to move next entry.",
    "8368": "Start address of the next available catalogue entry.",
    "8373": "HL=Start address of catalogue entry to delete.",
    "8378": "BC=Length of catalogue entries to move.",
    "8379": "HL=Start address of catalogue entry to delete.",
    "8381": "20 bytes is the size of a catalogue entry.",
    "8384": "HL=Start address of previous catalogue entry.",
    "8385": "DE=Start address of previous catalogue entry.",
    "8386": "HL=Start address of catalogue entry to delete.",
    "8387": "DE=End address of catalogue entry to delete.",
    "8389": "Move all catalogue entries.",
    "8388": "HL=End address of next catalogue entry.",
    "8391": "Start address of the next available catalogue entry.",
    "8394": "20 bytes is the size of a catalogue entry.",
    "8398": "Store the new location of the next available catalogue entry.",
    "8402": "Page in logical RAM bank 4 (physical RAM bank 7)",
    "8407": "HL points to ten $00 bytes, the initial comparison filename.",
    "8410": "BC point to ten $FF bytes.",
    "8481": "Lowest theoretical filename.",
    "8491": "Highest theoretical filename.",
    "8413": "IX points to first catalogue entry.",
    "8417": "Check for BREAK.",
    "8420": "Save address of catalogue entry.",
    "8422": "HL points to current catalogue entry. Top of stack points to ten $00 data.",
    "8423": "Find address of next free catalogue entry.",
    "8428": "Have we reached end of catalogue?",
    "8430": "Fetch address of catalogue entry.",
    "8431": "Jump ahead if end of catalogue reached.",
    "8434": "DE=Current catalogue entry.",
    "8437": "Compare current filename (initially ten $00 bytes).",
    "8442": "Jump if current catalogue name is 'above' the previous.",
    "8445": "DE=Last filename",
    "8448": "Compare current filename (initially ten $FF bytes).",
    "8453": "Jump if current catalogue name is 'below' the previous.",
    "8457": "BC=Address of current catalogue entry name.",
    "8458": "-20 (20 bytes is the size of a catalogue entry).",
    "8461": "Point to next catalogue entry.",
    "8463": "Check next filename.",
    "8465": "HL points to current catalogue entry.",
    "8466": "Address of highest theoretical filename data.",
    "8470": "Was a new filename to print found?",
    "8473": "Return if all filenames printed.",
    "8475": "HL=Address of current catalogue entry name.",
    "8476": "Print the catalogue entry.",
    "8479": "Repeat for next filename.",
    "8501": "Save address of filename.",
    "8503": "[No need to transfer BC to HL since they already have the same value].",
    "8504": "Copy the filename to N_STR1 so that it",
    "8507": "is visible when this RAM bank is paged out.",
    "8512": "Page in logical RAM bank 5 (physical RAM bank 0).",
    "8520": "Save temporary stack.",
    "8524": "Use original stack.",
    "8525": "HL points to filename.",
    "8528": "10 characters to print.",
    "8530": "Print each character of the filename.",
    "8541": "Print a newline character.",
    "8547": "Copy permanent colours to temporary colours.",
    "8552": "Save original stack.",
    "8556": "Switch back to temporary stack.",
    "8559": "Page in logical RAM bank 4 (physical RAM bank 7).",
    "8562": "HL=Address of filename.",
    "8564": "Printer channel.",
    "8566": "Jump ahead.",
    "8568": "Main screen channel.",
    "8573": "Jump forward if syntax is being checked.",
    "8582": "Delegate handling to ROM 1.",
    "8584": "\"C Nonsense in BASIC\" during syntax checking if not",
    "8587": "at end of line or statement.",
    "8591": "Jump forward if syntax is being checked.",
    "8593": "Open channel 'K'.",
    "8599": "[*BUG* - This call will re-select channel 'S' and so should have been called prior to opening [*BUG* - This call will re-select channel 'S' and so should have been called prior to opening channel 'K'. It is a direct copy of the code that appears in the standard Spectrum ROM (and ROM 1). It is debatable whether it is better to reproduce the bug so as to ensure that the INPUT routine operates the same in 128K mode as it does in 48K mode. Credit: Geoff Wearmouth]",
    "8601": "TV_FLAG. Signal that the lower screen is being handled. [Not a bug as has been reported elsewhere. The confusion seems to have arisen due to the incorrect system variable being originally mentioned in the Spectrum ROM Disassembly by Logan and O'Hara]",
    "8606": "Call the subroutine to deal with the INPUT items.",
    "8608": "Move on to the next statement if checking syntax.",
    "8612": "Delegate handling to ROM 1.",
    "8615": "Jump to new COPY routine.",
    "8619": "Re-initialise the machine.",
    "8622": "Get character from BASIC line.",
    "8623": "\",\". Check for second parameter.",
    "8625": "Jump ahead (for error C) if not.",
    "8627": "Advance pointer into BASIC line.",
    "8628": "Get parameter.",
    "8629": "Radius to calculator stack.",
    "8631": "Move to consider next statement if checking syntax.",
    "8635": "Delegate handling to ROM 1.",
    "8638": "Get current character.",
    "8641": "Jump if there is a third parameter.",
    "8639": "\",\"",
    "8643": "Error C during syntax checking if not at end of line/statement.",
    "8647": "Delegate handling to ROM 1.",
    "8650": "Get the next character.",
    "8652": "Angle to calculator stack.",
    "8654": "Error C during syntax checking if not at end of line/statement.",
    "8658": "Delegate handling to ROM 1.",
    "8662": "Search to see if the array already exists.",
    "8664": "Jump if array variable not found.",
    "8669": "Jump ahead during syntax checking.",
    "8671": "Test the syntax for string arrays as if they were numeric.",
    "8674": "Check the syntax of the parenthesised expression.",
    "8676": "Error when checking syntax unless at end of line/statement.",
    "8680": "Delegate handling to ROM 1.",
    "8683": "Produce error report.",
    "8686": "\"C Nonsense in BASIC\"",
    "8687": "FLAGS2. Is the screen clear?",
    "8691": "Return if it is.",
    "8693": "Otherwise clear the whole display.",
    "8696": "A line in the editing area is considered as line '-2'.",
    "8699": "Signal no current line number.",
    "8702": "Indicate 'syntax checking' mode.",
    "8706": "Point to start of the BASIC command line.",
    "8710": "Evaluate the command line.",
    "8712": "Is it a numeric value?",
    "8716": "Jump to produce an error if a string result.",
    "8718": "Get current character.",
    "8719": "Is it the end of the line?",
    "8721": "Jump if not to produce an error.",
    "8723": "If so, indicate 'execution' mode.",
    "8727": "Point to start of the BASIC command line.",
    "8730": "Set up the error handler routine address.",
    "8737": "Evaluate the command line.",
    "8739": "Is it a numeric value?",
    "8743": "Jump to produce an error if a string result.",
    "8745": "DE points to last calculator value.",
    "8751": "The length of the floating point value.",
    "8755": "HL points to value on top of calculator stack.",
    "8757": "Copy the value in the workspace to the top of the calculator stack.",
    "8759": "[Could have saved 1 byte by using a JR instruction]",
    "8762": "Produce error report.",
    "8765": "\"Q Parameter error\"",
    "8766": "Make it appear that 'Enter' has been pressed.",
    "8768": "Process key press.",
    "8775": "Create a byte in the workspace.",
    "8777": "Address of the cursor.",
    "8780": "Save it.",
    "8784": "Save it.",
    "8781": "Current channel information.",
    "8785": "Channel 'R', the workspace.",
    "8791": "Print a floating point number to the workspace.",
    "8793": "Get the current channel information address.",
    "8795": "Set appropriate flags back for the old channel.",
    "8797": "DE=Address of the old cursor position.",
    "8798": "Address of the cursor.",
    "8802": "HL=Length of floating point number.",
    "8804": "Fetch the character and make it appear to have been typed.",
    "8805": "Process the key press.",
    "8809": "Decrement floating point number character count.",
    "8812": "Repeat for all characters.",
    "8815": "Save registers.",
    "8817": "Use Workspace RAM configuration (physical RAM bank 7).",
    "8820": "Editor flags.",
    "8823": "Reset 'line altered' flag",
    "8826": "Main screen",
    "8832": "Process key press.",
    "8835": "Editor flags.",
    "8838": "Reset 'line altered' flag",
    "8840": "Use Normal RAM Configuration (physical RAM bank 0).",
    "8843": "Restore registers.",
    "8846": "Get the address of command being typed in.",
    "8850": "Store it as the address of next character to be interpreted.",
    "8853": "Get the next character.",
    "8855": "Point to start of typed in command.",
    "8858": "Is it 'LET'?",
    "8860": "Return if not with zero flag reset.",
    "8861": "HL points to next character.",
    "8864": "Fetch next character.",
    "8866": "Has end of line been found?",
    "8868": "Return if so with zero flag set.",
    "8869": "\":\". Has start of new statement been found?",
    "8871": "Loop back if not.",
    "8873": "Return zero flag reset indicating a multi-statement",
    "8874": "LET command.",
    "8875": "Save B.",
    "8876": "Start of operator token table.",
    "8879": "Fetch character from the table.",
    "8880": "Advance to next entry.",
    "8881": "End of table?",
    "8882": "Jump if end of table reached.",
    "8884": "Found required character?",
    "8885": "Jump if not to try next character in table.",
    "8887": "Restore character to A.",
    "8888": "Return with zero flag set to indicate an operator.",
    "8889": "Reset zero flag to indicate not an operator.",
    "8891": "Restore character to A.",
    "8893": "'+',  '-',  '*', '/',  '^',  '=', '>',  '<',",
    "8901": "'<=', '>=', '<>', 'OR', 'AND', end marker",
    "8907": "'RND'. (first 48K token)",
    "8909": "Jump ahead if not a token with zero flag reset.",
    "8913": "Jump ahead if not a function token.",
    "8917": "Jump ahead if not a function token.",
    "8921": "Jump ahead if not a function token.",
    "8911": "'BIN'.",
    "8915": "'AT'.",
    "8919": "'TAB'.",
    "8923": "Return zero flag set if a function token.",
    "8925": "Return zero flag set if a function token.",
    "8928": "Fetch character code.",
    "8929": "Make lowercase.",
    "8931": "Is it 'a' or above?",
    "8933": "Jump ahead if not a letter.",
    "8935": "Is it below '{'?",
    "8937": "Jump ahead if not.",
    "8939": "Character is a letter so return",
    "8940": "with zero flag set.",
    "8941": "Fetch character code.",
    "8942": "Is it '.'?",
    "8944": "Return zero flag set indicating numeric.",
    "8945": "Is character a number?",
    "8948": "Jump ahead if not a number.",
    "8950": "Get next character.",
    "8951": "Is character a number?",
    "8954": "Repeat for next character if numeric.",
    "8956": "Is it '.'?",
    "8958": "Return zero flag set indicating numeric.",
    "8959": "Is it 'E'?",
    "8961": "Return zero flag set indicating  numeric.",
    "8962": "Is it 'e'?",
    "8964": "Return zero flag set indicating  numeric.",
    "8965": "Jump to test for operator tokens.",
    "8967": "Reset the zero flag to indicate non-alphanumeric.",
    "8970": "Is it below '0'?",
    "8972": "Jump below '0'.",
    "8974": "Is it below ':'?",
    "8976": "Jump above '9'",
    "8978": "Set zero flag if numeric.",
    "8980": "This will cause zero flag to be reset.",
    "8983": "String index.",
    "8988": "Get string expression.",
    "8992": "A ',' indicates another string.",
    "8994": "Jump ahead if no more.",
    "8996": "Advance to the next character.",
    "8997": "Loop back.",
    "8999": "Check the index.",
    "9000": "Maximum of 8 strings (to support synthesisers, drum machines or sequencers).",
    "9004": "Produce error report.",
    "9007": "\"p (c) 1986 Sinclair Research Ltd\" [*BUG* - This should be \"Parameter error\". The Spanish 128 produces \"p Bad parameter\" but to save memory perhaps the UK 128 was intended to use the existing \"Q Parameter error\" and the change of the error code byte here was overlooked. In that case it would have had a value of $19. Note that generation of this error when using the main screen editor will result in a crash. Credit: Andrew Owen]",
    "9008": "Ensure end-of-statement or end-of-line.",
    "9011": "Continue with PLAY code.",
    "9527": "Number of table entries.",
    "9528": "Key code: Cursor up.",
    "9529": "CURSOR-UP handler routine.",
    "9531": "Key code: Cursor Down.",
    "9532": "CURSOR-DOWN handler routine.",
    "9534": "Key code: Cursor Left.",
    "9535": "CURSOR-LEFT handler routine.",
    "9537": "Key code: Cursor Right.",
    "9538": "CURSOR-RIGHT handler routine.",
    "9540": "Key code: Extend Mode + P.",
    "9541": "TEN-ROWS-UP handler routine.",
    "9543": "Key code: Symbol Shift + I.",
    "9544": "TEN-ROWS-DOWN handler routine.",
    "9546": "Key code: Extend Mode + I.",
    "9547": "WORD-LEFT handler routine.",
    "9549": "Key code: Extend Mode + Shift + J.",
    "9550": "WORD-RIGHT handler routine.",
    "9552": "Key code: Extend Mode + N, or Graph + W.",
    "9553": "TOP-OF-PROGRAM handler routine.",
    "9555": "Key code: Extend Mode + T, or Graph + V.",
    "9556": "END-OF-PROGRAM handler routine.",
    "9558": "Key code: Extend Mode Symbol Shift + 2, or Graph Y.",
    "9559": "START-OF-LINE handler routine.",
    "9561": "Key code: Extend Mode + M, or Graph + X.",
    "9562": "END-OF-LINE handler routine.",
    "9564": "Key code: Extend Mode + Shift + K.",
    "9565": "DELETE-RIGHT handler routine.",
    "9567": "Key code: Delete.",
    "9568": "DELETE handler routine.",
    "9570": "Key code: Extend Mode + W.",
    "9571": "DELETE-WORD-RIGHT handler routine.",
    "9573": "Key code: Extend Mode + E.",
    "9574": "DELETE-WORD-LEFT handler routine.",
    "9576": "Key code: Extend Mode + J.",
    "9577": "DELETE-TO-END-OF-LINE handler routine.",
    "9579": "Key code: Extend Mode + K.",
    "9580": "DELETE-TO-START-OF-LINE handler routine.",
    "9582": "Key code: Enter.",
    "9583": "ENTER handler routine.",
    "9585": "Key code: Extend Mode + Symbol Shift + 8, or Graph + Z.",
    "9586": "TOGGLE handler routine.",
    "9588": "Key code: Edit.",
    "9589": "MENU handler routine.",
    "9591": "Number of entries.",
    "9592": "Key code: Cursor up.",
    "9593": "MENU-UP handler routine.",
    "9595": "Key code: Cursor down.",
    "9596": "MENU-DOWN handler routine.",
    "9598": "Key code: Edit.",
    "9599": "MENU-SELECT handler routine.",
    "9601": "Key code: Enter.",
    "9602": "MENU-SELECT handler routine.",
    "9604": "Reset Cursor Position.",
    "9607": "No top line.",
    "9610": "Line number at top of screen.",
    "9613": "Signal waiting for key press, and menu is displayed.",
    "9615": "Store the Editor flags.",
    "9618": "No current line number.",
    "9621": "Current line number.",
    "9624": "Reset indentation settings.",
    "9627": "Reset to 'L' Mode",
    "9630": "[Could have saved one byte by using JP $365E (ROM 0)]",
    "9637": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9640": "Select main screen.",
    "9645": "Jump table for Main Menu.",
    "9648": "Store current menu jump table address.",
    "9651": "The Main Menu text.",
    "9654": "Store current menu text table address.",
    "9657": "Store address of menu on stack.",
    "9658": "Editor flags.",
    "9661": "Indicate 'menu displayed'.",
    "9663": "Signal return to main menu.",
    "9665": "Current menu index.",
    "9666": "Select top entry.",
    "9668": "Retrieve address of menu.",
    "9669": "Display menu and highlight first item.",
    "9672": "Jump ahead to enter the main key waiting and processing loop.",
    "10052": "Number of entries.",
    "10054": "Tape Loader option handler.",
    "10057": "128 BASIC option handler.",
    "10060": "Calculator option handler.",
    "10063": "48 BASIC option handler.",
    "10066": "Tape Tester option handler.",
    "10068": "Number of entries.",
    "10069": "\"128     \"",
    "10078": "\"Tape Loader\"",
    "10089": "\"128 BASIC\"",
    "10098": "\"Calculator\"",
    "10116": "\"Tape Tester\" + end mark",
    "10128": "Number of entries.",
    "10130": "(Return to) 128 BASIC option handler.",
    "10133": "Renumber option handler.",
    "10136": "Screen option handler.",
    "10139": "Print option handler.",
    "10142": "Exit option handler.",
    "10145": "\"Options \", \"128 BASIC\", \"Renumber\",",
    "10161": "\"Screen\", \"Print, \"Exit\", end marker",
    "9675": "Point IX at editing settings information.",
    "9685": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9691": "Select main screen.",
    "9693": "Reset 'L' mode.",
    "9699": "Has a key been pressed?",
    "9701": "Wait for a key press.",
    "9703": "Editor flags.",
    "9706": "Signal line has not been altered.",
    "9708": "Is editing area the lower screen?",
    "9710": "If so then skip printing a banner and jump ahead to return to the Editor.",
    "9712": "Fetch mode.",
    "9715": "Calculator mode?",
    "9717": "Jump ahead if so.",
    "9719": "Edit Menu mode?",
    "9721": "Jump if not to re-display Main menu.",
    "9724": "Clear screen and print \"128 BASIC\" in the banner line.",
    "9727": "Jump ahead to return to the Editor.",
    "9729": "Clear screen and print \"Calculator\" in the banner line.",
    "9732": "Reset Below-Screen Line Edit Buffer settings to their default values.",
    "9735": "Reset Above-Screen Line Edit Buffer settings to their default values.",
    "9738": "Fetch the mode.",
    "9741": "Calculator mode?",
    "9743": "Jump ahead if not to wait for a key press.",
    "9745": "Fetch current line number.",
    "9749": "Is there a current line number?",
    "9750": "Jump ahead if so.",
    "9752": "Address of start of BASIC program.",
    "9755": "Address of start of variables area.",
    "9760": "HL=Length of program.",
    "9762": "Jump if a program exists.",
    "9767": "Set no line number last edited.",
    "9770": "Fetch line number of last edited line.",
    "9773": "Use Normal RAM Configuration (physical RAM bank 0).",
    "9777": "Find address of line number held in HL, or the next line if it does not exist.",
    "9780": "Find line number for specified address, and return in DE.",
    "9782": "Use Workspace RAM configuration (physical RAM bank 7).",
    "9785": "Save the current line number.",
    "9789": "Editor flags.",
    "9792": "Process the BASIC line?",
    "9794": "Jump ahead if calculator mode.",
    "9799": "Signal no editable characters in the line prior to the cursor.",
    "9802": "Relist the BASIC program.",
    "9805": "Set attribute at editing position so as to show the cursor.",
    "9808": "Call the ENTER handler routine.",
    "9811": "Use temporary stack.",
    "9814": "Reset 'L' mode.",
    "9817": "Wait for a key. [Note that it is possible to change CAPS LOCK mode whilst on a menu]",
    "9820": "Save key code.",
    "9821": "Tone of keyboard click.",
    "9824": "Produce a key click noise.",
    "9827": "Retrieve key code.",
    "9828": "Process the key press.",
    "9831": "Wait for another key.",
    "9833": "Editor flags.",
    "9836": "Is a menu displayed?",
    "9838": "Save key code and flags.",
    "9839": "Use menu keys lookup table",
    "9842": "Jump if menu is being displayed.",
    "9844": "Use editing keys lookup table.",
    "9847": "Find and call the action handler for this key press.",
    "9850": "Jump ahead if no match found.",
    "9852": "If required then produce error beep.",
    "9855": "Restore key code.",
    "9857": "Restore key code and flags.",
    "9858": "Jump if menu is not being displayed.",
    "9860": "Select 'L' mode.",
    "9865": "Editor flags.",
    "9868": "Is the Screen Line Edit Buffer is full?",
    "9870": "Jump if not to process the key code.",
    "9872": "Produce error beep.",
    "9875": "[Could have save a byte by using JP $26E7 (ROM 0)]",
    "9876": "Was it a supported function key code?",
    "9878": "Ignore by jumping back to wait for another key. [*BUG* - This should be RET NC since it was called from the loop at $2653 (ROM 0). Repeatedly pressing an unsupported key will result in a stack memory leak and eventual overflow. Credit: John Steven (+3), Paul Farrow (128)] ",
    "9880": "Jump forward to handle the character key press.",
    "9883": "Fetch mode.",
    "9886": "Calculator mode?",
    "9888": "Return if so (TOGGLE has no effect in Calculator mode).",
    "9889": "Clear Editing Display.",
    "9892": "Editor flags.",
    "9895": "Reset 'line altered' flag.",
    "9898": "Toggle screen editing area flag.",
    "9903": "Jump forward if the editing area is now the upper area.",
    "9905": "Set the lower area as the current editing area.",
    "9908": "Jump forward.",
    "9910": "Set the upper area as the current editing area.",
    "9913": "Signal do not produce an error beep.",
    "9915": "Clear lower editing area display.",
    "9918": "Editor flags.",
    "9921": "Signal using lower screen.",
    "9923": "Reset to lower screen.",
    "9926": "Set default lower screen editing cursor settings.",
    "9929": "Set default lower screen editing settings.",
    "9932": "Jump ahead to continue.",
    "9934": "Editor flags.",
    "9937": "Signal using main screen.",
    "9939": "Reset Cursor Position.",
    "9942": "Clear screen and print the \"128 BASIC\" banner line.",
    "9945": "Line number at top of screen.",
    "9949": "Is there a line?",
    "9950": "If there is then get the address of BASIC line for this line number.",
    "9953": "Relist the BASIC program.",
    "9956": "Set attribute at editing position so as to show the cursor, and return.",
    "9962": "Divide by 2.",
    "9966": "Pitch.",
    "9969": "Duration.",
    "9973": "Produce a tone.",
    "9978": "Produce Success Beep",
    "9980": "Frequency*Time.",
    "9983": "Duration.",
    "9986": "Jump to produce the tone.",
    "9988": "Remove cursor, restoring old attribute.",
    "9991": "HL points to Editor flags.",
    "9994": "Signal 'menu is being displayed'.",
    "9996": "HL=$EC0C.",
    "9997": "Set 'current menu item' as the top item.",
    "9999": "Address of text for current menu.",
    "10002": "Display menu and highlight first item.",
    "10005": "Signal do not produce an error beep.",
    "10007": "HL points to Editor flags.",
    "10010": "Clear 'displaying menu' flag.",
    "10012": "HL=$EC0C.",
    "10013": "A=Current menu option index.",
    "10014": "HL points to jump table for current menu.",
    "10019": "Restore menu screen area.",
    "10024": "Call the item in the jump table corresponding to the currently selected menu item.",
    "10027": "Set attribute at editing position so as to show the cursor, and return.",
    "10030": "Signal move up.",
    "10031": "Jump ahead to continue.",
    "10033": "Signal moving down.",
    "10039": "Address of text for current menu.",
    "10038": "Save it.",
    "10037": "Fetch current menu index.",
    "10042": "Call if moving up.",
    "10045": "Call if moving down.",
    "10048": "HL=Address of current menu index store.",
    "10049": "Store the new menu index.",
    "10187": "Number of entries.",
    "10189": "(Return to) Calculator option handler.",
    "10192": "Exit option handler.",
    "10194": "Number of entries.",
    "10195": "\"Options \", \"Caluclator\", \"Exit\", end marker",
    "10219": "AT 1,0; INK 0; PAPER 7; BRIGHT 1;",
    "10235": "\"To cancel - press BREAK twice\"",
    "10257": "Toggle between editing in the lower and upper screen areas.",
    "10260": "Jump ahead.",
    "10262": "Clear screen and print the \"Tape Tester\" in the banner.",
    "10265": "Run the tape tester, exiting via the 'Exit' option menu handler.",
    "10268": "Editor flags.",
    "10271": "Indicate main screen editing.",
    "10273": "Reset Cursor Position.",
    "10276": "Top row to clear.",
    "10278": "Bottom row to clear.",
    "10280": "Clear specified display rows.",
    "10283": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10286": "Jump back to show the menu.",
    "10289": "Clear screen and print \"Tape Loader\" in the banner line.",
    "10295": "Signal using lower screen area.",
    "10297": "Point to message \"To cancel - press BREAK twice\".",
    "10300": "Print the text.",
    "10303": "Signal using main screen area.",
    "10305": "[This bit is unused in the 48K Spectrum and only ever set in 128K mode via the Tape Loader option. It is never subsequently tested or reset. It may have been the intention to use this to indicate that the screen requires clearing after loading to remove the \"Tape Loader\" banner and the lower screen message \"To cancel - press BREAK twice\"]",
    "10307": "Tape Loader mode.",
    "10309": "[Redundant since call to $1AF1 (ROM 0) will set it to $FF]",
    "10315": "Perform 'Print AT 0,0;'.",
    "10318": "Run the tape loader.",
    "10321": "Run the renumber routine.",
    "10324": "If not successful then produce error beep if required.",
    "10327": "There is no current line number.",
    "10330": "Current line number.",
    "10333": "Temporary E_PPC used by BASIC Editor.",
    "10336": "Jump ahead to display the \"128 BASIC\" banner if required, set the menu mode and return.",
    "10338": "Perform an LLIST.",
    "10341": "Editor flags.",
    "10344": "Using lower editing screen?",
    "10346": "Jump ahead if so.",
    "10351": "Allow leading space.",
    "10353": "Clear screen and print the \"128 BASIC\" banner line.",
    "10356": "Editor flags.",
    "10359": "Signal not to process the BASIC line.",
    "10361": "Signal return to main menu.",
    "10363": "Select Edit menu mode. [Could have saved 1 byte by using XOR A]",
    "10365": "Edit Menu jump table.",
    "10368": "Edit Menu text table.",
    "10371": "Store the new mode and menu details.",
    "10373": "Editor flags.",
    "10376": "Signal to process the BASIC line.",
    "10378": "Signal return to calculator.",
    "10380": "Signal editing are is the main screen.",
    "10382": "Reset cursor position.",
    "10385": "Clear screen and print \"Calculator\" in the banner line.",
    "10388": "Set calculator mode.",
    "10390": "Store mode.",
    "10393": "No current line number.",
    "10396": "Store current line number.",
    "10399": "Relist the BASIC program.",
    "10402": "B=Row. C=Column. Top left of screen.",
    "10405": "Preferred column.",
    "10406": "Store editing position and print cursor.",
    "10409": "Select calculator mode.",
    "10411": "Calculator Menu jump table",
    "10414": "Calculator Menu text table",
    "10417": "Store mode.",
    "10420": "Store address of current menu jump table.",
    "10423": "Store address of current menu text.",
    "10427": "Return to the Editor.",
    "10430": "Reset to main screen.",
    "10433": "Set default main screen editing cursor details.",
    "10436": "Set default main screen editing settings.",
    "10439": "Top row of editing area.",
    "10441": "Bottom row of editing area.",
    "10443": "Clear specified display rows.",
    "10446": "Jump to show Main menu.",
    "10449": "Number of bytes in table.",
    "10450": "$F6EE = Cursor position - row 0.",
    "10451": "$F6EF = Cursor position - column 0.",
    "10452": "$F6F0 = Cursor position - column 0 preferred.",
    "10453": "$F6F1 = Top row before scrolling up.",
    "10454": "$F6F2 = Bottom row before scrolling down.",
    "10455": "$F6F3 = Number of rows in the editing area.",
    "10456": "Number of bytes in table.",
    "10457": "$F6EE = Cursor position - row 0.",
    "10458": "$F6EF = Cursor position - column 0.",
    "10459": "$F6F0 = Cursor position - column 0 preferred.",
    "10460": "$F6F1 = Top row before scrolling up.",
    "10461": "$F6F2 = Bottom row before scrolling down.",
    "10462": "$F6F3 = Number of rows in the editing area.",
    "10463": "Default lower screen editing information.",
    "10466": "Editing information stores.",
    "10469": "Copy bytes.",
    "10472": "Default main screen editing information.",
    "10475": "Editing information stores.",
    "10478": "Copy bytes.",
    "10481": "Editor flags.",
    "10484": "Clear carry flag. [Redundant instruction since carry flag return state never checked]",
    "10485": "[Redundant instruction]",
    "10486": "Is the Screen Line Edit Buffer is full?",
    "10488": "Jump if it is to set attribute at editing position so as to show the cursor, and return.",
    "10491": "Signal got a key press.",
    "10493": "Signal current line has been altered.",
    "10495": "Save address of the flags.",
    "10496": "Save key code.",
    "10497": "Remove cursor, restoring old attribute.",
    "10501": "Get and save key code.",
    "10502": "Insert the character into the Screen Line Edit Buffer.",
    "10505": "Get key code.",
    "10506": "B=Current cursor column position.",
    "10507": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.",
    "10510": "Get address of the flags.",
    "10511": "Signal wait for a key.",
    "10513": "Jump if new position not available to set cursor attribute at existing editing position, and return.",
    "10516": "A=New cursor column position.",
    "10517": "Jump if new position is editable to store editing position and print cursor. [This only needs to be JP $29F8 (ROM 0), thereby saving 3 bytes, since a branch to $29F2 (ROM 0) would have been taken above if the carry flag was reset]",
    "10520": "Set attribute at editing position so as to show the cursor, and return.",
    "10523": "HL points to Editor flags.",
    "10526": "Indicate 'line altered'.",
    "10528": "Remove cursor, restoring old attribute. Exit with C=row, B=column.",
    "10531": "Delete character to the right, shifting subsequent rows as required.",
    "10534": "Signal do not produce an error beep.",
    "10535": "A=The new cursor editing position.",
    "10536": "Store editing position and print cursor, and then return.",
    "10539": "HL points to Editor flags.",
    "10542": "Signal that the Screen Line Edit Buffer is not full.",
    "10544": "Indicate 'line altered'.",
    "10546": "Remove cursor, restoring old attribute. Exit with C=row, B=column.",
    "10549": "Select previous column position (Returns carry flag set if editable).",
    "10552": "Signal do not produce an error beep if not editable.",
    "10553": "Jump if not editable to set attribute at editing position so as to show the cursor, and return.",
    "10556": "Delete character to the right, shifting subsequent rows as required.",
    "10559": "Signal do not produce an error beep.",
    "10560": "A=The new cursor editing position.",
    "10561": "Store editing position and print cursor, and then return.",
    "10564": "Remove cursor, restoring old attribute.",
    "10567": "Save preferred column number.",
    "10568": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "10571": "Stack current editing position.",
    "10572": "Column 0.",
    "10574": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "10577": "Retrieve current editing position.",
    "10578": "Jump ahead if editable position found, i.e. not a blank row.",
    "10583": "Point to the flag byte for the row.",
    "10584": "Fetch the flag byte.",
    "10585": "Invert it.",
    "10586": "Keep the 'first row' and 'last row' flags.",
    "10588": "Jump if both flags were set indicating not on a BASIC line.",
    "10590": "Editor flags.",
    "10593": "Has the current line been altered?",
    "10595": "Jump ahead if not.",
    "10597": "Enter line into program.",
    "10600": "Jump if syntax error to produce an error beep.",
    "10602": "Find end of the current BASIC line in the Screen Line Edit Buffer, scrolling up rows as required. Returns column number into B.",
    "10605": "Find address of end position in current BASIC line. Returns address into HL.",
    "10608": "Insert a blank line in the Screen Line Edit Buffer, shifting subsequent rows down.",
    "10611": "First column.",
    "10613": "A=Preferred column number.",
    "10614": "Signal do not produce an error beep.",
    "10615": "Store editing position and print cursor, and then return.",
    "10618": "Discard stacked item.",
    "10619": "Signal do not produce an error beep.",
    "10620": "Set attribute at current editing position so as to show the cursor, and return.",
    "10623": "Discard stacked item.",
    "10624": "Set attribute at current editing position so as to show the cursor, and return.",
    "10627": "Fetch mode.",
    "10630": "Calculator mode?",
    "10632": "Exit if so.",
    "10633": "Remove cursor, restoring old attribute.",
    "10636": "The first possible line number.",
    "10639": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10642": "Find address of line number 0, or the next line if it does not exist.",
    "10643": "Return address in HL.",
    "10645": "Find line number for specified address, and return in DE.",
    "10646": "DE=Address of first line in the BASIC program.",
    "10648": "Use Workspace RAM configuration (physical RAM bank 7).",
    "10651": "Store the current line number.",
    "10655": "Paper 1, Ink 7 - Blue.",
    "10657": "Set the cursor colour.",
    "10660": "Relist the BASIC program.",
    "10663": "Signal do not produce an error beep.",
    "10664": "Set attribute at editing position so as to show the cursor, and return.",
    "10667": "Fetch mode.",
    "10670": "Calculator mode?",
    "10672": "Exit if so.",
    "10673": "Remove cursor, restoring old attribute.",
    "10676": "The last possible line number, 9999.",
    "10679": "Use Normal RAM Configuration (physical RAM bank 0).",
    "10682": "Find address of line number 9999, or the previous line if it does not exist.",
    "10683": "Return address in HL.",
    "10685": "DE=Address of last line number.",
    "10686": "Find line number for specified address, and return in DE.",
    "10687": "DE=Address of last line in the BASIC program.",
    "10689": "Use Workspace RAM configuration (physical RAM bank 7).",
    "10692": "Store the current line number.",
    "10696": "Paper 1, Ink 7 - Blue.",
    "10698": "Set the cursor colour.",
    "10701": "Relist the BASIC program.",
    "10704": "Signal do not produce an error beep.",
    "10705": "Set attribute at editing position so as to show the cursor, and return.",
    "10708": "Remove cursor, restoring old attribute.",
    "10711": "Find start of the current word to the left.",
    "10714": "Jump if no word to the left to restore cursor attribute at current editing position, and return. [Could have saved 4 bytes by joining the routine below, i.e. JR $29E7]",
    "10717": "A=New cursor column number. Carry flag is set indicating not to produce an error beep.",
    "10718": "Store editing position and print cursor, and then return.",
    "10721": "Remove cursor, restoring old attribute.",
    "10724": "Find start of the current word to the right.",
    "10727": "Jump if no word to the right to restore cursor attribute at current editing position, and return.",
    "10729": "A=The new cursor editing column number. Carry is set indicating not to produce an error beep.",
    "10730": "Store editing position and print cursor, and then return.",
    "10732": "Get current cursor position (C=row, B=column, A=preferred column).",
    "10735": "Restore previous colour to character square",
    "10738": "Get current cursor position (C=row, B=column, A=preferred column).",
    "10741": "Set editing position character square to cursor colour to show it. [Could have saved 1 byte by using a JR instruction to join the end of the routine below]",
    "10744": "Store new editing position.",
    "10749": "Paper 1, Ink 7 - Blue.",
    "10751": "Store new cursor colour.",
    "10756": "Set editing position character square to cursor colour to show it.",
    "10759": "Editing info.",
    "10762": "Row number.",
    "10764": "Column number.",
    "10766": "Preferred column number.",
    "10769": "Editing information.",
    "10772": "Row number.",
    "10774": "Column number.",
    "10776": "Preferred column number.",
    "10779": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "10782": "[Could have saved 2 bytes by calling the unused routine at $2E7B (ROM 0)]",
    "10784": "Point to the column position within the row.",
    "10786": "Get character at this position.",
    "10789": "Remove cursor, restoring old attribute.",
    "10792": "E=Preferred column.",
    "10793": "The ten lines to move down.",
    "10796": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "10799": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "10800": "Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.",
    "10802": "A=Preferred column.",
    "10803": "Store cursor editing position.",
    "10806": "B=Preferred column.",
    "10807": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10810": "Jump if no editable position found on the row, i.e. a blank row.",
    "10812": "Decrement row counter.",
    "10813": "Repeat to move down to the next row.",
    "10815": "A=Preferred column.",
    "10816": "Jump if editable row exists to store editing position and print cursor, and then return.",
    "10819": "Move back up to the previous row.",
    "10823": "B=Preferred column.",
    "10824": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10827": "A=Preferred column.",
    "10828": "Carry will be reset indicating to produce an error beep.",
    "10829": "Store editing position and print cursor, and then return.",
    "10831": "Remove cursor, restoring old attribute.",
    "10834": "E=Preferred column.",
    "10835": "The ten lines to move up.",
    "10838": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "10841": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "10842": "Jump if there was no row above to set cursor attribute colour at existing editing position, and return.",
    "10844": "A=Preferred column.",
    "10845": "Store cursor editing position.",
    "10848": "B=Preferred column.",
    "10849": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10852": "Jump if no editable positions were found in the row, i.e. it is a blank row.",
    "10854": "Decrement row counter.",
    "10855": "Repeat to move up to the previous row.",
    "10857": "A=Preferred column.",
    "10858": "Jump if editable row exists to store editing position and print cursor, and then return. [Redundant check of the carry flag, should just be JP $29F8 (ROM 0)]",
    "10861": "Save the preferred column number and the flags.",
    "10862": "Move back down to the next row. Returns new row number in C.",
    "10865": "Column 0.",
    "10867": "Find editable position in the Screen Line Edit Buffer row to the right, return column position in B.",
    "10870": "A=Preferred column. Carry will be reset indicating to produce an error beep.",
    "10871": "Store editing position and print cursor, and then return.",
    "10874": "Remove cursor, restoring old attribute.",
    "10877": "Find the end of the current BASIC line in the Screen Line Edit Buffer.",
    "10880": "Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.",
    "10883": "A=The new cursor editing column number. Carry is set indicating not to produce an error beep.",
    "10884": "Store editing position and print cursor, and then return.",
    "10887": "Remove cursor, restoring old attribute.",
    "10890": "Find the start of the current BASIC line in the Screen Line Edit Buffer.",
    "10893": "Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.",
    "10896": "A=The new cursor editing position. Carry is set indicating not to produce an error beep.",
    "10897": "Store editing position and print cursor, and then return.",
    "10900": "Remove cursor, restoring old attribute.",
    "10903": "E=Preferred column.",
    "10905": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "10908": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "10909": "Jump if there was no row above to set cursor attribute colour at existing editing position, and return.",
    "10912": "B=Preferred column.",
    "10913": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10916": "A=Preferred column.",
    "10917": "Jump if an editable position was found to store editing position and print cursor, and then return.",
    "10920": "Save the preferred column number and the flags.",
    "10921": "Move down to the next row, shifting rows up as appropriate. Returns new row number in C.",
    "10924": "Column 0.",
    "10926": "Find closest Screen Line Edit Buffer editable position to the right.",
    "10929": "A=Preferred column. Carry flag is reset indicating to produce an error beep.",
    "10930": "Store editing position and print cursor, and then return.",
    "10933": "Remove cursor, restoring old attribute.",
    "10936": "E=Preferred column.",
    "10945": "B=Preferred column.",
    "10938": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "10941": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "10942": "Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.",
    "10946": "Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.",
    "10949": "A=Preferred column.",
    "10950": "Jump if an editable position was found to store editing position and print cursor, and then return.",
    "10953": "Save the preferred column.",
    "10954": "Move up to the previous row, shifting rows down as appropriate.",
    "10962": "A=Preferred column.",
    "10958": "B=Preferred column.",
    "10959": "Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.",
    "10963": "Reset carry flag to indicate to produce an error beep.",
    "10964": "Store editing position and print cursor, and then return.",
    "10967": "Remove cursor, restoring old attribute. Returns with C=row, B=column.",
    "10970": "Find next Screen Line Edit Buffer editable position to left, wrapping to previous row as necessary.",
    "10973": "Jump if editable position found to store editing position and print cursor, and then return.",
    "10976": "Set cursor attribute at existing editing position, and return. Carry flag is reset indicating to produce an error beep.",
    "10979": "Remove cursor, restoring old attribute.",
    "10982": "Find next Screen Line Edit Buffer editable position to right, wrapping to next row if necessary.",
    "10985": "Jump if editable position found to store editing position and print cursor, and then return.",
    "10988": "Save the carry flag and preferred column number.",
    "10989": "Move up to the previous row, shifting rows down as appropriate.",
    "10992": "Column 31.",
    "10994": "Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)",
    "10997": "Carry flag is reset indicating to produce an error beep.",
    "10998": "Store editing position and print cursor, and then return.",
    "11002": "Find Screen Line Edit Buffer editable position from previous column (or current column if the previous column does not exist) to the right, return column position in B.",
    "11005": "If no editable character found then search to the left for an editable character, return column position in B.",
    "11011": "Find Screen Line Edit Buffer editable position to the left, returning column position in B.",
    "11014": "If no editable character found then search from previous column (or current column if the previous column does not exist) to the right, return column position in B.",
    "11019": "If current BASIC line has been altered and moved off of then insert it into the program.",
    "11022": "Jump if BASIC line was not inserted. [Could have saved 1 byte by using RET NC]",
    "11024": "Save the new cursor row and column numbers.",
    "11025": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11028": "Column 0.",
    "11030": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "11033": "If no editable position found then the cursor is on a blank row so shift all BASIC lines below it up to close the gap.",
    "11036": "Retrieve the new cursor row and column numbers.",
    "11037": "Point to the editing area information.",
    "11040": "Fetch the upper scroll threshold.",
    "11042": "Jump if on a row below the threshold.",
    "11041": "Is it on the threshold?",
    "11044": "Save the new cursor row and column numbers.",
    "11045": "Shift all edit buffer rows down, and update display file if required.",
    "11049": "Return if edit buffer rows were shifted.",
    "11050": "On the top row of the editing area?",
    "11052": "Return with carry flag reset if on the top row.",
    "11053": "Move onto the previous row.",
    "11054": "Signal a new row was moved to.",
    "11056": "Save row number.",
    "11057": "DE=Start address in Screen Line Edit Buffer of row held in C, i.e. the new cursor row.",
    "11060": "Column 0.",
    "11062": "Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "11065": "Get row number.",
    "11066": "Jump if editable position found, i.e. the row exists. [Could have saved 2 bytes by using JP NC,$2F80 (ROM 0)]",
    "11068": "Cursor is on a blank row so shift all BASIC lines below it up to close the gap.",
    "11071": "Insert the BASIC Line into the BASIC program if the line has been altered.",
    "11074": "Jump if the line was inserted into the program. [Could have saved 1 byte by using RET NC]",
    "11076": "Point to the editing area information.",
    "11079": "Point to the 'Bottom Row Scroll Threshold' value. [Could have saved 1 byte by using LD HL,$F6F2]",
    "11080": "Fetch the new cursor row number.",
    "11081": "Is it on the lower scroll threshold?",
    "11082": "Jump if on a row above the threshold.",
    "11084": "Save the new cursor row and column numbers.",
    "11085": "Save the editing area information address.",
    "11086": "Shift all edit buffer rows up, and update display file if required.",
    "11091": "Return if edit buffer rows were shifted.",
    "11092": "Point to the 'Number of Rows in the Editing Area' value.",
    "11093": "A=Number of rows in the editing area.",
    "11094": "On the last row of the editing area?",
    "11095": "Return with carry flag reset if on the bottom row.",
    "11096": "Move onto the next row.",
    "11097": "Signal a new row was moved to.",
    "11099": "Save the key code character.",
    "11100": "Back one column position.",
    "11101": "Jump if already at beginning of row.",
    "11104": "E=Column number.",
    "11105": "Find Screen Line Edit Buffer editable position to the left, returning column position in B.",
    "11108": "A=Column number.",
    "11109": "Return if the new column is editable, i.e. the cursor can be moved within this row.",
    "11110": "E=Store the column number.",
    "11111": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then",
    "11114": "insert the previous BASIC line into the BASIC program if it has been altered.",
    "11115": "A=Column number.",
    "11116": "Return if there was no row above.",
    "11117": "Column 31.",
    "11119": "Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)",
    "11122": "A=Column number of the closest editable position.",
    "11123": "Return if an editable position was found, i.e. the cursor can be moved.",
    "11124": "Restore the key code character.",
    "11125": "Set column position 0.",
    "11127": "[*BUG* - This should really ensure the carry flag is reset to signal that no editable position to the left exists, e.g. by using OR A. Fortunately, the carry flag is always reset when this routine is called and so the bug is harmless. Credit: Paul Farrow]",
    "11128": "Save the key code character.",
    "11129": "Advance to the next column position.",
    "11130": "Column 31.",
    "11135": "E=New column number.",
    "11133": "Jump if reached end of row.",
    "11136": "Find Screen Line Edit Buffer editable position from previous column to the right, returning column position in B.",
    "11139": "A=New column number.",
    "11140": "Return if the new column is editable, i.e. the cursor can be moved within this row.",
    "11141": "B=Original column position.",
    "11142": "Save original column and row numbers.",
    "11143": "HL=Address of the new editable position.",
    "11144": "Editor flags.",
    "11147": "Got a key press?",
    "11149": "Jump if not.",
    "11151": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11157": "Point to the flag byte for the current row.",
    "11159": "Does the BASIC line row span onto another row?",
    "11161": "Jump if so to test the next row (it could just be the cursor).",
    "11163": "Signal that the row spans onto another row, i.e. a new blank row containing the cursor.",
    "11165": "Signal that the row is not the last row of the BASIC line.",
    "11167": "Point to the next row.",
    "11171": "DE=Address of the next row. [Redundant calculation as never used. Could have saved 5 bytes]",
    "11172": "HL=Address of the new editable position.",
    "11173": "B=Original column number. C=Row number.",
    "11174": "Save flag byte for the previous row.",
    "11175": "Move down to the next row, shifting rows up as appropriate. Returns new row number in C.",
    "11178": "Retrieve flag byte for the previous row.",
    "11179": "DE=Start address in Screen Line Edit Buffer of the new row, as specified in C.",
    "11185": "HL=Address of the row after the new row.",
    "11186": "DE=Address of the row after the new row. HL=Address of the new row.",
    "11187": "Signal 'not the start row of the BASIC line'.",
    "11189": "Signal 'end row of the BASIC line'.",
    "11191": "Insert a blank row into the Screen Edit Buffer at row specified by C, shifting rows down.",
    "11194": "Indent the row by setting the appropriate number of null characters in the current Screen Line Edit Buffer row.",
    "11197": "A=First column after indentation.",
    "11198": "Signal not to produce an error beep.",
    "11200": "HL=Address of the new editable position.",
    "11201": "B=Original column position.",
    "11202": "E=New column number.",
    "11203": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then",
    "11206": "insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "11207": "A=Original column position.",
    "11208": "Return if there was no row below.",
    "11209": "Column 0.",
    "11211": "Find Screen Line Edit Buffer editable position to the right, returning column position in B.",
    "11214": "A=New column position.",
    "11215": "Return if an editable position was found, i.e. the cursor can be moved.",
    "11216": "A=Preferred column number.",
    "11217": "Column 0.",
    "11219": "Return with carry flag reset.",
    "11220": "Save registers.",
    "11222": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11225": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "11228": "Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]",
    "11231": "Save registers.",
    "11242": "Save registers.",
    "11233": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11239": "Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]",
    "11236": "Find editable position from current column to the left, returning the column number in B.",
    "11244": "Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.",
    "11247": "Jump if not editable, i.e. at start of line.",
    "11249": "Get character at new position.",
    "11252": "Is it a space?",
    "11254": "Jump back if it is, until a non-space or start of line is found.",
    "11256": "Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.",
    "11259": "Jump if not editable, i.e. at start of line.",
    "11261": "Get character at new position.",
    "11264": "Is it a space?",
    "11266": "Jump back if it is not, until a space or start of line is found.",
    "11268": "Find next Screen Line Edit Buffer editable position to right to start of the word, moving to next row if necessary. [Returns carry flag set since the character will exist]",
    "11271": "Jump forward to restore registers and return.",
    "11273": "Save registers.",
    "11275": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.",
    "11278": "Jump if none editable, i.e. at end of line.",
    "11280": "Get character at new position.",
    "11283": "Is it a space?",
    "11285": "Jump back if it is not, until a space or end of line is found.",
    "11287": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.",
    "11290": "Jump if none editable, i.e. at end of line.",
    "11292": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "11295": "Jump if none editable, i.e. at start of next line.",
    "11297": "Get character at new position.",
    "11300": "Is it a space?",
    "11302": "Loop back until a non-space is found, i.e. start of a word.",
    "11304": "Indicate cursor position can be moved.",
    "11305": "Jump forward to restore registers and return.",
    "11310": "Clear carry flag to indicate cursor position can not be moved.",
    "11307": "If no word on this row then find next Screen Line Edit Buffer editable position to left, moving to previous row if necessary thereby restoring the row number to its original value.",
    "11311": "Jump forward to restore registers and return.",
    "11313": "Save registers.",
    "11315": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11321": "Point to flag byte of next row.",
    "11322": "On first row of the BASIC line?",
    "11324": "Jump if on the first row of the BASIC line.",
    "11326": "Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then insert the previous BASIC line into the BASIC program if it has been altered.",
    "11329": "Jump back if still on the same BASIC line, i.e. was not on first row of the BASIC line.",
    "11331": "Jump forward to restore registers and return.",
    "11333": "Column 0.",
    "11335": "Find Screen Line Edit Buffer editable position to the right, return column position in B. (Returns carry flag reset if blank row)",
    "11338": "Jump forward to restore registers and return.",
    "11340": "Save registers.",
    "11342": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11348": "Point to flag byte of next row.",
    "11349": "On last row of the BASIC line?",
    "11351": "Jump if on the last row of the BASIC line.",
    "11353": "Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.",
    "11356": "Jump back if still on the same BASIC line, i.e. was not on last row of the BASIC line.",
    "11358": "Jump forward to restore registers and return.",
    "11360": "Column 31.",
    "11362": "Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag reset if blank row)",
    "11365": "Restore registers.",
    "11368": "Editor flags.",
    "11371": "Has the current line been altered?",
    "11373": "Signal line not inserted into BASIC program.",
    "11374": "Return if it has not.",
    "11375": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11381": "HL points to the flag byte for the row.",
    "11382": "Is this the end of the BASIC line?",
    "11384": "Signal line not inserted into BASIC program.",
    "11385": "Return if it is not.",
    "11386": "Insert line into BASIC program.",
    "11388": "Editor flags.",
    "11391": "Has current line been altered?",
    "11393": "Signal success.",
    "11394": "Return if it has not.",
    "11395": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11401": "Point to the flag byte for the row.",
    "11402": "Is this the first row of the BASIC line?",
    "11404": "Signal success.",
    "11405": "Return if it is not.",
    "11406": "Signal on first row of BASIC line.",
    "11408": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11414": "Point to the flag byte for the row.",
    "11415": "First row of the BASIC line?",
    "11417": "Jump ahead if so.",
    "11419": "Move to previous row.",
    "11420": "Jump back until found the first row of the BASIC line or the top of the screen.",
    "11423": "Row 0.",
    "11425": "Signal first row of BASIC line above screen.",
    "11427": "BASIC line insertion flags.",
    "11430": "BASIC line insertion error flags.",
    "11433": "Signal location of cursor not yet found.",
    "11439": "[Could have saved 1 byte by using XOR A]",
    "11441": "Starting column number of the first visible row of the BASIC line being entered.",
    "11445": "Fetch the row number of the first visible row of the BASIC line being entered.",
    "11447": "Store the start row number of the first visible row of the BASIC line being entered.",
    "11451": "No editable characters in the line prior to the cursor.",
    "11454": "Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.",
    "11457": "Tokenize the typed BASIC line.",
    "11460": "IX=Address of cursor settings.",
    "11462": "Use Normal RAM Configuration (physical RAM bank 0).",
    "11465": "Syntax check/execute the command line.",
    "11468": "Use Workspace RAM configuration (physical RAM bank 7).",
    "11471": "IX=Address of cursor settings.",
    "11473": "Fetch error code.",
    "11476": "Was an error code set?",
    "11477": "Jump ahead if so.",
    "11479": "Editor flags.",
    "11482": "Signal line has not been altered.",
    "11484": "Reset to 'L' Mode.",
    "11487": "Fetch mode.",
    "11490": "Calculator mode?",
    "11492": "If not calculator mode then relist the BASIC program.",
    "11495": "Produce success beep.",
    "11498": "Get current cursor position (C=Row, B=Column, A=Preferred column).",
    "11501": "Set the carry flag to signal that that BASIC line was inserted successfully.",
    "11503": "BASIC line insertion flags.",
    "11506": "BASIC line insertion error flags.",
    "11509": "Fetch the BASIC line insertion error flags.",
    "11510": "Signal location of cursor found.",
    "11512": "Update the BASIC line insertion flags with the error flags.",
    "11516": "Restore the initial column number, i.e. column 0.",
    "11520": "Restore the initial row number, i.e. row number of the first visible row of the BASIC line being entered.",
    "11521": "Locate the position to insert the error marker into the typed BASIC line.",
    "11524": "Jump if the error marker was found.",
    "11526": "Fetch the number of editable characters in the line prior to the cursor within the Screen Line Edit Buffer.",
    "11530": "Fetch the number of editable characters in the line prior to the cursor within the Screen Line Edit Buffer.",
    "11534": "HL=Difference between the cursor and the error marker positions (negative if the error marker is after the cursor).",
    "11536": "Save the flags.",
    "11537": "HL=Difference between the cursor and error marker.",
    "11538": "Get current cursor position, returning C=row number, B=column number, A=preferred column number.",
    "11541": "HL=Difference between the cursor and error marker.",
    "11542": "Restore the flags.",
    "11543": "Jump if error marker is after the cursor position.",
    "11545": "Jump if cursor is at the same location as the error marker.",
    "11547": "Save the number of positions to move.",
    "11548": "B=Cursor column number.",
    "11549": "Find previous editable position to the left in the Screen Line Edit Buffer, moving to previous row if necessary.",
    "11552": "Retrieve the number of positions to move.",
    "11553": "Jump if no previous editable position exists.",
    "11555": "Decrement the number of positions to move.",
    "11558": "Jump back if the cursor position requires further moving.",
    "11560": "Jump ahead to continue.",
    "11562": "Save the number of positions that the error marker is before the cursor. This will be a negative number is the cursor is after the error marker.",
    "11563": "Editor flags.",
    "11566": "Signal 'got a key press'. Used in routine at $2B78 (ROM 0) to indicate that a new character has caused the need to shift the cursor position.",
    "11568": "Retrieve the negative difference in the cursor and error marker positions.",
    "11569": "DE=Negative difference in the cursor and error marker positions.",
    "11570": "Make the negative difference a positive number by subtracting it from 0.",
    "11574": "HL=Positive difference in the cursor and error marker positions.",
    "11576": "Save the number of positions to move.",
    "11577": "B=Cursor column number.",
    "11578": "Find next editable position to the right in the Screen Line Edit Buffer, moving to next row if necessary.",
    "11581": "Retrieve the number of positions to move.",
    "11582": "Jump if no next editable position exists.",
    "11584": "Decrement the number of positions to move.",
    "11587": "Jump back if the cursor position requires further moving.",
    "11589": "Editor flags.",
    "11592": "Set 'waiting for key press' flag.",
    "11594": "Store cursor editing position.",
    "11597": "Paper 2, Ink 7 - Red.",
    "11599": "Set the cursor colour to show the position of the error.",
    "11602": "Reset the carry flag to signal that a syntax error occurred.",
    "11604": "Point to the 'insert BASIC line' details.",
    "11607": "Has the column with the cursor been found?",
    "11609": "Jump if it has been found.",
    "11614": "Increment the count of the number of editable characters in the BASIC line up to the cursor.",
    "11618": "Point to the 'insert BASIC line' details.",
    "11621": "Fetch flags.",
    "11623": "Fetch the column number of the character being examined.",
    "11625": "Fetch the row number of the character being examined.",
    "11627": "Extract the status code.",
    "11653": "Number of table entries.",
    "11654": "On first row of the BASIC line.",
    "11657": "Using lower screen and only first row of the BASIC line visible.",
    "11660": "First row of the BASIC line off top of screen.",
    "11629": "Jump table to select appropriate handling routine.",
    "11632": "Call handler routine.",
    "11635": "E=Return status.",
    "11637": "Jump if no match found.",
    "11639": "A='Enter' character.",
    "11641": "Save the next character position row to examine.",
    "11643": "Save the next character position column to examine.",
    "11645": "Save the character.",
    "11646": "Fetch the current status flags.",
    "11647": "Keep the upper nibble.",
    "11649": "Update the location flags that indicate where to obtain the next character from.",
    "11650": "Store the status flags.",
    "11651": "Retrieve the character.",
    "11663": "Find row address in Above-Screen Line Edit Buffer, return in DE.",
    "11666": "Fetch character from Above-Screen Line Edit Buffer row.",
    "11669": "Jump if end of row reached.",
    "11671": "Is it a null character, i.e. not editable?",
    "11673": "Jump back if so until character found or end of row reached.",
    "11675": "Signal a character was returned from the Above-Screen Line Edit Buffer row, with A holding the character.",
    "11677": "Return with zero flag reset to indicate match found.",
    "11678": "Next row.",
    "11679": "Column 0.",
    "11685": "Exceeded last row of Above-Screen Line Edit Buffer?",
    "11684": "Fetch the row number.",
    "11686": "Jump back if not exceeded last row the Above-Screen Line Edit Buffer.",
    "11688": "Column 0.",
    "11690": "Row 0. This is the first visible row of the BASIC line on screen.",
    "11692": "Save address of the table entry.",
    "11693": "Point to the cursor position details.",
    "11696": "Fetch the row number of the cursor.",
    "11697": "Is cursor on the first visible row of the BASIC line?",
    "11698": "Jump if not.",
    "11701": "Fetch the column number of the cursor.",
    "11702": "Reached the column with the cursor in the first visible row of the BASIC line?",
    "11703": "Jump if not.",
    "11705": "BASIC line insertion flags.",
    "11708": "Indicate that the column with the cursor has been found.",
    "11710": "Retrieve address of the table entry.",
    "11711": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11714": "Fetch character from Screen Line Edit Buffer row at column held in B, then increment B.",
    "11717": "Jump if end of row reached.",
    "11719": "Is the character a null, i.e. not editable?",
    "11721": "Jump back if null to keep fetching characters until a character is found or the end of the row is reached.",
    "11723": "L=Signal a character was returned from the Screen Line Edit Buffer row, with A holding the character.",
    "11725": "Return with zero flag reset to indicate match found.",
    "11730": "Is it the last row of the BASIC line?",
    "11729": "Point to the flag byte for the row.",
    "11732": "Jump if not.",
    "11734": "L=Signal at the end of the last row of the BASIC line.",
    "11736": "A='Enter' character.",
    "11738": "Return with zero flag reset to indicate match found.",
    "11739": "Point to the 'top row scroll threshold' value.",
    "11742": "Next row of the BASIC line in the Screen Line Edit Buffer.",
    "11743": "Fetch the number of the last row in the Screen Line Edit Buffer.",
    "11744": "Exceeded the upper scroll threshold?",
    "11745": "Column 0.",
    "11747": "Jump back if not to retrieve the character from the next row.",
    "11749": "Column 0. [Redundant byte]",
    "11751": "Row 1. (Row 0 holds a copy of the last row visible on screen)",
    "11753": "Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.",
    "11756": "Fetch character from Below-Screen Line Edit Buffer row, incrementing the column number.",
    "11759": "Jump if end of row reached.",
    "11761": "Is the character a null, i.e. not editable?",
    "11763": "Jump back if null to keep fetching characters until a character is found or the end of the row is reached.",
    "11765": "L=Signal a character was returned from the Below-Screen Line Edit Buffer row, with A holding the character.",
    "11767": "Return with zero flag reset to indicate match found.",
    "11771": "Point to the flag byte for the row.",
    "11772": "Is it the last row of the BASIC line?",
    "11774": "Jump if so.",
    "11776": "Next row.",
    "11777": "Column 0.",
    "11779": "Fetch number of rows in the Below-Screen Line Edit Buffer.",
    "11782": "Exceeded last line in Below-Screen Line Edit Buffer?",
    "11783": "Jump back if not to retrieve the character from the next row.",
    "11785": "L=Signal at the end of the last row of the BASIC line.",
    "11787": "A='Enter' character.",
    "11789": "Return with zero flag reset to indicate match found.",
    "11790": "Column 31.",
    "11792": "Is column > 31?",
    "11794": "Return if B is greater than 31.",
    "11796": "HL=Column number.",
    "11799": "Fetch the character at the specified column.",
    "11800": "Increment the column number.",
    "11801": "Signal character fetched.",
    "11803": "Number of bytes to copy.",
    "11804": "Number of editing rows (20 for upper screen).",
    "11805": "Number of bytes to copy.",
    "11806": "Number of editing rows (1 for lower screen).",
    "11810": "Signal using main screen.",
    "11812": "Upper screen lines table.",
    "11815": "Destination workspace variable. The number of editing rows on screen.",
    "11818": "Copy one byte from $2E1C (ROM 0) to $EC15",
    "11824": "Signal using lower screen.",
    "11829": "Perform 'PRINT AT 0,0;'.",
    "11832": "Lower screen lines table.",
    "11835": "Destination workspace variable. The number of editing rows on screen.",
    "11838": "Copy one byte from $2E1E (ROM 0) to $EC15",
    "11841": "[Could have saved 1 byte by calling routine at $2E7B (ROM 0)]",
    "11843": "HL=Column number.",
    "11844": "HL=Address in edit buffer of the specified column.",
    "11845": "Fetch the contents.",
    "11846": "Is it a null character, i.e. end-of-line or past the end-of-line?",
    "11849": "Return if this character is part of the edited line.",
    "11852": "Jump ahead if the first column.",
    "11854": "Otherwise check the",
    "11855": "preceding byte",
    "11856": "and if it is non-zero",
    "11857": "then return with",
    "11859": "HL pointing to the",
    "11860": "first zero byte.",
    "11862": "Get the current character.",
    "11863": "Is it a null (i.e. end-of-line)?",
    "11865": "Signal position is editable.",
    "11866": "Return if this character is part of the edited line.",
    "11867": "Advance to the next position.",
    "11868": "Increment the column number.",
    "11870": "Reached the end of the row?",
    "11872": "Jump back if more columns to check.",
    "11874": "Return with carry flag reset if specified column position does not exist.",
    "11875": "[Could have saved 1 byte by calling routine at $2E7B (ROM 0)]",
    "11877": "HL=Column number.",
    "11878": "HL=Address in edit buffer of the specified column.",
    "11879": "Fetch the contents.",
    "11880": "Is it a null character, i.e. end-of-line or past the end-of-line?",
    "11882": "Signal position is editable.",
    "11883": "Return if an editable character was found.",
    "11884": "Get the current character.",
    "11885": "Is it a null, i.e. non-editable?",
    "11887": "Jump if not.",
    "11889": "At column 0?",
    "11891": "Return if so.",
    "11892": "Next column position to test.",
    "11893": "Decrement column index number.",
    "11894": "Repeat test on previous column.",
    "11896": "Advance to the column after the editable position.",
    "11897": "Signal position is editable.",
    "11901": "HL=Column number.",
    "11902": "HL=Address in edit buffer of the specified column.",
    "11903": "Get the current character.",
    "11905": "Editor flags.",
    "11908": "Clear carry flag. [Redundant since carry flag return state never checked]",
    "11909": "Is the Screen Line Edit Buffer is full?",
    "11911": "Return if it is.",
    "11912": "Save cursor position.",
    "11913": "Save key code. [Redundant since $30B4 (ROM 0) preserves AF]",
    "11914": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11917": "Get key code. [Redundant since $30B4 (ROM 0) preserves AF]",
    "11918": "Insert character into edit buffer row at current cursor position, shifting the row right. Returns carry flag reset. Zero flag will be set if byte shift out of last column position was $00.",
    "11921": "Save key code and flags.",
    "11922": "HL=Address of edit buffer row. DE=Address of flags.",
    "11923": "Print a row of the edit buffer to the screen.",
    "11926": "DE=Address of edit buffer row. HL=Address of flags.",
    "11927": "Get key code and flags.",
    "11928": "Sets the carry flag since it was reset via the call to $16AC (ROM 0). [Redundant since never tested]",
    "11929": "Jump ahead to make a return if there was no spill out from column 31, with the carry flag set.",
    "11931": "Save key code.",
    "11932": "First column in the next row.",
    "11934": "Next row.",
    "11935": "The number of editing rows on screen.",
    "11938": "Has the bottom of the Screen Line Edit Buffer been reached?",
    "11939": "Jump ahead if so.",
    "11941": "Fetch contents of flag byte for the row (byte after the 32 columns).",
    "11942": "E=Old flags.",
    "11943": "Mask off 'last row of BASIC line' flag. [Other bits not used, could have used AND $F7]",
    "11945": "Has the status changed?",
    "11946": "Store the new flags, marking it as not the last BASIC row.",
    "11947": "A=Original flags byte for the row.",
    "11948": "Signal that the row spans onto another row.",
    "11950": "Save the flags.",
    "11951": "DE=Start address in Screen Line Edit Buffer of the following row, as specified in C.",
    "11954": "Fetch the flags.",
    "11955": "Jump if the character was not inserted into the last row of the BASIC line.",
    "11957": "Signal not the first row of the BASIC line.",
    "11959": "Insert a blank line into the Screen Edit Buffer.",
    "11962": "Jump if the buffer is full to exit.",
    "11964": "Indent the row by setting the appropriate number of null characters in the current Screen Line Edit Buffer row.",
    "11967": "Get key code.",
    "11968": "Jump back to insert the character in the newly inserted row. [Could have saved 2 bytes by using JR $2EC5 (ROM 0)]",
    "11970": "Find editable position on this row from the previous column to the right, returning column number in B.",
    "11973": "Get key code.",
    "11974": "Jump back to insert the character into the first editable position of next the row.",
    "11976": "Get key code.",
    "11977": "Insert the character at the start of the Below-Screen Line Edit Buffer, shifting all existing characters to the right.",
    "11980": "Retrieve cursor position.",
    "11982": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "11985": "Signal 'first row' and 'last row', indicating a new blank row.",
    "11987": "Save registers.",
    "11989": "B=Row number.",
    "11990": "The empty row data.",
    "11993": "C=Flags for the row.",
    "11995": "Shift all Screen Line Edit Buffer rows down and insert a new blank row, updating the display file if required.",
    "11999": "A=Flags for the row.",
    "12000": "Jump if no edit buffer rows were shifted.",
    "12002": "B=Row number, where the new blank row now is.",
    "12003": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12009": "Point to the flag byte for the row.",
    "12010": "Store the flag byte value for the row.",
    "12011": "Signal edit buffer rows were shifted.",
    "12012": "Restore registers.",
    "12015": "32 null column markers, i.e. none of the columns are editable.",
    "12047": "Flags: Bit 0: 1=The first row of the BASIC line. Bit 1: 0=Does not span onto another row. Bit 2: 0=Not used (always 0). Bit 3: 1=The last row of the BASIC line. Bit 4: 0=No associated line number. Bit 5: 0=Not used (always 0). Bit 6: 0=Not used (always 0). Bit 7: 0=Not used (always 0).",
    "12048": "There is no BASIC line number associated with this edit row.",
    "12050": "Save initial cursor row and column numbers.",
    "12051": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12054": "Stack initial cursor row and column numbers again.",
    "12058": "Point to the flag byte for this row.",
    "12059": "Does the row span onto another row?",
    "12061": "A null character will be inserted. [Could have saved 1 byte by using XOR A and placing it above the BIT 1,(HL) instruction]",
    "12063": "Jump ahead if the row does not span onto another row, i.e. the last row.",
    "12065": "C=Advance to the next row.",
    "12071": "A=Number of editing lines.",
    "12070": "DE points to the first character of the next row. HL points to the first character of the current row.",
    "12074": "Has the end of the screen been reached?",
    "12075": "Jump back if within screen range to find the last row of the BASIC line.",
    "12077": "Point to last row on screen.",
    "12078": "Shift all characters of the BASIC Line held within the Below-Screen Line Edit Buffer.",
    "12081": "Fetch the initial cursor row and column numbers.",
    "12082": "Stack initial cursor row and column numbers.",
    "12083": "DE=Start address in Screen Line Edit Buffer of the last row, as specified in C.",
    "12086": "HL=Initial cursor row and column numbers.",
    "12087": "B=Character to insert.",
    "12088": "A=Row number to delete from.",
    "12089": "Deleting from the same row as the cursor is on within the BASIC line?",
    "12090": "A=Character to insert.",
    "12091": "Save the flags status.",
    "12092": "Jump if not deleting from the row containing the cursor.",
    "12094": "B=Initial column number.",
    "12095": "Jump ahead to continue, with zero flag set to indicate deleting from the row contain the cursor.",
    "12097": "Save the character to insert.",
    "12098": "Save initial cursor row and column numbers.",
    "12101": "Find first editable position on this row searching to the right, returning column number in B.",
    "12104": "HL=Initial cursor row and column numbers.",
    "12105": "A=Character to insert, and zero flag reset to indicate not deleting from the row contain the cursor.",
    "12106": "HL=Initial cursor row and column numbers.",
    "12107": "Deleting flags.",
    "12110": "Signal deleting on the row matching the cursor position.",
    "12112": "Jump if deleting from the row matching the cursor position.",
    "12114": "Signal not deleting on the row matching the cursor position.",
    "12116": "Insert the character into the end of the edit buffer row, shifting all columns left until the cursor position is reached.",
    "12119": "A=Character shifted out, and therefore to be potentially shifted into the end of the previous row.",
    "12120": "B=New column number. C=Row number.",
    "12121": "DE=Start address of row to delete from.",
    "12122": "Deleting flags.",
    "12125": "Deleting from the row matching the cursor position?",
    "12127": "Jump ahead if so.",
    "12129": "Column 0.",
    "12131": "Is there an editable character on the row?",
    "12134": "Jump if there is.",
    "12136": "Shift up all BASIC line rows below to close the gap.",
    "12139": "DE=Start address of row to delete from.",
    "12140": "B=New column number. C=Row number.",
    "12141": "Jump ahead.",
    "12143": "HL=Start address of the row.",
    "12144": "B=New column number. C=Row number.",
    "12145": "Print the row of the edit buffer to the screen, if required.",
    "12148": "A=Character to insert.",
    "12149": "Previous row.",
    "12150": "B=Character to insert.",
    "12151": "HL=Initial cursor row and column numbers.",
    "12152": "Retrieve the flags status (zero flag set if deleting from the row matching the cursor position).",
    "12153": "A=Character to insert.",
    "12154": "Jump back if not deleting from the row matching the cursor position, i.e. all rows after the cursor have not yet been shifted.",
    "12157": "[Redundant since never subsequently checked]",
    "12158": "Retrieve initial cursor row and column numbers.",
    "12163": "Point to the flag byte for the row.",
    "12165": "Is the cursor on a blank row (which is flagged as the first row of a BASIC line)?",
    "12167": "Jump ahead if it is. [Could have improved speed by jumping to $2FB6 (ROM 0) since DE already holds the start address of the row]",
    "12169": "Save the cursor row flag byte.",
    "12170": "Save the cursor row number in C.",
    "12171": "Is the cursor on row 0?",
    "12173": "Jump ahead if it is not, i.e. there is at least one row above.",
    "12176": "Save the cursor row number.",
    "12179": "Find closest line number (or $0000 if no line).",
    "12182": "Line number at top of screen.",
    "12185": "Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer,",
    "12188": "i.e. that are off the top of the screen.",
    "12189": "Decrement the row count, i.e. one less row off the top of the screen.",
    "12190": "DE=Address of row in Above-Screen Line Edit Buffer.",
    "12193": "Retrieve the cursor row number.",
    "12194": "Jump ahead.",
    "12196": "Previous row, i.e. the last row of the BASIC line that contains editable characters.",
    "12197": "DE=Start address in Screen Line Edit Buffer of the previous row.",
    "12200": "Retrieve the cursor row number.",
    "12201": "Retrieve the cursor row flag byte, which indicates last row of BASIC line.",
    "12205": "Point to the flag byte for the previous row.",
    "12206": "Signal that the previous row does not span onto another row.",
    "12208": "Keep the previous row's first BASIC row flag.",
    "12209": "Update the flag byte for the previous row.",
    "12210": "B=Row number in the Screen Line Edit Buffer.",
    "12211": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12214": "Shift up rows of the BASIC line in the Below-Screen Line Edit Buffer, or insert the next line BASIC line if buffer empty.",
    "12217": "Shift Screen Line Edit Buffer rows up from row specified by B and update the display file if required.",
    "12220": "Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.",
    "12223": "Save address of the editing area information.",
    "12224": "Does a previous character exist in the current Screen Line Edit Buffer row?",
    "12227": "Jump if at the start of the BASIC line to print all rows.",
    "12229": "Is previous column position editable? (Returns carry flag set if editable)",
    "12232": "Retrieve address of the editing area information.",
    "12233": "Jump if not editable to print all rows.",
    "12235": "Get character from current cursor position.",
    "12238": "Save current character.",
    "12239": "Save address of the editing area information.",
    "12240": "Delete character to the right, shifting subsequent rows as required.",
    "12243": "Retrieve address of the editing area information.",
    "12244": "Retrieve current character.",
    "12245": "Is it a space?",
    "12247": "Jump back if so to find the end of the last word.",
    "12249": "Save address of the editing area information.",
    "12250": "Does a previous character exist in the current Screen Line Edit Buffer row?",
    "12253": "Jump if at the start of a BASIC line to print all rows.",
    "12255": "Is previous column position editable? (Returns carry flag set if editable)",
    "12258": "Retrieve address of the editing area information.",
    "12259": "Jump if not editable to print all rows.",
    "12261": "Get character from current cursor position",
    "12264": "Is it a space?",
    "12266": "Jump if so.",
    "12268": "Save address of the editing area information.",
    "12269": "Delete character to the right, shifting subsequent rows as required.",
    "12272": "Retrieve address of the editing area information.",
    "12273": "Jump back to delete next character until start of the word found.",
    "12275": "Save address of the editing area information.",
    "12276": "Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.",
    "12279": "Retrieve address of the editing area information.",
    "12280": "Fetch the new end column number.",
    "12281": "Save the flags status.",
    "12282": "Save address of the editing area information.",
    "12286": "Re-enable display file updates.",
    "12288": "The number of editing rows on screen. [This will end up being used as the alternate cursor column]",
    "12291": "Save the row and new column numbers.",
    "12292": "B=Print from row 0.",
    "12294": "C=Number of editing rows on screen.",
    "12295": "Set the zero flag to signal not to change cursor position settings.",
    "12296": "Print all Screen Line Edit Buffer rows to the display file.",
    "12299": "Retrieve the row and new column numbers.",
    "12300": "Editor flags.",
    "12303": "Indicate current line has been altered.",
    "12305": "Retrieve address of the editing area information.",
    "12306": "Store editing position and print cursor.",
    "12309": "Retrieve the flags status.",
    "12311": "Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.",
    "12314": "Save address of the editing area information.",
    "12315": "Get character from current cursor position.",
    "12318": "Retrieve address of the editing area information.",
    "12319": "Is it a null character, i.e. end of BASIC line?",
    "12321": "Signal do not produce an error beep.",
    "12322": "Jump if end of the BASIC line to print all rows.",
    "12324": "Save the character.",
    "12325": "Save address of the editing area information.",
    "12326": "Delete character to the right, shifting subsequent rows as required.",
    "12329": "Retrieve address of the editing area information.",
    "12330": "Retrieve the character.",
    "12331": "Was the character a space?",
    "12333": "Jump back if not to delete the next character until the end of the word is found.",
    "12335": "Get character from current cursor position.",
    "12338": "Is it a space?",
    "12340": "Signal do not produce an error beep.",
    "12341": "Jump if not to print all rows.",
    "12343": "Save address of the editing area information.",
    "12344": "Delete character to the right, shifting subsequent rows as required.",
    "12347": "Retrieve address of the editing area information.",
    "12348": "Jump back to delete all subsequent spaces until the start of the next word or the end of the line is found.",
    "12350": "Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.",
    "12353": "Save address of the editing area information.",
    "12354": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12360": "Point to the flag byte for the row.",
    "12361": "Is it the first row of the BASIC line?",
    "12363": "Jump if so.",
    "12365": "Is previous column position editable? (Returns carry flag set if editable)",
    "12368": "Jump if not editable since nothing to delete.",
    "12370": "Delete character to the right, shifting subsequent rows as required.",
    "12373": "Retrieve address of the editing area information.",
    "12374": "Jump back to delete next character until first row of the BASIC line is found.",
    "12376": "[Redundant byte]",
    "12377": "Fetch the new end column number.",
    "12378": "Is it at the start of the row?",
    "12380": "Jump if so since nothing to delete.",
    "12382": "Point to previous column.",
    "12383": "Get character from current cursor position.",
    "12386": "Point back to the new end column.",
    "12387": "Is it a null character, i.e. not editable?",
    "12389": "Jump if so since nothing to delete.",
    "12391": "Point to previous column.",
    "12392": "Delete character to the right, shifting subsequent rows as required.",
    "12395": "Jump back to delete the next character until the start of the BASIC line is found.",
    "12397": "Retrieve address of the editing area information.",
    "12398": "Signal not to produce error beep.",
    "12399": "Jump back to print all rows.",
    "12402": "Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.",
    "12405": "Get character from current cursor position.",
    "12408": "Is it a null character, i.e. at end of BASIC line?",
    "12410": "Signal not to produce an error beep.",
    "12411": "Jump if end of BASIC line to print all rows.",
    "12413": "Save address of the editing area information.",
    "12414": "Delete character to the right, shifting subsequent rows as required.",
    "12417": "Retrieve address of the editing area information.",
    "12418": "Jump back to delete the next character until the end of the BASIC line is found.",
    "12420": "Editor flags.",
    "12423": "Signal that the Screen Line Edit Buffer is not full.",
    "12425": "Remove cursor, restoring old attribute.",
    "12431": "Indicate not to print edit buffer rows, therefore preventing intermediate screen updates.",
    "12433": "Point to the editing area information.",
    "12437": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12443": "HL=Address of the flag byte for this row.",
    "12444": "Is this the first row of a BASIC line?",
    "12446": "Jump if not.",
    "12448": "Fetch the column number.",
    "12449": "At the start of the row?",
    "12451": "Jump ahead if so.",
    "12453": "Move to the previous column.",
    "12454": "Get current character from Screen Line Edit Buffer.",
    "12457": "Move back to the original column.",
    "12458": "Does the position contain a null?",
    "12460": "Jump if not.",
    "12462": "Reset the zero flag.",
    "12466": "Set the zero flag.",
    "12468": "Point to the Screen Line Edit Buffer.",
    "12471": "Save A.",
    "12472": "A=Edit row number.",
    "12473": "35 bytes per row.",
    "12476": "Row requested found?",
    "12477": "Jump to exit if so.",
    "12479": "Advance to next row.",
    "12481": "Jump to test if requested row found.",
    "12483": "Transfer address to DE.",
    "12484": "Restore A.",
    "12487": "DE=Start address in Screen Line Edit Buffer of the row specified in C.",
    "12493": "DE = $EC16 + $0023*C + B.",
    "12496": "Number of bytes in table.",
    "12497": "$F6F5 = Number of rows held in the Below-Screen Line Edit Buffer.",
    "12498": "$F6F6/7. [*BUG* - These two bytes should not be here and the table should only contain 3 bytes. Credit: Paul Farrow]",
    "12500": "$F6F8/9 = Points to next location within the Below-Screen Line Edit Buffer.",
    "12502": "Default Below-Screen Line Edit Buffer settings.",
    "12505": "Destination address.",
    "12508": "Copy bytes.",
    "12511": "Save BC.",
    "12512": "Save DE.",
    "12513": "Point to the Below-Screen Line Edit Buffer details.",
    "12516": "Save it.",
    "12517": "A=Number of rows held in Below-Screen Line Edit Buffer.",
    "12518": "Are there any rows below screen?",
    "12519": "Jump if so.",
    "12521": "Save the address of the Below-Screen Line Edit Buffer details.",
    "12522": "Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine into RAM.",
    "12525": "HL=Line number of the BASIC line in the program area being edited.",
    "12528": "Create line number representation in the Keyword Construction Buffer of the next BASIC line.",
    "12531": "Jump if next line does not exist, with HL holding $0000.",
    "12533": "Store the new line number.",
    "12537": "BC=Line number of the next BASIC line, or last BASIC line in the program.",
    "12538": "Retrieve the address of the Below-Screen Line Edit Buffer details.",
    "12539": "Copy the BASIC line into the Below-Screen Line Edit Buffer, or empty the first buffer row if the BASIC line does not exist.",
    "12542": "Decrement the count of the number of rows held in the Below-Screen Line Edit Buffer, i.e. assume the rows have been shifted.",
    "12543": "Jump forward.",
    "12545": "Editor flags.",
    "12548": "Signal that the Screen Line Edit Buffer is not full.",
    "12550": "Below-Screen Line Edit Buffer, the temporary copy of line being edited.",
    "12555": "Move all rows in the Below-Screen Line Edit Buffer up by one row.",
    "12559": "20 rows.",
    "12564": "Decrement the count of the number of rows held in the Below-Screen Line Edit Buffer.",
    "12565": "[Redundant since never subsequently checked]",
    "12566": "DE=Points to number of rows held in the Below-Screen Line Edit Buffer.",
    "12567": "Update the number of rows held in the Below-Screen Line Edit Buffer",
    "12568": "HL=Address of first row in the Below-Screen Line Edit Buffer.",
    "12571": "Restore DE.",
    "12572": "Restore BC.",
    "12574": "Save BC.",
    "12575": "DE=Start address in Screen Line Edit Buffer of the last editing row.",
    "12579": "Point to the flag byte for the edit buffer row.",
    "12580": "Fetch flag byte.",
    "12581": "Invert bits.",
    "12584": "Jump if not the first row of the BASIC line or no associated line number stored.",
    "12586": "HL=Points at flag byte of the last Screen Line Edit Buffer row.",
    "12587": "DE=Address of the last Screen Line Edit Buffer row.",
    "12591": "DE=Corresponding BASIC line number.",
    "12592": "Save it.",
    "12593": "Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.",
    "12596": "HL=Corresponding line number for last editing row.",
    "12597": "Find the closest line number.",
    "12600": "Jump if line does not exist.",
    "12602": "Store as the line number of the BASIC line being edited.",
    "12605": "DE=Address of the last Screen Line Edit Buffer row.",
    "12606": "HL=Points at flag byte of edit buffer row.",
    "12607": "Is it the first row of the BASIC line?",
    "12609": "Point to the Below-Screen Line Edit Buffer details.",
    "12612": "Save the address of the Below-Screen Line Edit Buffer details.",
    "12613": "Jump if not the first row of the BASIC line.",
    "12615": "Signal no rows held in the Below-Screen Line Edit Buffer. [Could have saved 1 byte by using XOR A]",
    "12617": "Signal Below-Screen Line Edit Buffer is not full.",
    "12618": "Store new flag.",
    "12620": "Fetch the number of rows held in the Below-Screen Line Edit Buffer.",
    "12621": "Has the bottom of the buffer been reached?",
    "12623": "Jump if so, with the carry flag reset to indicate the buffer is full.",
    "12625": "Length of an edit buffer row.",
    "12628": "Address of the first row in the Below-Screen Line Edit Buffer.",
    "12631": "HL=Address of the last row in the Screen Line Edit Buffer, DE=Address of the first row in the Below-Screen Line Edit Buffer.",
    "12632": "Copy the last Screen Line Edit Buffer row into the first Below-Screen Line Edit Buffer row, i.e. the 'visible' edit buffer row.",
    "12638": "DE=End of the last row in the Below-Screen Line Edit Buffer.",
    "12639": "Length of an edit buffer row.",
    "12643": "HL=End of penultimate row in the Below-Screen Line Edit Buffer.",
    "12645": "Length of the Below-Screen Line Edit Buffer minus one row.",
    "12648": "Shift all the rows down by one.",
    "12650": "Increment the number of rows held in the Below-Screen Line Edit Buffer.",
    "12651": "Signal Below-Screen Line Edit Buffer is not full",
    "12652": "Jump to store the number of rows held in the Below-Screen Line Edit Buffer.",
    "12654": "Save registers.",
    "12656": "Save the character to insert.",
    "12657": "Column 0.",
    "12659": "Row 1.",
    "12661": "Save address of the row's flag byte.",
    "12662": "Find row address specified by C in the Below-Screen Line Edit Buffer, into DE.",
    "12665": "Retrieve address of the row's flag byte.",
    "12666": "Is this the end row of the BASIC line?",
    "12668": "Indicate that it is no longer the end row of the BASIC line.",
    "12670": "Jump if it was the end row of the BASIC line.",
    "12672": "Find first editable position on this row from the previous column to the right, returning column number in B.",
    "12675": "A=Character to insert.",
    "12676": "Insert character into the start of the edit buffer row, shifting the row right. Returns carry flag reset.",
    "12679": "Jump if the byte shifted out of the last column position was $00, hence no more shifting required.",
    "12681": "Stack the character which needs to be inserted into the next row.",
    "12682": "B=First column in the next row.",
    "12684": "C=Next row.",
    "12686": "Has the bottom row of the Below-Screen Line Edit Buffer been reached, i.e. row 21?",
    "12688": "Jump ahead if not.",
    "12690": "Point to last character of the current row.",
    "12691": "Get the character.",
    "12692": "Point back to the flag byte of this row.",
    "12693": "Is the character a null character? [Could have saved 1 byte by using AND A]",
    "12695": "Jump ahead if it is.",
    "12697": "Save address of the flag byte.",
    "12698": "Editor flags.",
    "12701": "Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is full.",
    "12703": "HL=Address of the flag byte.",
    "12704": "Does the row span onto another row?",
    "12706": "Signal that the row spans onto another row.",
    "12708": "Signal not the last row of the BASIC line.",
    "12710": "Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.",
    "12713": "Jump back if spans onto another row to shift it also.",
    "12715": "B=Column number. C=Row number.",
    "12716": "DE=Start address of the row in the edit buffer.",
    "12717": "Null all column positions in the edit buffer row.",
    "12720": "Set the flag byte for the row to indicate it is the last row of the BASIC line.",
    "12722": "DE=Start address of the row in the edit buffer.",
    "12723": "B=Column number. C=Row number.",
    "12724": "Indent the row by setting the appropriate number of null characters.",
    "12727": "Get character to insert.",
    "12728": "Jump back to insert it.",
    "12730": "Get the row number.",
    "12731": "Store as the number of rows held within the Below-Screen Line Edit Buffer.",
    "12734": "Mark this row as the last row of the BASIC line.",
    "12736": "Restore registers.",
    "12739": "Address of the Below-Screen Line Edit Buffer.",
    "12742": "Jump to find the row address and return.",
    "12745": "Save registers.",
    "12747": "Editor flags.",
    "12750": "Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is not full.",
    "12752": "A=Number of rows held in the Below-Screen Line Edit Buffer.",
    "12755": "C=Number of rows held in the Below-Screen Line Edit Buffer.",
    "12756": "Are there any rows in the Below-Screen Line Edit Buffer?",
    "12757": "A null character.",
    "12759": "Jump if there are no rows. [Redundant check since this routine should never be called if there are no rows in this buffer]",
    "12761": "Find the address of the last used row within Below-Screen Line Edit Buffer, into DE.",
    "12764": "Save the character to insert.",
    "12765": "Start searching from column 0.",
    "12767": "Find editable position on this row to the right, returning column number in B.",
    "12770": "Jump if no editable position found, i.e. a blank row.",
    "12772": "A=Character to insert.",
    "12773": "Insert the character into the end of the edit buffer row, shifting all columns left until the cursor position is reached.",
    "12776": "A=Character shifted out, zero flag set if the shifted out character was a null ($00).",
    "12777": "Save the row number.",
    "12778": "Start searching from column 0.",
    "12780": "Is this now a blank row? i.e. Find editable position on this row to the right, returning column number in B.",
    "12783": "C=Row number.",
    "12784": "Jump if editable position found.",
    "12786": "Point to the flag byte for the blank row.",
    "12787": "Fetch the flag byte.",
    "12788": "Save the flag byte for the blank row.",
    "12789": "Save the row number.",
    "12790": "Fetch the row number of this blank row.",
    "12791": "Is this the first row in the Below-Screen Line Edit Buffer?",
    "12793": "Jump if not.",
    "12795": "The number of editing rows on screen.",
    "12798": "C=Bottom row number in the Screen Line Edit Buffer.",
    "12799": "DE=Start address in Screen Line Edit Buffer of the bottom row, as specified in C.",
    "12802": "Jump ahead to continue.",
    "12804": "Previous row within the Below-Screen Line Edit Buffer.",
    "12805": "Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.",
    "12808": "Retrieve the row number.",
    "12809": "A=Flag byte value for the blank row.",
    "12813": "Point to the flag byte for the row above.",
    "12814": "Signal that the row above does not span onto another row.",
    "12816": "Or in the flag bits from the blank row, essentially this will retain the 'last row' bit.",
    "12817": "Update the flag byte for the row above.",
    "12818": "Point to the number of rows held in the Below-Screen Line Edit Buffer.",
    "12821": "Decrement the row count.",
    "12822": "Fetch the character shifted out from the current row, ready for insertion into the row above.",
    "12823": "Previous row.",
    "12824": "Jump back if the character shifted out was not null, i.e. more rows above to shift.",
    "12826": "[Redundant since never subsequently checked]",
    "12827": "Restore registers.",
    "12830": "Number of bytes in table.",
    "12831": "$F9DB = Number of rows held in the Above-Screen Line Edit Buffer.",
    "12832": "$F9DC/D = Points to next available location within the Above-Screen Line Edit Buffer.",
    "12834": "Default Above-Screen Line Edit Buffer settings.",
    "12837": "Destination address.",
    "12840": "Copy bytes.",
    "12843": "Save registers.",
    "12845": "Point to the Above-Screen Line Edit Buffer settings.",
    "12848": "Save address of the Above-Screen Line Edit Buffer settings.",
    "12849": "Fetch number of rows of the BASIC line that are off the top of the screen.",
    "12850": "Are there any rows off the top of the screen?",
    "12851": "Jump if there are.",
    "12853": "Save address of the Above-Screen Line Edit Buffer settings.",
    "12854": "Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.",
    "12857": "HL=New line number at top of screen.",
    "12860": "Verify the line number exists, or fetch the next line number if not.",
    "12863": "Jump if the line does not exist.",
    "12865": "Store the line number found as the one at the top of screen.",
    "12869": "BC=New line number at top of screen.",
    "12870": "HL=Address of the Above-Screen Line Edit Buffer settings.",
    "12873": "Point to the first row of the Above-Screen Line Edit Buffer.",
    "12874": "Jump if the line did not exist.",
    "12876": "Copy the new BASIC line into the Above-Screen Line Edit Buffer.",
    "12879": "Decrement the count of the number of rows held in the Above-Screen Line Edit Buffer.",
    "12880": "HL=Start of the next row in the Above-Screen Line Edit Buffer.",
    "12881": "Jump ahead to continue.",
    "12883": "HL=Address of the next location within the Above-Screen Line Edit Buffer to use.",
    "12889": "Point to the previous row location within the Above-Screen Line Edit Buffer.",
    "12891": "Signal to update the number of rows held in the Above-Screen Line Edit Buffer.",
    "12892": "Decrement the count of the number of rows held in the Above-Screen Line Edit Buffer.",
    "12893": "DE=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "12894": "HL=Address of the Above-Screen Line Edit Buffer settings.",
    "12895": "Jump if no need to update the count of the number of rows in the Above-Screen Line Edit Buffer.",
    "12897": "Store the number of rows held in the Above-Screen Line Edit Buffer.",
    "12901": "Store the address of the next row to use within the Above-Screen Line Edit Buffer.",
    "12902": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "12903": "Restore registers.",
    "12906": "Save registers.",
    "12911": "Point to the flag byte for this row within the Below-Screen or Screen Line Edit Buffer.",
    "12916": "Jump if not the first row of the BASIC line or no associated line number stored.",
    "12918": "DE=Start address of the row.",
    "12919": "HL=Address of the flag byte for the row in the Line Edit Buffer.",
    "12923": "DE=Line number of the corresponding BASIC line.",
    "12924": "Store this as the line number that is at the top of the screen.",
    "12928": "HL=Address of the flag byte for the row in the Below-Screen or Screen Line Edit Buffer.",
    "12929": "DE=Start address of the row.",
    "12930": "Is this the last row of the BASIC line?",
    "12932": "Point to the Above-Screen Line Edit Buffer settings.",
    "12935": "Stack the address of the Above-Screen Line Edit Buffer settings.",
    "12936": "Jump if not the last row of the BASIC line.",
    "12938": "Stack the address of the Above-Screen Line Edit Buffer settings.",
    "12939": "Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.",
    "12942": "Line number at top of screen.",
    "12945": "Create line number representation in the Keyword Construction Buffer of the next BASIC line.",
    "12948": "Update the line number at top of screen.",
    "12951": "HL=Address of the Above-Screen Line Edit Buffer settings.",
    "12954": "Point to the start of the Above-Screen Line Edit Buffer.",
    "12955": "No rows held in the Above-Screen Line Edit Buffer. [Could have saved 1 byte by using XOR A]",
    "12957": "Signal to update the number of rows count.",
    "12958": "Jump back to store the new Above-Screen Line Edit Buffer settings.",
    "12960": "Fetch the number of rows held in the Above-Screen or Screen Line Edit Buffer.",
    "12961": "Are there 20 rows, i.e. the buffer is full?",
    "12963": "Jump if the buffer is full, with the carry flag reset.",
    "12965": "Increment the count of the number of rows in the Above-Screen Line Edit Buffer.",
    "12966": "Fetch the address of the next row to use within the Above-Screen Line Edit Buffer.",
    "12969": "The length of one row in the edit buffer, including the 3 data bytes.",
    "12972": "DE=Address of next location within the Above-Screen Line Edit Buffer, HL=Address of the row in the Below-Screen or Screen Line Edit Buffer to store.",
    "12973": "Copy the row of the BASIC line into the Above-Screen Line Edit Buffer.",
    "12975": "HL=Address of next row to use within the Above-Screen Line Edit Buffer.",
    "12976": "Signal to update the count of the number of rows.",
    "12977": "Jump back to store the new Above-Screen Line Edit Buffer settings.",
    "12979": "HL=Address of the Above-Screen Line Edit Buffer settings.",
    "12980": "Restore registers.",
    "12983": "Point to the start of the Above-Screen Line Edit Buffer.",
    "12986": "Find the row address.",
    "12989": "Number of table entries.",
    "12990": "Code: Enter.",
    "12991": "Address of the 'Enter' action handler routine.",
    "12993": "Code: NULL.",
    "12994": "Null remaining columns of an edit buffer row.",
    "12996": "Code: FLASH.",
    "12997": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "13000": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "13003": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "13006": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "13009": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "13012": "Fetch next de-tokenized character from the BASIC line within the program area.",
    "12999": "Code: BRIGHT.",
    "13002": "Code: INVERSE.",
    "13005": "Code: OVER.",
    "13008": "Code: INK.",
    "13011": "Code: PAPER.",
    "13014": "HL=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line Edit Buffer.",
    "13015": "DE=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line Edit Buffer.",
    "13018": "Advance to the start of the row in the edit buffer.",
    "13019": "DE=Address of the start of the BASIC line in the Above-Screen/Below-Screen Line Edit Buffer.",
    "13023": "Point to the flag byte for the row.",
    "13024": "Signal the first row of the BASIC line.",
    "13029": "Store the corresponding BASIC line number.",
    "13030": "Row 1.",
    "13032": "Column 0.",
    "13034": "Save the column and row numbers.",
    "13035": "Save the Above-Screen/Below-Screen Line Edit Buffer address.",
    "13036": "Fetch mode.",
    "13039": "Calculator mode?",
    "13041": "If not then fetch the next de-tokenized character from the BASIC line within the program area.",
    "13044": "Retrieve the Above-Screen/Below-Screen Line Edit Buffer address.",
    "13045": "Retrieve the column and row numbers.",
    "13046": "Jump if Editor mode and a character was available (if calculator mode then carry flag was reset by test above).",
    "13048": "A=Row number.",
    "13049": "Is it row 1?",
    "13051": "A='Enter' character.",
    "13053": "Jump if not.",
    "13055": "A=Column number.",
    "13056": "Is it column 0?",
    "13057": "A='Null' character, the code used to indicate to null edit positions.",
    "13059": "Jump if so.",
    "13061": "A='Enter' character.",
    "13063": "The action handler table.",
    "13066": "Call the action handler routine to process the character.",
    "13069": "Jump if no more characters are available.",
    "13071": "Jump back if an action handler was found so as to process the next character.",
    "13073": "A=Character.",
    "13076": "Exceeded column 31?",
    "13077": "Jump ahead if not.",
    "13079": "New flag byte value indicating the row spans onto another row and there is an associated line number.",
    "13081": "Mark this row as spanning onto the next and clear the following row's flags.",
    "13084": "Jump ahead if not at bottom of the line edit buffer.",
    "13086": "Discard the stacked item.",
    "13087": "A='Enter' character.",
    "13089": "Jump back to process the 'Enter' code.",
    "13091": "Indent the row by setting the appropriate number of null characters in the current Above-Screen Line Edit Buffer row.",
    "13094": "A=Character.",
    "13095": "Store the character in the current row/column in the Above-Screen Line Edit Buffer.",
    "13098": "Jump back to handle the next character.",
    "13100": "HL=Address of the BASIC line being edited in the Above-Screen Line Edit Buffer.",
    "13101": "A=Number of rows in the Above-Screen Line Edit Buffer.",
    "13102": "[Redundant since carry flag is always set by here, and zero flag never subsequently checked]",
    "13103": "[Redundant since never subsequently checked]",
    "13105": "Save the new flag byte value.",
    "13106": "HL=Address of flag byte for the row.",
    "13109": "Retrieve the new flag byte value.",
    "13110": "Toggle to set 'associated line number' and 'row spans onto another row' flags.",
    "13111": "Store the new flag byte value.",
    "13112": "A=Row number.",
    "13113": "At bottom of line edit buffer?",
    "13115": "Return if so.",
    "13116": "Advance the row number.",
    "13120": "Point to the start of the next row.",
    "13125": "Point to the flag byte for the next row.",
    "13126": "Clear the flags to indicate no BASIC line on this row.",
    "13128": "Signal still on a row within the edit buffer.",
    "13130": "Find the address of the BASIC line in the program area with the specified line number.",
    "13133": "Return if the line exists.",
    "13134": "No line number.",
    "13138": "Create next line number representation in the Keyword Construction Buffer.",
    "13141": "Return if line exists.",
    "13142": "Line not found.",
    "13146": "Fetch the next de-tokenized character from the BASIC line within the program area.",
    "13150": "Return if a character was available.",
    "13151": "Signal no line number of command.",
    "13154": "Signal no further character to fetch from the BASIC line within the program area.",
    "13157": "Signal no further character to fetch from the Keyword Construction Buffer.",
    "13160": "Source for Insert Keyword Representation Into Keyword Construction Buffer routine.",
    "13163": "Destination for Insert Keyword Representation Into Keyword Construction Buffer routine.",
    "13169": "Copy the routine to RAM bank 7 at address $FCAE.",
    "13172": "Disable interrupts whilst paging.",
    "13176": "Page in ROM 1, SCREEN 0, no locking, RAM bank 7.",
    "13180": "Was the token $F5 or above?",
    "13184": "Was the token $E5 or above?",
    "13188": "Was the token $D5 or above?",
    "13192": "Was the token $C5 or above?",
    "13196": "Was the token $B5 or above?",
    "13200": "$0096. Token table entry \"RND\" in ROM 1.",
    "13207": "$00CF. Token table entry \"ASN\" in ROM 1.",
    "13214": "$0100. Token table entry \"OR\" in ROM 1.",
    "13221": "$013E. Token table entry \"MERGE\" in ROM 1.",
    "13228": "$018B. Token table entry \"RESTORE\" in ROM 1.",
    "13235": "$01D4. Token table entry \"PRINT\" in ROM 1.",
    "13238": "Take a copy of the index value.",
    "13239": "If A=0 then already have the entry address.",
    "13240": "If indexed item found then jump ahead to copy the characters of the token.",
    "13242": "Fetch a character.",
    "13243": "Point to next character.",
    "13244": "Has end of token marker been found?",
    "13246": "Loop back for next character if not.",
    "13248": "Count down the index of the required token.",
    "13249": "Jump back to test whether the required token has been reached.",
    "13251": "DE=Keyword Construction Buffer.",
    "13254": "Store the start address of the constructed keyword.",
    "13258": "Print a leading space?",
    "13262": "Signal leading space not required.",
    "13264": "Jump if leading space not required.",
    "13269": "Print a leading space.",
    "13271": "Insert a leading space.",
    "13272": "Advance to next buffer position.",
    "13273": "Fetch a character of the keyword.",
    "13274": "Store it.",
    "13275": "Advance to next keyword character.",
    "13276": "Store the keyword character in the BASIC line buffer.",
    "13277": "Advance to the next buffer position.",
    "13278": "Test if the end of the keyword string.",
    "13280": "Jump back if not to repeat for all characters of the keyword.",
    "13282": "Get keyword character back.",
    "13283": "Mask off bit 7 which indicates the end of string marker.",
    "13285": "Point back at the last character of the keyword copied into the buffer",
    "13286": "and store it.",
    "13287": "Advance to the position in the buffer after the last character of the keyword.",
    "13288": "$A0. Space + end marker.",
    "13290": "Store an 'end of BASIC line so far' marker.",
    "13296": "Page in ROM 0, SCREEN 0, no locking, RAM bank 7.",
    "13298": "Re-enable interrupts.",
    "13300": "Disable interrupts whilst paging.",
    "13304": "Select ROM 1, SCREEN 0, RAM bank 7.",
    "13308": "$0096. Address of token table in ROM 1.",
    "13311": "Character code of the first token - 'RND'.",
    "13313": "Keyword Conversion Buffer holds the text to match against.",
    "13316": "Fetch a character from the buffer.",
    "13317": "Mask off terminator bit.",
    "13319": "Is it lowercase?",
    "13321": "Fetch the character again from the buffer.",
    "13322": "Jump if uppercase.",
    "13324": "Make the character uppercase.",
    "13326": "Does the character match the current item in the token table?",
    "13327": "Jump if it does not.",
    "13329": "Point to the next character in the buffer.",
    "13330": "Point to the next character in the token table.",
    "13331": "Has the terminator been reached?",
    "13333": "Jump back if not to test the next character in the token.",
    "13335": "Signal a match was found.",
    "13336": "Jump ahead to continue.",
    "13338": "The next character code to test against.",
    "13339": "Jump if all character codes tested.",
    "13341": "Fetch the character from the token table.",
    "13342": "Has the end terminator been found?",
    "13344": "Point to the next character.",
    "13345": "Jump back if no terminator found.",
    "13347": "Jump back to test against the next token.",
    "13349": "Clear the carry flag to indicate no match found.",
    "13350": "Fetch the character code of the matching token ($00 for no match).",
    "13351": "Select ROM 0, SCREEN 0, RAM bank 7.",
    "13358": "Re-enable interrupts.",
    "13360": "Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the address of the next character in the BASIC line within the program area being de-tokenized).",
    "13363": "[*BUG* - Supposed to be XOR A to ensure that a leading space is shown before a command keyword is printed. However, most of the time the A register will enter the routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]",
    "13364": "Print a leading space flag.",
    "13367": "Use Normal RAM Configuration (physical RAM bank 0).",
    "13370": "Find address of the specified BASIC line, into HL.",
    "13373": "Jump if suitable line number not found, i.e. end of program reached.",
    "13375": "Jump if line number did not match, i.e. is higher than the line requested.",
    "13377": "BC=Line number.",
    "13379": "Jump if the first program line requested (line number of 0).",
    "13381": "Move to the start of the next BASIC line.",
    "13384": "Check whether at the end of the BASIC program.",
    "13387": "Jump if at the end of the BASIC program.",
    "13389": "HL=Address of the BASIC line.",
    "13391": "DE=Line number.",
    "13392": "Use Workspace RAM configuration (physical RAM bank 7).",
    "13395": "Save the line number.",
    "13396": "Save the address of the BASIC line+1.",
    "13397": "Save IX.",
    "13399": "IX=Keyword Construction Buffer, the location where the line number will be created.",
    "13403": "Store the start of the buffer as the next location to store a character in.",
    "13407": "HL=Line number.",
    "13408": "Signal no digit printed yet.",
    "13410": "-1000.",
    "13413": "Insert the thousand digit.",
    "13416": "-100.",
    "13419": "Insert the hundred digit.",
    "13422": "-10.",
    "13425": "Insert the ten digit.",
    "13428": "-1.",
    "13431": "Insert the units digits. [Note that this is not designed to handle line number 0, which technically is not supported by Sinclair BASIC. The call would need to be preceded by a LD B,$01 instruction to make this function support a line number of 0. Credit: Ian Collier (+3), Andrew Owen (128)]",
    "13434": "IX points to previous ASCII digit.",
    "13441": "Set bit 7 to mark it as the end of the line number representation.",
    "13444": "Restore registers.",
    "13446": "HL=Address of the BASIC line+1.",
    "13447": "DE=Line number.",
    "13448": "HL=Points to length field of the BASIC line.",
    "13450": "HL=Points to the command field of the BASIC line.",
    "13451": "Store it as the next character to fetch when parsing the BASIC line to de-tokenize it.",
    "13454": "DE=Points to the command field of the BASIC line, HL=Line number.",
    "13455": "Signal line exists.",
    "13457": "Use Workspace RAM configuration (physical RAM bank 7).",
    "13460": "Return with carry flag reset to signal line does not exist.",
    "13461": "A=Counter.",
    "13462": "Keep adding DE",
    "13463": "and incrementing the counter",
    "13464": "until there is no carry.",
    "13466": "Adjust for the last addition and",
    "13468": "counter value that caused the overflow.",
    "13469": "Convert to an ASCII digit.",
    "13471": "Store in the buffer.",
    "13474": "Is it a zero?",
    "13476": "Jump ahead if not.",
    "13478": "Get the 'digit printed' flag.",
    "13480": "Jump ahead if already printed a digit.",
    "13482": "Otherwise this is a leading zero, so",
    "13484": "store a zero byte to indicate 'nothing to print'.",
    "13487": "and jump ahead to point to the next buffer location.",
    "13489": "Indicate 'digit printed'.",
    "13491": "Point to the next buffer location.",
    "13494": "Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the address of the next character in the BASIC line within the program area being de-tokenized).",
    "13497": "[*BUG* - Supposed to be XOR A to ensure that a leading space is shown before a command keyword is printed. However, most of the time the A register will enter the routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]",
    "13498": "Store 'print a leading space' flag.",
    "13501": "Use Normal RAM Configuration (physical RAM bank 0).",
    "13504": "Find the address of the BASIC line with this line number, or the next line otherwise.",
    "13507": "Jump if does not exist.",
    "13509": "HL=Address of BASIC line.",
    "13511": "Address of $0000, i.e. no line exists?",
    "13512": "Assume line number found.",
    "13513": "Jump if a line was found.",
    "13516": "Reset carry flag to indicate line number does not exist",
    "13517": "and jump to make a return.",
    "13519": "Save the address of the original line.",
    "13520": "Skip past the line number.",
    "13522": "Retrieve the line length into DE.",
    "13526": "Point to the start of the next line.",
    "13527": "DE=Address of original line.",
    "13532": "Signal not at end of BASIC.",
    "13533": "Return if not at end of program.",
    "13534": "Signal at end of BASIC.",
    "13536": "Test the first byte.",
    "13538": "Return if not the same.",
    "13539": "Test the second byte.",
    "13543": "Return if not the same.",
    "13544": "Signal line number matches.",
    "13550": "Signal no next character to fetch from the Keyword Construction Buffer.",
    "13553": "Signal no next character to fetch within the BASIC line in the program area.",
    "13559": "BC=Line number. [Quicker to have used the instructions LD B,H / LD C,L]",
    "13563": "Address of the start of BASIC program.",
    "13566": "Test for end of BASIC program.",
    "13569": "Return if at end of program.",
    "13570": "Compare line number at (HL) with BC.",
    "13573": "Return if line number matches or is lower than the first program line number.",
    "13577": "Return with carry and zero flags set if first program line was requested (line number 0).",
    "13578": "Get address of next BASIC line.",
    "13581": "Test for end of BASIC program.",
    "13584": "Return if at end of program.",
    "13585": "Compare line number at (HL) with BC.",
    "13588": "If line number not the same or greater then back to test next line.",
    "13591": "Fetch the address of the character within the Keyword Construction Buffer.",
    "13595": "Is there an address defined, i.e. characters still within the buffer to fetch?",
    "13596": "Jump ahead if not.",
    "13598": "Fetch a character from the buffer.",
    "13599": "Point to the next character.",
    "13600": "Was it a trailing space, i.e. the last character?",
    "13602": "Save the character.",
    "13603": "Signal 'print a leading space'.",
    "13605": "Jump ahead if not.",
    "13607": "Signal 'do not print a leading space'.",
    "13609": "Store the 'print a leading space' flag value.",
    "13612": "Get the character back.",
    "13613": "Is it the last character in the buffer, i.e. the terminator bit is set?",
    "13615": "Jump ahead if not.",
    "13617": "Signal no more characters within the Keyword Construction Buffer to fetch.",
    "13620": "Store the address of the next line number/keyword character within the construction buffer, or $0000 if no more characters.",
    "13623": "Mask off the terminator bit.",
    "13625": "Jump ahead to continue. [Could have saved 1 byte by using JR $358F (ROM 0)]",
    "13628": "Fetch the address of the next character within the BASIC line construction workspace.",
    "13632": "Is there a character defined, i.e. end of line not yet reached?",
    "13633": "Jump ahead if not. [Could have saved 1 byte by using JR $3591 (ROM 0)]",
    "13636": "Use Normal RAM Configuration (physical RAM bank 0).",
    "13639": "Fetch a character from the buffer.",
    "13640": "Is it the hidden number marker indicating a floating-point representation?",
    "13642": "Jump ahead if it is not.",
    "13644": "Skip over it the floating-point representation.",
    "13650": "Jump back to fetch the next character.",
    "13652": "Use Workspace RAM configuration (physical RAM bank 7).",
    "13655": "Point to the next character.",
    "13656": "Store the address of the next command within the BASIC line to fetch.",
    "13659": "'RND'. Is the current character a standard '48K' keyword? ('RND' = first 48K keyword)",
    "13661": "Jump ahead if not.",
    "13663": "Reduce command code range to $00-$5A.",
    "13665": "Construct a string representation of the keyword in the Keyword Construction Buffer.",
    "13668": "Jump back to fetch and return the first character of the keyword string. [Could have saved 1 byte by using JR $3517 (ROM 0)]",
    "13671": "Is it a '128K' keyword, i.e. 'SPECTRUM' or 'PLAY'?",
    "13673": "Jump if not.",
    "13675": "Jump if it is 'PLAY'.",
    "13677": "Keyword string \"SPECTRUM\".",
    "13716": "\"SPECTRUM",
    "13724": "\"PLAY\"",
    "13728": "\"GOTO\"",
    "13732": "\"GOSUB\"",
    "13737": "\"DEFFN\"",
    "13742": "\"OPEN#\"",
    "13747": "\"CLOSE#\"",
    "13753": "Number of bytes in table.",
    "13754": "Flag never subsequently used. Possibly intended to indicate the start of a new BASIC line and hence whether indentation required.",
    "13755": "Number of characters to indent by.",
    "13680": "Jump forward.",
    "13682": "Keyword string \"PLAY\".",
    "13685": "Copy the keyword string characters into the Keyword Construction Buffer.",
    "13688": "Jump back to fetch and return the first character of the keyword string. [Could have saved 1 byte by using JR $3517 (ROM 0)]",
    "13691": "Save the character.",
    "13694": "Signal to print a trailing space.",
    "13697": "Get the character back.",
    "13698": "Is it an 'Enter' character?",
    "13700": "Jump if not to exit.",
    "13705": "Signal no further character to fetch from the Keyword Construction Buffer.",
    "13708": "Signal no further character to fetch from the BASIC line within the program area.",
    "13711": "Set the carry flag to indicate that a character was available.",
    "13714": "Reset the carry flag to indicate that a character was not available.",
    "13756": "HL=Address of the indentation settings data table.",
    "13759": "Destination address.",
    "13762": "Copy two bytes from $35B9-$35BA (ROM 0) to $FD6A-$FD6B.",
    "13768": "Point to the required column.",
    "13769": "Store the character.",
    "13770": "Advance to the next column.",
    "13772": "Null remaining column positions in the edit buffer row.",
    "13775": "Fetch the flag byte.",
    "13776": "Signal associated line number and last row in the BASIC line.",
    "13778": "Update the flag byte.",
    "13779": "[Redundant since flag never subsequently tested. Deleting these instructions would have saved 5 bytes]",
    "13782": "Flag possibly intended to indicate the start of a new BASIC line and hence whether indentation required.",
    "13784": "Signal no more characters are available, i.e. end of line.",
    "13786": "Null remaining column positions in the edit buffer row.",
    "13789": "Signal last row of the BASIC line in the row flag byte.",
    "13791": "[Redundant since flag never subsequently tested. Deleting these instructions would have saved 5 bytes]",
    "13794": "Flag possibly intended to indicate the start of a new BASIC line and hence whether indentation required.",
    "13796": "Signal no more characters are available, i.e. end of line.",
    "13799": "HL=Number of columns.",
    "13801": "Point to column position in line edit buffer row.",
    "13802": "32 columns.",
    "13804": "Found specified column?",
    "13805": "Return if so.",
    "13806": "Store a null in the location.",
    "13808": "Next buffer position.",
    "13809": "Increment column position counter.",
    "13810": "Repeat for next column.",
    "13812": "Get the number of indentation columns.",
    "13815": "Start at first column.",
    "13819": "HL=Column position.",
    "13821": "Put a null in the column position.",
    "13823": "Next position.",
    "13825": "Repeat for all remaining columns.",
    "13828": "Save registers.",
    "13831": "Save edit buffer row address.",
    "13835": "Is printing of the edit buffer row required?",
    "13837": "Retrieve edit buffer row address.",
    "13838": "Jump if printing is not required.",
    "13840": "B=Cursor row position.",
    "13841": "Print the edit buffer row to the screen. Returns with the carry flag set.",
    "13844": "Restore registers.",
    "13848": "Save registers.",
    "13851": "Save edit buffer row address.",
    "13855": "Is updating of the display file required?",
    "13857": "Retrieve edit buffer row address.",
    "13858": "Jump if updating is not required.",
    "13860": "E=Cursor row position, i.e. row to shift from.",
    "13861": "Shift up edit rows in the display file, replacing the bottom row with the top entry from the Below-Screen Line Edit Buffer.",
    "13864": "Restore registers.",
    "13868": "Save registers.",
    "13871": "Save edit buffer row address.",
    "13875": "Is updating of the display file required?",
    "13877": "Retrieve edit buffer row address.",
    "13878": "Jump if updating is not required.",
    "13880": "E=Cursor row position, i.e. row to shift from.",
    "13881": "Shift down edit rows in the display file, replacing the top row with the bottom entry from the Above-Screen Line Edit Buffer.",
    "13884": "Restore registers.",
    "13888": "Save registers.",
    "13892": "Swap B with C.",
    "13895": "Set cursor position attribute.",
    "13898": "Restore registers.",
    "13903": "Save registers",
    "13907": "Swap B with C.",
    "13910": "Restore cursor position attribute.",
    "13913": "Restore registers.",
    "13918": "Select 'L' mode.",
    "13923": "Reset repeat key duration.",
    "13932": "Select L-Mode and Print in L-Mode.",
    "13935": "Editor flags.",
    "13938": "Return to the calculator?",
    "13943": "Jump ahead if so.",
    "13945": "Select Editor/Menu mode.",
    "13948": "Select BASIC/Calculator mode.",
    "13951": "Preserve contents of HL.",
    "13957": "Wait for a key press.",
    "13959": "Clear the new key indicator flag.",
    "13961": "Fetch the key pressed from LAST_K.",
    "13967": "Remove extended mode.",
    "13969": "Is it a control code?",
    "13971": "Jump if not to accept all characters and token codes (used for the keypad).",
    "13973": "Is it a cursor key?",
    "13975": "Jump back if not to wait for another key.",
    "13977": "Is it a cursor key?",
    "13979": "Jump back if not to wait for another key.",
    "13981": "Handle CAPS LOCK code and 'mode' codes.",
    "13984": "Jump back if mode might have changed.",
    "13986": "Restore contents of HL.",
    "13989": "Handle CAPS LOCK code and 'mode' codes via ROM 1.",
    "13992": "Save address of menu text.",
    "13993": "Store copy of menu screen area and system variables.",
    "13999": "Signal using main screen.",
    "14001": "HL=Address of menu text.",
    "14002": "Fetch number of table entries.",
    "14003": "Point to first entry.",
    "14005": "Set title colours.",
    "14316": "AT 7,7; OVER 0; INVERSE 0; INK 7; PAPER 0; BRIGHT 1;",
    "14330": "PAPER 0; \" \"; PAPER 7; INK 0;",
    "14354": "\" \"; INK 2; \"!\"; PAPER 6; \" \"; INK 4; \"!\"; PAPER 5; \" \"; INK 0; \" \"",
    "14008": "Print them.",
    "14012": "Print menu title pointed to by HL.",
    "14016": "Print Sinclair stripes.",
    "14019": "Black ' '.",
    "14022": "Print it.",
    "14025": "HL=Address of first menu item text.",
    "14026": "Save number of menu items left to print.",
    "14030": "Perform 'Print AT 8,7;' (this is the top left position of the menu).",
    "14033": "Save row print coordinates.",
    "14034": "Number of columns in a row of the menu.",
    "14036": "Print ' '.",
    "14039": "Fetch menu item character.",
    "14041": "End marker found?",
    "14043": "Jump if end of text found.",
    "14045": "Print menu item character",
    "14046": "Repeat for all characters in menu item text.",
    "14048": "Clear bit 7 to yield a final text character.",
    "14050": "Print it.",
    "14051": "Print trailing spaces",
    "14054": "Until all columns filled.",
    "14056": "Fetch row print coordinates.",
    "14057": "Next row.",
    "14058": "Print AT.",
    "14062": "Repeat for all menu items.",
    "14064": "Coordinates, pixel (111, 56) = end row 13, column 7.",
    "14067": "Fetch number of menu items to E.",
    "14072": "Determine number of pixels to span all menu items.",
    "14074": "D=8*Number of menu items - 1.",
    "14076": "Number of pixels in width of menu.",
    "14078": "B=-1, C=0. Plot a vertical line going up.",
    "14081": "A=Number of vertical pixels to plot.",
    "14082": "Plot line.",
    "14085": "B=0, C=1. Plot a horizontal line going to the right.",
    "14088": "A=Number of horizontal pixels to plot.",
    "14089": "Plot line.",
    "14092": "B=1, C=0. Plot a vertical line going down.",
    "14095": "A=Number of vertical pixels to plot.",
    "14096": "Include end pixel.",
    "14097": "Plot line.",
    "14100": "A=Index of menu option to highlight.",
    "14101": "Toggle menu option selection so that it is highlight.",
    "14105": "Save registers.",
    "14109": "Coordinates to BC.",
    "14112": "$22E9. Plot pixel",
    "14114": "Restore registers.",
    "14118": "Determine coordinates of next pixel.",
    "14120": "Repeat for all pixels.",
    "14123": "'AT'.",
    "14125": "Print",
    "14127": "Print",
    "14129": "Print",
    "14126": "B=Row number.",
    "14128": "C=Column number.",
    "14131": "Fetch a character.",
    "14132": "Advance to next character.",
    "14133": "Reach end of string?",
    "14135": "Return if so.",
    "14136": "Print the character.",
    "14137": "Back for the next character.",
    "14139": "Set carry flag to signal to save screen area.",
    "14140": "Jump ahead to continue.",
    "14143": "Store for TVFLAG.",
    "14142": "Reset carry flag to signal restore screen area.",
    "14149": "Jump if storing copies.",
    "14151": "Exchange source and destination pointers.",
    "14152": "Transfer the byte.",
    "14154": "Jump if storing copies.",
    "14156": "Restore source and destination pointers.",
    "14157": "DE=$EEF7 by now.",
    "14160": "Jump if storing copies.",
    "14162": "Exchange source and destination pointers.",
    "14163": "Copy 20 bytes.",
    "14166": "Copy COORDS until ATTR_T.",
    "14168": "Jump if storing copies.",
    "14170": "Restore source and destination pointers.",
    "14171": "Save copy direction flag.",
    "14172": "Menu will be at row 7, column 7.",
    "14175": "B=Number of rows to end row of screen. C=Number of columns to the end column of the screen.",
    "14178": "A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).",
    "14181": "B=Row number within editing area.",
    "14182": "B=Bottom screen row to store.",
    "14183": "A=Number of rows to store. [Could have been just $07 freeing up 630 bytes of workspace]",
    "14185": "B holds number of row to store.",
    "14186": "A holds number of rows left to store.",
    "14187": "DE=End of destination address.",
    "14189": "HL=Display file address of row B.",
    "14191": "Menu always starts at column 7.",
    "14194": "HL=Address of attribute byte at column 7.",
    "14196": "Store / restore menu screen row.",
    "14201": "Next row.",
    "14206": "B=Menu row is 8 lines deep. C=Menu is 14 columns wide.",
    "14203": "Repeat for next row",
    "14202": "More rows to store / restore?",
    "14209": "Save number of row lines.",
    "14210": "Just keep the column count in BC.",
    "14212": "Save display file starting address.",
    "14213": "Retrieve copy direction flag.",
    "14214": "Jump if storing copies of display file bytes.",
    "14216": "Exchange source and destination pointers.",
    "14217": "Copy the row of menu display file bytes.",
    "14219": "Jump if storing copies of display file bytes.",
    "14221": "Restore source and destination pointers.",
    "14222": "Save copy direction flag.",
    "14223": "Fetch display file starting address.",
    "14224": "Advance to next line",
    "14225": "Fetch number of lines.",
    "14226": "Repeat for next line.",
    "14228": "B=0. C=Number of columns.",
    "14229": "DE=Destination address.",
    "14231": "HL=Address of attribute byte.",
    "14233": "DE=Address of attribute byte.",
    "14236": "Retrieve copy direction flag.",
    "14237": "Jump if storing copies of attribute bytes.",
    "14239": "Restore source and destination pointers.",
    "14240": "Copy the row of menu attribute bytes.",
    "14242": "Jump if storing copies of attribute bytes.",
    "14244": "Restore source and destination pointers.",
    "14245": "Save copy direction flag.",
    "14247": "Toggle old menu item selection to de-highlight it.",
    "14250": "Decrement menu index.",
    "14251": "Jump if not exceeded top of menu.",
    "14254": "Fetch number of menu items.",
    "14255": "Ignore the title.",
    "14256": "Make it indexed from 0.",
    "14257": "Toggle new menu item selection to highlight it.",
    "14260": "Ensure carry flag is set to prevent immediately",
    "14261": "calling menu down routine upon return.",
    "14262": "Save DE.",
    "14263": "Toggle old menu item selection to de-highlight it.",
    "14266": "Increment menu index.",
    "14267": "Save menu index.",
    "14268": "fetch number of menu items.",
    "14269": "Ignore the title.",
    "14270": "Make it indexed from 0.",
    "14271": "Has bottom of menu been exceeded?",
    "14272": "Fetch menu index.",
    "14273": "Jump if bottom menu not exceeded.",
    "14276": "Select top menu item.",
    "14277": "Toggle new menu item selection to highlight it.",
    "14280": "Restore DE.",
    "14282": "Save registers.",
    "14285": "First attribute byte at position (9,7).",
    "14288": "The increment for each row.",
    "14292": "Jump ahead if highlighting the first entry.",
    "14294": "Otherwise increase HL",
    "14295": "for each row.",
    "14298": "Flash 0, Bright 1, Paper 7, Ink 0 = Bright white.",
    "14300": "Is the entry already highlighted?",
    "14301": "Jump ahead if not.",
    "14303": "Flash 0, Bright 1, Paper 5, Ink 0 = Bright cyan.",
    "14305": "There are 14 columns to set.",
    "14307": "Set the attributes for all columns.",
    "14312": "Restore registers.",
    "14370": "Save registers.",
    "14373": "Graphics bit-patterns",
    "14379": "Copy two characters.",
    "14384": "Save CHARS.",
    "14391": "Set CHARS to point to new graphics.",
    "14397": "Print it.",
    "14394": "Point to the strip string.",
    "14401": "Restore CHARS.",
    "14404": "Restore registers.",
    "14408": "\"128 BASIC\" text from main menu.",
    "14411": "Jump ahead to print banner.",
    "14416": "Jump ahead to print banner.",
    "14421": "Jump ahead to print banner.",
    "14418": "\"Tape Loader\" text from main menu.",
    "14413": "\"Calculator\" text from main menu.",
    "14423": "\"Tape Tester\" text from main menu.",
    "14426": "Address in memory of the text of the selected menu item.",
    "14427": "Clear lower editing area display.",
    "14430": "Address of banner row in attributes.",
    "14433": "32 columns.",
    "14435": "FLASH 0, BRIGHT 1, PAPER 0, INK 0.",
    "14437": "Set a black row.",
    "14441": "Menu title colours table.",
    "14444": "Print the colours as a string.",
    "14450": "Perform 'Print AT 21,0;'.",
    "14453": "Address in memory of the text of the selected menu item.",
    "14454": "Print the text.",
    "14457": "B has not changed and still holds 21.",
    "14459": "Perform 'Print AT 21,26;'.",
    "14462": "Print Sinclair stripes and return to calling routine.",
    "14465": "Top row of editing area.",
    "14467": "Bottom row of editing area.",
    "14469": "Reset Display.",
    "14472": "Use Normal RAM Configuration (physical RAM bank 0).",
    "14475": "DE=Count of the number of BASIC lines.",
    "14479": "Were there any BASIC lines?",
    "14480": "Jump if not to return since there is nothing to renumber.",
    "14487": "HL=HL*DE in ROM 1. HL=Number of lines * Line increment = New last line number.",
    "14489": "DE=Offset of new last line number from the first line number.",
    "14490": "Starting line number for Renumber.",
    "14493": "HL=New last line number.",
    "14494": "10000.",
    "14498": "Would the last line number above 9999?",
    "14500": "Jump if so to return since Renumber cannot proceed.",
    "14503": "HL=Address of first BASIC line.",
    "14506": "Find the address of the next BASIC line from the",
    "14507": "location pointed to by HL, returning it in DE.",
    "14509": "Advance past the line number bytes to point",
    "14510": "at the line length bytes.",
    "14511": "Store the address of the BASIC line's length bytes.",
    "14514": "Advance past the line length bytes to point",
    "14515": "at the command.",
    "14516": "Store the address of the next BASIC line.",
    "14520": "Get a character from the BASIC line.",
    "14522": "Advance past a floating point number, if present.",
    "14524": "Is the character an 'ENTER'?",
    "14526": "Jump if so to examine the next line.",
    "14528": "Parse the line, renumbering any tokens that may be followed by a line number.",
    "14531": "Repeat for all remaining character until end of the line.",
    "14533": "DE=Address of the next BASIC line.",
    "14537": "Fetch the address of the end of the BASIC program.",
    "14541": "Has the end of the BASIC program been reached?",
    "14543": "HL=Address of start of the current BASIC line.",
    "14544": "Jump back if not to examine the next line.",
    "14546": "DE=Count of the number of BASIC lines.",
    "14550": "BC=Count of the number of BASIC lines.",
    "14554": "HL=Address of first BASIC line.",
    "14557": "BC=Count of number of lines left to update.",
    "14558": "DE=Index of the current line.",
    "14559": "HL=Address of current BASIC line.",
    "14560": "HL=Renumber line increment.",
    "14564": "Calculate new line number offset, i.e. Line increment * Line index.",
    "14566": "The initial line number when renumbering.",
    "14570": "HL=The new line number for the current line.",
    "14571": "DE=The new line number for the current line.",
    "14572": "HL=Address of current BASIC line.",
    "14573": "Store the new line number for this line.",
    "14577": "Fetch the line length.",
    "14581": "Point to the next line.",
    "14582": "DE=Index of the current line.",
    "14583": "Increment the line index.",
    "14584": "BC=Count of number of lines left to update.",
    "14585": "Decrement counter.",
    "14588": "Jump back while more lines to update.",
    "14590": "Use Workspace RAM configuration (physical RAM bank 7).",
    "14593": "Clear the address of line length bytes of the 'current line being renumbered'.",
    "14597": "Signal not to produce an error beep.",
    "14599": "LINE, LIST, LLIST, GOTO, GOSUB, RESTORE, RUN",
    "14606": "Point to the next character.",
    "14607": "Store it.",
    "14610": "DE=Address of next character.",
    "14611": "There are 7 tokens that may be followed by a line",
    "14614": "number, and these are listed in the table at $3907 (ROM 0).",
    "14617": "Search for a match for the current character.",
    "14619": "HL=Address of next character.",
    "14620": "Return if no match found.",
    "14621": "Counts the number of digits in the current line number representation. B will be $00 from above.",
    "14623": "Fetch the next character.",
    "14624": "Is it a space?",
    "14626": "Jump ahead if so to parse the next character.",
    "14629": "Is the character a numeric digit?",
    "14631": "Jump if a numeric digit to parse the next character.",
    "14633": "Is it a decimal point?",
    "14635": "Jump ahead if so to parse the next character.",
    "14637": "Does it indicate a hidden number?",
    "14639": "Jump ahead if so to process it.",
    "14641": "Convert to lower case.",
    "14643": "Is it an exponent 'e'?",
    "14645": "Jump if not to parse the next character.",
    "14647": "Have any digits been found?",
    "14649": "Jump ahead to parse the next character.",
    "14651": "Retrieve the address of the next character.",
    "14655": "Increment the number digit counter.",
    "14656": "Point to the next character.",
    "14657": "Jump back to parse the character at this new address.",
    "14659": "Note the number of digits in the old line number reference.",
    "14663": "Save the address of the current character.",
    "14665": "Advance past internal floating point representation, if present.",
    "14667": "Skip over any spaces.",
    "14670": "Fetch the new character.",
    "14671": "HL=Address of the current character.",
    "14672": "Is it ':'?",
    "14674": "Jump if so.",
    "14676": "Is it 'ENTER'?",
    "14678": "Return if not.",
    "14679": "Point to the next character.",
    "14681": "Move floating point number to the calculator stack.",
    "14684": "Fetch the number line to BC.",
    "14687": "Transfer the number line to HL.",
    "14688": "Find the address of the line number specified by HL.",
    "14689": "HL=Address of the BASIC line, or the next one if it does not exist.",
    "14691": "Jump if the line exists.",
    "14693": "Has the end of the BASIC program been reached?",
    "14696": "Jump ahead if not.",
    "14698": "Make the reference point to line 9999.",
    "14701": "Jump ahead to update the reference to use the new line number.",
    "14703": "Store the address of the referenced line.",
    "14706": "DE=Count of the number of BASIC lines up to the referenced line.",
    "14709": "Fetch the line number increment.",
    "14713": "HL=Number of lines * Line increment = New referenced line number.",
    "14715": "Starting line number for Renumber.",
    "14719": "HL=New referenced line number.",
    "14720": "Temporary buffer to generate ASCII representation of the new line number.",
    "14723": "Save the new line number being referenced.",
    "14724": "Create the ASCII representation of the line number in the buffer.",
    "14729": "DE=Number of digits in the new line number.",
    "14731": "DE=Number of digits in the new line number.",
    "14732": "HL=Address of the first non-'0' character in the buffer.",
    "14734": "HL=Number of digits in the new line number.",
    "14736": "Fetch the number of digits in the old line number reference.",
    "14741": "Has the number of digits changed?",
    "14743": "Store the difference between the number of digits in the old and new line numbers.",
    "14746": "Jump if they are the same length.",
    "14748": "Jump if the new line number contains less digits than the old.",
    "14751": "BC=Length of extra space required for the new line number.",
    "14752": "Fetch the start address of the old line number representation within the BASIC line.",
    "14755": "Save start address of the line number reference.",
    "14756": "DE=Number of non-'0' characters in the line number string.",
    "14757": "Fetch the start of the spare memory.",
    "14760": "Would a memory overflow occur if the space were created?",
    "14761": "Jump if not to return without changing the line number reference.",
    "14763": "DE=New STKEND address.",
    "14764": "Would there be at least 130 bytes at the top of RAM?",
    "14768": "Jump if not to return without changing the line number reference.",
    "14770": "Is the new STKEND address below the stack?",
    "14773": "Jump if not to return without changing the line number reference.",
    "14775": "DE=Number of non-'0' characters in the line number string.",
    "14776": "HL=Start address of line number reference.",
    "14778": "Create the space for the extra line number digits.",
    "14780": "Jump ahead to update the number digits.",
    "14782": "Discard stacked items.",
    "14784": "Use Workspace RAM configuration (physical RAM bank 7).",
    "14787": "Reset the carry flag so that an error beep will be produced.",
    "14789": "BC=Number of digits in the old line number reference.",
    "14790": "Decrement number of digits in the new line number.",
    "14791": "Repeat until BC has been decremented by the number of digits in the new line number, thereby leaving BC holding the number of digits in the BASIC line to be discarded.",
    "14793": "Fetch the start address of the old line number representation within the BASIC line.",
    "14797": "Discard the redundant bytes.",
    "14799": "Fetch the start address of the old line number representation within the BASIC line.",
    "14803": "HL=Address of the first non-'0' character in the buffer.",
    "14804": "BC=Number of digits in the new line number.",
    "14805": "Copy the new line number into place.",
    "14807": "HL=Address after the line number text in the BASIC line.",
    "14808": "Store the hidden number marker.",
    "14810": "Retrieve the new line number being referenced.",
    "14811": "HL=Address of the next position within the BASIC line.",
    "14814": "Put the line number on the calculator stack, returning HL pointing to it.",
    "14816": "DE=Address of the next position within the BASIC line.",
    "14820": "Copy the floating point form into the BASIC line.",
    "14822": "HL=Address of character after the newly inserted floating point number bytes.",
    "14824": "HL=Address of the current line's length bytes.",
    "14830": "DE=Existing length of the current line.",
    "14831": "HL=Change in length of the line.",
    "14835": "DE=New length of the current line.",
    "14836": "HL=Address of the current line's length bytes.",
    "14839": "Store the new length.",
    "14840": "HL=Address of the next BASIC line.",
    "14843": "DE=Change in length of the current line.",
    "14847": "Store the new address of the next BASIC line.",
    "14851": "HL=Address of character after the newly inserted floating point number bytes.",
    "14853": "Fetch the address of the variables",
    "14856": "and store it.",
    "14859": "Fetch the start of the BASIC program",
    "14862": "and compare against the address of",
    "14866": "the end address to check whether there is",
    "14867": "a BASIC program.",
    "14869": "Jump if there is no BASIC program.",
    "14871": "Fetch the start address of the BASIC program.",
    "14874": "A count of the number of lines.",
    "14877": "Save the line number count.",
    "14879": "Find the address of the next BASIC line from the location pointed to by HL, returning it in DE.",
    "14881": "Fetch the start of the variables area,",
    "14884": "i.e. end of the BASIC program.",
    "14887": "Jump if end of BASIC program reached.",
    "14889": "HL=Address of current line.",
    "14890": "Retrieve the line number count.",
    "14891": "Increment line number count.",
    "14892": "Jump back to look for the next line.",
    "14894": "Retrieve the number of BASIC lines and",
    "14895": "increment since originally started on a line.",
    "14897": "There are no BASIC lines.",
    "14901": "Point to the next character.",
    "14902": "Fetch the next character.",
    "14903": "Is it a space?",
    "14905": "Jump if so to skip to next character.",
    "14908": "Store the buffer address.",
    "14909": "BC=-1000.",
    "14912": "Insert how many 1000s there are.",
    "14915": "BC=-100.",
    "14918": "Insert how many 100s there are.",
    "14921": "BC=-10.",
    "14923": "Insert how many 10s there are.",
    "14926": "A=Remainder.",
    "14927": "Convert into an ASCII character ('0'..'9').",
    "14929": "Store it in the buffer.",
    "14930": "Point to the next buffer position.",
    "14931": "Skip over 3 leading zeros at most.",
    "14933": "Retrieve the buffer start address.",
    "14934": "Fetch a character.",
    "14935": "Is it a leading zero?",
    "14937": "Return as soon as a non-'0' character is found.",
    "14938": "Replace it with a space.",
    "14940": "Point to the next buffer location.",
    "14941": "Repeat until all leading zeros removed.",
    "14944": "Assume a count of 0 additions.",
    "14945": "Add the negative value.",
    "14946": "Increment the counter.",
    "14947": "If no overflow then jump back to add again.",
    "14949": "Undo the last step",
    "14951": "and the last counter increment.",
    "14952": "Convert to an ASCII character ('0'..'9').",
    "14954": "Store it in the buffer.",
    "14955": "Point to the next buffer position.",
    "14957": "Number of bytes in table.",
    "14958": "[Setting never used]",
    "14960": "[Setting never used]",
    "14961": "[Setting never used]",
    "14962": "[Setting never used]",
    "14963": "[Setting never used]",
    "14959": "$FD6D = Rows above the editing area.",
    "14964": "$FD72 = Cursor attribute colour (blue paper, white ink).",
    "14965": "$FD73 = Stored cursor position screen attribute colour (None = black paper, black ink).",
    "14966": "Number of bytes in table.",
    "14967": "[Setting never used]",
    "14969": "[Setting never used]",
    "14970": "[Setting never used]",
    "14971": "[Setting never used]",
    "14972": "[Setting never used]",
    "14968": "$FD6D = Rows above the editing area.",
    "14973": "$FD72 = Cursor attribute colour (blue paper, white ink).",
    "14974": "$FD73 = Stored cursor position screen attribute colour (None = black paper, black ink).",
    "14975": "Point IX at cursor settings in workspace.",
    "14979": "Initial values table for the lower screen cursor settings.",
    "14982": "Jump ahead.",
    "14984": "Initial values table for the main screen cursor settings.",
    "14987": "DE=Cursor settings in workspace.",
    "14990": "Jump to copy the settings.",
    "14993": "Print character held in A.",
    "14995": "Print character held in D.",
    "14998": "Mask off flash and bright bits.",
    "15000": "Store it as the new cursor attribute value.",
    "15005": "A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).",
    "15008": "B=Row number within editing area.",
    "15009": "B=Screen row number.",
    "15010": "Get address of attribute byte into HL.",
    "15013": "Fetch current attribute byte.",
    "15014": "Store the current attribute byte.",
    "15017": "Invert colours.",
    "15018": "Mask off flash and bright bits.",
    "15020": "Get cursor colour.",
    "15023": "Store new attribute value to screen.",
    "15024": "[Redundant since calling routine preserves AF]",
    "15026": "A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).",
    "15029": "B=Row number within editing area.",
    "15030": "B=Screen row number.",
    "15031": "Get address of attribute byte into HL.",
    "15034": "Get previous attribute value.",
    "15037": "Set colour.",
    "15039": "Save the address of the Below-Screen Line Edit Buffer row.",
    "15040": "Indicate to shift rows up.",
    "15042": "A=Number of editing rows on screen.",
    "15043": "A=Number of rows to shift, i.e. from current row to end of edit screen.",
    "15044": "Jump ahead.",
    "15046": "Save the address of the first row in Below-Screen Line Edit Buffer.",
    "15047": "A=Number of editing rows on screen.",
    "15048": "E=Row number to shift from.",
    "15049": "B=Number of editing rows on screen.",
    "15050": "A=Number of rows to shift, i.e. from current row to end of edit screen.",
    "15051": "Indicate to shift rows down.",
    "15053": "C=Number of rows to shift.",
    "15054": "A=Row number to shift from.",
    "15055": "Is it the final row of the editing screen?",
    "15056": "Jump if so to simply display the row.",
    "15058": "Save number of editing rows on screen, in E.",
    "15059": "B=Inverted row number, i.e. 24-row number.",
    "15062": "B=Inverted row number, C=Number of rows left to shift.",
    "15063": "Store the direction flag.",
    "15069": "Fetch the direction flag.",
    "15067": "DE=Destination display file address.",
    "15065": "HL=Destination display file address, for the row number specified by 24-B.",
    "15070": "Jump if moving up to the previous row.",
    "15072": "Move to the previous row (note that B is inverted, i.e. 24-row number).",
    "15073": "Jump ahead.",
    "15075": "Move to the next row (note that B is inverted, i.e. 24-row number).",
    "15076": "DE=Destination display file address.",
    "15078": "HL=Source display file address, for the row number held in B.",
    "15080": "DE=Destination display file address.",
    "15081": "Fetch the direction flag.",
    "15082": "32 columns.",
    "15084": "8 lines.",
    "15091": "Copy one line in the display file.",
    "15096": "Next source line in the display file.",
    "15097": "Next destination line in the display file.",
    "15098": "Repeat for all lines in the row.",
    "15100": "Save the duration flag.",
    "15101": "DE=Address of next destination row in the display file.",
    "15102": "HL=Address of next source row in the display file.",
    "15103": "DE=Address of corresponding attribute cell.",
    "15105": "HL=Address of corresponding source attribute cell.",
    "15106": "Store source attribute cell on the stack, and fetch the next destination row in the display file in HL.",
    "15107": "HL=Address of next destination row in the display file.",
    "15108": "DE=Address of corresponding destination attribute cell.",
    "15110": "HL=Address of corresponding destination attribute cell.",
    "15111": "Store destination attribute cell on the stack, and fetch the source attribute cell in HL.",
    "15112": "DE=Destination attribute cell.",
    "15116": "Copy one row of the attributes file.",
    "15118": "Retrieve the direction flag.",
    "15119": "B=Inverted row number, C=Number of rows left to shift.",
    "15120": "Shifting up or down?",
    "15121": "Jump if shifting rows up.",
    "15123": "Move to the previous row, i.e. the row to copy (note that B is inverted, i.e. 24-row number).",
    "15124": "Jump ahead.",
    "15126": "Move to the next row, i.e. the row to copy (note that B is inverted, i.e. 24-row number).",
    "15127": "Decrement the row counter.",
    "15128": "H=Direction flag.",
    "15129": "Jump if back more rows to shift.",
    "15131": "E=Number of editing rows on screen.",
    "15132": "B=Number of editing rows on screen.",
    "15133": "HL=Address of the Line Edit Buffer row to print (either in the Above-Screen Line Edit Buffer or in the Below-Screen Line Edit Buffer).",
    "15134": "Exchange colour items.",
    "15137": "Transfer address of edit buffer row to DE.",
    "15142": "Editor flags.",
    "15145": "Test the editing area flag.",
    "15147": "Allow leading space.",
    "15149": "Jump if editing area is the main screen.",
    "15151": "Suppress leading space.",
    "15156": "The first column position of the edit row.",
    "15158": "Print AT.",
    "15161": "HL=Address of edit buffer row.",
    "15162": "32 columns.",
    "15164": "Character present in this position?",
    "15166": "Jump if character found.",
    "15168": "Display a space for a null character.",
    "15170": "Is it a single character or UDG?",
    "15172": "Jump if it is a UDG.",
    "15175": "Print the character.",
    "15177": "Repeat for all column positions.",
    "15180": "Restore original suppress leading space status.",
    "15184": "Exchange colour items.",
    "15187": "[Redundant since never subsequently checked]",
    "15189": "Use Normal RAM Configuration (physical RAM bank 0).",
    "15192": "Print it (need to page in RAM bank 0 to allow access to UDGs).",
    "15193": "Use Workspace RAM configuration (physical RAM bank 7).",
    "15196": "Jump back for next character.",
    "15198": "Exchange 48 and 128 editing colour items.",
    "15201": "Bottom row to clear.",
    "15203": "A=Number of rows to clear.",
    "15204": "C=Number of rows to clear.",
    "15205": "B=Number of rows to end of screen.",
    "15208": "B=Row number. C=Row to clear.",
    "15210": "Find display file address.",
    "15212": "8 lines in the row.",
    "15214": "Save start of row address.",
    "15215": "32 columns.",
    "15218": "Blank the row.",
    "15222": "Get start of row address.",
    "15223": "Next line.",
    "15225": "Repeat for all rows.",
    "15227": "32 columns.",
    "15231": "Find attribute address.",
    "15234": "BC=32 columns.",
    "15238": "Set display file position attribute.",
    "15240": "Repeat for all attributes in the row.",
    "15242": "B=Row number. C=Number of rows to clear.",
    "15245": "Repeat for all rows.",
    "15247": "Exchange 48 and 128 editing colour items.",
    "15250": "[Redundant since never subsequently checked]",
    "15252": "Reverse column number.",
    "15255": "C=33-C. Columns to end of screen.",
    "15256": "Row 24.",
    "15258": "A=24-B.",
    "15259": "Subtract the number of rows above the editing area.",
    "15262": "B=Rows to end of screen.",
    "15264": "Save BC.",
    "15265": "A=0.",
    "15267": "DE=B*256.",
    "15278": "DE=B*32.",
    "15280": "Start of attributes file.",
    "15283": "B=0.",
    "15284": "Add column offset.",
    "15285": "Add row offset.",
    "15286": "Restore BC.",
    "15288": "Save registers.",
    "15291": "Fetch main colour items.",
    "15298": "Store them.",
    "15299": "Alternate Editor ATTR_P, MASK_P. Fetch alternate Editor colour items.",
    "15302": "Alternate Editor ATTR_T, MASK_T.",
    "15306": "Store alternate Editor colour items as main colour items.",
    "15313": "Retrieve main colour items ATTR_T and MASK_T.",
    "15314": "Alternate Editor ATTR_P, MASK_P.",
    "15317": "Alternate Editor ATTR_T, MASK_T. Store alternate Editor colour items as main colour items.",
    "15321": "Alternate P_FLAG. Temporary Editor store for P_FLAG.",
    "15327": "Fetch alternate Editor version.",
    "15328": "Store main version in alternate Editor store.",
    "15329": "A=Alternate Editor version.",
    "15330": "Store it as main version.",
    "15333": "Restore registers.",
    "15337": "Signal no key press.",
    "15340": "Turn interrupts off since need accurate timing.",
    "15341": "Read tape input port (bit 5).",
    "15343": "Set the zero flag based on the state of the input line.",
    "15345": "Save initial state of the tape input.",
    "15346": "Screen attribute position (7,1).",
    "15349": "DE=column spacing of the black squares.",
    "15352": "Count 6 black squares.",
    "15353": "A=Flash 0, Bright 0, Paper black, Ink black.",
    "15354": "Set a black square.",
    "15355": "Move to next column position.",
    "15356": "Repeat for all 6 black squares.",
    "15358": "Count of the number of high signals read from the tape port.",
    "15361": "Read 2048 tape samples. [*BUG* - This should be $07C0 so that the maximum sample count corresponds to column 31 and not column 32, and hence a spill over onto the following row. Credit: Paul Farrow]",
    "15364": "Read keyboard row H to ENTER.",
    "15369": "Test for ENTER.",
    "15371": "Jump to exit Tape Tester if ENTER pressed.",
    "15373": "Read keyboard row B to SPACE.",
    "15377": "Test for SPACE (i.e. BREAK).",
    "15379": "Jump to exit Tape Tester if SPACE/BREAK pressed.",
    "15381": "Read keyboard row 1 to 5.",
    "15385": "Test for 1 (i.e. EDIT).",
    "15387": "Jump to exit Tape Tester if 1/EDIT pressed.",
    "15389": "Decrement sample counter.",
    "15392": "Zero flag set if all samples read.",
    "15396": "Read the tape port.",
    "15398": "If low then continue with next sample.",
    "15400": "Tape port was high so increment high signal counter.",
    "15401": "Continue with next sample.",
    "15403": "HL could hold up to $0800.",
    "15409": "HL=HL*4. HL could now hold $0000 to $2000.",
    "15411": "Retrieve initial state of the tape port.",
    "15412": "This dictates how to interpret the number of high signals counted.",
    "15414": "Re-store initial state of the tape port.",
    "15415": "A=Column 32.",
    "15417": "A=32-H. H could hold up to $20 so A could be $00.",
    "15418": "L=32-H. L holds a value between $00 to $20.",
    "15421": "Retrieve initial state of the tape port.",
    "15422": "L holds a value between $00 to $20.",
    "15424": "Set H to $00.",
    "15425": "Attribute position (8,31).",
    "15428": "Print a blue bar 32 columns wide underneath the 6 black squares. It is drawn here so that it erases the previous cyan marker.",
    "15430": "Flash 0, Bright 1, Paper blue, Ink black = Bright blue.",
    "15433": "Wait for the screen to be redrawn.",
    "15435": "Set each blue square in the attributes file.",
    "15436": "Move to previous attribute position.",
    "15437": "Repeat for all 32 columns.",
    "15439": "Move back to first attribute column.",
    "15440": "Determine column to show cyan marker at.",
    "15441": "Flash 0, Bright 1, paper cyan, Ink 0 = Bright cyan.",
    "15443": "Show the cyan marker.",
    "15444": "Go back and count a new set of samples.",
    "15446": "Re-enable interrupts.",
    "15447": "Count 25 interrupts.",
    "15449": "Wait for half a second.",
    "15455": "Signal no key press",
    "15457": "Setting the carry flag here serves no purpose.",
    "15459": "Signal to locate the error marker.",
    "15461": "Jump forward.",
    "15463": "Signal to tokenize the BASIC line. [Could have saved 1 byte by using XOR A]",
    "15465": "Store the 'locate error marker' flag.",
    "15471": "Reset count of the number of characters in the typed BASIC line being inserted.",
    "15474": "Reset count of the number of characters in the tokenized version of the BASIC line being inserted.",
    "15478": "Store the stack pointer.",
    "15481": "Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the address of the next character in the BASIC line within the program area being de-tokenized).",
    "15484": "[Could have saved 1 byte by using XOR A]",
    "15486": "Signal last character was not a keyword and was not a space.",
    "15489": "HL=Start address of the Keyword Conversion Buffer.",
    "15492": "Store as the next available location.",
    "15495": "Use Normal RAM Configuration (physical RAM bank 0).",
    "15499": "Clear the editing areas.",
    "15501": "Use Workspace RAM configuration (physical RAM bank 7).",
    "15504": "[Could have saved 1 byte by using XOR A, or 2 bytes by clearing this above]",
    "15506": "Clear Keyword Conversion Buffer flags - not within REM, not with Quotes, no characters in the buffer.",
    "15512": "Store the address of the workspace for the tokenized BASIC line.",
    "15515": "[Could have saved 1 byte by using LD H,A followed by LD L,A]",
    "15518": "Signal no space character between words in the Keyword Conversion Buffer.",
    "15524": "Increment count of the number of characters in the typed BASIC line.",
    "15528": "Fetch the next character from BASIC line being inserted, return in B.",
    "15531": "Save the character status value.",
    "15532": "Have any Keyword Conversion Buffer flags been set?",
    "15535": "Has anything be put into the buffer yet?",
    "15537": "Jump if so.",
    "15539": "Retrieve the character status value.",
    "15540": "Is the character a letter?",
    "15542": "Jump if not.",
    "15544": "Insert the character into the Keyword Conversion Buffer.",
    "15547": "Jump if no more room within the buffer, hence string is too large to be a token.",
    "15549": "Signal Keyword Conversion Buffer contains characters.",
    "15554": "Jump back to fetch and process the next character.",
    "15556": "Fetch the address of the space character between words within the Keyword Conversion Buffer.",
    "15560": "Is there an address set?",
    "15561": "Jump if so to copy the first word into the BASIC line workspace and the move the second word to the start of the Keyword Conversion Buffer. Further characters can then be appended and the contents re-evaluated in case a complete keyword is then available.",
    "15564": "Save the character to insert.",
    "15565": "Copy Keyword Conversion Buffer contents into BASIC line workspace.",
    "15568": "Retrieve the character to insert.",
    "15571": "Signal the Keyword Conversion Buffer is empty.",
    "15574": "Retrieve the character status value.",
    "15575": "Is it a space, or not a letter and not a '#' and not a '$'?",
    "15577": "Jump back if so to insert the character either into the Keyword Conversion Buffer or the BASIC line workspace.",
    "15579": "Retrieve the character to insert.",
    "15580": "Insert character into BASIC line workspace.",
    "15583": "Return if tokenizing is complete.",
    "15587": "Increment the count of the number of characters in the typed BASIC line being inserted.",
    "15591": "Fetch the next character from BASIC line being inserted.",
    "15594": "Save the flags.",
    "15595": "Jump back to insert the character of the non-keyword string into the BASIC line workspace.",
    "15597": "Retrieve the character to insert.",
    "15598": "Insert character into BASIC line workspace, tokenizing '<>', '<=' and '>=' if encountered.",
    "15601": "Return if tokenizing is complete.",
    "15602": "Jump back to fetch and process the next character.",
    "15604": "Is the Keyword Conversion Buffer empty or the contents marked as being within quotes or within a REM?",
    "15606": "Jump back if so to insert the character since this is either the first character of a new word or is within quotes or within a REM.",
    "15608": "Retrieve the character status value.",
    "15609": "Is it a letter or a '#' or a '$'?",
    "15611": "Jump if so to simply insert the character.",
    "15613": "Save the next character to insert and the character status value.",
    "15614": "Attempt to identify the string in Keyword Conversion Buffer.",
    "15617": "Retrieve the next character to insert and the character status value.",
    "15618": "Jump if keyword identified.",
    "15620": "Fetch the address of the space character between words within the Keyword Conversion Buffer.",
    "15624": "Is there an address set, i.e. a space between words?",
    "15625": "Jump if there is a space character.",
    "15627": "Retrieve the character status value.",
    "15628": "Is it a space?",
    "15630": "Jump if not to copy Keyword Conversion Buffer into the workspace since it is not a keyword.",
    "15632": "Insert the character into the Keyword Conversion Buffer.",
    "15635": "Jump back if no room to insert the character, i.e. not a keyword since too large.",
    "15637": "Fetch the next location address.",
    "15640": "Point back to the last character.",
    "15641": "Store as the address of the space character. This is used for double keywords such as DEF FN.",
    "15644": "Jump back to fetch and process the next character.",
    "15646": "Save the character to insert and the character status value.",
    "15647": "Point to the start address of the Keyword Conversion Buffer.",
    "15650": "Fetch the address of the space character between words within the Keyword Conversion Buffer.",
    "15655": "Is the space possibly at the start of the buffer?",
    "15656": "Jump if not.",
    "15659": "Is the space at the start of the buffer?",
    "15660": "Jump if not.",
    "15662": "Point to the next location within the buffer, counter-acting the following decrement.",
    "15663": "Point to the previous location within the buffer.",
    "15664": "Jump ahead to copy all characters to the BASIC line workspace.",
    "15666": "Point to the next location within the Keyword Conversion Buffer.",
    "15667": "Fetch a character from the Keyword Conversion Buffer.",
    "15668": "Mask off the terminator bit.",
    "15670": "HL=Location within Keyword Conversion Buffer.",
    "15671": "DE=Location of last character within the Keyword conversion Buffer.",
    "15672": "Insert character into BASIC line workspace, including a stored '<' or '>' character.",
    "15678": "Possibly reached the character prior to the space?",
    "15679": "Jump back if not to copy the next character.",
    "15682": "Reached the character prior to the space?",
    "15683": "Jump back if not to copy the next character.",
    "15685": "DE=Address of the space character between words.",
    "15692": "Set the address of the space character to be the start of the buffer.",
    "15695": "BC=Next location within the Keyword Conversion Buffer.",
    "15699": "Point to the last used location.",
    "15701": "Is the space possibly at the start of the buffer?",
    "15702": "Jump if not.",
    "15705": "Is the space at the start of the buffer?",
    "15706": "Jump if not.",
    "15708": "DE=Address after the space character within the Keyword Conversion Buffer.",
    "15709": "HL=Start address of the Keyword Conversion Buffer.",
    "15713": "Signal no space character between words.",
    "15716": "HL=Start address of the Keyword Conversion Buffer.",
    "15718": "Is the space possibly the last character in the buffer?",
    "15719": "Jump if not.",
    "15722": "Is the space the last character in the buffer?",
    "15723": "Jump if not.",
    "15725": "Retrieve the character to insert and the character status value.",
    "15726": "Jump ahead to continue.",
    "15728": "Fetch a character from the second word.",
    "15729": "Store it at the beginning of the buffer.",
    "15732": "Reached the last character in the buffer, i.e. the terminator bit set?",
    "15734": "Jump if not to copy the next character.",
    "15736": "Store the new address of the next free location.",
    "15739": "Jump back to attempt identification of the 'second' word as a keyword.",
    "15741": "Save the next character to insert and the character status value.",
    "15742": "Insert character held in A into BASIC line workspace.",
    "15745": "Retrieve the next character to insert and the character status value.",
    "15749": "Indicate no space character between words in the Keyword Conversion Buffer.",
    "15752": "Fetch the flag bits.",
    "15755": "Within a REM statement?",
    "15757": "Jump if so to retain the 'within a REM' flag bit.",
    "15761": "Signal no characters within the Keyword Conversion Buffer.",
    "15764": "Start address of the Keyword Conversion Buffer.",
    "15767": "Store this as the next location within the buffer.",
    "15770": "Jump back to insert the next character either into the Keyword Conversion Buffer or the BASIC line workspace.",
    "15773": "Fetch the next character from the BASIC line being inserted.",
    "15776": "Save the character.",
    "15777": "Is it below '?' (the error marker)?",
    "15779": "Jump if so.",
    "15781": "Make lowercase.",
    "15783": "Is it a letter?",
    "15786": "Jump if so.",
    "15788": "Indicate not space, not letter, not '#' and not '$'.",
    "15791": "Is it a space?",
    "15793": "Jump if so.",
    "15795": "Is it '#'?",
    "15797": "Jump if so.",
    "15799": "Jump if below '#'.",
    "15801": "Is it '$'?",
    "15803": "Jump if not.",
    "15805": "Indicate a '#' or '$'.",
    "15808": "Indicate a space.",
    "15811": "Indicate a letter.",
    "15814": "Is the character above 'z'?",
    "15816": "Return with carry flag reset if above 'z'.",
    "15817": "Is the character below 'a'?",
    "15819": "Return with carry flag reset if below 'a'.",
    "15821": "Start address of the Keyword Conversion Buffer.",
    "15824": "Store the next available location.",
    "15827": "A=0.",
    "15831": "Signal no space character between words in the Keyword Conversion Buffer.",
    "15834": "Fetch a character from the buffer.",
    "15835": "Mask off the terminator bit.",
    "15837": "Save buffer location.",
    "15838": "Insert the character into the BASIC line workspace, suppressing spaces as required.",
    "15841": "Retrieve buffer location.",
    "15842": "Re-fetch the character from the buffer.",
    "15843": "Is it the terminator character?",
    "15845": "Return if so.",
    "15846": "Point to the next character in the buffer.",
    "15847": "Jump back to handle next buffer character.",
    "15849": "Fetch address within Keyword Conversion Buffer.",
    "15852": "Address after Keyword Conversion Buffer.",
    "15856": "Has end of buffer possibly been reached?",
    "15864": "Start address of Keyword Conversion Buffer.",
    "15861": "Jump if so. [Could have saved a byte by using JR instead of JP]",
    "15860": "Has end of buffer been reached?",
    "15868": "Possibly at the start of the buffer?",
    "15869": "Jump if not.",
    "15872": "At the start of the buffer?",
    "15873": "Jump if so to simply store the character.",
    "15875": "Point to the last character.",
    "15877": "Clear the terminator bit from the last character.",
    "15879": "Point back at the current location.",
    "15881": "Retrieve the new character.",
    "15882": "Set the terminator bit.",
    "15884": "Store the character in the buffer.",
    "15885": "Point to the next location.",
    "15886": "Store the address of the next location.",
    "15889": "Signal character inserted.",
    "15892": "Clear the carry flag to indicate no room to insert the character within the buffer.",
    "15894": "Save the character to insert.",
    "15895": "Was the previous character '<' or '>'?",
    "15899": "Jump if so.",
    "15901": "Retrieve the character to insert.",
    "15902": "Is it '>'?",
    "15904": "Jump if so to store for special treatment later.",
    "15906": "Is it '<'?",
    "15908": "Jump if so to store for special treatment later.",
    "15910": "Insert the character into the BASIC line workspace.",
    "15913": "[Could have saved 1 byte by using JP $3E64 (ROM 0)]",
    "15914": "Store '<' or '>'.",
    "15917": "Signal tokenizing not complete or error marker not found.",
    "15919": "Was the previous character '<'?",
    "15921": "Reset the indicator that the previous",
    "15923": "character was '<' or '>'.",
    "15926": "Jump ahead if not '<'.",
    "15928": "Retrieve the character to insert.",
    "15929": "Is it '>'?",
    "15931": "Jump ahead if not.",
    "15933": "Tokenize to the single character '<>'.",
    "15935": "Jump back to insert the character and return.",
    "15937": "Is it '='?",
    "15939": "Jump ahead if not.",
    "15941": "Tokenize to '<='.",
    "15943": "Jump back to insert the character and return.",
    "15945": "Save the current character to insert.",
    "15946": "\"<\"",
    "15948": "Put the preceding '<' character into the line.",
    "15951": "Retrieve the character to insert.",
    "15952": "Jump back to insert the character and return.",
    "15954": "Retrieve the character to insert.",
    "15955": "Is it '='?",
    "15957": "Jump ahead if not.",
    "15959": "Tokenize to '>='.",
    "15961": "Jump back to insert the character and return.",
    "15963": "Save the current character to insert.",
    "15964": "\">\"",
    "15966": "Put the preceding '>' character into the line.",
    "15969": "Retrieve the character to insert.",
    "15970": "Jump back to insert the character and return.",
    "15972": "Is it 'ENTER'?",
    "15974": "Jump ahead if so.",
    "15976": "Is it 'REM'?",
    "15978": "Save the character.",
    "15979": "Jump ahead if not REM.",
    "15981": "Indicate that within a REM statement.",
    "15986": "Jump ahead to insert the character into the BASIC line workspace.",
    "15988": "Is it a quote?",
    "15990": "Jump ahead if not.",
    "15995": "Signal last character was not a keyword.",
    "15997": "Toggle the 'within quotes' flag. Will be 1 for an opening quote, then 0 for a closing quote.",
    "16002": "Retrieve the character.",
    "16003": "Insert the character into the BASIC line workspace, suppressing spaces as required.",
    "16006": "Indicate BASIC line tokenization not complete.",
    "16008": "Fetch the 'locate error marker' flag.",
    "16011": "Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]",
    "16013": "Jump if tokenizing the BASIC line.",
    "16015": "BC=Count of number of the characters in the typed BASIC line being inserted.",
    "16022": "Restore the stack pointer.",
    "16023": "Indicate the error marker was not found within the tokenized BASIC line.",
    "16024": "Return back to the top level calling routine, to $2D04 (ROM 0).",
    "16026": "Carry flag reset to indicate tokenizing complete.",
    "16028": "Save the character to insert in E.",
    "16032": "D=BASIC line insertion flags.",
    "16033": "Restore character to insert back to A.",
    "16034": "Is it a space?",
    "16036": "Jump ahead if not.",
    "16038": "A=BASIC line insertion flags.",
    "16039": "Was the last character a token?",
    "16041": "Jump ahead if so.",
    "16043": "A=BASIC line insertion flags.",
    "16044": "Was the last character a space?",
    "16046": "Jump ahead if so.",
    "16048": "A=BASIC line insertion flags.",
    "16049": "Signal the last character was a space.",
    "16051": "Store the updated BASIC line insertion flags.",
    "16055": "Retrieve the character to insert.",
    "16056": "Insert the character into the BASIC line workspace.",
    "16059": "A=BASIC line insertion flags.",
    "16063": "A=BASIC line insertion flags.",
    "16064": "Signal last character was not a token.",
    "16066": "Store the updated BASIC line insertion flags.",
    "16069": "[Could have saved 2 bytes by using JR $3EB3 (ROM 0)]",
    "16070": "Compare against the token 'SPECTRUM' (the first 128K keyword).",
    "16072": "Jump ahead if a token.",
    "16074": "A=BASIC line insertion flags.",
    "16075": "Was the last character a space?",
    "16077": "Jump ahead if it was.",
    "16079": "A=BASIC line insertion flags.",
    "16080": "Signal last character was not a keyword.",
    "16082": "Store the new flags.",
    "16085": "Retrieve the character to insert.",
    "16086": "Insert the character into the BASIC line workspace.",
    "16089": "[Could have saved one byte by using JP $3EFB (ROM 0)]",
    "16090": "Save the BASIC line insertion flags.",
    "16091": "Insert a space into the line.",
    "16093": "Insert the character into the BASIC line workspace.",
    "16096": "Retrieve the flags.",
    "16097": "A=BASIC line insertion flags.",
    "16098": "Signal last character was not a keyword.",
    "16100": "Signal last character was not a space.",
    "16102": "Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3ED2 (ROM 0)]",
    "16105": "Retrieve the character to insert.",
    "16106": "Insert the character into the BASIC line workspace.",
    "16110": "A=BASIC line insertion flags.",
    "16111": "Signal last character was not a space.",
    "16113": "Signal last character was a keyword.",
    "16115": "Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3ED2 (ROM 0)]",
    "16118": "Retrieve the character to insert.",
    "16119": "Insert the character into the BASIC line workspace.",
    "16126": "Increment the count of the number of characters in the tokenized BASIC line.",
    "16130": "HL=Address of next insertion position in the BASIC line workspace.",
    "16133": "Save the character to insert.",
    "16134": "Fetch the 'locate error marker' flag.",
    "16137": "Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]",
    "16139": "A=Character to insert.",
    "16140": "Jump if tokenizing the BASIC line.",
    "16142": "Fetch the address of the character after the error marker.",
    "16147": "Has the error marker position possibly been reached?",
    "16148": "Jump ahead if not.",
    "16151": "Has the error marker position been reached?",
    "16152": "Jump ahead if not.",
    "16154": "Count of the number of characters in the typed BASIC line until the error marker location was found.",
    "16158": "Count of the number of characters in the tokenized BASIC line until the error marker location.",
    "16164": "Jump if the tokenized version is longer than the typed version.",
    "16166": "Count of the number of characters in the tokenized version of the BASIC line until the error marker location.",
    "16170": "Fetch the saved stack pointer.",
    "16173": "Restore the stack pointer.",
    "16174": "Set the carry flag to indicate the error marker has been located.",
    "16175": "Return back to the top level calling routine, to $2D04 (ROM 0).",
    "16176": "Set the carry flag to indicate error marker locating mode.",
    "16177": "Jump ahead to continue.",
    "16180": "Reset carry flag to signal BASIC line tokenizing mode.",
    "16181": "Use Normal RAM Configuration (physical RAM bank 0).",
    "16184": "Jump if tokenizing the BASIC line.",
    "16186": "Fetch the current character in the tokenized BASIC line.",
    "16187": "DE=Insert position within the tokenized BASIC line.",
    "16188": "Is it the 'number' marker?",
    "16190": "Jump ahead if not.",
    "16192": "Skip over the 5 byte hidden number representation.",
    "16197": "Jump ahead to continue.",
    "16199": "Save the character to insert and the carry flag reset.",
    "16200": "Request to insert 1 byte.",
    "16205": "Check that there is memory available for 1 byte,",
    "16208": "automatically producing error '4' if not.",
    "16210": "BC=Number of bytes. HL=Address location before the position.",
    "16211": "Update all system variables due to the insertion. Exit with DE pointing to old STKEND position, BC with number of bytes 'shifted'.",
    "16213": "Fetch the start of the spare memory.",
    "16216": "DE=Address of spare memory. HL=Address of character in the BASIC line.",
    "16217": "Shift up all affected bytes to make the room for the new character.",
    "16219": "Retrieve the character to insert and the flags. The carry flag will be reset and hence will indicate that tokenizing the BASIC line is not complete.",
    "16220": "Store the character in the BASIC line workspace.",
    "16221": "Advance to the next character in the BASIC line.",
    "16222": "Use Workspace RAM configuration (physical RAM bank 7).",
    "16225": "Store the address of the next insertion position within the BASIC line workspace.",
    "16233": "Would adding the specified number of bytes overflow the RAM area?",
    "16234": "Jump to produce an error if so.",
    "16236": "DE=New end address.",
    "16237": "Would there be at least 130 bytes at the top of RAM?",
    "16241": "Jump to produce an error if not.",
    "16243": "If the stack is lower in memory, would there still be enough room?",
    "16245": "Return if there would.",
    "16248": "Signal error \"4 Out of Memory\".",
    "16251": "Jump to error handler routine.",
    "16254": "Attempt to identify 48K mode keyword.",
    "16257": "Return if keyword identified.",
    "16258": "Base character code (results in codes $F9-$FF).",
    "16260": "DE=Address of Keyword Conversion Buffer.",
    "16263": "HL=Keywords string table.",
    "16266": "Attempt to identify 128K mode/mis-spelled keyword.",
    "16269": "Return if no keyword identified.",
    "16270": "Was it \"CLOSE#\"?",
    "16274": "Use character code for 'CLOSE #'.",
    "16276": "Jump ahead to continue.",
    "16284": "Jump ahead to continue.",
    "16292": "Jump ahead to continue.",
    "16300": "Jump ahead to continue.",
    "16308": "Jump ahead to continue.",
    "16278": "Was it \"OPEN#\"?",
    "16280": "Jump if not.",
    "16288": "Jump if not.",
    "16296": "Jump if not.",
    "16304": "Jump if not.",
    "16282": "Use character code for 'OPEN #'.",
    "16286": "Was it \"DEFFN\"?",
    "16290": "Use character code for 'DEF FN'.",
    "16294": "Was it \"GOSUB\"?",
    "16298": "Use character code for 'GO SUB'.",
    "16302": "Was it \"GOTO\"?",
    "16306": "Use character code for 'GO TO'.",
    "16310": "Reduce to $A3 for 'SPECTRUM' and $A4 for 'PLAY'.",
    "16312": "Signal keyword identified.",
    "16314": "Get number of bytes to copy.",
    "16315": "Point to the first byte to copy.",
    "16316": "Fetch the byte from the source",
    "16317": "and copy it to the destination.",
    "16318": "Increment destination address.",
    "16319": "Increment source address.",
    "16320": "Repeat for all bytes.",
    "16323": "Test against '0'.",
    "16329": "Return with carry flag reset if not numeric character.",
    "16327": "Test against ':'.",
    "16326": "Return with carry flag reset if not numeric character.",
    "16330": "Get numeric value.",
    "16332": "Return with carry flag set to indicate a numeric character.",
    "16334": "Save registers.",
    "16336": "Fetch number of table entries.",
    "16337": "Point to first entry.",
    "16338": "Possible match for A?",
    "16342": "DE=Address to call if a match.",
    "16343": "Jump if a match.",
    "16345": "Next table entry.",
    "16346": "Repeat for next table entry.",
    "16348": "Return with carry flag reset to signal an error beep is required",
    "16349": "and with the zero flag reset to signal a match was not found.",
    "16350": "Restore registers.",
    "16353": "HL=Action routine to call.",
    "16356": "Indirectly call the action handler routine.",
    "16359": "Jump if no error beep is required.",
    "16361": "Set zero flag to indicate a match was found.",
    "16362": "Exit with carry flag reset to indicate error beep required.",
    "16363": "Set zero flag to indicate a match was found.",
    "16364": "Signal no error beep required.",
    "16366": "Jump to the action handler routine.",
    "16368": "Martin Brennan.",
    "16371": "Steve Berry.",
    "16374": "Andrew Cummins.",
    "16377": "Rupert Goodwins.",
    "16380": "Kevin Males."
  },
  "PrefixComments": {
    "0": "RST $00 - Reset Machine",
    "16": "RST $10 - Print A Character",
    "24": "RST $18 - Collect A Character",
    "40": "RST 28 calls a routine in ROM 1 (or alternatively a routine in RAM while ROM 1 is paged in). Call as follows: RST 28 / DEFW address.",
    "56": "This routine preserves the HL register pair. It then performs the following: 1) Execute the ROM switching code held in RAM to switch to ROM 1; 2) Execute the maskable interrupt routine in ROM 1; 3) Execute the ROM switching code held in RAM to return to ROM 0; Return to address $0048 (ROM 0)",
    "74": "ERROR HANDLER ROUTINES - PART 1 - 128K Error Routine",
    "92": "RESTART ROUTINES - PART 2 -Call ROM 1 Routine (RST $28 Continuation); Continuation from routine at $0028 (ROM 0).",
    "107": "RAM ROUTINES: The following code will be copied to locations $5B00 to $5B57, within the old ZX Printer buffer.",
    "127": "Return to Other ROM Routine (copied to $5B14)",
    "136": "Error Handler Routine (copied to $5B1D)",
    "154": "'P' Channel Input Routine (copied to $5B2F)",
    "159": "'P' Channel Output Routine (copied to $5B34)",
    "181": "'P' Channel Exit Routine (copied to $5B4A)",
    "195": "ERROR HANDLER ROUTINES - PART 2: Called from ONERR ($5B1D) to execute the routine pointed to by system variable SYNRET.",
    "199": "Reset Routine (RST $00 Continuation, Part 1): Continuation from routine at $0000 (ROM 0). It performs a test on all RAM banks. This test is crude and can fail to detect a variety of RAM errors.",
    "256": "ROUTINE VECTOR TABLE",
    "305": "INITIALISATION ROUTINES - PART 2: Fatal RAM Error -- Set the border colour to indicate which RAM bank was found faulty.",
    "311": "Reset Routine (RST $00 Continuation, Part 2): Continuation from routine at $00C7 (ROM 0).",
    "413": "Entry point for NEW with interrupts disabled and physical RAM bank 0 occupying the upper RAM region $C000 - $FFFF, i.e. the normal BASIC memory configuration.",
    "1417": "The 'Initial Channel Information': Initially there are four channels ('K', 'S', 'R', & 'P') for communicating with the 'keyboard', 'screen', 'work space' and 'printer'. For each channel the output routine address comes before the input routine address and the channel's code. This table is almost identical to that in ROM 1 at $15AF but with changes to the channel P routines to use the RS232 port instead of the ZX Printer. Used at $01DD (ROM 0).",
    "1438": "The 'Initial Stream Data': Initially there are seven streams - $FD to $03. This table is identical to that in ROM 1 at $15C6. Used at $0226 (ROM 0).",
    "610": "[Note this is where $EC13 (temporary P_FLAG) and $FF24 should be set]",
    "619": "COMMAND EXECUTION ROUTINES - PART 1: Execute Command Line - A typed in command resides in the editing workspace. Execute it.  The command could either be a new line to insert, or a line number to delete, or a numerical expression to evaluate.",
    "690": "Calculator mode",
    "696": "Otherwise ignore the command",
    "698": "Return from BASIC Line Syntax Check: This routine is returned to when a BASIC line has been syntax checked.",
    "705": "The syntax check was successful, so now proceed to parse the line for insertion or execution",
    "719": "Parse a BASIC Line with No Line Number",
    "780": "[*BUG* - Whenever a typed in command is executed directly from the editing workspace, a new GO SUB marker is set up on the stack. Any existing GO SUB calls that were on the stack are lost and as a result attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. However, the stack marker will already have been lost due to the error handler routine at $0321. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. This is why it is necessary for a new GO SUB marker needs to be set up. Credit: Michal Skrzypek]",
    "801": "ERROR HANDLER ROUTINES - PART 3: Error Handler Routine - [*BUG* - Upon terminating a BASIC program, either via reaching the end of the program or due to an error occurring, execution is passed to this routine. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. However, this means that any existing GO SUB calls that were on the stack are lost and so attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a \"7 RETURN without GOSUB\" error report message being displayed. When a new typed in command is executed, the code at $030C sets up a new GO SUB marker on the stack. Credit: Michal Skrzypek]",
    "842": "Display error code held in ERR_NR",
    "906": "Display a new error message - [Note that there is no test to range check the error code value and therefore whether a message exists for it. Poking directly to system variable ERR_NR with an invalid code (43 or above) will more than likely cause a crash]",
    "924": "Display a standard error message.",
    "1007": "Error Handler Routine When Parsing BASIC Line",
    "1015": "COMMAND EXECUTION ROUTINES - PART 2: Parse a BASIC Line with a Line Number - This routine handles insertion of a BASIC line specified with a line number, or just a line number specified on its own, i.e. delete the line.",
    "1059": "The line already exists so delete it",
    "1071": "Just a line number entered. The requested line has already been deleted so move the program cursor to the next line",
    "1132": "ERROR HANDLER ROUTINES - PART 4: New Error Message Vector Table",
    "1164": "New Error Message Table",
    "1405": "Print a message which is terminated by having bit 7 set, pointed at by DE.",
    "1452": "ERROR HANDLER ROUTINES - PART 5: Produce Error Report",
    "1477": "Handle a standard error code",
    "1480": "Handle a new error code",
    "1494": "Check for BREAK into Program",
    "1510": "RS232 PRINTER ROUTINES: RS232 Channel Handler Routines - This routine handles input and output RS232 requested. It is similar to the routine in the ZX Interface 1 ROM at $0D5A, but in that ROM the routine is only used for input.",
    "1535": "Handle INPUT#",
    "1552": "Return here from the input/output routine",
    "1560": "A character was not received",
    "1563": "A character was received",
    "1581": "Enter was received so end reading the stream",
    "1591": "Handle INKEY$# and PRINT#",
    "1597": "Return here from the input/output routine. When returning from the output routine, either the carry or zero flags should always be set to avoid the false generation of error report \"8 End of file\" [though this is not always the case - see bugs starting at $086C (ROM 0)].",
    "1601": "FORMAT Routine: The format command sets the RS232 baud rate, e.g. FORMAT \"P\"; 9600. It attempts to match against one of the supported baud rates, or uses the next higher baud rate if a non-standard value is requested. The maximum baud rate supported is 9600, and this is used for any rates specified that are higher than this.",
    "1688": "Lookup the timing constant to use for the specified baud rate",
    "1720": "Baud Rate Table: Consists of entries of baud rate value followed by timing constant to use in the RS232 routines.",
    "1711": "The baud rate has been matched",
    "1752": "RS232 Input Routine - Exit: Carry flag set if a byte was read with the byte in A. Carry flag reset upon error.",
    "1765": "Read Byte from RS232 Port: The timing of the routine is achieved using the timing constant held in system variable BAUD. Exit: Carry flag set if a byte was read, or reset upon error. A=Byte read in.",
    "1806": "Look for the start bit",
    "1834": "A start bit has been found, so the 8 data bits are now read in. As each bit is read in, it is shifted into the msb of A. Bit 7 of A is preloaded with a 1 to represent the start bit and when this is shifted into the carry flag it signifies that 8 data bits have been read in.",
    "1858": "Received one 1",
    "1867": "Received one 0",
    "1876": "After looping 8 times to read the 8 data bits, the start bit in the bit counter will be shifted out and hence A will contain a received byte.",
    "1879": "The success and failure paths converge here",
    "1905": "The device at the other end of the cable may send a second byte even though CTS is low. So repeat the procedure to read another byte.",
    "1916": "No second byte incoming so return status of the first byte read attempt",
    "1931": "A second byte is on its way and is received exactly as before",
    "1966": "Received one 1",
    "1975": "Received one 0",
    "1984": "Exit with the byte that was read in",
    "1994": "RS232 Output Routine: This routine handles control codes, token expansion, graphics and UDGs. It therefore cannot send binary data and hence cannot support EPSON format ESC control codes [Credit: Andrew Owen]. The routine suffers from a number of bugs as described in the comments below. It also suffers from a minor flaw in the design, which prevents interlacing screen and printer control codes and their parameters. Entry: A=character to output. Exit : Carry flag reset indicates success.",
    "2007": "All parameters processed",
    "2021": "Process tokens",
    "2055": "Printable character",
    "2082": "Handle a carriage return",
    "2078": "Process control codes",
    "2100": "Handle a comma",
    "2120": "Column 8, 16, 24 or 32 reached. Output multiple spaces until the desired column position is reached.",
    "2144": "Handle AT and TAB",
    "2153": "Handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER",
    "2162": "All parameters processed",
    "2174": "Handle TAB parameter",
    "2178": "Process AT and TAB",
    "2186": "Column position equal or greater than length of row requested",
    "2211": "Write Byte to RS232 Port - The timing of the routine is achieved using the timing constant held in system variable BAUD. Entry: A holds character to send. Exit:  Carry and zero flags reset.",
    "2248": "Transmit each bit",
    "2260": "Transmit a 0",
    "2266": "Transmit a 1",
    "2288": "COPY Command Routine - This routine copies 22 rows of the screen, outputting them to the printer a half row at a time. It is designed for EPSON compatible printers supporting double density bit graphics and 7/72 inch line spacing. Only the pixel information is processed; the attributes are ignored.",
    "2425": "EPSON Printer Control Code Tables",
    "2318": "Copy done so reset printer line spacing before exiting",
    "2325": "Output Half Row",
    "2342": "Output a column of pixels (at double height)",
    "2389": "Output Nibble of Pixels: Send each nibble of pixels (i.e. column of 4 pixels) output 3 times so that the width of a pixel is the same size as its height.",
    "2399": "Output Characters from Table: This routine is used to send a sequence of EPSON printer control codes out to the RS232 port. It sends (HL) characters starting from HL+1.",
    "2413": "Test Whether Pixel (B,C) is Set",
    "2509": "[*BUG* - At this point interrupts are disabled and IY is now being used as a pointer to the master PLAY information block. Unfortunately, interrupts are enabled during the STK_FETCH call and IY is left containing the wrong value. This means that if an interrupt were to occur during execution of the subroutine then there would be a one in 65536 chance that (IY+$40) will be corrupted - this corresponds to the volume setting for music channel A. Rewriting the SWAP routine to only re-enable interrupts if they were originally enabled would cure this bug (see end of file for description of her suggested fix). Credit: Toni Baker, ZX Computing Monthly]",
    "2437": "PLAY COMMAND ROUTINES - Up to 3 channels of music/noise are supported by the AY-3-8912 sound generator. Up to 8 channels of music can be sent to support synthesisers, drum machines or sequencers via the MIDI interface, with the first 3 channels also played by the AY-3-8912 sound generator. For each channel of music, a MIDI channel can be assigned to it using the 'Y' command. Entry: B=The number of strings in the PLAY command (1..8).",
    "2565": "Entry point here from the vector table at $011B",
    "2609": "Calculate Timing Loop Counter <<< RAM Routine >>> - This routine is copied into the command data block (offset $2B..$37) by the routine at $0A05 (ROM 0). It uses the floating point calculator found in ROM 1, which is usually invoked via a RST $28 instruction. Since ROM 0 uses RST $28 to call a routine in ROM 1, it is unable to invoke the floating point calculator this way. It therefore copies the following routine to RAM and calls it with ROM 1 paged in.",
    "2622": "Test BREAK Key: Test for BREAK being pressed. Exit: Carry flag reset if BREAK is being pressed.",
    "2634": "Select Channel Data Block Duration Pointers: Point to the start of the channel data block duration pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2639": "Select Channel Data Block Pointers: Point to the start of the channel data block pointers within the command data block. Entry: IY=Address of the command data block. Exit : HL=Address of current channel pointer.",
    "2663": "Get Channel Data Block Address for Current String: Entry: HL=Address of channel data block pointer. Exit : IX=Address of current channel data block.",
    "2670": "Next Channel Data Pointer",
    "2685": "PLAY Command (Continuation): This section is responsible for processing the PLAY command and is a continuation of the routine at $0985 (ROM 0). It begins by determining the first note to play on each channel and then enters a loop to play these notes, fetching the subsequent notes to play at the appropriate times.",
    "2694": "HL=Address of channel data pointer.",
    "2711": "The first notes to play for each channel have now been determined. A loop is entered that coordinates playing the notes and fetching subsequent notes when required. Notes across channels may be of different lengths and so the shortest one is determined, the tones for all channels set and then a waiting delay entered for the shortest note delay. This delay length is then subtracted from all channel note lengths to leave the remaining lengths that each note needs to be played for. For the channel with the smallest note length, this will now have completely played and so a new note is fetched for it. The smallest length of the current notes is then determined again and the process described above repeated. A test is made on each iteration to see if all channels have run out of data to play, and if so this ends the PLAY command.",
    "2743": "PLAY Command Character Table: Recognised characters in PLAY commands.",
    "2757": "Get Play Character: Get the current character from the PLAY string and then increment the character pointer within the string. Exit: Carry flag set if string has been fully processed. Carry flag reset if character is available. A=Character available.",
    "2769": "Get Next Note in Semitones: Finds the number of semitones above C for the next note in the string, Entry: IX=Address of the channel data block. Exit : A=Number of semitones above C, or $80 for a rest.",
    "3577": "Semitones Table: This table contains an entry for each note of the scale, A to G, and is the number of semitones above the note C.",
    "2845": "Get Numeric Value from Play String: Get a numeric value from a PLAY string, returning 0 if no numeric value present. Entry: IX=Address of the channel data block. Exit : BC=Numeric value, or 0 if no numeric value found.",
    "2885": "The end of the numeric value was reached",
    "2896": "Multiply DE by 10: Entry: DE=Value to multiple by 10. Exit : DE=Value*10.",
    "2908": "Find Next Note from Channel String: Entry: IX=Address of channel data block.",
    "2947": "Comes here after processing a non-numeric digit that does not have a specific command routine handler Hence the next note to play has been determined and so a return is made to process the other channels.",
    "2949": "Play Command '!' (Comment): A comment is enclosed within exclamation marks, e.g. \"! A comment !\". Entry: IX=Address of the channel data block.",
    "3530": "PLAY Command Jump Table: Handler routine jump table for all PLAY commands.",
    "2960": "Play Command 'O' (Octave): The 'O' command is followed by a numeric value within the range 0 to 8, although due to loose range checking the value MOD 256 only needs to be within 0 to 8. Hence O256 operates the same as O0. Entry: IX=Address of the channel data block.",
    "2981": "Play Command 'N' (Separator): The 'N' command is simply a separator marker and so is ignored. Entry: IX=Address of the channel data block.",
    "2982": "Play Command '(' (Start of Repeat): A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice. Entry: IX=Address of the channel data block.",
    "3010": "Play Command ')' (End of Repeat): A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice. Brackets can also be nested within each other, to 4 levels deep. If a closing bracket if used without a matching opening bracket then the whole string up until that point is repeated indefinitely. Entry: IX=Address of the channel data block.",
    "3020": ";Has the bracket level been repeated, i.e. re-reached the same position in the string as the closing bracket return address?",
    "3036": "The bracket level has been repeated. Now check whether this was the outer bracket level.",
    "3044": "The outer bracket level has been repeated",
    "3049": "The repeat was caused by a single closing bracket so re-initialise the repeat",
    "3056": "A new level of closing bracket nesting",
    "3102": "There is one more closing bracket then opening brackets, i.e. repeat string indefinitely",
    "3111": "Get Address of Bracket Pointer Store: Entry: IX=Address of the channel data block. DE=Offset to the bracket pointer stores. A=Index into the bracket pointer stores. Exit : HL=Address of the specified pointer store.",
    "3122": "Play Command 'T' (Tempo): A tempo command must be specified in the first play string and is followed by a numeric value in the range 60 to 240 representing the number of beats (crotchets) per minute. Entry: IX=Address of the channel data block.",
    "3141": "A holds a value in the range 60 to 240",
    "3190": "Tempo Command Return: The calculator stack now holds the value (10/(Tempo*4))/7.33e-6 and this is stored as the tempo value. The result is used an inner loop counter in the wait routine at $0F76 (ROM 0). Each iteration of this loop takes 26 T-states. The time taken by 26 T-states is 7.33e-6 seconds. So the total time for the loop to execute is 2.5/TEMPO seconds.",
    "3204": "Play Command 'M' (Mixer): This command is used to select whether to use tone and/or noise on each of the 3 channels. It is followed by a numeric value in the range 1 to 63, although due to loose range checking the value MOD 256 only needs to be within 0 to 63. Hence M256 operates the same as M0. Entry: IX=Address of the channel data block.",
    "3213": "Bit 0: 1=Enable channel A tone. Bit 0: 1=Enable channel A tone. Bit 1: 1=Enable channel B tone. Bit 2: 1=Enable channel C tone. Bit 3: 1=Enable channel A noise. Bit 4: 1=Enable channel B noise. Bit 5: 1=Enable channel C noise.",
    "3221": "Play Command 'V' (Volume): This sets the volume of a channel and is followed by a numeric value in the range 0 (minimum) to 15 (maximum), although due to loose range checking the value MOD 256 only needs to be within 0 to 15. Hence V256 operates the same as V0. Entry: IX=Address of the channel data block.",
    "3233": "[*BUG* - An attempt to set the volume for a sound chip channel is now made. However, this routine fails to take into account that it is also called to set the volume for a MIDI only channel, i.e. play strings 4 to 8. As a result, corruption occurs to various sound generator registers, causing spurious sound output. There is in fact no need for this routine to set the volume for any channels since this is done every time a new note is played - see routine at $0A97 (ROM 0). the bug fix is to simply to make a return at this point. This routine therefore contains 11 surplus bytes. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "3245": "Play Command 'U' (Use Volume Effect): This command turns on envelope waveform effects for a particular sound chip channel. The volume level is now controlled by the selected envelope waveform for the channel, as defined by the 'W' command. MIDI channels do not support envelope waveforms and so the routine has the effect of setting the volume of a MIDI channel to maximum, i.e. 15. It might seem odd that the volume for MIDI channels is set to 15 rather than just filtered out. However, the three sound chip channels can also drive three MIDI channels and so it would be inconsistent for these MIDI channels to have their volume set to 15 but have the other MIDI channels behave differently. However, it could be argued that all MIDI channels should be unaffected by the 'U' command. There are no parameters to this command. Entry: IX=Address of the channel data block.",
    "3258": "Play command 'W' (Volume Effect Specifier): This command selects the envelope waveform to use and is followed by a numeric value in the range 0 to 7, although due to loose range checking the value MOD 256 only needs to be within 0 to 7. Hence W256 operates the same as W0. Entry: IX=Address of the channel data block.",
    "3278": "Play Command 'X' (Volume Effect Duration): This command allows the duration of a waveform effect to be specified, and is followed by a numeric value in the range 0 to 65535. A value of 1 corresponds to the minimum duration, increasing up to 65535 and then maximum duration for a value of 0. If no numeric value is specified then the maximum duration is used. Entry: IX=Address of the channel data block.",
    "3293": "Play Command 'Y' (MIDI Channel): This command sets the MIDI channel number that the string is assigned to and is followed by a numeric value in the range 1 to 16, although due to loose range checking the value MOD 256 only needs to be within 1 to 16. Hence Y257 operates the same as Y1. Entry: IX=Address of the channel data block.",
    "3310": "Play Command 'Z' (MIDI Programming Code): This command is used to send a programming code to the MIDI port. It is followed by a numeric value in the range 0 to 255, although due to loose range checking the value MOD 256 only needs to be within 0 to 255. Hence Z256 operates the same as Z0. Entry: IX=Address of the channel data block.",
    "3318": "Play Command 'H' (Stop): This command stops further processing of a play command. It has no parameters. Entry: IX=Address of the channel data block.",
    "3323": "Play Commands 'a'..'g', 'A'..'G', '1'..\"12\", '&' and '_': This handler routine processes commands 'a'..'g', 'A'..'G', '1'..\"12\", '&' and '_', and determines the length of the next note to play. It provides the handling of triplet and tied notes. It stores the note duration in the channel data block's duration length entry, and sets a pointer in the command data block's duration lengths pointer table to point at it. A single note letter is deemed to be a tied note count of 1. Triplets are deemed a tied note count of at least 2. Entry: IX=Address of the channel data block. A=Current character from play string.",
    "3329": "The character is a number digit",
    "3359": "It is a triplet semi-quaver (10), triplet quaver (11) or triplet crotchet (12)",
    "3378": "The note duration was in the range 1 to 9",
    "3405": "A triplet note was found as part of a tied note",
    "3423": "A non-triplet tied note",
    "3438": "The number found was not part of a tied note, so store the duration value",
    "3444": "This subroutine is called to increment the tied notes counter",
    "3457": "The character is not a number digit so is 'A'..'G', '&' or '_'",
    "3464": "Store a pointer to the channel data block's duration length into the command data block",
    "3489": "End of String Found: This routine is called when the end of string is found within a comment. It marks the string as having been processed and then returns to the main loop to process the next string.",
    "3490": "Enter here if the end of the string is found whilst processing a string.",
    "3500": "Point to Duration Length within Channel Data Block: Entry: IX=Address of the channel data block. Exit : HL=Address of the duration length within the channel data block.",
    "3508": "Store Entry in Command Data Block's Channel Duration Length Pointer Table: Entry: IY=Address of the command data block. IX=Address of the channel data block for the current string. HL=Address of the duration length store within the channel data block. Exit : HL=Address of the duration length store within the channel data block. DE=Channel duration.",
    "3568": "Identify Command Character: This routines attempts to match the command character to those in a table. The index position of the match indicates which command handler routine is required to process the character. Note that commands are case sensitive. Entry: A=Command character. Exit : Zero flag set if a match was found. BC=Indentifying the character matched, 1 to 15 for match and 0 for no match.",
    "3584": "Find Note Duration Length: Entry: C=Duration value (0 to 12, although a value of 0 is never used). Exit : DE=Note duration length.",
    "3596": "Note Duration Table: A whole note is given by a value of 96d and other notes defined in relation to this. The value of 96d is the lowest common denominator from which all note durations can be defined.",
    "3609": "Is Numeric Digit?: Tests whether a character is a number digit. Entry: A=Character. Exit : Carry flag reset if a number digit.",
    "3616": "Play a Note On a Sound Chip Channel: This routine plays the note at the current octave and current volume on a sound chip channel. For play strings 4 to 8, it simply stores the note number and this is subsequently played later. Entry: IX=Address of the channel data block. A=Note value as number of semitones above C (0..11).",
    "3633": "Only set the noise generator frequency on the first channel",
    "3656": "Channel 0, 1 or 2",
    "3671": ";Note number 21 to 107 (range 0 to 86)",
    "3708": "Set Sound Generator Register: Entry: D=Register to write. E=Value to set register to.",
    "3721": "Read Sound Generator Register: Entry: A=Register to read. Exit : A=Value of currently selected sound generator register.",
    "3731": "Turn Off All Sound",
    "3738": "Turn off the sound from the AY-3-8912",
    "3756": "Now reset all MIDI channels in use",
    "3784": "Get Previous Character from Play String: Get the previous character from the PLAY string, skipping over spaces and 'Enter' characters. Entry: IX=Address of the channel data block.",
    "3811": "Get Current Character from Play String: Get the current character from the PLAY string, skipping over spaces and 'Enter' characters. Exit: Carry flag set if string has been fully processed. Carry flag reset if character is available. A=Character available.",
    "3858": "Produce Play Error Reports",
    "3906": "Play Note on Each Channel: Play a note and set the volume on each channel for which a play string exists.",
    "3935": "One of the 3 sound chip generator channels so set the channel's volume for the new note",
    "3958": "Wait Note Duration: This routine is the main timing control of the PLAY command. It waits for the specified length of time, which will be the lowest note duration of all active channels. The actual duration of the wait is dictated by the current tempo. Entry: DE=Note duration, where 96d represents a whole note. Enter a loop waiting for (135+ ((26*(tempo-100))-5) )*DE+5 T-states",
    "3974": "Tempo timing value = (10/(TEMPO*4))/7.33e-6, where 7.33e-6 is the time for 26 T-states. The loop below takes 26 T-states per iteration, where the number of iterations is given by the tempo timing value. So the time for the loop to execute is 2.5/TEMPO seconds. For a TEMPO of 60 beats (crotchets) per second, the time per crotchet is 1/24 second. The duration of a crotchet is defined as 24 from the table at $0E0C, therefore the loop will get executed 24 times and hence the total time taken will be 1 second. The tempo timing value above has 100 subtracted from it, presumably to approximately compensate for the overhead time previously taken to prepare the notes for playing. This reduces the total time by 2600 T-states, or 733us.",
    "3985": "Find Smallest Duration Length: This routine finds the smallest duration length for all current notes being played across all channels. Exit: DE=Smallest duration length.",
    "3997": "HL=Address of channel data pointer. DE holds the smallest duration length found so far.",
    "4013": "The current channel's duration was not smaller so restore the last smallest into DE.",
    "4033": "Play a Note on Each Channel and Update Channel Duration Lengths: This routine is used to play a note and set the volume on all channels. It subtracts an amount of time from the duration lengths of all currently playing channel note durations. The amount subtracted is equivalent to the smallest note duration length currently being played, and as determined earlier. Hence one channel's duration will go to 0 on each call of this routine, and the others will show the remaining lengths of their corresponding notes. Entry: IY=Address of the command data block.",
    "4092": "The current channel uses the smallest found duration length",
    "4134": "The channel has more tied notes",
    "4186": "Check whether another channel needs its duration length updated",
    "4198": "[*BUG* - By this point, the volume for both sound chip and MIDI channels has been set to 0, i.e. off. So although the new notes have been set playing on the sound chip channels, no sound is audible. For MIDI channels, no new notes have yet been output and hence these are also silent. If the time from turning the volume off for the current note to the time to turn the volume on for the next note is short enough, then it will not be noticeable. However, the code at $1066 (ROM 0) introduces a 1/96th of a note delay and as a result a 1/96th of a note period of silence between notes. The bug can be resolved by simply deleting the two instructions below that introduce the delay. A positive side effect of the bug in the 'V' volume command at $0C95 (ROM 0) is that it can be used to overcome the gaps of silence between notes for sound chip channels. By interspersing volume commands between notes, a new volume level is immediately set before the 1/96th of a note delay is introduced for the new note. Therefore, the delay occurs when the new note is audible instead of when it is silent. For example, PLAY \"cV15cV15c\" instead of PLAY \"ccc\". The note durations are still 1/96th of a note longer than they should be though. This technique will only work on the sound chip channels and not for any MIDI channels. Credit: Ian Collier (+3), Paul Farrow (128)]",
    "4207": "All channel durations have been updated. Update the volume on each sound chip channel, and the volume and note on each MIDI channel",
    "4246": "Note Lookup Table: Each word gives the value of the sound generator tone registers for a given note. There are 9 octaves, containing a total of 108 notes. These represent notes 21 to 128. Notes 0 to 20 cannot be reproduced on the sound chip and so note 21 will be used for all of these (they will however be sent to a MIDI device if one is assigned to a channel). [Note that both the sound chip and the MIDI port can not play note 128 and so its inclusion in the table is a waste of 2 bytes]. The PLAY command does not allow octaves higher than 8 to be selected directly. Using PLAY \"O8G\" will select note 115. To select higher notes, sharps must be included, e.g. PLAY \"O8#G\" for note 116, PLAY \"O8##G\" for note 117, etc, up to PLAY \"O8############G\" for note 127. Attempting to access note 128 using PLAY \"O8#############G\" will lead to error report \"m Note out of range\".",
    "4462": "Play Note on MIDI Channel: This routine turns on a note on the MIDI channel and sets its volume, if MIDI channel is assigned to the current string. Three bytes are sent, and have the following meaning: Byte 1: Channel number $00..$0F, with bits 4 and 7 set. Byte 2: Note number $00..$7F. Byte 3: Note velocity $00..$78.",
    "4467": "A holds the assigned channel number ($00..$0F)",
    "4493": "Turn MIDI Channel Off: This routine turns off a note on the MIDI channel, if a MIDI channel is assigned to the current string. Three bytes are sent, and have the following meaning: Byte 1: Channel number $00..$0F, with bit 7 set. Byte 2: Note number $00..$7F. Byte 3: Note velocity $40. Entry: IX=Address of the channel data block.",
    "4498": "A holds the assigned channel number ($00..$0F)",
    "4515": "Send Byte to MIDI Device: This routine sends a byte to the MIDI port. MIDI devices communicate at 31250 baud, although this routine actually generates a baud rate of 31388, which is within the 1% tolerance supported by MIDI devices. Entry: A=Byte to send.",
    "4587": "SAVE Routine",
    "4594": "LOAD Routine",
    "4601": "VERIFY Routine",
    "4608": "MERGE Routine",
    "4624": "RAM disk operation",
    "4637": "RAM Disk Command Handling: The information relating to the file is copied into memory in $5B66 (FLAGS3) to ensure that it is available once other RAM banks are switched in. This code is very similar to that in the ZX Interface 1 ROM at $08F6. Entry: HL=Start address. IX=File header descriptor.",
    "4673": "A copy of the header information has now been copied from IX+$00 onwards to HD_00 onwards",
    "4720": "The file exists else the call above would have produced an error \"h file does not exist\"",
    "4752": "Either a verify program/array or a load/verify CODE/SCREEN$ type file",
    "4759": "Cannot merge CODE/SCREEN$",
    "4763": "RAM Disk VERIFY! Routine",
    "4778": "File was smaller than requested",
    "4805": "RAM Disk MERGE! Routine",
    "4827": "RAM Disk LOAD! Routine",
    "4839": "Start address was not specified",
    "4854": "Test if there is room since file is bigger than requested",
    "4863": "Test file type",
    "4870": "Array type",
    "4874": "Start address of existing array was specified",
    "4885": "Insert new array entry into variables area",
    "4917": "Program type",
    "4990": "RAM Disk Load Bytes: Make a check that the requested length is not zero before proceeding to perform the LOAD, MERGE or VERIFY. Note that VERIFY simply performs a LOAD. Entry: HL=Destination address. DE=Length. IX=Address of catalogue entry. HD_00-HD_11 holds file header information.",
    "4997": "Get Expression from BASIC Line: Returns in BC.",
    "5011": "Check Filename and Copy: Called to check a filename for validity and to copy it into N_STR1 ($5B67).",
    "5054": "Cassette / RAM Disk Command Handling: Handle SAVE, LOAD, MERGE, VERIFY commands. Bit 3 of FLAGS3 indicates whether a cassette or RAM disk command. This code is very similar to that in ROM 1 at $0605.",
    "5113": "Continue to handle the name of the program.",
    "5120": "The name is now transferred to the work space (second location onwards)",
    "5127": "The many different parameters, if any, that follow the command are now considered. Start by handling 'xxx \"name\" DATA'.",
    "5132": "'xxx \"name\" DATA'",
    "5167": "Continue with the handling of an existing array",
    "5188": "The next part is common to both 'old' and 'new' arrays",
    "5201": "The last part of the statement is examined before joining the other pathways",
    "5215": "Now Consider 'SCREEN$'",
    "5219": "'xxx \"name\" SCREEN$'",
    "5250": "Now consider 'CODE'",
    "5254": "'xxx \"name\" CODE'",
    "5280": "Look for a 'starting address'",
    "5300": "Fetch the 'length' as it was specified",
    "5304": "The parameters are now stored in the header area of the work space",
    "5327": "'SCREEN$' and 'CODE' are both of type 3",
    "5333": "'xxx \"name\"' / 'SAVE \"name\" LINE'",
    "5369": "'LINE' and 'no further parameters' are both of type 0",
    "5401": "In all cases the header information has now been prepared: The location 'IX+00' holds the type number. Locations 'IX+01 to IX+0A' holds the name ($FF in 'IX+01' if null). Locations 'IX+0B & IX+0C' hold the number of bytes that are to be found in the 'data block'. Locations 'IX+0D to IX+10' hold a variety of parameters whose exact interpretation depends on the 'type'. The routine continues with the first task being to separate SAVE from LOAD, VERIFY and MERGE.",
    "5419": "In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of the 'header area' in the work space hold the prepared information, as detailed above; and it is now time to fetch a 'header' from the tape.",
    "5423": "Relist the BASIC Program from the Current Line: This routine lists the BASIC program from the current line number. It initially shows the last line displayed but rows may subsequently be scrolled up until the required BASIC line has been found. The structure of the ROM program only supports listing BASIC lines that are 20 rows or less; larger lines are shown truncated to 20 rows.",
    "5430": "A loop is entered to display a screenful of program listing. If the current line number is not found in the lines displayed then all lines are scrolled up and the listing reproduced. This procedure repeats until the current line number has been found and displayed.",
    "5463": "The current settings indicate that the top BASIC line straggles into the Above-Screen Line Edit Buffer. It is therefore necessary to insert the current BASIC line into the Below-Screen Line Edit Buffer and then shift the appropriate number of rows into the Above-Screen Line Edit Buffer.",
    "5475": "Either there the top BASIC line does not straggle off the top of the the screen or the appropriate number of rows have been copied into the Above-Screen Line Edit Buffer. In the latter case, the Below-Screen Line Edit Buffer contains the remaining rows of the BASIC line and which be copied into the top of the Screen Line Edit Buffer.",
    "5487": "Enter a loop to copy BASIC line rows into the Screen Line Edit Buffer. The Below-Screen Line Edit Buffer is used as a temporary store for holding each BASIC line as it is copied into the Screen Line Edit Buffer. If the top BASIC line straggles above the screen then this loop is entered with the remains of the line already in the Below-Screen Line Edit Buffer.",
    "5497": "The current line has not yet been found so examine the current row in case it is the current line",
    "5507": "The Below-Screen Line Edit Buffer contains a complete BASIC line so determine whether this is the current line",
    "5545": "This is the current line so scan across the BASIC line to locate the cursor column position",
    "5526": "Copy the row of the BASIC line from the Below-Screen Line Edit Buffer into the Screen Line Edit Buffer",
    "5554": "There are editable characters on this row prior to the cursor. [*BUG* - Entering '  10 REM' or '0010 REM' will insert the line into the program area but instead of placing the cursor on the following row it is placed after the following BASIC line, or if the line inserted was the last in the program then the cursor is placed on row 20. The bug occurs due to the leading spaces or zeros, and hence will apply to every BASIC command. When the line is inserted into the Screen Line Edit Buffer, the leading spaces are discarded and hence the line length is shorter than that typed in. However, it is the typed in line length that is used when parsing the BASIC line in the Screen Line Edit Buffer and as a result this causes an attempt to find the remaining characters on the following row of the Screen Line Edit Buffer. If another BASIC line is on the following Screen Line Edit Buffer row then the search completes and the cursor is placed on the row after this BASIC line. If there is not a BASIC line on the following row then the search continues on the next row. Since this will also be empty, the search advances onto the next row, and then the next, and so on until row 20 is reached. To fix the bug, the typed in character count until the cursor (held in $EC06) ideally needs to be adjusted to match the actual number of characters stored in the Screen Line Edit Buffer. However, this is not a trivial change to implement. A simpler solution to fix the bug is to intercept when a move to the next row is made and to determine whether the BASIC line actually continues on this row. Credit: Paul Farrow]",
    "5561": "An editable character was found to the right on the current row",
    "5568": "Column position of cursor located, find the closest editable character",
    "5579": "Store the current cursor position",
    "5587": "Move to next row",
    "5594": "The bottom screen row has been exceeded",
    "5601": "Current line has not yet been found",
    "5605": "This is not the current line",
    "5620": "There is no current line number",
    "5657": "All rows printed",
    "5637": "Print All Screen Line Edit Buffer Rows to the Display File: Print all rows of the edit buffer to the display file, and updating the cursor position settings if required. Entry: Zero flag reset if update of cursor position settings required. B=Row number. C=Number of editing rows on screen.",
    "5659": "Find the new cursor column position",
    "5680": "Clear Editing Display",
    "5689": "Shift All Edit Buffer Rows Up and Update Display File if Required: This routine shifts all edit buffer rows up, updating the display file if required. Entry: HL=Address of the 'Bottom Row Scroll Threshold' within the editing area information. Exit : Carry flag set if edit buffer rows were shifted.",
    "5692": "Attempt to shift a row into the Above-Screen Line Edit Buffer",
    "5701": ";A change to the number of rows in the Above-Screen Line Edit Buffer occurred",
    "5704": "Shift All Screen Line Edit Buffer Rows Up and Update Display File if Required",
    "5717": "Shift all Screen Line Edit Buffer rows up",
    "5730": "All Screen Line Edit Buffer rows have been shifted up",
    "5743": "Shift All Edit Buffer Rows Down and Update Display File if Required: This routine shifts all edit buffer rows down, updating the display file if required. Exit : Carry flag set if edit buffer rows were shifted. B=Last row number to shift. Shift all rows in the Above-Screen Line Edit Buffer, shifting in a new BASIC line if applicable",
    "5749": "Entry point from routine at $2ED3 (ROM 0) to insert a blank row",
    "5751": "Shift all rows in the Below-Screen Line Edit Buffer down, shifting in a new BASIC line if applicable",
    "5786": "All Screen Line Edit Buffer rows have been shifted down",
    "5801": ";The Below-Screen Line Edit Buffer is full",
    "5804": "Insert Character into Edit Buffer Row, Shifting Row Right: This routine shifts a byte into an edit buffer row, shifting all existing characters right until either the end of the row is reached or the specified end column is reached. Entry: DE=Start address of an edit buffer row. A=Character to shift into left of row. B=Column to start shifting at. Exit : A=Byte shifted out from last column. HL=Points byte after row (i.e. flag byte). Zero flag set if the character shifted out was a null ($00).",
    "5811": "Shift all bytes in the row to the right.",
    "5825": "Insert Character into Edit Buffer Row, Shifting Row Left: This routine shifts a byte into an edit buffer row, shifting all existing characters left until either the beginning of the row is reached or the specified end column is reached. Entry: DE=Start address of an edit buffer row. A=Character to shift into right of row. B=Column to stop shifting at. Exit : A=Byte shifted out. HL=Points byte before row. Zero flag set if the character shifted out was a null ($00).",
    "5852": "The Syntax Offset Table: Similar in construction to the table in ROM 1 at $1A48. [No instruction fetch at $1708 hence ZX Interface 1 will not be paged in by this ROM. Credit: Paul Farrow].",
    "6063": "The 'Main Parser' Of the BASIC Interpreter: The parsing routine of the BASIC interpreter is entered at $17AF (ROM 0) when syntax is being checked, and at $1838 (ROM 0) when a BASIC program of one or more statements is to be executed. This code is similar to that in ROM 1 at $1B17.",
    "6080": "The Statement Loop: Each statement is considered in turn until the end of the line is reached.",
    "6102": "A statement has been identified so, first, its initial command is considered",
    "6141": "Each of the command class routines applicable to the present command are executed in turn. Any required separators are also considered.",
    "6170": "The 'Separator' Subroutine: The report 'Nonsense in BASIC is given if the required separator is not present. But note that when syntax is being checked the actual report does not appear on the screen - only the 'error marker'. This code is similar to that in ROM 1 at $1B6F.",
    "6177": "The 'Statement Return' Subroutine: After the correct interpretation of a statement, a return is made to this entry point. This code is similar to that in ROM 1 at $1B76.",
    "6200": "The 'Line Run' Entry Point: This entry point is used wherever a line in the editing area is to be 'run'. In such a case the syntax/run flag (bit 7 of FLAGS) will be set. The entry point is also used in the syntax checking of a line in the editing area that has more than one statement (bit 7 of FLAGS will be reset). This code is similar to that in ROM 1 at $1B8A.",
    "6220": "The 'Line New' Subroutine: There has been a jump in the program and the starting address of the new line has to be found. This code is similar to that in ROM 1 at 1B9E.",
    "6242": "REM Routine: The return address to STMT-RET is dropped which has the effect of forcing the rest of the line to be ignored. This code is similar to that in ROM 1 at $1BB2.",
    "6243": "The 'Line End' Routine: If checking syntax a simple return is made but when 'running' the address held by NXTLIN has to be checked before it can be used. This code is similar to that in ROM 1 at $1BB3.",
    "6256": "The 'Line Use' Routine: This routine has three functions: 1) Change statement zero to statement '1'. 2)Find the number of the new line and enter it into PPC. 3) Form the address of the start of the line after. This code is similar to that in ROM 1 at $1BBF.",
    "6274": "The 'Next Line' Routine: On entry the HL register pair points to the location after the end of the 'next' line to be handled and the DE register pair to the location before the first character of the line. This applies to lines in the program area and also to a line in the editing area - where the next line will be the same line again whilst there are still statements to be interpreted. This code is similar to that in ROM 1 at $1BD1.",
    "6312": "The 'STMT-NEXT' Routine: If the present character is a 'carriage return' then the 'next statement' is on the 'next line', if ':' it is on the same line; but if any other character is found then there is an error in syntax. The routine is the equivalent of routine STMT_NEXT in ROM 1 at $1BF4.",
    "6305": "The 'CHECK-END' Subroutine: This is called when the syntax of the edit-line is being checked. The purpose of the routine is to give an error report if the end of a statement has not been reached and to move on to the next statement if the syntax is correct. The routine is the equivalent of routine CHECK_END in ROM 1 at $1BEE.",
    "6340": "The 'Command Classes - 0C, 0D & 0E': For commands of class-0D a numeric expression must follow.",
    "6343": "The commands of class-0C must not have any operands. e.g. SPECTRUM.",
    "6344": "The commands of class-0E may be followed by a set of items. e.g. PLAY.",
    "6349": "After the command class entries and the separator entries in the parameter table have been considered the jump to the appropriate command routine is made. The routine is similar to JUMP-C-R in ROM 1 at $1C16.",
    "6358": "The 'Command Classes - 00, 03 & 05': These routines are the equivalent of the routines in ROM 1 starting at $1C0D. The commands of class-03 may, or may not, be followed by a number. e.g. RUN & RUN 200.",
    "6361": "The commands of class-00 must not have any operands. e.g. COPY & CONTINUE.",
    "6362": "The commands of class-05 may be followed by a set of items. e.g. PRINT & PRINT \"222\".",
    "6393": "The 'Command Class - 01': Command class 01 is concerned with the identification of the variable in a LET, READ or INPUT statement.",
    "6397": "The 'Command Class - 02': Command class 02 is concerned with the actual calculation of the value to be assigned in a LET statement.",
    "6405": "The 'Command Class - 04': The command class 04 entry point is used by FOR & NEXT statements.",
    "6409": "The 'Command Class - 08': Command class 08 allows for two numeric expressions, separated by a comma, to be evaluated.",
    "6414": "The 'Command Class - 06': Command class 06 allows for a single numeric expression to be evaluated.",
    "6418": "Report C - Nonsense in BASIC",
    "6422": "The 'Command Class - 0A': Command class 0A allows for a single string expression to be evaluated.",
    "6426": "The 'Command Class - 07': Command class 07 is the command routine for the six colour item commands. Makes the current temporary colours permanent.",
    "6461": "The following instructions cleverly copy the even bits of the supplied byte to the odd bits. In effect making the permanent bits the same as the temporary ones.",
    "6468": "The 'Command Class - 09': This routine is used by PLOT, DRAW & CIRCLE statements in order to specify the default conditions of 'FLASH 8; BRIGHT 8; PAPER 8;' that are set up before any embedded colour items are considered.",
    "6472": "The 'Command Class - 0B': This routine is used by SAVE, LOAD, VERIFY & MERGE statements.",
    "6503": "IF Routine: On entry the value of the expression between the IF and the THEN is the 'last value' on the calculator stack. If this is logically true then the next statement is considered; otherwise the line is considered to have been finished.",
    "6510": "Now 'delete' the last value on the calculator stack",
    "6529": "FOR Routine: This command routine is entered with the VALUE and the LIMIT of the FOR statement already on the top of the calculator stack.",
    "6542": "There has not been a STEP supplied so the value '1' is to be used.",
    "6566": "The three values on the calculator stack are the VALUE (v), the LIMIT (l) and the STEP (s). These values now have to be manipulated. Delegate handling to ROM 1.",
    "6570": "READ Routine",
    "6603": "Pick up a value from the DATA list.",
    "6635": "DATA Routine: During syntax checking a DATA statement is checked to ensure that it contains a series of valid expressions, separated by commas. But in 'run-time' the statement is passed by.",
    "6641": "A loop is now entered to deal with each expression in the DATA statement.",
    "6652": "The DATA statement has to be passed-by in 'run-time'.",
    "6654": "On entry the A register will hold either the token 'DATA' or the token 'DEF FN': depending on the type of statement that is being 'passed-by'.",
    "6658": "RUN Routine: The parameter of the RUN command is passed to NEWPPC by calling the GO TO command routine. The operations of 'RESTORE 0' and 'CLEAR 0' are then performed before a return is made.",
    "6669": "CLEAR Routine: This routine allows for the variables area to be cleared, the display area cleared and RAMTOP moved. In consequence of the last operation the machine stack is rebuilt thereby having the effect of also clearing the GO SUB stack.",
    "6695": "The value in the BC register pair which will be used as RAMTOP is tested to ensure it is neither too low nor too high.",
    "6739": "GO SUB Routine: The present value of PPC and the incremented value of SUBPPC are stored on the GO SUB stack.",
    "6767": "RETURN Routine: The line number and the statement number that are to be made the object of a 'return' are fetched from the GO SUB stack.",
    "6796": "DEF FN Routine: During syntax checking a DEF FN statement is checked to ensure that it has the correct form. Space is also made available for the result of evaluating the function. But in 'run-time' a DEF FN statement is passed-by.",
    "6807": "First consider the variable of the function.",
    "6835": "A loop is now entered to deal with each parameter in turn.",
    "6867": "Next the definition of the function is considered.",
    "6896": "MOVE Routine",
    "6897": "Run Tape Loader: Used by Main Menu - Tape Loader option.",
    "6932": "List Program to Printer: Used by Edit Menu - Print option.",
    "6955": "SPECTRUM Routine: Return to 48K BASIC Mode. This routine will force caps lock is off.",
    "6975": "[*BUG* - Although the channel 'P' information has been reconfigured to use the ZX Printer, the ZX printer buffer and associated system variables still need to be cleared. Failure to do so means that the first use of the ZX Printer will cause garbage to the printed, i.e. the paging routines and new system variables still present in the ZX Printer buffer. Subsequently printer output will then be ok since the ZX Printer buffer and system variables will be cleared. Worse still, there is the possibility that new data to be printed will be inserted beyond the ZX Printer buffer since ROM 1 does not trap whether the ZX Printer system variable PR_POSN and PR_CC hold invalid values. The bug can be fixed by inserting the following instructions, which cause the ZX Printer buffer to be cleared immediately after switching to ROM 1 and before the error report \"0 OK\" is produced. Credit: Paul Farrow and Andrew Owen.]",
    "6983": "Main Menu - 48 BASIC Option",
    "6995": "Set 'P' Channel Data: This routine overwrites the 'P' channel data with the 'S' channel data, i.e. the default values when using the ZX Printer.",
    "7022": "LOAD \"\" Command Bytes: Used by the Tape Loader routine.",
    "7025": "LLIST Routine",
    "7029": "LIST Routine",
    "7075": "Come here if the stream was unaltered.",
    "7085": "RAM Disk SAVE! Routine",
    "7141": "CAT! Routine",
    "7180": "ERASE! Routine",
    "7214": "Load Header from RAM Disk",
    "7224": "The file exists else the call above would have produced an error \"h file does not exist\"",
    "7243": "Load from RAM Disk: Used by LOAD, VERIFY and MERGE. Note that VERIFY will simply perform a LOAD. Entry: HL=Destination address. DE=Length (will be greater than zero). IX=File descriptor. IX=Address of catalogue entry (IX+$10-IX+$12 points to the address of the file's data, past its header). HD_00-HD_11 holds file header information.",
    "7268": "Page Logical RAM Bank: This routine converts between logical and physical RAM banks and pages the selected bank in. Entry: A=Logical RAM bank.",
    "7297": "Physical RAM Bank Mapping Table",
    "7303": "Compare Filenames: Compare filenames at N_STR1 and IX. Exit: Zero flag set if filenames match. Carry flag set if filename at DE is alphabetically lower than filename at IX.",
    "7306": "Compare filenames at DE and IX",
    "7319": "Create New Catalogue Entry: Add a catalogue entry with filename contained in N_STR1. Exit: HL=Address of next free catalogue entry. IX=Address of newly created catalogue entry.",
    "7411": "Adjust RAM Disk Free Space: Adjust the count of free bytes within the RAM disk. The routine can produce \"4 Out of memory\" when adding. Entry: AHL=Size adjustment (negative when a file added, positive when a file deleted). A=Bit 7 set for adding data, else deleting data.",
    "7425": "Deleting data",
    "7434": "Adding data",
    "7442": "Find Catalogue Entry for Filename: Entry: Filename stored at N_STR1 ($5B67). Exit : Zero flag set if file does not exist. If file exists, IX points to catalogue entry. Always leaves logical RAM bank 4 paged in.",
    "7477": "Find RAM Disk File: Find a file in the RAM disk matching name held in N_STR1, and return with IX pointing to the catalogue entry.",
    "7510": "Update Catalogue Entry: Entry: IX=Address of catalogue entry (IX+$10-IX+$12 points to end of the file). Exits with logical RAM bank 4 paged in.",
    "7572": "Copy the end address of the previous entry into the new entry",
    "7596": "Save Bytes to RAM Disk: Entry: IX=Address of catalogue entry. HL=Source address in conventional RAM. BC=Length. Advances IX+$10-IX+$12 as bytes are saved so that always points to next location to fill, eventually pointing to the end of the file.",
    "7610": "Source is below $C000",
    "7615": "Source spans across $C000",
    "7628": "Source fits completely below upper RAM bank (less than $C000)",
    "7637": "Source fits completely within upper RAM bank (greater than or equal $C000)",
    "7647": "Source spans transfer buffer",
    "7652": "Source fits completely within transfer buffer",
    "7657": "Transfer a block",
    "7716": "The end of a RAM bank has been reached so switch to the next bank",
    "7735": "Load Bytes from RAM Disk: Used for loading file header and data. Entry: IX=RAM disk catalogue entry address. IX+$10-IX+$12 points to the next address to fetch from the file. HL=Destination address. BC=Requested length.",
    "7749": "Destination is below $C000",
    "7754": "Code will span across $C000",
    "7772": "Code fits completely below upper RAM bank (less than $C000)",
    "7783": "Code destined for upper RAM bank (greater than or equal to $C000)",
    "7793": "Code will span transfer buffer",
    "7798": "Code will all fit within transfer buffer",
    "7808": "Transfer a block",
    "7825": "Enter a loop to transfer BC bytes, either to required destination or to the transfer buffer",
    "7868": "The end of a RAM bank has been reached so switch to the next bank",
    "7887": "Transfer Bytes to RAM Bank 4 - Vector Table Entry: This routine can be used to transfer bytes from the current RAM bank into logical RAM bank 4. It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0. Entry: HL=Source address in conventional RAM. DE=Destination address in logical RAM bank 4 (physical RAM bank 7). BC=Number of bytes to save.",
    "7912": "Entered here by load vector routine",
    "7940": "Transfer Bytes from RAM Bank 4 - Vector Table Entry: This routine can be used to transfer bytes from logical RAM bank 4 into the current RAM bank. It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0. Entry: HL=Source address in logical RAM bank 4 (physical RAM bank 7). DE=Destination address in current RAM bank. BC=Number of bytes to load.",
    "7968": "Use Normal RAM Configuration: Page in physical RAM bank 0, use normal stack and stack TARGET address. Entry: HL=TARGET address.",
    "7994": "Select RAM Bank: Used twice by the ROM to select either physical RAM bank 0 or physical RAM bank 7. However, it could in theory also be used to set other paging settings. Entry: A=RAM bank number.",
    "8005": "Use Workspace RAM Configuration: Page in physical RAM bank 7, use workspace stack and stack TARGET address. Entry: HL=TARGET address.",
    "8031": "Erase a RAM Disk File: N_STR1 contains the name of the file to erase.",
    "8170": "At this point we have the registers and alternate registers pointing to the actual bytes in the RAM disk for the file to be deleted and the next file, with length bytes of the catalogue entry for the file to be deleted containing the length of bytes for all subsequent files that need to be moved down in memory. A loop is entered to move all of these bytes where the delete file began. DHL holds the address of the byte to be moved. E contains the value which should be OUTed to $5B5C to page in the relevant RAM page.",
    "8254": "The file has been moved",
    "8402": "Print RAM Disk Catalogue: This routine prints catalogue filenames in alphabetically order. It does this by repeatedly looping through the catalogue to find the next 'highest' name.",
    "8481": "Print Catalogue Filename Data",
    "8501": "Print Single Catalogue Entry: Entry: HL=Address of filename. BC=Address of filename.",
    "8564": "LPRINT Routine",
    "8568": "PRINT Routine",
    "8588": "INPUT Routine: This routine allows for values entered from the keyboard to be assigned to variables. It is also possible to have print items embedded in the INPUT statement and these items are printed in the lower part of the display.",
    "8615": "COPY Routine",
    "8618": "NEW Routine",
    "8622": "CIRCLE Routine: This routine draws an approximation to the circle with centre co-ordinates X and Y and radius Z. These numbers are rounded to the nearest integer before use. Thus Z must be less than 87.5, even when (X,Y) is in the centre of the screen. The method used is to draw a series of arcs approximated by straight lines.",
    "8638": "DRAW Routine: This routine is entered with the co-ordinates of a point X0, Y0, say, in COORDS. If only two parameters X, Y are given with the DRAW command, it draws an approximation to a straight line from the point X0, Y0 to X0+X, Y0+Y. If a third parameter G is given, it draws an approximation to a circular arc from X0, Y0 to X0+X, Y0+Y turning anti-clockwise through an angle G radians.",
    "8661": "DIM Routine: This routine establishes new arrays in the variables area. The routine starts by searching the existing variables area to determine whether there is an existing array with the same name. If such an array is found then it is 'reclaimed' before the new array is established. A new array will have all its elements set to zero if it is a numeric array, or to 'spaces' if it is an array of strings.",
    "8679": "An 'existing array' is reclaimed.",
    "8683": "Error Report C - Nonsense in BASIC",
    "8687": "Clear Screen Routine: Clear screen if it is not already clear.",
    "8696": "Evaluate Numeric Expression: This routine is called when a numerical expression is typed directly into the editor or calculator. A numeric expression is any that begins with '(', '-' or '+', or is one of the function keywords, e.g. ABS, SIN, etc, or is the name of a numeric variable.",
    "8702": "Check the syntax of the BASIC line",
    "8723": "The BASIC line has passed syntax checking so now execute it",
    "8815": "Process Key Press: Entry: A=Key code.",
    "8846": "Find Start of BASIC Command: Point to the start of a typed in BASIC command and return first character in A.",
    "8855": "Is LET Command?: A typed in command resides in the editing workspace. This function tests whether the text is a single LET command. Exit: Zero flag set if a single LET command.",
    "8875": "Is Operator Character?: Exit: Zero flag set if character is an operator.",
    "8887": "Found",
    "8889": "Not found",
    "8893": "Operator Tokens Table",
    "8907": "Is Function Character?: Exit: Zero set if a function token.",
    "8928": "Is Numeric or Function Expression?: Exit: Zero flag set if a numeric or function expression.",
    "8970": "Is Numeric Character?: Exit: Zero flag set if numeric character.",
    "8983": "PLAY Routine",
    "9014": "UNUSED ROUTINES - PART 1: There now follows 513 bytes of routines that are not used by the ROM, from $2336 (ROM 0) to $2536 (ROM 0). They are remnants of the original Spanish 128's ROM code, although surprisingly they appear in a different order within that ROM.",
    "9527": "Editing Keys Action Table: Each editing key code maps to the appropriate handling routine. This includes those keys which mirror the functionality of the add-on keypad; these are found by trapping the keyword produced by the keystrokes in 48K mode. [Surprisingly there is no attempt to produce an intelligible layout; instead the first 16 keywords have been used. Additionally the entries for DELETE and ENTER should probably come in the first six entries for efficiency reasons.]",
    "9591": "Menu Keys Action Table: Each menu key code maps to the appropriate handling routine.",
    "9604": "Initialise Mode Settings: Called before Main menu displayed.",
    "9631": "Show Main Menu",
    "10052": "Main Menu: Jump table for the main 128K menu, referenced at $25AD (ROM 0).",
    "10068": "Text for the main 128K menu",
    "10128": "Edit Menu: Jump table for the Edit menu",
    "10144": "Text for the Edit menu",
    "9675": "Return to Editor / Calculator / Menu from Error",
    "9724": "Edit menu Print mode",
    "9729": "Calculator mode",
    "9732": "Return to the Editor: Either as the result of a re-listing, an error or from completing the Edit Menu Print option.",
    "9745": "Calculator mode",
    "9764": "No program exists",
    "9811": "Main Waiting Loop: Enter a loop to wait for a key press. Handles key presses for menus, the Calculator and the Editor.",
    "9833": "Process Key Press: Handle key presses for the menus and the Editor. Entry: A=Key code. Zero flag set if a menu is being displayed.",
    "9857": "No action defined for key code",
    "9860": "A menu is being displayed, so just ignore key press",
    "9865": "A menu is not being displayed",
    "9872": "The buffer is full so ignore the key press",
    "9883": "TOGGLE Key Handler Routine: Toggle between editing in the lower and upper screen areas. Also used by the editing menu SCREEN option.",
    "9915": "Select Lower Screen: Set the lower screen as the editing area.",
    "9934": "Select Upper Screen: Set the upper screen as the editing area.",
    "9959": "Produce Error Beep: This is the entry point to produce the error beep, e.g. when trying to cursor up or down past the BASIC program.",
    "9964": "This entry point is called to produce the key click tone. In 48K mode, the key click sound uses an HL value of $00C8 and so is 16 times shorter than in 128K mode.",
    "9988": "Menu Key Press Handler - MENU: This is executed when the EDIT key is pressed, either from within a menu or from the BASIC editor.",
    "10007": "Menu Key Press Handler - SELECT",
    "10030": "Menu Key Press Handler - CURSOR UP",
    "10050": "Comes here to complete handling of Menu cursor up and down. Also as the handler routines for Edit Menu return to 128 BASIC option and Calculator menu return to Calculator option, which simply make a return.",
    "10033": "Menu Key Press Handler - CURSOR DOWN",
    "10187": "Calculator Menu: Jump table for the Calculator menu",
    "10194": "Text for the Calculator menu",
    "10219": "Tape Loader Text",
    "10257": "Edit Menu - Screen Option",
    "10262": "Main Menu - Tape Tester Option",
    "10268": "Edit Menu / Calculator Menu - Exit Option",
    "10289": "Main Menu - Tape Loader Option",
    "10321": "Edit Menu - Renumber Option",
    "10338": "Edit Menu - Print Option",
    "10341": "Edit Menu - Renumber option joins here",
    "10356": "Edit Menu - Screen option joins here",
    "10373": "Main Menu - Calculator Option",
    "10417": "Edit Menu - Print option joins here",
    "10430": "Reset Cursor Position",
    "10439": "Return to Main Menu",
    "10449": "Main Screen Error Cursor Settings: Main screen editing cursor settings. Gets copied to $F6EE.",
    "10456": "Lower Screen Good Cursor Settings: Lower screen editing cursor settings. Gets copied to $F6EE.",
    "10463": "Initialise Lower Screen Editing Settings: Used when selecting lower screen. Copies 6 bytes from $28D9 (ROM 0) to $F6EE.",
    "10472": "Initialise Main Screen Editing Settings: Used when selecting main screen. Copies 6 bytes from $28D2 (ROM 0) to $F6EE.",
    "10481": "Handle Key Press Character Code: This routine handles a character typed at the keyboard, inserting it into the Screen Line Edit Buffer as appropriate. Entry: A=Key press character code.",
    "10523": "DELETE-RIGHT Key Handler Routine: Delete a character to the right. An error beep is not produced if there is nothing to delete. Exit: Carry flag set to indicate not to produce an error beep.",
    "10539": "DELETE Key Handler Routine: Delete a character to the left. An error beep is not produced if there is nothing to delete. Exit: Carry flag set to indicate not to produce an error beep.",
    "10564": "ENTER Key Handler Routine: This routine handles ENTER being pressed. If not on a BASIC line then it does nothing. If on an unaltered BASIC line then insert a blank row after it and move the cursor to it. If on an altered BASIC line then attempt to enter it into the BASIC program, otherwise return to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10580": "No editable characters on the row, i.e. a blank row",
    "10590": "On a BASIC line",
    "10597": "The current BASIC line has been altered",
    "10611": "Display the cursor on the first column of the next row",
    "10618": "Cursor is on a blank row, which is not part of a BASIC line",
    "10623": "A syntax error occurred so return signalling to produce an error beep",
    "10627": "TOP-OF-PROGRAM Key Handler Routine: Move to the first row of the first line of the BASIC program. An error beep is not produced if there is no program. Exit: Carry flag set to indicate not to produce an error beep.",
    "10667": "END-OF-PROGRAM Key Handler Routine: Move to the last row of the bottom line of the BASIC program. An error beep is not produced if there is no program. Exit: Carry flag set to indicate not to produce an error beep.",
    "10673": "Editor mode",
    "10708": "WORD-LEFT Key Handler Routine: This routine moves to the start of the current word that the cursor is on, or if it is on the first character of a word then it moves to the start of the previous word. If there is no word to move to then signal to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10721": "WORD-RIGHT Key Handler Routine: This routine moves to the start of the next word. If there is no word to move to then signal to produce an error beep. Exit: Carry flag reset to indicate to produce an error beep.",
    "10732": "Remove Cursor: Remove editing cursor colour from current position. Exit: C=row number. B=Column number.",
    "10738": "Show Cursor: Set editing cursor colour at current position. Exit: C=row number. B=Column number.",
    "10744": "Display Cursor: Set editing cursor position and colour and then show it. Entry: C=Row number. B=Column number. A=Preferred column number.",
    "10759": "Fetch Cursor Position: Returns the three bytes of the cursor position. C=Row number. B=Column number A=Preferred column number.",
    "10769": "Store Cursor Position: Store new editing cursor position. C=Row number. B=Column number. A=Preferred column number.",
    "10778": "Get Current Character from Screen Line Edit Buffer: Entry: C=Row number. B=Column number. Exit : A=Character.",
    "10789": "TEN-ROWS-DOWN Key Handler Routine: Move down 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is not 10 rows below. Exit: Carry flag reset to indicate to produce an error beep.",
    "10818": "A blank row was found below, must be at the end of the BASIC program",
    "10831": "TEN-ROWS-UP Key Handler Routine: Move up 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is not 10 rows above. Exit: Carry flag reset to indicate to produce an error beep.",
    "10861": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10874": "END-OF-LINE Key Handler Routine: Move to the end of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line. Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.",
    "10887": "START-OF-LINE Key Handler Routine: Move to the start of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line. Exit: Carry flag reset to indicate to produce an error beep.",
    "10900": "CURSOR-UP Key Handler Routine: Move up 1 row, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is no row above. Exit: Carry flag reset to indicate to produce an error beep.",
    "10920": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10933": "CURSOR-DOWN Key Handler Routine: Move down 1 row, attempting to place the cursor as close to the preferred column number as possible. An error beep is produced if there is no row below. Exit: Carry flag reset to indicate to produce an error beep.",
    "10953": "A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]",
    "10967": "CURSOR-LEFT Key Handler Routine: Move left 1 character, stopping if the start of the first row of the first BASIC line is reached. An error beep is produced if there is no character to the left or no previous BASIC line to move to. Exit: Carry flag reset to indicate to produce an error beep.",
    "10976": "A blank row was found above, must be at the start of the BASIC program",
    "10979": "CURSOR-RIGHT Key Handler Routine: Move right 1 character, stopping if the end of the last row of the last BASIC line is reached. An error beep is produced if there is no character to the right or no next BASIC line to move to. Exit: Carry flag reset to indicate to produce an error beep.",
    "10988": "A blank row was found below, must be at the end of the BASIC program",
    "11001": "Find Closest Screen Line Edit Buffer Editable Position to the Right else Left: This routine searches the specified Screen Line Edit Buffer row from the specified column to the right looking for the first editable position. If one cannot be found then a search is made to the left. Entry: B=Column number. Exit : Carry flag set if character at specified column is editable. B=Number of closest editable column. HL=Address of closest editable position.",
    "11010": "Find Closest Screen Line Edit Buffer Editable Position to the Left else Right: This routine searches the specified Screen Line Edit Buffer row from the specified column to the left looking for the first editable position. If one cannot be found then a search is made to the right. Entry: B=Column number. Exit : Carry flag set if character at specified column is editable. B=Number of closest editable column. HL=Address of closest editable position.",
    "11019": "Insert BASIC Line, Shift Edit Buffer Rows Down If Required and Update Display File If Required: Called from the cursor up and down related key handlers. For example, when cursor up key is pressed the current BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary to shift all rows down should the upper scroll threshold be reached. If the cursor was on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row. Entry: C=Current cursor row number in the Screen Line Edit Buffer. Exit : C=New cursor row number in the Screen Line Edit Buffer. Carry flag set if a new row was moved to.",
    "11044": "The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll down one row",
    "11050": "The edit buffer rows were not shifted down",
    "11056": "Insert BASIC Line, Shift Edit Buffer Rows Up If Required and Update Display File If Required: Called from the cursor up and down related key handlers. For example, when cursor down key is pressed the current BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary to shift all rows up should the lower scroll threshold be reached. If the cursor was on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row. Entry: C=Current cursor row number in the Screen Line Edit Buffer. Exit : C=New cursor row number in the Screen Line Edit Buffer. Carry flag set if a new row was moved to.",
    "11076": "The BASIC line was not inserted into the program. C=New cursor row number, B=New cursor column number, A=New cursor preferred column number",
    "11084": "The lower row threshold for triggering scrolling the screen has been reached so proceed to scroll up one row",
    "11092": "The edit buffer rows were not shifted up",
    "11099": "Find Next Screen Line Edit Buffer Editable Position to Left, Wrapping Above if Required: This routine searches to the left to see if an editable position exists. If there is no editable position available to the left on the current row then the previous row is examined from the last column position. Entry: B=Column number. Carry flag reset. Exit : Carry flag set if a position to the 'left' exists. B=Number of new editable position. HL=Address of new editable position.",
    "11110": "Wrap above to the previous row",
    "11117": "A row above exists",
    "11124": "Return column 0",
    "11128": "Find Next Screen Line Edit Buffer Editable Position to Right, Wrapping Below if Required: This routine searches to the right to see if an editable position exists. If there is no editable position available to the right on the current row then the next row is examined from the first column position. The routine is also called when a character key has been pressed and in this case if the cursor moves to the next row then a blank row is inserted and all affected rows are shifted down. Entry: B=Column number. C=Row number. Exit : Carry flag set if a position to the 'right' exists. B=Number of closest editable column, i.e. new column number. A=New column position, i.e. preferred column number or indentation column number. HL=Address of the new editable position.",
    "11135": "New position is within the row",
    "11141": "Need to wrap below to the next row",
    "11151": "A key is being pressed so need to insert a new row",
    "11163": "The BASIC line row does not span onto another row, i.e. cursor at end of line",
    "11200": "Wrap below to the next row. Either a key was not being pressed, or a key was being pressed and the BASIC line spans onto a row below (which could contain the cursor only)",
    "11209": "A row below exists",
    "11216": "Return column 0",
    "11220": "Find Screen Line Edit Buffer Editable Position from Previous Column to the Right: This routine finds the first editable character position in the specified Screen Line Edit Buffer row from the previous column to the right. It first checks the current column, then the previous column and then the columns to the right. The column containing the first non-null character encountered is returned. Entry: B=Column number to start searching from. C=Row number. Exit : Carry flag set if an editable character was found. B=Number of closest editable column.",
    "11231": "Find Screen Line Edit Buffer Editable Position to the Left: This routine finds the first editable character position in the Screen Line Edit Buffer row from the current column to the left. It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to the left and if an editable character is found then it returns the column to the right of it. Entry: B=Column number to start searching from. C=Row number. Exit : Carry flag set if an editable character was found. B=Number of the column after the editable position.",
    "11242": "Find Start of Word to Left in Screen Line Edit Buffer: This routine searches for the start of the current word to the left within the current Screen Line Edit Buffer. It is called from the WORD-LEFT key handler routine. Entry: C=Row number. Exit : Carry flag set if word to the left is found. B=Column position of the found word.",
    "11244": "Search towards the left of this row until a space or start of line is found",
    "11256": "Search towards the left of this row until the start of the word or start of the line is found",
    "11268": "A space prior to the word was found",
    "11273": "Find Start of Word to Right in Screen Line Edit Buffer: This routine searches for the start of the current word to the right within the current Screen Line Edit Buffer. It is called from the WORD-RIGHT key handler routine. Entry: C=Row number. Exit : Carry flag set if word to the right is found. B=Column position of the found word.",
    "11275": "Search towards the right of this row until a space or end of line is found",
    "11287": "Search towards the right of this row until the start of a new word or end of the line is found",
    "11304": "Start of new word found",
    "11313": "Find Start of Current BASIC Line in Screen Line Edit Buffer: This routine searches for the start of the BASIC line, wrapping to the previous rows as necessary. It is called from the START-OF-LINE key handler routine. Entry: C=Row number. Exit : Carry flag set if row is not blank. B=New cursor column.",
    "11326": "Not on the first row of the BASIC line",
    "11333": "On the first row of the BASIC line, so find the starting column",
    "11340": "Find End of Current BASIC Line in Screen Line Edit Buffer: This routine searches for the end of the BASIC line, wrapping to the next rows as necessary. It is called from the END-OF-LINE key handler routine. Entry: C=Row number. Exit : Carry flag set if row is not blank. B=New cursor column.",
    "11353": "Not on the last row of the BASIC line",
    "11360": "On the last row of the BASIC line, so find the last column",
    "11368": "Insert BASIC Line into Program if Altered: Entry: C=Row number. Exit : Carry flag set if BASIC line was not inserted into the program.",
    "11388": "Insert Line into BASIC Program If Altered and the First Row of the Line: Entry: C=Row number. B=Column number. Exit : Carry flag set if successful, reset if a syntax error.",
    "11406": "Insert Line into BASIC Program: This routine parses a line and if valid will insert it into the BASIC program. If in calculator mode then the line is not inserted into the BASIC program. If a syntax error is found then the location to show the error marker is determined. Entry: C=Row number. Exit : Carry flag reset if a syntax error. Carry flag set if the BASIC line was inserted successfully, and C=Cursor row number, B=Cursor column number, A=Preferred cursor column number.",
    "11408": "Find the start address of the row in the Screen Line Edit Buffer",
    "11423": "First row of the BASIC line is above the screen",
    "11427": "DE=Start address of the first row of the BASIC line; HL=Address of the flag byte for the first row of the BASIC line",
    "11503": "A syntax error occurred",
    "11526": "Assume the error maker is at the same position as the cursor",
    "11530": "The position of the error marker within the typed BASIC line has been determined. Now shift the cursor to the corresponding position on the screen.",
    "11547": "The error marker is before the cursor position. Move the cursor back until it is at the same position as the error marker.",
    "11562": "The error marker is after the cursor position. Move the cursor back until it is at the same position as the error marker.",
    "11589": "The cursor position is at the location of the error marker position",
    "11604": "Fetch Next Character from BASIC Line to Insert: This routine fetches a character from the BASIC line being inserted. The line may span above or below the screen, and so the character is retrieved from the appropriate buffer. Exit : A=Character fetched from the current position, or 'Enter' if end of line found.",
    "11629": "Register A: Bit 0: 1=First row of the BASIC line off top of screen. Bit 1: 1=On first row of the BASIC line. Bit 2: 1=Using lower screen and only first row of the BASIC line visible. Bit 3: 1=At end of last row of the BASIC line (always 0 at this point).",
    "11653": "Fetch Next Character Jump Table",
    "11635": "Register L: $01 - A character was returned from the Above-Screen Line Edit Buffer row. $02 - A character was returned from the Screen Line Edit Buffer row. $04 - A character was returned from the Below-Screen Line Edit Buffer row. $08 - At the end of the last row of the BASIC line. Register A holds the character fetched or 'Enter' if at the end of the BASIC line.",
    "11663": "Fetch Character from the Current Row of the BASIC Line in the Screen Line Edit Buffer: Fetch character from the current row of the BASIC line in the Screen Line Edit Buffer, skipping nulls until the end of the BASIC line is found. Entry: C=Row number. Exit : L=$01 - A character was returned from the Above-Screen Line Edit Buffer row, with A holding the character. $02 - A character was returned from the Screen Line Edit Buffer row, with A holding the character. $04 - A character was returned from the Below-Screen Line Edit Buffer row, with A holding the character. $08 - At the end of the last row of the BASIC line, with A holding an 'Enter' character. Zero flag set to indicate a match from the handler table was found.",
    "11678": "End of row reached - no more editable characters in Above-Screen Line Edit Buffer row",
    "11688": "All characters from rows off top of screen fetched so continue onto the rows on screen",
    "11692": "Table entry point - On visible row of BASIC line: C=Row number of the first visible row of the BASIC line in the Screen Line Edit Buffer. B=Starting column number of the first visible row of the BASIC line in the Screen Line Edit Buffer",
    "11700": "Cursor on first visible row of the BASIC line in the Screen Line Edit Buffer.",
    "11723": "A character in the current row of the BASIC line was found",
    "11726": "End of row reached - no editable characters in the Screen Line Edit Buffer row",
    "11734": "On last row of the BASIC line and finished fetching characters from the line",
    "11739": "Not on the last row of the BASIC line so move to the beginning of the next, if it is on screen.",
    "11749": "The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll up one line",
    "11753": "Table entry point - Using lower screen and only top row of a multi-row BASIC line is visible",
    "11768": "End of row reached - no editable characters in the (below screen) Below-Screen Line Edit Buffer row",
    "11785": "All characters from rows off bottom of screen fetched so return an 'Enter'",
    "11790": "Fetch Character from Edit Buffer Row: Entry: B =Column number. DE=Start address of row in Edit Buffer. Exit : Carry flag set indicates character fetched, reset if column out of range.",
    "11803": "Upper Screen Rows Table: Copied to $EC15-$EC16.",
    "11805": "Lower Screen Rows Table: Copied to $EC15-$EC16",
    "11807": "Reset to Main Screen",
    "11821": "Reset to Lower Screen",
    "11841": "Find Edit Buffer Editable Position from Previous Column to the Right: This routine finds the first editable character position in the specified edit buffer row from the previous column to the right. It first checks the current column, then the previous column and then the columns to the right. The column containing the first non-null character encountered is returned. Entry: B =Column number to start searching from. DE=Start of row in edit buffer. Exit : Carry flag set if an editable character was found. HL=Address of closest editable position. B=Number of closest editable column.",
    "11875": "Find Edit Buffer Editable Position to the Left: This routine finds the first editable character position in the specified edit buffer row from the current column to the left. It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to the left and if an editable character is found then it returns the column to the right of it. Entry: B =Column number to start searching from. DE=Start of row in edit buffer. Exit : Carry flag set if an editable character was found. HL=Address of closest editable position. B=Number of the column after the editable position.",
    "11899": "Fetch Edit Buffer Row Character: Entry: DE=Add of edit buffer row. B=Column number. Exit : A=Character at specified column. [Not used by the ROM]",
    "11905": "Insert Character into Screen Line Edit Buffer: Called when a non-action key is pressed. It inserts a character into the Screen Line Edit Buffer if there is room. Entry: A=Character code. B=Cursor column position. C=Cursor row position.",
    "11918": "Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the following row and shift all existing characters right by one. Repeat this process until all rows have been shifted.",
    "11931": "There was a spill out from the current row, and so this character will need to be inserted as the first character of the following row. If this is the last row of the BASIC line then a new row will need to be inserted.",
    "11941": "The editing screen is not full",
    "11957": "The character was inserted into the last row of the BASIC line causing a spill of an existing character into a new row, and therefore a new 'last' row needs to be inserted.",
    "11970": "The character was not inserted into the last row of the BASIC line, so find the first editable position on the following row, i.e. skip over any indentation.",
    "11976": "The Screen Edit Line Buffer is full and the character insertion requires shifting of all rows that are off screen in the Below-Screen Line Edit Buffer.",
    "11980": "All paths join here",
    "11982": "Insert Blank Row into Screen Edit Buffer, Shifting Rows Down: This routine inserts a blank row at the specified row, shifting affected rows down. Entry: C=Row number to insert the row at. Exit : Carry flag set to indicate edit buffer rows were shifted.",
    "11987": "DE=Address of row within Screen Line Edit Buffer. C=Row number to insert the row at. A=Screen Line Edit Buffer row flags value.",
    "12002": "Rows were shifted down",
    "12050": "Delete a Character from a BASIC Line in the Screen Line Edit Buffer: Delete a character at the specified position, shifting subsequent characters left as applicable. Entry: B=Column number. C=Row number.",
    "12055": "Enter a loop to find the last row of the BASIC line or the end of the visible screen, whichever comes first",
    "12065": "The row spans onto another",
    "12077": "The end of the screen has been reached without the end of the BASIC line having been reached",
    "12081": "A loop is entered to shift all characters to the left, beginning with the last row of the BASIC line in the Screen Line Edit Buffer and until the row that matches the current cursor position is reached.",
    "12094": "Deleting from the row matching the cursor position within the BASIC line, therefore only shift those bytes after the cursor position",
    "12097": "Deleting on row after that matching the cursor position, therefore shift all editable characters within the row",
    "12106": "DE=Start address of Screen Line Edit Buffer row. A=Character to shift into right of row. B=The column to start shifting at. C=Row number to start shifting from. Zero flag is set if deleting from the row matching the cursor position.",
    "12129": "Deleting from a row after the cursor position",
    "12136": "Shifting the characters on this row has resulted in a blank row, so shift all rows below screen up to remove this blank row",
    "12143": "There are characters remaining on the row following the shift so display this to the screen and then continue to shift the remaining rows ",
    "12160": "Shift Rows Up to Close Blank Row in Screen Line Edit Buffer: The cursor is on a blank row but has been moved off of it. Therefore shift all BASIC lines below it up so as to remove the blank row. Entry: DE=Address of the row in the Screen Line Edit Buffer containing the cursor. C=Row number in the Screen Line Edit Buffer containing the cursor. Carry flag set if rows were shifted up, i.e. a row below existed.",
    "12169": "Cursor not on a blank row but is on its own row at the end of a multi-row BASIC line",
    "12175": "Cursor on row 0, hence a BASIC line must be off the top of the screen [???? Can this ever be the case?]",
    "12196": "There is a row above so set this as the last row of the BASIC line",
    "12210": "Shift up all rows below the old cursor position within the Screen Line Edit Buffer and including the Below-Screen Line Edit Buffer, and update the display file if required",
    "12220": "DELETE-WORD-LEFT Key Handler Routine: This routine deletes to the start of the current word that the cursor is on, or if it is on the first character of a word then it deletes to the start of the previous word. Since the function works by deleting one character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker. If there is no word to delete then an error beep is requested. Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.",
    "12235": "A previous character exists and is editable",
    "12249": "The end of the word to delete has been found, so enter a loop to search for the start of the word",
    "12268": "Character is not a space",
    "12275": "A space prior to a word has been found",
    "12280": "Print all rows to the screen",
    "12311": "DELETE-WORD-RIGHT Key Handler Routine: This routine deletes to the start of the next word. Since the function works by deleting one character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker. If there is no word to delete then an error beep is requested.",
    "12350": "DELETE-TO-START-OF-LINE Key Handler Routine: Delete to the start of the current BASIC line. Since the function works by deleting one character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker. An error beep is not produced if there is no characters in the current BASIC line. Exit: Carry flag set to indicate not to produce an error beep.",
    "12365": "Not in the first row of a BASIC line",
    "12377": "In the first row of the BASIC line",
    "12399": "DELETE-TO-END-OF-LINE Key Handler Routine: Delete to the end of the current BASIC line. Since the function works by deleting one character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker. An error beep is not produced if there is no characters in the current BASIC line. Exit: Carry flag set to indicate not to produce an error beep.",
    "12420": "Remove Cursor Attribute and Disable Updating Display File: This routine is called by the DELETE key handler routines. Aside from removing the cursor from the display, it prevents display file updates occurring whilst the delete functions are executing. Exit: HL=Address of the editing area information. A=Cursor column number preferred. B=Cursor column number. C=Cursor row number.",
    "12437": "Previous Character Exists in Screen Line Edit Buffer? This routine tests the whether a previous character exists in the current BASIC line within the Screen Line Edit Buffer. Entry: C=Row number. B=Column number.Exit : Zero flag set if at start of the BASIC line (first column or leading null).",
    "12448": "On first row of a BASIC line",
    "12468": "Find Row Address in Screen Line Edit Buffer: Find address in Screen Line Edit Buffer of specified row. This routine calculates DE = $EC16 + $0023*C. Entry: C=Row number. Exit : DE=Address of edit row.",
    "12486": "Find Position within Screen Line Edit Buffer: Find the address of a specified row and column in the Screen Line Edit Buffer. The routine calculates DE = $EC16 + $0023*C + B. Entry: B=Column number. C=Row number. Exit : HL=Address of specified position. [Not used by the ROM]",
    "12496": "Below-Screen Line Edit Buffer Settings: This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F6F5. It should only contain a table of 3 bytes to tie up with the space allocated within the Editor workspace variables at $F6F5. As a result, the last 2 bytes will get copied into the Below-Screen Line Edit Buffer itself. It appears that the word at $F6F6 is supposed to be a pointer to the next available or accessed location within the buffer but this facility is never used. Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $30D6 (ROM 0) to simply set the byte at $F6F5 directly.",
    "12502": "Set Below-Screen Line Edit Buffer Settings: Sets the default values for the Below-Screen Line Edit Buffer settings. Copy 5 bytes from $30D1-$30D5 (ROM 0) to $F6F5-$F6F9.",
    "12511": "Shift Up Rows in Below-Screen Line Edit Buffer: Shifts up all rows in the Below-Screen Line Edit Buffer, or if empty then copies a BASIC line from the program area into the Below-Screen Line Edit Buffer. Exit: HL=Address of the Below-Screen Line Edit Buffer.",
    "12521": "There are no rows in the Below-Screen Line Edit Buffer",
    "12545": "There are rows in the Below-Screen Line Edit Buffer so shift all rows up",
    "12574": "Shift Down Rows in Below-Screen Line Edit Buffer: Shifts down all rows in the Below-Screen Line Edit Buffer, or the last Screen Line Edit Buffer row contains a complete BASIC line then it empties the Below-Screen Line Edit Buffer. Entry: DE=Start address in Screen Line Edit Buffer of the last editing row. Exit : Carry flag reset to indicate Below-Screen Line Edit Buffer full. A =Number of rows held in the Below-Screen Line Edit Buffer. HL=Address of first row in the Below-Screen Line Edit Buffer.",
    "12586": "First row of the BASIC line or an associated line number stored",
    "12615": "The first row of the BASIC line, hence after the shift there will not be a row straggling off the bottom of the screen",
    "12620": "Not the first row the BASIC line",
    "12625": "The Below-Screen Line Edit Buffer is not full so copy the last Screen Line Edit Buffer row into the top 'visible' Below-Screen Line Edit Buffer row",
    "12634": "Copy all Below-Screen Line Edit Buffer rows down",
    "12654": "Insert Character into Below-Screen Line Edit Buffer: Called when a non-action key is pressed and rows of the BASIC line spans into the Below-Screen Line Edit Buffer and therefore require shifting. Entry: HL=Current row's flag byte. A=Character code to insert at the start of the first row of the Below-Screen Line Edit Buffer.",
    "12672": "The row in the Below-Screen Line Edit Buffer is not the last row of the BASIC line. Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the following row and shift all existing characters right by one. Repeat this process until all rows have been shifted.",
    "12681": "The end character of the row has spilled out so it must be inserted as the first editable character of the following row",
    "12690": "The bottom row of the Below-Screen Line Edit Buffer has been reached",
    "12697": "The Below-Screen Line Edit Buffer is completely full",
    "12704": "Check whether there is another row to shift",
    "12715": "All existing rows have now been shifted but a new row needs to be inserted",
    "12730": "The shifting of all rows has completed",
    "12739": "Find Row Address in Below-Screen Line Edit Buffer: Find address in the Below-Screen Line Edit Buffer of specified row. This routine calculates DE = $F6F8 + $0023*C. Entry: C=Row number. Exit : Address of edit row in DE.",
    "12745": "Delete a Character from a BASIC Line in the Below-Screen Line Edit Buffer: Delete a character at the specified position, shifting subsequent characters left as applicable. Exit: A=Character shifted out of the top row of the Below-Screen Line Edit Buffer.",
    "12761": "There is at least one row in the Below-Screen Line Edit Buffer",
    "12772": "The row is not blank",
    "12773": "DE=Address within a row of edit buffer. A=Character to shift into right of row. B=The column to start shifting at.",
    "12786": "The row is already blank or the result of the shift has caused it to become blank. HL points to the last blank character in the row.",
    "12795": "The first row in the Below-Screen Line Edit Buffer is empty and hence the BASIC line now fits completely on screen, i.e. within the Screen Line Edit Buffer",
    "12804": "The blank row is not the first row in the Below-Screen Line Edit Buffer, and hence there are further rows above to be shifted",
    "12822": "Continue with the next row",
    "12826": "All rows in the Below-Screen Line Edit Buffer have been shifted",
    "12830": "Above-Screen Line Edit Buffer Settings: This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F9DB. It appears that the word at $F9DC is supposed to be a pointer to the next available or accessed location within the buffer but this facility is never used. Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $3222 (ROM 0) to simply set the byte at $F9DB directly.",
    "12834": "Set Above-Screen Line Edit Buffer Settings: Sets the default values for the Above-Screen Line Edit Buffer settings. Copy 3 bytes from $321F-$3221 (ROM 0) to $F9DB-$F9DD.",
    "12843": "Shift Rows Down in the Above-Screen Line Edit Buffer: If Above-Screen Line Edit Buffer contains row then decrement the count, i.e. less rows off screen. If the Above-Screen Line Edit Buffer is empty then load in the new BASIC line at the top of the screen. Exit : HL=Address of next row to use within the Above-Screen Line Edit Buffer. Carry flag reset if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.",
    "12853": "There are no rows of the BASIC line off the top of the screen so use the top line that is visible on screen",
    "12876": "The line specified as the one at the top of the screen does exists",
    "12883": "There are rows of the BASIC line off the top of the screen",
    "12893": "A=New number of rows held in the Above-Screen Line Edit Buffer. HL=Address of a next row to use within the Above-Screen Line Edit Buffer. Carry flag reset if no need to update the count of the number of rows in the Above-Screen Line Edit Buffer.",
    "12906": "Shift Row Up into the Above-Screen Line Edit Buffer if Required: This routine is used to shift up a Screen Line Edit Buffer or a Below-Screen Line Edit Buffer row into the Above-Screen Line Edit Buffer. If shifting the top row of the Screen Line Edit Buffer would result in a straggle into the Above-Screen Line Edit Buffer then the top row is shifted into the next available location within the Above-Screen Line Edit Buffer. If the shift would place the start of a BASIC line on the top row then the Above-Screen Line Edit Buffer is set as empty. The routine is also called when relisting the BASIC program. The first BASIC line may straggle above the screen and so it is necessary to load the BASIC line into the Above-Screen Line Edit Buffer. This is achieved by using the Below-Screen Line Edit Buffer as a temporary line workspace. This routine is called to shift each row into the Above-Screen Line Edit Buffer as appropriate. Entry: DE=Start address of the first row in the Screen Line Edit Buffer, or start address of a Below-Screen Line Edit Buffer row. Exit : HL=Address of next row to use within the Below-Screen or Screen Line Edit Buffer. Carry flag set if the Line Edit Buffer if not full.",
    "12918": "First row of the BASIC line and associated line number stored",
    "12938": "The last row of the BASIC line",
    "12960": "Not the last row of the BASIC line",
    "12965": "Shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer",
    "12979": "Above-Screen Line Edit Buffer is full",
    "12983": "Find Row Address in Above-Screen Line Edit Buffer: Find the address in the Above-Screen Line Edit Buffer of the specified row. This routine calculates DE = $F9DE + $0023*C. Entry: C=Row number. Exit : DE=Address of edit row.",
    "12989": "BASIC Line Character Action Handler Jump Table",
    "13014": "Copy a BASIC Line into the Above-Screen or Below-Screen Line Edit Buffer: Copy a BASIC line into the Above-Screen or Below-Screen Line Edit Buffer, handling indentation. Entry: HL=Address of the previous row's flag byte in Above-Screen or Below-Screen Line Edit Buffer. BC=Line number corresponding to the row being edited. Exit : A=Number of rows in the Above-Screen Line Edit Buffer. HL=Address of the first row of the BASIC line being edited in the Above-Screen Line Edit Buffer. DE=Address of the last row of the BASIC line being edited in the Above-Screen Line Edit Buffer.",
    "13034": "Enter a loop to process each character from the current BASIC line",
    "13048": "Calculator mode, or Editor mode and a character was not available",
    "13055": "Row 1",
    "13073": "A character was available but there was no action handler routine to process it",
    "13079": "Exceeded last column",
    "13086": "At the bottom of the edit buffer so process the line as if an 'Enter' character had been encountered",
    "13091": "The edit buffer has room for another character",
    "13100": "No more characters are available",
    "13105": "Set 'Continuation' Row in Line Edit Buffer: This routine is used when the insertion of a BASIC line needs to span onto a another row. It marks the current row as 'not the last row of the BASIC line' and clears the following row's flags. Entry: DE=Address of start of line edit buffer row. B=Column number (will be $20). C=Row number. A=New flag byte value (will be $12). Exit : Carry flag reset if bottom of line edit buffer reached. HL=Address of the flag byte for the new row.",
    "13130": "Find Address of BASIC Line with Specified Line Number: This routine finds the address of the BASIC line in the program area with the specified line number, or the next line is the specified one does not exist. Entry: HL=Line number. Exit : Carry flag set if line exists. DE=Points to the command of the BASIC line within the program area. HL=Line number ($0000 for no line number).",
    "13138": "Create Next Line Number Representation in Keyword Construction Buffer: This routine is used to create a string representation of the line number for the next line after the specified line, and store it in the Keyword Construction Buffer. Entry: HL=Line number. A=Print leading space flag ($00=Print leading space). Exit : Carry flag set to indicate specified line exists. DE=Points to the command field of the BASIC line. HL=Line number, or $0000 if line does not exist.",
    "13151": "Copy 'Insert Keyword Representation into Keyword Construction Buffer' Routine into RAM: Copies Insert Keyword Representation Into Keyword Construction Buffer routine into physical RAM bank 7, and resets pointers to indicate that there is no BASIC line currently being de-tokenized.",
    "13146": "Fetch Next De-tokenized Character from Selected BASIC Line in Program Area: Exit: Carry flag reset if a character was available. A=Character fetched.",
    "13172": "Insert Keyword Representation into Keyword Construction Buffer <<< RAM Routine >>>: This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80). Only standard Spectrum keywords are handled by this routine (SPECTRUM and PLAY are processed elsewhere). The routine is run from RAM bank 7 at $FCAE so that access to both ROMs is available. Depending on the value of A (which should be the ASCII code less $A5, e.g. 'RND', the first (48K) keyword, has A=0), a different index into the token table is taken. This is to allow speedier lookup since there are never more than 15 keywords to advance through. Entry: A=Keyword character code-$A5 (range $00-$5A). DE=Insertion address within Keyword Construction Buffer.",
    "13200": "Used for token range $A5-$B4 ($00 <= A <= $0F)",
    "13205": "Used for token range $B5-$C4 ($10 <= A <= $1F)",
    "13212": "Used for token range $C5-$D4 ($20 <= A <= $2F)",
    "13219": "Used for token range $D5-$E4 ($30 <= A <= $3F)",
    "13226": "Used for token range $E5-$F4 ($40 <= A <= $4F)",
    "13233": "Used for token range $F5-$FF (A >= $50)",
    "13251": "Copy Keyword Characters <<< RAM Routine >>>: This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80). A leading space will be inserted if required and a trailing space is always inserted. The routine is run from physical RAM bank 7 so that access to both ROMs is available. Entry: HL=Address of keyword string in ROM 1. DE=Insertion address within Keyword Construction Buffer.",
    "13300": "Identify Token from Table: This routine identifies the string within the Keyword Conversion Buffer and returns the character code. The last character of the string to identify has bit 7 set. Only 48K mode tokens are identified. Exit: Carry flag set if token identified. A=Character code.",
    "13313": "Entry point here used to match 128K mode tokens and mis-spelled tokens",
    "13335": "A match was found",
    "13341": "The token does not match so skip to the next entry in the token table",
    "13349": "All character codes tested and no match found",
    "13350": "The common exit point",
    "13360": "Create Next Line Number Representation in Keyword Construction Buffer: This routine is used to create a string representation of the line number for the next line after the specified line, and store it in the Keyword Construction Buffer. Entry: HL=Line number. Entry: A=Print leading space flag ($00=Print leading space). Exit : Carry flag set to indicate specified line available. DE=Points to the command field of the BASIC line. HL=Line number.",
    "13377": "The line number requested exists",
    "13381": "Fetch the next line",
    "13389": "Insert line number into the BASIC Line Construction Buffer",
    "13457": "End of program reached, no line number available",
    "13461": "Insert ASCII Line Number Digit: Insert text representation of a line number digit in a buffer. Insert a $00 character for every leading zero. Entry: DE=Subtraction amount (-1000, -100, -10, -1). HL=Line number. IX=Address of the buffer to write the ASCII line number to. B=Indicates if digit printed yet ($00=not printed). Exit : IX points to next buffer location. B=$01 if digit printed. HL=Line number remainder.",
    "13469": "A=Number of multiples of DE in the line number",
    "13494": "Find Address of BASIC Line with Specified Line Number: This routine finds the address of the BASIC line in the program area with the specified line number, or the next line is the specified one does not exist. Entry: HL=Line number. A=$00 to print a leading space. Exit : Carry flag set if line exists. DE=Points to the command of the BASIC line within the program area. HL=Line number.",
    "13519": "Move to Next BASIC Line: Entry: HL=Address of current BASIC line. Exit : HL=Address of next BASIC line. DE=Address of current BASIC line.",
    "13529": "Check if at End of BASIC Program: Check whether at the end of the BASIC program. Entry: HL=Address of BASIC line. Exit : Carry flag reset if end of BASIC program reached.",
    "13536": "Compare Line Numbers: Compare line number at (HL) has line number held in BC. Entry: HL=Address of first line number. BC=Second line number. Exit : Carry flag and zero flag set if the line number matches. Zero flag reset if no match, with carry flag set if line number held in BC is lower than the line number pointed to by HL.",
    "13546": "Clear BASIC Line Construction Pointers",
    "13558": "Find Address of BASIC Line: This routine finds the address of the BASIC line within the program area with the specified line number. Entry: HL=Line number to find ($0000 for first program line). Exit : Carry flag set if requested or next line exists. Zero flag reset if no match, with carry flag set if line number is lower than the first program line number. HL=Address of the BASIC line number, or $0000 if line does not exist. DE=Address of previous BASIC line number, or $0000 if line does not exist. BC=Line number.",
    "13591": "Fetch Next De-tokenized Character from BASIC Line in Program Area: This routine translates a tokenized BASIC line within the program area into the equivalent 'typed' line, i.e. non-tokenized. The line number has been previously converted into a string representation and is held within the Keyword Construction Buffer at $FCA3. On each call of this routine, the next character of the BASIC line representation is fetched. Initially this is the line number characters from the Keyword Construction Buffer, and then the characters from the program line itself. As a token character is encountered, it is converted into its string representation and stored in the Keyword Construction Buffer. Then each character of this string is fetched in turn. Once all of these characters have been fetched, the next character will be from the last position accessed within the BASIC line in the program area. Exit: Carry flag set to indicate that a character was available. A=Character fetched.",
    "13598": "There is a character within the Keyword Construction Buffer",
    "13628": "There is no line number/keyword defined within the buffer so fetch the next tokenized character from the BASIC line in the program area",
    "13671": "It is not a standard 48K keyword",
    "13675": "It is a 128K keyword",
    "13677": "Handle 'SPECTRUM'",
    "13716": "Keywords String Table: The following strings are terminated by having bit 7 set, referenced at $356D (ROM 0) and $3F87 (ROM 0). The table consists of the new 128K mode keywords and mis-spelled keywords.",
    "13753": "Indentation Settings",
    "13691": "Not a keyword",
    "13702": "The end of the line was found so signal no further characters to fetch",
    "13713": "There was no character within the buffer",
    "13756": "Set Indentation Settings",
    "13765": "Store Character in Column of Edit Buffer Row: Store character in the specified column of the current edit buffer row. Entry: B=Column number. DE=Start address of row. A=Character to insert. Exit : B=Next column number.",
    "13772": "'Enter' Action Handler Routine: Entry: B=Initial column to null. DE=Address of start of edit row. Exit : Carry flag set to indicate no more characters are available, i.e. end of line.",
    "13786": "'Null Columns' Action Handler Routine: Entry: B=Initial column to null. DE=Address of start of edit row. Exit : Carry flag set to indicate no more characters are available, i.e. end of line.",
    "13798": "Null Column Positions: This routine inserts null characters into the remainder of a line edit buffer row. Entry: B=Initial column to null. DE=Address of start of edit row. Exit : HL=Address of the row's flag byte.",
    "13812": "Indent Edit Buffer Row: Indent a row by setting the appropriate number of characters in an edit buffer row to nulls, i.e. character $00. Entry: DE=Address of row within edit buffer. Exit : B=First usable column number in the row.",
    "13828": "Print Edit Buffer Row to Display File if Required: Print a row of the edit buffer to the display file if required. Entry: HL=Address of edit buffer row.",
    "13848": "Shift Up Edit Rows in Display File if Required: This routine shifts edit rows in the display file up if required, replacing the bottom row with the top entry from the Below-Screen Line Edit Buffer. Entry: HL=Address of first row within the Below-Screen Line Edit Buffer. C=Number of editing rows on screen. B=Row number to shift from.",
    "13868": "Shift Down Edit Rows in Display File if Required: This routine shifts edit rows in the display file down if required, replacing the top row with the bottom entry from the Above-Screen Line Edit Buffer. Entry: HL=Address of next row to use within the Above-Screen Line Edit Buffer. C=Number of editing rows on screen. B=Row number to shift from.",
    "13888": "Set Cursor Attribute Colour: Entry: C=Row number, B=Column number.",
    "13903": "Restore Cursor Position Previous Attribute: Entry: C=row, B=column.",
    "13918": "Reset 'L' Mode",
    "13951": "Wait for a Key Press: Exit: A holds key code.",
    "13981": "Control code or cursor key",
    "13992": "Display Menu: HL=Address of menu text.",
    "14330": "Menu Title Space Table",
    "14316": "Menu Title Colours Table",
    "14338": "Menu Sinclair Stripes Bitmaps: Bit-patterns for the Sinclair stripes used on the menus.",
    "14354": "Sinclair Strip 'Text': CHARS points to RAM at $5A98, and characters ' ' and '!' redefined as the Sinclair strips using the bit patterns above.",
    "14105": "Plot a Line: Entry: H=Line pixel coordinate. L=Column pixel coordinate. B=Offset to line pixel coordinate ($FF, $00 or $01). C=Offset to column pixel coordinate ($FF, $00 or $01). A=number of pixels to plot.",
    "14123": "Print \"AT B,C\" Characters",
    "14131": "Print String: Print characters pointed to by HL until $FF found.",
    "14139": "Store Menu Screen Area: Store copy of menu screen area and system variables.",
    "14142": "Restore Menu Screen Area: Restore menu screen area and system variables from copy. Entry: IX=Address of the cursor settings information.",
    "14206": "Store / Restore Menu Screen Row: Entry: HL=Start address of menu row in display file. DE=Screen location/Workspace store for screen row. AF'=Carry flag set for store to workspace, reset for restore to screen. Exit : DE=Screen location/workspace store for next screen row.",
    "14228": "Now save the attributes",
    "14247": "Move Up Menu",
    "14262": "Move Down Menu",
    "14282": "Toggle Menu Option Selection Highlight: Entry: A=Menu option index to highlight.",
    "14370": "Print the Sinclair stripes on the menu",
    "14408": "Print '128 BASIC' Banner",
    "14413": "Print 'Calculator' Banner",
    "14418": "Print 'Tape Loader' Banner",
    "14423": "Print 'Tape Tester' Banner",
    "14426": "Print Banner",
    "14465": "Clear Lower Editing Display",
    "14472": "RENUMBER ROUTINE: Exit: Carry flag reset if required to produce an error beep.",
    "14546": "The end of the BASIC program has been reached so now it is time to update the line numbers and line lengths.",
    "14503": "There is a program that can be renumbered",
    "14599": "Tokens Using Line Numbers: A list of all tokens that maybe followed by a line number and hence require consideration.",
    "14606": "Parse a Line Renumbering Line Number References: This routine examines a BASIC line for any tokens that may be followed by a line number reference and if one is found then the new line number if calculated and substituted for the old line number reference. Although checks are made to ensure an out of memory error does not occur, the routine simply returns silently in such scenarios and the renumber routine will continue onto the next BASIC line. Entry: HL=Address of current character in the current BASIC line. A=Current character.",
    "14621": "A token that might be followed by a line number was found. If it is followed by a line number then proceed to renumber the line number reference. Note that the statements such as GO TO VAL \"100\" will not be renumbered. The line numbers of each BASIC line will be renumbered as the last stage of the renumber process at $38D2 (ROM 0).",
    "14651": "A line number reference was not found",
    "14659": "An embedded number was found",
    "14679": "End of statement/line found",
    "14720": "HL=New line number being referenced",
    "14750": "The new line number contains more digits than the old line number",
    "14782": "No room available to insert extra line number digits",
    "14784": "[At this point the stack contains 3 surplus items. These are not explicitly popped off the stack since the call to $1F45 (ROM 0) will restore the stack to the state it was in at $3888 (ROM 0) when the call to $1F20 (ROM 0) saved it.] Exit if no BASIC program, renumbering would cause a line number overflow or renumbering would cause an out of memory condition",
    "14789": "The new line number contains less digits than the old line number",
    "14799": "The appropriate amount of space now exists in the BASIC line so update the line number value",
    "14853": "Count the Number of BASIC Lines: This routine counts the number of lines in the BASIC program, or if entered at $3A0B (ROM 0) counts the number of lines up in the BASIC program to the address specified in HD_0F+1. Exit: DE=Number of lines.",
    "14897": "No BASIC program",
    "14901": "Skip Spaces",
    "14908": "Create ASCII Line Number Representation: Creates an ASCII representation of a line number, replacing leading zeros with spaces. Entry: HL=The line number to convert. DE=Address of the buffer to build ASCII representation in. B=Number of non-'0' characters minus 1 in the ASCII representation. Exit : HL=Address of the first non-'0' character in the buffer.",
    "14931": "Now skip over leading zeros",
    "14944": "Insert Line Number Digit: This routine effectively works out the result of HL divided by BC. It does this by repeatedly adding a negative value until no overflow occurs. Entry: HL=Number to test. BC=Negative amount to add. DE=Address of buffer to insert ASCII representation of the number of divisions. Exit : HL=Remainder. DE=Next address in the buffer.",
    "14957": "Initial Lower Screen Cursor Settings: Copied to $FD6C-$FD73.",
    "14966": "Initial Main Screen Cursor Settings: Copied to $FD6C-$FD73.",
    "14975": "Set Main Screen Editing Cursor Details: Set initial cursor editing settings when using the main screen.",
    "14984": "Set Lower Screen Editing Cursor Details: Set initial cursor editing settings when using the lower screen. Copies 8 bytes from $3A77-$3A7E (ROM 0) to $FD6C-$FD73.",
    "14993": "Print 'AD': [Never called by ROM].",
    "14998": "Store Cursor Colour: Entry: A=Cursor attribute byte. IX=Address of the cursor settings information.",
    "15005": "Set Cursor Position Attribute: Entry: B=Row number. C=Column number. IX=Address of the cursor settings information.",
    "15026": "Restore Cursor Position Attribute: Entry: B=Row number. C=Column number. IX=Address of the cursor settings information.",
    "15039": "Shift Up Edit Rows in Display File:  This routine shifts edit rows in the display file up, replacing the bottom row with the top entry from the Below-Screen Line Edit Buffer. Entry: HL=Address of first row in the Below-Screen Line Edit Buffer. E=Number of editing rows on screen. B=Row number to shift from.",
    "15046": "Shift Down Edit Rows in Display File: This routine shifts edit rows in the display file down, replacing the top row with the bottom entry from the Above-Screen Line Edit Buffer. Entry: HL=Address of next row to use within the Above-Screen Line Edit Buffer. E=Number of editing rows on screen. B=Row number to shift from.",
    "15053": "Shift Rows",
    "15058": "Shift all display file and attributes rows up",
    "15081": "Copy one row of the display file",
    "15100": "Copy one row of display attributes",
    "15118": "Repeat to shift the next row",
    "15134": "Print a Row of the Edit Buffer to the Screen: This routine prints all 32 characters of a row in the edit buffer to the display file. When shifting all rows up, this routine prints the top entry of the Below-Screen Line Edit Buffer to the first row of the display file. When shifting all rows down, this routine prints the bottom entry of the Above-Screen Line Edit Buffer to the last editing row of the display file. Entry: B =Row number to print at. HL=Address of edit buffer row to print.",
    "15198": "Clear Display Rows: Entry: B=Top row to clear from. D=Bottom row to clear to.",
    "15208": "Clear display file row",
    "15235": "Reset display file attributes",
    "15242": "Repeat for next row",
    "15252": "Find Rows and Columns to End of Screen: This routine calculates the number of rows to the end row of the screen and the number of columns to the end column of the screen. It takes into account the number of rows above the editing area. Entry: B=Row number. C=Column number. Exit : B=Number of rows to end row of screen. C=Number of columns to the end column of the screen.",
    "15256": "Find Rows to End of Screen: This routine calculates the number of rows to the end row of the screen. It takes into account the number of rows above the editing area. Entry: B=Row number. Exit : B=Number of rows to end of screen. IX=Address of the cursor settings information.",
    "15264": "Get Attribute Address: Get the address of the attribute byte for the character position (B,C). Entry: B=Row number. C=Column number. Exit : HL=Address of attribute byte.",
    "15288": "Exchange Colour Items: Exchange 128 Editor and main colour items.",
    "15337": "TAPE TESTER ROUTINE: The Tape Tester routine displays a bright blue bar completely across row 8, with 6 black markers evenly distributed above it on row 7 (columns 1, 7, 13, 19, 25 and 31). The tape port is read 2048 times and the number of highs/lows counted. A cyan marker is placed on the blue bar to indicate the ratio of high and lows. The higher the tape player volume, the further to the right the cyan marker will appear. The Tape Tester can be exited by pressing BREAK (though only SPACE checked), ENTER or EDIT (though only key 1 checked). Note that no attempt to read the keypad is made and so it cannot be used to exit the Tape Tester.",
    "15346": "Print 6 black attribute square across row 7, at 6 column intervals.",
    "15358": "Now enter the main loop checking for the tape input signal",
    "15414": "If the initial tape port level was high then invert the count in H, i.e. determine number of low signals. Note that if H holds $00 then the following code will result in a column position for the cyan marker of 32, and hence it will appear in the first column of the row below.",
    "15421": "If the initial tape port level was low then H holds the number of high signals found.",
    "15423": "L holds the column at which to show the cyan marker.",
    "15446": "Half second delay then clear key press flag. This is called upon entry and exit of the Tape Tester.",
    "15459": "Tokenize BASIC Line: This routine serves two purposes. The first is to tokenize a typed BASIC line into a tokenized version. The second is when a syntax error is subsequently detected within the tokenized line, and it is then used to search for the position within the typed line where the error marker should be shown.",
    "15521": "Enter a loop to fetch each character from the BASIC line and insert it into the workspace, tokenizing along the way",
    "15532": "C=$01 if not a space, not a letter, not a '#' and not a '$'. $02 if a '#' or '$'. $03 if a space. $06 if a letter. B=Character fetched.",
    "15539": "The first character to potentially put into the Keyword Conversion Buffer",
    "15544": "Insert the character",
    "15556": "No room to insert the character into the Keyword Conversion Buffer hence string is too large to be a valid token",
    "15564": "Copy the Keyword Conversion Buffer into the BASIC line workspace",
    "15574": "C=$01 if not a space, not a letter, not a '#' and not a '$'. $02 if a '#' or '$'. $03 if a space. $06 if a letter. B=Character fetched.",
    "15579": "The string was too long to be a keyword and was followed by a space, a '#' or a '$'. Enter a loop to insert each character of the string into the BASIC line workspace.",
    "15597": "The character is not a letter so insert directly into the BASIC line workspace",
    "15604": "Keyword Conversion buffer flags are set - either the buffer already contains characters, or within quotes or within a REM statement",
    "15608": "C=$01 if not a space, not a letter, not a '#' and not a '$'. $02 if a '#' or '$'. $03 if a space. $06 if a letter.",
    "15613": "The character is a space, or is not a letter and not a '#' and not a '$', i.e. the last character was the end of a potential keyword",
    "15620": "The string in the Keyword Conversion Buffer was not identified as a keyword",
    "15632": "Character is a space. Allow this as the keyword could be DEF FN, GO TO, GO SUB, etc.",
    "15646": "The string in the Keyword Conversion Buffer contains two words separated by a space that do not form a valid double keyword (such as DEF FN, GO SUB, GO TO, etc). For a BASIC line such as 'IF FLAG THEN' the Keyword Conversion Buffer holds the characters 'FLAG THEN'. The 'FLAG' characters get moved to the workspace and the 'THEN' characters are shifted to the start of the Keyword Conversion Buffer before being re-evaluated to see if they form a keyword.",
    "15666": "Copy all characters from the Keyword Conversion Buffer prior to the space into the BASIC line workspace",
    "15685": "Now proceed to handle the next word",
    "15708": "The space character is at the start of the Keyword Conversion Buffer",
    "15728": "The space is not at the start of the Keyword Conversion Buffer, i.e. the buffer contains another word after the space. The first word has already been copied to the BASIC line workspace so now copy the second word to the start of the Keyword Conversion Buffer and then see if it is a valid keyword. [It is not recommended to name a variable as per a keyword since statements such as 'PRINT then' will fail the syntax check since the variable 'then' is interpreted as the keyword 'THEN' and so the statement is seen as 'PRINT THEN', which in this case is invalid.] HL points to the start of the Keyword Conversion Buffer. DE points to the space between the two words.",
    "15741": "The string in the Keyword Conversion Buffer was identified as a keyword, so insert the token character code of the keyword into the BASIC line workspace. A=Character code of identified token.",
    "15746": "The token has been inserted into the BASIC line workspace so reset the Keyword Conversion Buffer",
    "15773": "Fetch Next Character and Character Status from BASIC Line to Insert: Fetch the next character from the BASIC line being inserted and check whether a letter, a space, a '#' or a '$'. Exit: B=Character. A=$01 if not a space, not a letter, not a '#' and not a '$'. $02 if a '#' or '$'. $03 if a space. $06 if a letter.",
    "15814": "Is Lowercase Letter? Entry: A=Character code. Exit : Carry flag set is a lowercase letter.",
    "15821": "Copy Keyword Conversion Buffer Contents into BASIC Line Workspace",
    "15849": "Insert Character into Keyword Conversion Buffer: Entry; B=Character to insert. Exit : Carry flag reset if no room to insert the character within the buffer.",
    "15864": "End of buffer not reached",
    "15875": "Not at the start of the buffer so need to remove terminator bit from the previous character",
    "15891": "End of buffer reached",
    "15894": "Insert Character into BASIC Line Workspace, Handling '>' and '<': This routine inserts a character into the BASIC line workspace, tokenizing '>=', '<=' and '<>'. Entry: A=Character to insert. Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete. If searching for the error marker location then returns with the carry flag set if the error marker has not been found, otherwise a return is made to the main calling routine with BC holding the number of characters in the typed BASIC line, i.e. the error marker location is at the end of the line.",
    "15914": "The character was '<' or '>'",
    "15919": "The previous character was '<' or '>'",
    "15928": "Previous character was '<'",
    "15945": "Previous character was '<' and new character is '<'",
    "15954": "Previous character was '>'",
    "15963": "Previous character was '>' and new character is '>'",
    "15972": "Insert Character into BASIC Line Workspace, Handling 'REM' and Quotes: This routine inserts a character into the BASIC line workspace, with special handling of a 'REM' command and strings contained within quotes. Entry: A=Character to insert. Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete. If searching for the error marker location then returns with the carry flag set if the error marker has not been found, otherwise a return is made directly to the main calling routine with BC holding the number of characters in the typed BASIC line, i.e. the error marker location is at the end of the line.",
    "15981": "It is a 'REM' character",
    "15992": "It is a quote character",
    "16008": "It is an 'ENTER' character",
    "16015": "The end of the line was reached and no error marker was found so assume the error marker exists at the end of the typed line",
    "16028": "Insert Character into BASIC Line Workspace With Space Suppression: This routine is called to insert a character into the BASIC line workspace, suppressing both leading and trailing spaces around tokens, e.g. 'PRINT 10' does not require a space stored between 'PRINT' and '10' within the BASIC line. The routine maintains two flags which indicate whether the last character was a space or was a token. Whenever a space is encountered, it is noted but not inserted straight away. It is only after the subsequent character is examined that the routine can determine whether the space should or should not be inserted. Entry: A=Character to insert. Exit : A=Updated BASIC line insertion flags.",
    "16038": "Character to insert is a space",
    "16048": "Character to insert is a space and the last character was not a space/token. This could be the start of a new keyword so note the space but do not insert it now.",
    "16055": "Character to insert is a space and the last character was a space. The new space could be the start of a new keyword so keep the 'last character was a space' flag set but insert a space for the previous space that was noted.",
    "16063": "Character to insert is a space and the last character was a token. Do not insert trailing spaces for tokens.",
    "16070": "Character to insert is not a space",
    "16074": "Character to insert is not a space and not a token",
    "16079": "Character to insert is not a space and not a token and the last character inserted was not a space, so just insert the character",
    "16090": "Character to insert is not a space and not a token and the last character was a space. Since the new character is not a token, the previous space was not the start of a new keyword so insert a space and then the new character.",
    "16110": "Character to insert is a token. Clear any previously noted space since leading spaces are not required for tokens.",
    "16123": "Insert a Character into BASIC Line Workspace: This routine is called for two purposes. The first use is for inserting a character or token into the BASIC line workspace (situated at E_LINE). The second use is after a syntax error has been identified within the tokenized BASIC line in the workspace and the location of the error marker needs to be established. For the second case, the system variable X_PTR holds the address of where the error occurred within the tokenized BASIC line in the workspace. The Editor needs to identify how many characters there are before the equivalent error position is reached within the typed BASIC line. To locate it, the typed BASIC line is re-parsed but this time without inserting any characters into the BASIC line workspace, since this still contains the tokenized line from before. This tokenized line will now also include embedded floating point numbers for any numeric literals contained within the BASIC line. As the typed line is re-parsed, a count of the characters examined so far is kept and instead of inserting tokenized characters within the BASIC line workspace, a check is made to see whether the insertion location has reached the address of the error marker. If it has then the parsing of the BASIC line terminates and the count of the typed line characters indicates the equivalent position within it of the error. However, should the last character have been a token then the typed line count will also include the number of characters that form the keyword, and so this must be subtracted from the count. Entry: A=Character to insert. DE=Address of insertion position within the BASIC line workspace. Exit : If searching for the error marker position and it is found then a return is made directly to the top level calling routine with BC holding the number of characters in the typed BASIC line prior to the equivalent error marker position.",
    "16142": "Locating the error marker",
    "16176": "The error marker has not yet been reached",
    "16179": "Tokenizing the BASIC line",
    "16186": "Searching for the error marker so need to consider embedded floating point numbers",
    "16199": "Come here if tokenizing the BASIC line",
    "16230": "Room for BC Bytes? Test whether there is room for the specified number of bytes in the spare memory, producing error \"4 Out of memory\" if not. Entry: BC=Number of bytes required. Exit : Returns if the room requested room is available else an error '4' is produced.",
    "16254": "Identify Keyword: This routine identifies the string within the Keyword Conversion Buffer and returns the token character code. The last character of the string has bit 7 set. The routine attempts to identify 48K mode keywords, 128K mode keywords and a number of mis-spelled keywords (those that require a space within them). Exit: Carry flag set if a keyword was identified. A=Token character code.",
    "16258": "Attempt to identify 128K mode keywords and mis-spelled keywords.",
    "16270": "Attempt to convert mis-spelled keywords",
    "16314": "Copy Data Block: This routine is used on 8 occasions to copy a block of default data. Entry: DE=Destination address. HL=Address of source data table, which starts with the number of bytes to copy followed by the bytes themselves.",
    "16323": "Get Numeric Value for ASCII Character: [Never called by this ROM]",
    "16334": "Call Action Handler Routine: If the code in A matches an entry in the table pointed to by HL then execute the action specified by the entry's routine address. Entry: A=Code. HL=Address of action table. Exit : Zero flag reset if no match found. Carry flag reset if an error beep is required, or to signal no suitable action handler found. HL=Address of next table entry if a match was found.",
    "16348": "No match found",
    "16353": "Found a match",
    "16367": "PROGRAMMERS' INITIALS: [Provided by Andrew Owen]",
    "16383": "END OF ROM MARKER"
  },
  "Literals": {
    "23386": [
      "RETADDR"
    ],
    "23296": [
      "SWAP",
      "SWAP_RAM"
    ],
    "23388": [
      "BANK_M"
    ],
    "23384": [
      "TARGET"
    ],
    "23316": [
      "YOUNGER",
      "YOUNGER_RAM"
    ],
    "23435": [
      "SYNRET"
    ],
    "23432": [
      "ROW01"
    ],
    "23389": [
      "RAMRST"
    ],
    "23551": [
      "TSTACK"
    ],
    "23427": [
      "SFNEXT"
    ],
    "23429": [
      "SPSPACE",
      "SFSPACE"
    ],
    "23431": [
      "SFSPACE_P2"
    ],
    "23732": [
      "P_RAMT"
    ],
    "23675": [
      "UDG"
    ],
    "23608": [
      "RASP"
    ],
    "23730": [
      "RAMTOP"
    ],
    "23606": [
      "CHARS"
    ],
    "23393": [
      "SERFL"
    ],
    "23391": [
      "BAUD"
    ],
    "23395": [
      "COL"
    ],
    "23397": [
      "TVPARS"
    ],
    "23396": [
      "WIDTH"
    ],
    "23444": [
      "RNFIRST"
    ],
    "23446": [
      "RNSTEP"
    ],
    "23631": [
      "CHANS"
    ],
    "23639": [
      "DATADD"
    ],
    "23635": [
      "PROG"
    ],
    "23627": [
      "VARS"
    ],
    "23641": [
      "E_LINE"
    ],
    "23649": [
      "WORKSP"
    ],
    "23651": [
      "STKBOT"
    ],
    "23653": [
      "STKEND"
    ],
    "23693": [
      "ATTR_P"
    ],
    "23695": [
      "MASK_P"
    ],
    "23624": [
      "BORDCR"
    ],
    "23561": [
      "REPDEL"
    ],
    "23568": [
      "STRMS"
    ],
    "23425": [
      "OLDSP"
    ],
    "23398": [
      "FLAGS3"
    ],
    "23325": [
      "ONERR"
    ],
    "23613": [
      "ERR_SP"
    ],
    "23645": [
      "CH_ADD"
    ],
    "23612": [
      "TVFLAG"
    ],
    "23692": [
      "SCR_CT"
    ],
    "23610": [
      "ERR_NR"
    ],
    "23563": [
      "DEFADD"
    ],
    "5009": [
      "ERR_MSGS"
    ],
    "23621": [
      "PPC"
    ],
    "23664": [
      "OSPPC"
    ],
    "23620": [
      "NSPPC"
    ],
    "23625": [
      "E_PPC"
    ],
    "23390": [
      "RAMERR"
    ],
    "23647": [
      "X_PTR"
    ],
    "23370": [
      "POUT2"
    ],
    "23409": [
      "HD_00"
    ],
    "23611": [
      "FLAGS"
    ],
    "23566": [
      "TD_DATA"
    ],
    "23410": [
      "HD_0B"
    ],
    "23412": [
      "HD_0D"
    ],
    "23416": [
      "HD_11"
    ],
    "23414": [
      "HD_0F"
    ],
    "23399": [
      "N_STR1"
    ],
    "23418": [
      "SC_00"
    ],
    "23419": [
      "SC_0B"
    ],
    "23421": [
      "SC_0D"
    ],
    "23423": [
      "SC_0F"
    ],
    "23618": [
      "NEWPPC"
    ],
    "23668": [
      "T_ADDR"
    ],
    "23623": [
      "SUBPPC"
    ],
    "23637": [
      "NXTLIN"
    ],
    "23697": [
      "P_FLAG"
    ],
    "23448": [
      "STRIP1"
    ],
    "23437": [
      "LASTV"
    ],
    "23643": [
      "K_CUR"
    ],
    "23633": [
      "CURCHL"
    ],
    "23609": [
      "PIP"
    ],
    "23617": [
      "MODE"
    ],
    "13716": [
      "SPECTRUM_STR"
    ],
    "23562": [
      "REPPER"
    ],
    "23560": [
      "LAST_K"
    ],
    "23677": [
      "COORDS"
    ],
    "23442": [
      "RNLINE"
    ]
  },
  "LiteralReplacements": {
    "45": "RETADDR",
    "61": "SWAP_RAM",
    "65": "MASK_INT",
    "57": "MASK_INT_RET",
    "81": "BANK_M",
    "92": "TARGET",
    "95": "YOUNGER_RAM",
    "100": "TARGET",
    "112": "BANK_M",
    "118": "BANK_M",
    "131": "RETADDR",
    "137": "BANK_M",
    "142": "BANK_M",
    "154": "RS232_INP",
    "159": "RS232_OUT",
    "166": "BANK_M",
    "173": "BANK_M",
    "187": "BANK_M",
    "195": "SYNRET",
    "234": "ROW01",
    "321": "SWAP_RAM",
    "324": "SWAP",
    "334": "RAMRST",
    "337": "TSTACK",
    "349": "SFNEXT",
    "370": "SFSPACE",
    "373": "SFSPACE_P2",
    "384": "P_RAMT",
    "399": "UDG",
    "406": "RASP",
    "410": "RAMTOP",
    "416": "CHARS",
    "419": "RAMTOP",
    "442": "SERFL",
    "438": "BAUD",
    "445": "COL",
    "448": "TVPARS",
    "459": "WIDTH",
    "465": "RNFIRST",
    "468": "RNSTEP",
    "474": "CHANS",
    "477": "CHAN_INFO",
    "488": "DATADD",
    "492": "PROG",
    "495": "VARS",
    "501": "E_LINE",
    "510": "WORKSP",
    "513": "STKBOT",
    "516": "STKEND",
    "521": "ATTR_P",
    "524": "MASK_P",
    "527": "BORDCR",
    "541": "REPDEL",
    "553": "STRMS",
    "579": "COPYR_MSG",
    "593": "TSTACK",
    "596": "OLDSP",
    "619": "FLAGS3",
    "632": "ONERR",
    "636": "ERR_SP",
    "640": "RET_SYN_CHECK",
    "643": "SYNRET",
    "705": "E_LINE",
    "708": "CH_ADD",
    "759": "TVFLAG",
    "769": "SCR_CT",
    "784": "ONERR",
    "788": "ERR_SP",
    "792": "ERR_HANDLER",
    "795": "SYNRET",
    "801": "RAMTOP",
    "806": "TSTACK",
    "809": "OLDSP",
    "817": "FLAGS3",
    "827": "SFNEXT",
    "842": "ERR_NR",
    "856": "DEFADD",
    "924": "ERR_MSGS",
    "937": "PPC",
    "958": "ERR_NR",
    "978": "OSPPC",
    "981": "NSPPC",
    "999": "FLAGS3",
    "1015": "E_PPC",
    "1026": "E_PPC",
    "1037": "CH_ADD",
    "1041": "BASIC_ERRH",
    "1045": "WORKSP",
    "1075": "E_PPC",
    "1081": "E_PPC",
    "1096": "PROG",
    "1105": "PROG",
    "1111": "WORKSP",
    "1118": "E_PPC",
    "1458": "BANK_M",
    "1464": "ERR_SP",
    "1469": "RAMERR",
    "1484": "CH_ADD",
    "1487": "X_PTR",
    "1512": "POUT2",
    "1521": "ERR_SP",
    "1536": "ERR_SP",
    "1542": "ERR_SP",
    "1547": "RS232_H_RET",
    "1567": "RETADDR",
    "1575": "RETADDR",
    "1582": "BANK_M",
    "1592": "INKEY_RET",
    "1633": "CH_ADD",
    "1657": "HD_00",
    "1676": "HD_00",
    "1688": "BAUD_TABLE",
    "1715": "BAUD",
    "1752": "SERFL",
    "1770": "BAUD",
    "1774": "BAUD",
    "1984": "SERFL",
    "1995": "TVPARS",
    "2002": "TVPARS",
    "2021": "RETADDR",
    "2029": "RETADDR",
    "2034": "FLAGS",
    "2056": "COL",
    "2060": "WIDTH",
    "2071": "COL",
    "2100": "COL",
    "2144": "TD_DATA",
    "2149": "TVPARS",
    "2153": "TD_DATA",
    "2158": "TVPARS",
    "2163": "TD_DATA",
    "2178": "WIDTH",
    "2197": "COL",
    "2232": "BAUD",
    "2288": "HD_0B",
    "2293": "PRINTER_CC_TABLE",
    "2302": "PRINTER_LF",
    "2308": "HD_0B",
    "2318": "PRINTER_RESET",
    "2325": "HD_00",
    "2333": "HD_00",
    "2345": "HD_00",
    "2836": "STONES_TABLE",
    "2934": "CMD_JUMP_TABLE",
    "3179": "RETADDR",
    "3182": "YOUNGER",
    "3269": "ENV_WAVE_TABLE",
    "3571": "PLAY_CMD_TABLE",
    "3656": "NOTE_LOOKUP_TBL",
    "4587": "FLAGS3",
    "4594": "FLAGS3",
    "4601": "FLAGS3",
    "4608": "FLAGS3",
    "4613": "FLAGS3",
    "4624": "FLAGS3",
    "4637": "HD_0D",
    "4643": "HD_00",
    "4652": "HD_0B",
    "4661": "HD_11",
    "4670": "HD_0F",
    "4683": "HD_0F",
    "4690": "N_STR1",
    "4698": "FLAGS3",
    "4706": "HD_00",
    "4709": "SC_00",
    "4720": "SC_00",
    "4724": "HD_00",
    "4740": "FLAGS3",
    "4752": "FLAGS3",
    "4763": "SC_0B",
    "4766": "HD_0B",
    "4782": "SC_0D",
    "4789": "HD_0D",
    "4792": "HD_00",
    "4798": "PROG",
    "4805": "HD_0B",
    "4827": "HD_0B",
    "4831": "SC_0D",
    "4845": "SC_0B",
    "4864": "HD_00",
    "4885": "E_LINE",
    "4889": "HD_0B",
    "4897": "SC_0F",
    "4917": "FLAGS3",
    "4922": "PROG",
    "4926": "E_LINE",
    "4933": "HD_0B",
    "4937": "PROG",
    "4944": "HD_0F",
    "4949": "VARS",
    "4960": "HD_11",
    "4964": "NEWPPC",
    "4971": "FLAGS3",
    "4976": "PROG",
    "4979": "HD_0B",
    "4984": "DATADD",
    "5030": "N_STR1",
    "5043": "N_STR1",
    "5066": "T_ADDR",
    "5103": "T_ADDR",
    "5132": "T_ADDR",
    "5157": "T_ADDR",
    "5219": "T_ADDR",
    "5254": "T_ADDR",
    "5268": "T_ADDR",
    "5288": "T_ADDR",
    "5346": "T_ADDR",
    "5373": "E_LINE",
    "5376": "PROG",
    "5389": "VARS",
    "5401": "FLAGS3",
    "5409": "T_ADDR",
    "5430": "E_PPC",
    "5512": "E_PPC",
    "5605": "E_PPC",
    "5626": "E_PPC",
    "6071": "SUBPPC",
    "6075": "ERR_NR",
    "6102": "STMT_RET",
    "6115": "SPECTRUM_PARS",
    "6122": "PLAY_PARS",
    "6133": "SYN_OFFS_TABLE",
    "6141": "T_ADDR",
    "6146": "T_ADDR",
    "6149": "STMT_LOOP_RET",
    "6158": "CMD_CLASS_TABLE",
    "6193": "NEWPPC",
    "6203": "PPC",
    "6206": "WORKSP",
    "6210": "E_LINE",
    "6215": "NSPPC",
    "6223": "NSPPC",
    "6248": "NXTLIN",
    "6263": "PPC",
    "6274": "NXTLIN",
    "6278": "CH_ADD",
    "6349": "T_ADDR",
    "6367": "T_ADDR",
    "6375": "CLASS_035_RET",
    "6378": "RETADDR",
    "6381": "YOUNGER",
    "6440": "T_ADDR",
    "6451": "MASK_P",
    "6454": "ATTR_P",
    "6457": "P_FLAG",
    "6473": "FLAGS3",
    "6478": "FLAGS3",
    "6481": "T_ADDR",
    "6486": "T_ADDR",
    "6510": "STKEND",
    "6517": "STKEND",
    "6545": "STKEND",
    "6563": "STKEND",
    "6581": "X_PTR",
    "6584": "DATADD",
    "6604": "CH_ADD",
    "6612": "DATADD",
    "6615": "X_PTR",
    "6622": "CH_ADD",
    "6676": "RAMTOP",
    "6681": "VARS",
    "6685": "E_LINE",
    "6695": "STKEND",
    "6707": "P_RAMT",
    "6719": "RAMTOP",
    "6726": "RAMTOP",
    "6733": "ERR_SP",
    "6746": "PPC",
    "6752": "ERR_SP",
    "6778": "ERR_SP",
    "6783": "NEWPPC",
    "6877": "FLAGS",
    "6920": "E_LINE",
    "6938": "E_LINE",
    "6947": "E_LINE",
    "6958": "ERR_SP",
    "6977": "BANK_M",
    "6989": "BANK_M",
    "6995": "CHANS",
    "7085": "OLDSP",
    "7095": "HD_0B",
    "7112": "HD_00",
    "7118": "HD_0D",
    "7121": "HD_0B",
    "7136": "OLDSP",
    "7160": "OLDSP",
    "7175": "OLDSP",
    "7194": "OLDSP",
    "7209": "OLDSP",
    "7214": "OLDSP",
    "7238": "OLDSP",
    "7224": "HD_00",
    "7243": "OLDSP",
    "7263": "OLDSP",
    "7270": "RAMBANK_MAPPINGS",
    "7279": "BANK_M",
    "7285": "BANK_M",
    "7303": "N_STR1",
    "7347": "FLAGS3",
    "7355": "N_STR1",
    "7407": "SFNEXT",
    "7411": "SFSPACE",
    "7416": "SFSPACE_P2",
    "7427": "SFSPACE",
    "7430": "SFSPACE_P2",
    "7451": "SFNEXT",
    "7524": "FLAGS3",
    "7658": "STRIP1",
    "7665": "STRIP1",
    "7805": "STRIP1",
    "7854": "STRIP1",
    "7888": "BANK_M",
    "7931": "BANK_M",
    "7941": "BANK_M",
    "7976": "TARGET",
    "7979": "OLDSP",
    "7982": "OLDSP",
    "7988": "TARGET",
    "8000": "BANK_M",
    "8008": "TARGET",
    "8011": "OLDSP",
    "8014": "OLDSP",
    "8019": "TARGET",
    "8054": "SFNEXT",
    "8136": "BANK_M",
    "8162": "BANK_M",
    "8220": "BANK_M",
    "8244": "BANK_M",
    "8358": "SFNEXT",
    "8368": "SFNEXT",
    "8391": "SFNEXT",
    "8398": "SFNEXT",
    "8407": "LOWEST_NAME",
    "8410": "HIGHEST_NAME",
    "8423": "SFNEXT",
    "8466": "HIGHEST_NAME",
    "8504": "N_STR1",
    "8517": "OLDSP",
    "8520": "OLDSP",
    "8525": "N_STR1",
    "8549": "OLDSP",
    "8552": "OLDSP",
    "8699": "PPC",
    "8730": "ERR_HANDLER",
    "8733": "SYNRET",
    "8745": "LASTV",
    "8748": "STKEND",
    "8777": "K_CUR",
    "8781": "CURCHL",
    "8798": "K_CUR",
    "8846": "E_LINE",
    "8850": "CH_ADD",
    "8861": "CH_ADD",
    "8876": "OP_TOKENS_TABLE",
    "9621": "E_PPC",
    "9631": "TSTACK",
    "9634": "OLDSP",
    "9645": "MENU_JUMP_TABLE",
    "9651": "MENU_TEXT_TABLE",
    "9679": "TSTACK",
    "9682": "OLDSP",
    "9696": "FLAGS",
    "9745": "E_PPC",
    "9752": "PROG",
    "9755": "VARS",
    "9785": "E_PPC",
    "9811": "TSTACK",
    "9821": "PIP",
    "9839": "MENU_KEYS_TABLE",
    "9844": "ED_KEYS_TABLE",
    "9861": "MODE",
    "9959": "RASP",
    "10292": "TVFLAG",
    "10297": "TAPE_LDR_TEXT",
    "10330": "E_PPC",
    "10348": "TVFLAG",
    "10365": "EDIT_MENU_TABLE",
    "10368": "EDIT_TEXT_TABLE",
    "10396": "E_PPC",
    "10411": "CALC_MENU_TABLE",
    "10414": "CALC_MENU_TEXT",
    "10463": "MS_LW_CURS_SET",
    "10472": "MS_ERR_CURS_SET",
    "10651": "E_PPC",
    "10692": "E_PPC",
    "11473": "ERR_NR",
    "11629": "NEXT_CHAR_TABLE",
    "11807": "TVFLAG",
    "11812": "UPP_SCR_ROWS",
    "11821": "TVFLAG",
    "11832": "LOW_SCR_ROWS",
    "11990": "EMPTY_ROW_DATA",
    "12502": "BSCR_BUFF_SETS",
    "12834": "ASCR_BUFF_SETS",
    "13063": "BASIC_CH_ACTIONS",
    "13160": "INS_KW_REPR",
    "13563": "PROG",
    "13677": "SPECTRUM_STR",
    "13682": "PLAY_STR",
    "13756": "IND_SETS",
    "13920": "MODE",
    "13925": "REPPER",
    "13928": "FLAGS",
    "13940": "FLAGS3",
    "13952": "FLAGS",
    "13961": "LAST_K",
    "13964": "MODE",
    "13996": "TVFLAG",
    "14005": "TITLE_COLORS",
    "14019": "TITLE_SPC_COLORS",
    "14146": "TVFLAG",
    "14157": "COORDS",
    "14373": "SINCLAIR_STRIPES",
    "14384": "CHARS",
    "14391": "CHARS",
    "14394": "STRIP_TEXT",
    "14401": "CHARS",
    "14441": "TITLE_COLORS",
    "14483": "RNSTEP",
    "14490": "RNFIRST",
    "14503": "PROG",
    "14511": "RNLINE",
    "14537": "VARS",
    "14554": "PROG",
    "14560": "RNSTEP",
    "14566": "RNFIRST",
    "14593": "RNLINE",
    "14614": "LNUM_TOKENS",
    "14659": "HD_00",
    "14709": "RNSTEP",
    "14715": "RNFIRST",
    "14736": "HD_00",
    "14743": "HD_00",
    "14757": "STKEND",
    "14824": "RNLINE",
    "14831": "HD_00",
    "14843": "HD_00",
    "14853": "VARS",
    "14859": "PROG",
    "14871": "PROG",
    "14979": "LOWSCR_CUR_SETS",
    "14984": "MSCR_CUR_SETS",
    "15138": "TVFLAG",
    "15153": "TVFLAG",
    "15181": "TVFLAG",
    "15235": "ATTR_P",
    "15291": "ATTR_P",
    "15294": "MASK_P",
    "15306": "ATTR_P",
    "15309": "MASK_P",
    "15324": "P_FLAG",
    "15330": "P_FLAG",
    "15452": "FLAGS",
    "15509": "E_LINE",
    "16142": "X_PTR",
    "16213": "STKEND",
    "16230": "STKEND",
    "16248": "ERR_NR",
    "16263": "SPECTRUM_STR"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 11,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 12,
      "EndAddress": 15,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 16,
      "EndAddress": 19,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 20,
      "EndAddress": 23,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 24,
      "EndAddress": 27,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 28,
      "EndAddress": 31,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 32,
      "EndAddress": 35,
      "SectionType": 1,
      "Lenght": 4
    },
    {
      "StartAddress": 36,
      "EndAddress": 39,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 40,
      "EndAddress": 54,
      "SectionType": 1,
      "Lenght": 15
    },
    {
      "StartAddress": 55,
      "EndAddress": 55,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 56,
      "EndAddress": 1131,
      "SectionType": 1,
      "Lenght": 1076
    },
    {
      "StartAddress": 1132,
      "EndAddress": 1133,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1134,
      "EndAddress": 1135,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1136,
      "EndAddress": 1137,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1138,
      "EndAddress": 1139,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1140,
      "EndAddress": 1141,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1142,
      "EndAddress": 1143,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1144,
      "EndAddress": 1145,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1146,
      "EndAddress": 1147,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1148,
      "EndAddress": 1149,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1150,
      "EndAddress": 1151,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1152,
      "EndAddress": 1153,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1154,
      "EndAddress": 1155,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1156,
      "EndAddress": 1157,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1158,
      "EndAddress": 1159,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1160,
      "EndAddress": 1161,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1162,
      "EndAddress": 1163,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1164,
      "EndAddress": 1174,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 1175,
      "EndAddress": 1189,
      "SectionType": 2,
      "Lenght": 15
    },
    {
      "StartAddress": 1190,
      "EndAddress": 1199,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1200,
      "EndAddress": 1216,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1217,
      "EndAddress": 1235,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1236,
      "EndAddress": 1247,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1248,
      "EndAddress": 1266,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1267,
      "EndAddress": 1280,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1281,
      "EndAddress": 1297,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1298,
      "EndAddress": 1314,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1315,
      "EndAddress": 1328,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 1329,
      "EndAddress": 1345,
      "SectionType": 2,
      "Lenght": 17
    },
    {
      "StartAddress": 1346,
      "EndAddress": 1357,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1358,
      "EndAddress": 1376,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 1377,
      "EndAddress": 1404,
      "SectionType": 2,
      "Lenght": 28
    },
    {
      "StartAddress": 1405,
      "EndAddress": 1416,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 1417,
      "EndAddress": 1418,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1419,
      "EndAddress": 1420,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1421,
      "EndAddress": 1421,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1422,
      "EndAddress": 1423,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1424,
      "EndAddress": 1425,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1426,
      "EndAddress": 1426,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1427,
      "EndAddress": 1428,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1429,
      "EndAddress": 1430,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1431,
      "EndAddress": 1431,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1432,
      "EndAddress": 1433,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1434,
      "EndAddress": 1435,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 1436,
      "EndAddress": 1436,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1437,
      "EndAddress": 1437,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 1438,
      "EndAddress": 1439,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1440,
      "EndAddress": 1441,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1442,
      "EndAddress": 1443,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1444,
      "EndAddress": 1445,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1446,
      "EndAddress": 1447,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1448,
      "EndAddress": 1449,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1450,
      "EndAddress": 1451,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 1452,
      "EndAddress": 1719,
      "SectionType": 1,
      "Lenght": 268
    },
    {
      "StartAddress": 1720,
      "EndAddress": 1723,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1724,
      "EndAddress": 1727,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1728,
      "EndAddress": 1731,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1732,
      "EndAddress": 1735,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1736,
      "EndAddress": 1739,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1740,
      "EndAddress": 1743,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1744,
      "EndAddress": 1747,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1748,
      "EndAddress": 1751,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 1752,
      "EndAddress": 2424,
      "SectionType": 1,
      "Lenght": 673
    },
    {
      "StartAddress": 2425,
      "EndAddress": 2425,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2426,
      "EndAddress": 2427,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2428,
      "EndAddress": 2431,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 2432,
      "EndAddress": 2432,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2433,
      "EndAddress": 2433,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2434,
      "EndAddress": 2434,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 2435,
      "EndAddress": 2436,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 2437,
      "EndAddress": 2609,
      "SectionType": 1,
      "Lenght": 173
    },
    {
      "StartAddress": 2610,
      "EndAddress": 2620,
      "SectionType": 4,
      "Lenght": 11
    },
    {
      "StartAddress": 2621,
      "EndAddress": 2742,
      "SectionType": 1,
      "Lenght": 122
    },
    {
      "StartAddress": 2743,
      "EndAddress": 2756,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 2757,
      "EndAddress": 3529,
      "SectionType": 1,
      "Lenght": 773
    },
    {
      "StartAddress": 3530,
      "EndAddress": 3531,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3532,
      "EndAddress": 3533,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3534,
      "EndAddress": 3535,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3536,
      "EndAddress": 3537,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3538,
      "EndAddress": 3539,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3540,
      "EndAddress": 3541,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3542,
      "EndAddress": 3543,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3544,
      "EndAddress": 3545,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3546,
      "EndAddress": 3547,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3548,
      "EndAddress": 3549,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3550,
      "EndAddress": 3551,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3552,
      "EndAddress": 3553,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3554,
      "EndAddress": 3555,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3556,
      "EndAddress": 3557,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3558,
      "EndAddress": 3559,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 3560,
      "EndAddress": 3560,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3561,
      "EndAddress": 3561,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3562,
      "EndAddress": 3562,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3563,
      "EndAddress": 3563,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3564,
      "EndAddress": 3564,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3565,
      "EndAddress": 3565,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3566,
      "EndAddress": 3566,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3567,
      "EndAddress": 3567,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3568,
      "EndAddress": 3576,
      "SectionType": 1,
      "Lenght": 9
    },
    {
      "StartAddress": 3577,
      "EndAddress": 3583,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 3584,
      "EndAddress": 3595,
      "SectionType": 1,
      "Lenght": 12
    },
    {
      "StartAddress": 3596,
      "EndAddress": 3596,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3597,
      "EndAddress": 3597,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3598,
      "EndAddress": 3598,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3599,
      "EndAddress": 3599,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3600,
      "EndAddress": 3600,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3601,
      "EndAddress": 3601,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3602,
      "EndAddress": 3602,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3603,
      "EndAddress": 3603,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3604,
      "EndAddress": 3604,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3605,
      "EndAddress": 3605,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3606,
      "EndAddress": 3606,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3607,
      "EndAddress": 3607,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3608,
      "EndAddress": 3608,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3609,
      "EndAddress": 3864,
      "SectionType": 1,
      "Lenght": 256
    },
    {
      "StartAddress": 3865,
      "EndAddress": 3865,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3866,
      "EndAddress": 3872,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3873,
      "EndAddress": 3873,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3874,
      "EndAddress": 3880,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3881,
      "EndAddress": 3881,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3882,
      "EndAddress": 3888,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3889,
      "EndAddress": 3889,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3890,
      "EndAddress": 3896,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3897,
      "EndAddress": 3897,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3898,
      "EndAddress": 3904,
      "SectionType": 1,
      "Lenght": 7
    },
    {
      "StartAddress": 3905,
      "EndAddress": 3905,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 3906,
      "EndAddress": 4245,
      "SectionType": 1,
      "Lenght": 340
    },
    {
      "StartAddress": 4246,
      "EndAddress": 4247,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4248,
      "EndAddress": 4249,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4250,
      "EndAddress": 4251,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4252,
      "EndAddress": 4253,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4254,
      "EndAddress": 4255,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4256,
      "EndAddress": 4257,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4258,
      "EndAddress": 4259,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4260,
      "EndAddress": 4261,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4262,
      "EndAddress": 4263,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4264,
      "EndAddress": 4265,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4266,
      "EndAddress": 4267,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4268,
      "EndAddress": 4269,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4270,
      "EndAddress": 4271,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4272,
      "EndAddress": 4273,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4274,
      "EndAddress": 4275,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4276,
      "EndAddress": 4277,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4278,
      "EndAddress": 4279,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4280,
      "EndAddress": 4281,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4282,
      "EndAddress": 4283,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4284,
      "EndAddress": 4285,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4286,
      "EndAddress": 4287,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4288,
      "EndAddress": 4289,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4290,
      "EndAddress": 4291,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4292,
      "EndAddress": 4293,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4294,
      "EndAddress": 4295,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4296,
      "EndAddress": 4297,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4298,
      "EndAddress": 4299,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4300,
      "EndAddress": 4301,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4302,
      "EndAddress": 4303,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4304,
      "EndAddress": 4305,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4306,
      "EndAddress": 4307,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4308,
      "EndAddress": 4309,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4310,
      "EndAddress": 4311,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4312,
      "EndAddress": 4313,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4314,
      "EndAddress": 4315,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4316,
      "EndAddress": 4317,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4318,
      "EndAddress": 4319,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4320,
      "EndAddress": 4321,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4322,
      "EndAddress": 4323,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4324,
      "EndAddress": 4325,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4326,
      "EndAddress": 4327,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4328,
      "EndAddress": 4329,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4330,
      "EndAddress": 4331,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4332,
      "EndAddress": 4333,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4334,
      "EndAddress": 4335,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4336,
      "EndAddress": 4337,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4338,
      "EndAddress": 4339,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4340,
      "EndAddress": 4341,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4342,
      "EndAddress": 4343,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4344,
      "EndAddress": 4345,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4346,
      "EndAddress": 4347,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4348,
      "EndAddress": 4349,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4350,
      "EndAddress": 4351,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4352,
      "EndAddress": 4353,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4354,
      "EndAddress": 4355,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4356,
      "EndAddress": 4357,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4358,
      "EndAddress": 4359,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4360,
      "EndAddress": 4361,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4362,
      "EndAddress": 4363,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4364,
      "EndAddress": 4365,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4366,
      "EndAddress": 4367,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4368,
      "EndAddress": 4369,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4370,
      "EndAddress": 4371,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4372,
      "EndAddress": 4373,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4374,
      "EndAddress": 4375,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4376,
      "EndAddress": 4377,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4378,
      "EndAddress": 4379,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4380,
      "EndAddress": 4381,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4382,
      "EndAddress": 4383,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4384,
      "EndAddress": 4385,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4386,
      "EndAddress": 4387,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4388,
      "EndAddress": 4389,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4390,
      "EndAddress": 4391,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4392,
      "EndAddress": 4393,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4394,
      "EndAddress": 4395,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4396,
      "EndAddress": 4397,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4398,
      "EndAddress": 4399,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4400,
      "EndAddress": 4401,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4402,
      "EndAddress": 4403,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4404,
      "EndAddress": 4405,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4406,
      "EndAddress": 4407,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4408,
      "EndAddress": 4409,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4410,
      "EndAddress": 4411,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4412,
      "EndAddress": 4413,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4414,
      "EndAddress": 4415,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4416,
      "EndAddress": 4417,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4418,
      "EndAddress": 4419,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4420,
      "EndAddress": 4421,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4422,
      "EndAddress": 4423,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4424,
      "EndAddress": 4425,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4426,
      "EndAddress": 4427,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4428,
      "EndAddress": 4429,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4430,
      "EndAddress": 4431,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4432,
      "EndAddress": 4433,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4434,
      "EndAddress": 4435,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4436,
      "EndAddress": 4437,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4438,
      "EndAddress": 4439,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4440,
      "EndAddress": 4441,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4442,
      "EndAddress": 4443,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4444,
      "EndAddress": 4445,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4446,
      "EndAddress": 4447,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4448,
      "EndAddress": 4449,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4450,
      "EndAddress": 4451,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4452,
      "EndAddress": 4453,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4454,
      "EndAddress": 4455,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4456,
      "EndAddress": 4457,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4458,
      "EndAddress": 4459,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4460,
      "EndAddress": 4461,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 4462,
      "EndAddress": 4635,
      "SectionType": 1,
      "Lenght": 174
    },
    {
      "StartAddress": 4636,
      "EndAddress": 4636,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4637,
      "EndAddress": 4738,
      "SectionType": 1,
      "Lenght": 102
    },
    {
      "StartAddress": 4739,
      "EndAddress": 4739,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4740,
      "EndAddress": 4761,
      "SectionType": 1,
      "Lenght": 22
    },
    {
      "StartAddress": 4762,
      "EndAddress": 4762,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4763,
      "EndAddress": 4780,
      "SectionType": 1,
      "Lenght": 18
    },
    {
      "StartAddress": 4781,
      "EndAddress": 4781,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 4782,
      "EndAddress": 5052,
      "SectionType": 1,
      "Lenght": 271
    },
    {
      "StartAddress": 5053,
      "EndAddress": 5053,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5054,
      "EndAddress": 5111,
      "SectionType": 1,
      "Lenght": 58
    },
    {
      "StartAddress": 5112,
      "EndAddress": 5112,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5113,
      "EndAddress": 5165,
      "SectionType": 1,
      "Lenght": 53
    },
    {
      "StartAddress": 5166,
      "EndAddress": 5166,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5167,
      "EndAddress": 5851,
      "SectionType": 1,
      "Lenght": 685
    },
    {
      "StartAddress": 5852,
      "EndAddress": 5852,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5853,
      "EndAddress": 5853,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5854,
      "EndAddress": 5854,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5855,
      "EndAddress": 5855,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5856,
      "EndAddress": 5856,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5857,
      "EndAddress": 5857,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5858,
      "EndAddress": 5858,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5859,
      "EndAddress": 5859,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5860,
      "EndAddress": 5860,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5861,
      "EndAddress": 5861,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5862,
      "EndAddress": 5862,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5863,
      "EndAddress": 5863,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5864,
      "EndAddress": 5864,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5865,
      "EndAddress": 5865,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5866,
      "EndAddress": 5866,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5867,
      "EndAddress": 5867,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5868,
      "EndAddress": 5868,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5869,
      "EndAddress": 5869,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5870,
      "EndAddress": 5870,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5871,
      "EndAddress": 5871,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5872,
      "EndAddress": 5872,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5873,
      "EndAddress": 5873,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5874,
      "EndAddress": 5874,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5875,
      "EndAddress": 5875,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5876,
      "EndAddress": 5876,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5877,
      "EndAddress": 5877,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5878,
      "EndAddress": 5878,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5879,
      "EndAddress": 5879,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5880,
      "EndAddress": 5880,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5881,
      "EndAddress": 5881,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5882,
      "EndAddress": 5882,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5883,
      "EndAddress": 5883,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5884,
      "EndAddress": 5884,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5885,
      "EndAddress": 5885,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5886,
      "EndAddress": 5886,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5887,
      "EndAddress": 5887,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5888,
      "EndAddress": 5888,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5889,
      "EndAddress": 5889,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5890,
      "EndAddress": 5890,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5891,
      "EndAddress": 5891,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5892,
      "EndAddress": 5892,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5893,
      "EndAddress": 5893,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5894,
      "EndAddress": 5894,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5895,
      "EndAddress": 5895,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5896,
      "EndAddress": 5896,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5897,
      "EndAddress": 5897,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5898,
      "EndAddress": 5898,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5899,
      "EndAddress": 5899,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5900,
      "EndAddress": 5900,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5901,
      "EndAddress": 5901,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5902,
      "EndAddress": 5904,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 5905,
      "EndAddress": 5906,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5907,
      "EndAddress": 5908,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5909,
      "EndAddress": 5911,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 5912,
      "EndAddress": 5913,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5914,
      "EndAddress": 5915,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5916,
      "EndAddress": 5917,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5918,
      "EndAddress": 5918,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5919,
      "EndAddress": 5920,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5921,
      "EndAddress": 5921,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5922,
      "EndAddress": 5923,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5924,
      "EndAddress": 5929,
      "SectionType": 2,
      "Lenght": 6
    },
    {
      "StartAddress": 5930,
      "EndAddress": 5931,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5932,
      "EndAddress": 5933,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5934,
      "EndAddress": 5935,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5936,
      "EndAddress": 5936,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5937,
      "EndAddress": 5938,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5939,
      "EndAddress": 5939,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5940,
      "EndAddress": 5941,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5942,
      "EndAddress": 5942,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5943,
      "EndAddress": 5944,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5945,
      "EndAddress": 5945,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5946,
      "EndAddress": 5947,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5948,
      "EndAddress": 5948,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5949,
      "EndAddress": 5950,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5951,
      "EndAddress": 5951,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5952,
      "EndAddress": 5953,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5954,
      "EndAddress": 5954,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5955,
      "EndAddress": 5956,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5957,
      "EndAddress": 5958,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5959,
      "EndAddress": 5960,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5961,
      "EndAddress": 5961,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5962,
      "EndAddress": 5963,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5964,
      "EndAddress": 5964,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5965,
      "EndAddress": 5966,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5967,
      "EndAddress": 5967,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5968,
      "EndAddress": 5969,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5970,
      "EndAddress": 5970,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5971,
      "EndAddress": 5972,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5973,
      "EndAddress": 5974,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5975,
      "EndAddress": 5976,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5977,
      "EndAddress": 5978,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5979,
      "EndAddress": 5980,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5981,
      "EndAddress": 5981,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5982,
      "EndAddress": 5983,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5984,
      "EndAddress": 5984,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5985,
      "EndAddress": 5986,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5987,
      "EndAddress": 5987,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5988,
      "EndAddress": 5989,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5990,
      "EndAddress": 5991,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 5992,
      "EndAddress": 5993,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5994,
      "EndAddress": 5994,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5995,
      "EndAddress": 5996,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 5997,
      "EndAddress": 5997,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 5998,
      "EndAddress": 5999,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6000,
      "EndAddress": 6000,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6001,
      "EndAddress": 6002,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6003,
      "EndAddress": 6003,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6004,
      "EndAddress": 6004,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6005,
      "EndAddress": 6005,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6006,
      "EndAddress": 6006,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6007,
      "EndAddress": 6008,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6009,
      "EndAddress": 6010,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6011,
      "EndAddress": 6012,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6013,
      "EndAddress": 6014,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6015,
      "EndAddress": 6015,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6016,
      "EndAddress": 6016,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6017,
      "EndAddress": 6017,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6018,
      "EndAddress": 6018,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6019,
      "EndAddress": 6019,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6020,
      "EndAddress": 6020,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6021,
      "EndAddress": 6022,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6023,
      "EndAddress": 6024,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6025,
      "EndAddress": 6026,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6027,
      "EndAddress": 6028,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6029,
      "EndAddress": 6029,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6030,
      "EndAddress": 6031,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6032,
      "EndAddress": 6035,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6036,
      "EndAddress": 6037,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6038,
      "EndAddress": 6039,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 6040,
      "EndAddress": 6041,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6042,
      "EndAddress": 6042,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6043,
      "EndAddress": 6044,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6045,
      "EndAddress": 6048,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6049,
      "EndAddress": 6050,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6051,
      "EndAddress": 6051,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6052,
      "EndAddress": 6053,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6054,
      "EndAddress": 6054,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6055,
      "EndAddress": 6056,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6057,
      "EndAddress": 6057,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6058,
      "EndAddress": 6059,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6060,
      "EndAddress": 6060,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6061,
      "EndAddress": 6062,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6063,
      "EndAddress": 6184,
      "SectionType": 1,
      "Lenght": 122
    },
    {
      "StartAddress": 6185,
      "EndAddress": 6185,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6186,
      "EndAddress": 6240,
      "SectionType": 1,
      "Lenght": 55
    },
    {
      "StartAddress": 6241,
      "EndAddress": 6241,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6242,
      "EndAddress": 6303,
      "SectionType": 1,
      "Lenght": 62
    },
    {
      "StartAddress": 6304,
      "EndAddress": 6304,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6305,
      "EndAddress": 6324,
      "SectionType": 1,
      "Lenght": 20
    },
    {
      "StartAddress": 6325,
      "EndAddress": 6325,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6326,
      "EndAddress": 6326,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6327,
      "EndAddress": 6327,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6328,
      "EndAddress": 6328,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6329,
      "EndAddress": 6329,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6330,
      "EndAddress": 6330,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6331,
      "EndAddress": 6331,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6332,
      "EndAddress": 6332,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6333,
      "EndAddress": 6333,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6334,
      "EndAddress": 6334,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6335,
      "EndAddress": 6335,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6336,
      "EndAddress": 6336,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6337,
      "EndAddress": 6337,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6338,
      "EndAddress": 6338,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6339,
      "EndAddress": 6339,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6340,
      "EndAddress": 6420,
      "SectionType": 1,
      "Lenght": 81
    },
    {
      "StartAddress": 6421,
      "EndAddress": 6421,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6422,
      "EndAddress": 6601,
      "SectionType": 1,
      "Lenght": 180
    },
    {
      "StartAddress": 6602,
      "EndAddress": 6602,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6603,
      "EndAddress": 6717,
      "SectionType": 1,
      "Lenght": 115
    },
    {
      "StartAddress": 6718,
      "EndAddress": 6718,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6719,
      "EndAddress": 6794,
      "SectionType": 1,
      "Lenght": 76
    },
    {
      "StartAddress": 6795,
      "EndAddress": 6795,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 6796,
      "EndAddress": 7021,
      "SectionType": 1,
      "Lenght": 226
    },
    {
      "StartAddress": 7022,
      "EndAddress": 7024,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 7025,
      "EndAddress": 7296,
      "SectionType": 1,
      "Lenght": 272
    },
    {
      "StartAddress": 7297,
      "EndAddress": 7302,
      "SectionType": 2,
      "Lenght": 6
    },
    {
      "StartAddress": 7303,
      "EndAddress": 7326,
      "SectionType": 1,
      "Lenght": 24
    },
    {
      "StartAddress": 7327,
      "EndAddress": 7327,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7328,
      "EndAddress": 7440,
      "SectionType": 1,
      "Lenght": 113
    },
    {
      "StartAddress": 7441,
      "EndAddress": 7441,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7442,
      "EndAddress": 7484,
      "SectionType": 1,
      "Lenght": 43
    },
    {
      "StartAddress": 7485,
      "EndAddress": 7485,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 7486,
      "EndAddress": 8038,
      "SectionType": 1,
      "Lenght": 553
    },
    {
      "StartAddress": 8039,
      "EndAddress": 8039,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8040,
      "EndAddress": 8480,
      "SectionType": 1,
      "Lenght": 441
    },
    {
      "StartAddress": 8481,
      "EndAddress": 8490,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 8491,
      "EndAddress": 8500,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 8501,
      "EndAddress": 8685,
      "SectionType": 1,
      "Lenght": 185
    },
    {
      "StartAddress": 8686,
      "EndAddress": 8686,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8687,
      "EndAddress": 8764,
      "SectionType": 1,
      "Lenght": 78
    },
    {
      "StartAddress": 8765,
      "EndAddress": 8765,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8766,
      "EndAddress": 8892,
      "SectionType": 1,
      "Lenght": 127
    },
    {
      "StartAddress": 8893,
      "EndAddress": 8906,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 8907,
      "EndAddress": 9006,
      "SectionType": 1,
      "Lenght": 100
    },
    {
      "StartAddress": 9007,
      "EndAddress": 9007,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9008,
      "EndAddress": 9526,
      "SectionType": 1,
      "Lenght": 519
    },
    {
      "StartAddress": 9527,
      "EndAddress": 9527,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9528,
      "EndAddress": 9528,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9529,
      "EndAddress": 9530,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9531,
      "EndAddress": 9531,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9532,
      "EndAddress": 9533,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9534,
      "EndAddress": 9534,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9535,
      "EndAddress": 9536,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9537,
      "EndAddress": 9537,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9538,
      "EndAddress": 9539,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9540,
      "EndAddress": 9540,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9541,
      "EndAddress": 9542,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9543,
      "EndAddress": 9543,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9544,
      "EndAddress": 9545,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9546,
      "EndAddress": 9546,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9547,
      "EndAddress": 9548,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9549,
      "EndAddress": 9549,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9550,
      "EndAddress": 9551,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9552,
      "EndAddress": 9552,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9553,
      "EndAddress": 9554,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9555,
      "EndAddress": 9555,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9556,
      "EndAddress": 9557,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9558,
      "EndAddress": 9558,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9559,
      "EndAddress": 9560,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9561,
      "EndAddress": 9561,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9562,
      "EndAddress": 9563,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9564,
      "EndAddress": 9564,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9565,
      "EndAddress": 9566,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9567,
      "EndAddress": 9567,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9568,
      "EndAddress": 9569,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9570,
      "EndAddress": 9570,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9571,
      "EndAddress": 9572,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9573,
      "EndAddress": 9573,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9574,
      "EndAddress": 9575,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9576,
      "EndAddress": 9576,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9577,
      "EndAddress": 9578,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9579,
      "EndAddress": 9579,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9580,
      "EndAddress": 9581,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9582,
      "EndAddress": 9582,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9583,
      "EndAddress": 9584,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9585,
      "EndAddress": 9585,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9586,
      "EndAddress": 9587,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9588,
      "EndAddress": 9588,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9589,
      "EndAddress": 9590,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9591,
      "EndAddress": 9591,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9592,
      "EndAddress": 9592,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9593,
      "EndAddress": 9594,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9595,
      "EndAddress": 9595,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9596,
      "EndAddress": 9597,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9598,
      "EndAddress": 9598,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9599,
      "EndAddress": 9600,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 9601,
      "EndAddress": 9601,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 9602,
      "EndAddress": 9603,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 9604,
      "EndAddress": 10051,
      "SectionType": 1,
      "Lenght": 448
    },
    {
      "StartAddress": 10052,
      "EndAddress": 10052,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10053,
      "EndAddress": 10053,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10054,
      "EndAddress": 10055,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10056,
      "EndAddress": 10056,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10057,
      "EndAddress": 10058,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10059,
      "EndAddress": 10059,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10060,
      "EndAddress": 10061,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10062,
      "EndAddress": 10062,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10063,
      "EndAddress": 10064,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10065,
      "EndAddress": 10065,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10066,
      "EndAddress": 10067,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10068,
      "EndAddress": 10068,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10069,
      "EndAddress": 10077,
      "SectionType": 3,
      "Lenght": 9
    },
    {
      "StartAddress": 10078,
      "EndAddress": 10088,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 10089,
      "EndAddress": 10097,
      "SectionType": 2,
      "Lenght": 9
    },
    {
      "StartAddress": 10098,
      "EndAddress": 10115,
      "SectionType": 2,
      "Lenght": 18
    },
    {
      "StartAddress": 10116,
      "EndAddress": 10127,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 10128,
      "EndAddress": 10128,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10129,
      "EndAddress": 10129,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10130,
      "EndAddress": 10131,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10132,
      "EndAddress": 10132,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10133,
      "EndAddress": 10134,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10135,
      "EndAddress": 10135,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10136,
      "EndAddress": 10137,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10138,
      "EndAddress": 10138,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10139,
      "EndAddress": 10140,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10141,
      "EndAddress": 10141,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10142,
      "EndAddress": 10143,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10144,
      "EndAddress": 10144,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10145,
      "EndAddress": 10186,
      "SectionType": 2,
      "Lenght": 42
    },
    {
      "StartAddress": 10187,
      "EndAddress": 10187,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10188,
      "EndAddress": 10188,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10189,
      "EndAddress": 10190,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10191,
      "EndAddress": 10191,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10192,
      "EndAddress": 10193,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 10194,
      "EndAddress": 10194,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10195,
      "EndAddress": 10218,
      "SectionType": 2,
      "Lenght": 24
    },
    {
      "StartAddress": 10219,
      "EndAddress": 10256,
      "SectionType": 2,
      "Lenght": 38
    },
    {
      "StartAddress": 10257,
      "EndAddress": 10448,
      "SectionType": 1,
      "Lenght": 192
    },
    {
      "StartAddress": 10449,
      "EndAddress": 10449,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10450,
      "EndAddress": 10450,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10451,
      "EndAddress": 10451,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10452,
      "EndAddress": 10452,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10453,
      "EndAddress": 10453,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10454,
      "EndAddress": 10454,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10455,
      "EndAddress": 10455,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10456,
      "EndAddress": 10456,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10457,
      "EndAddress": 10457,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10458,
      "EndAddress": 10458,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10459,
      "EndAddress": 10459,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10460,
      "EndAddress": 10460,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10461,
      "EndAddress": 10461,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10462,
      "EndAddress": 10462,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 10463,
      "EndAddress": 11652,
      "SectionType": 1,
      "Lenght": 1190
    },
    {
      "StartAddress": 11653,
      "EndAddress": 11653,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11654,
      "EndAddress": 11654,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11655,
      "EndAddress": 11656,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 11657,
      "EndAddress": 11657,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11658,
      "EndAddress": 11659,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 11660,
      "EndAddress": 11660,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11661,
      "EndAddress": 11662,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 11663,
      "EndAddress": 11802,
      "SectionType": 1,
      "Lenght": 140
    },
    {
      "StartAddress": 11803,
      "EndAddress": 11803,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11804,
      "EndAddress": 11804,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11805,
      "EndAddress": 11805,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11806,
      "EndAddress": 11806,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 11807,
      "EndAddress": 12014,
      "SectionType": 1,
      "Lenght": 208
    },
    {
      "StartAddress": 12015,
      "EndAddress": 12046,
      "SectionType": 2,
      "Lenght": 32
    },
    {
      "StartAddress": 12047,
      "EndAddress": 12047,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12048,
      "EndAddress": 12049,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12050,
      "EndAddress": 12495,
      "SectionType": 1,
      "Lenght": 446
    },
    {
      "StartAddress": 12496,
      "EndAddress": 12496,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12497,
      "EndAddress": 12497,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12498,
      "EndAddress": 12499,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12500,
      "EndAddress": 12501,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12502,
      "EndAddress": 12829,
      "SectionType": 1,
      "Lenght": 328
    },
    {
      "StartAddress": 12830,
      "EndAddress": 12830,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12831,
      "EndAddress": 12831,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12832,
      "EndAddress": 12833,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12834,
      "EndAddress": 12988,
      "SectionType": 1,
      "Lenght": 155
    },
    {
      "StartAddress": 12989,
      "EndAddress": 12989,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12990,
      "EndAddress": 12990,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12991,
      "EndAddress": 12992,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12993,
      "EndAddress": 12993,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 12994,
      "EndAddress": 12995,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12996,
      "EndAddress": 12996,
      "SectionType": 3,
      "Lenght": 1
    },
    {
      "StartAddress": 12997,
      "EndAddress": 12998,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 12999,
      "EndAddress": 12999,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13000,
      "EndAddress": 13001,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 13002,
      "EndAddress": 13002,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13003,
      "EndAddress": 13004,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 13005,
      "EndAddress": 13005,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13006,
      "EndAddress": 13007,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 13008,
      "EndAddress": 13008,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13009,
      "EndAddress": 13010,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 13011,
      "EndAddress": 13011,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13012,
      "EndAddress": 13013,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 13014,
      "EndAddress": 13715,
      "SectionType": 1,
      "Lenght": 702
    },
    {
      "StartAddress": 13716,
      "EndAddress": 13723,
      "SectionType": 2,
      "Lenght": 8
    },
    {
      "StartAddress": 13724,
      "EndAddress": 13727,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 13728,
      "EndAddress": 13731,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 13732,
      "EndAddress": 13736,
      "SectionType": 2,
      "Lenght": 5
    },
    {
      "StartAddress": 13737,
      "EndAddress": 13741,
      "SectionType": 2,
      "Lenght": 5
    },
    {
      "StartAddress": 13742,
      "EndAddress": 13746,
      "SectionType": 2,
      "Lenght": 5
    },
    {
      "StartAddress": 13747,
      "EndAddress": 13752,
      "SectionType": 2,
      "Lenght": 6
    },
    {
      "StartAddress": 13753,
      "EndAddress": 13753,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13754,
      "EndAddress": 13754,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13755,
      "EndAddress": 13755,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 13756,
      "EndAddress": 14315,
      "SectionType": 1,
      "Lenght": 560
    },
    {
      "StartAddress": 14316,
      "EndAddress": 14329,
      "SectionType": 2,
      "Lenght": 14
    },
    {
      "StartAddress": 14330,
      "EndAddress": 14337,
      "SectionType": 2,
      "Lenght": 8
    },
    {
      "StartAddress": 14338,
      "EndAddress": 14353,
      "SectionType": 2,
      "Lenght": 16
    },
    {
      "StartAddress": 14354,
      "EndAddress": 14369,
      "SectionType": 2,
      "Lenght": 16
    },
    {
      "StartAddress": 14370,
      "EndAddress": 14598,
      "SectionType": 1,
      "Lenght": 229
    },
    {
      "StartAddress": 14599,
      "EndAddress": 14605,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 14606,
      "EndAddress": 14956,
      "SectionType": 1,
      "Lenght": 351
    },
    {
      "StartAddress": 14957,
      "EndAddress": 14957,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14958,
      "EndAddress": 14958,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14959,
      "EndAddress": 14959,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14960,
      "EndAddress": 14960,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14961,
      "EndAddress": 14961,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14962,
      "EndAddress": 14962,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14963,
      "EndAddress": 14963,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14964,
      "EndAddress": 14964,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14965,
      "EndAddress": 14965,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14966,
      "EndAddress": 14966,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14967,
      "EndAddress": 14967,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14968,
      "EndAddress": 14968,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14969,
      "EndAddress": 14969,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14970,
      "EndAddress": 14970,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14971,
      "EndAddress": 14971,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14972,
      "EndAddress": 14972,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14973,
      "EndAddress": 14973,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14974,
      "EndAddress": 14974,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 14975,
      "EndAddress": 16366,
      "SectionType": 1,
      "Lenght": 1392
    },
    {
      "StartAddress": 16367,
      "EndAddress": 16367,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16368,
      "EndAddress": 16369,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 16370,
      "EndAddress": 16370,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16371,
      "EndAddress": 16372,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 16373,
      "EndAddress": 16373,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16374,
      "EndAddress": 16375,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 16376,
      "EndAddress": 16376,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16377,
      "EndAddress": 16378,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 16379,
      "EndAddress": 16379,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16380,
      "EndAddress": 16381,
      "SectionType": 2,
      "Lenght": 2
    },
    {
      "StartAddress": 16382,
      "EndAddress": 16382,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16383,
      "EndAddress": 16383,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 16384,
      "EndAddress": 23551,
      "SectionType": 2,
      "Lenght": 7168
    },
    {
      "StartAddress": 23552,
      "EndAddress": 49151,
      "SectionType": 1,
      "Lenght": 25600
    },
    {
      "StartAddress": 49152,
      "EndAddress": 65535,
      "SectionType": 2,
      "Lenght": 16384
    }
  ],
  "DisassemblyFlags": 4
}