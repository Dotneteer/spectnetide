using System.Collections.Generic;
using Antlr4.Runtime;
using AntlrZ80Asm.SyntaxTree;

namespace AntlrZ80Asm
{
    partial class Z80AsmParser
    {
        /// <summary>
        /// Syntax errors caught dureing the parsing phase
        /// </summary>
        public List<Z80AsmParserErrorInfo> SyntaxErrors { get; } = new List<Z80AsmParserErrorInfo>();

        /// <summary>reset the parser's state</summary>
        public override void Reset()
        {
            base.Reset();
            RemoveErrorListeners();
            AddErrorListener(new Z80AsmErrorListener(this));
        }

        private class Z80AsmErrorListener : IAntlrErrorListener<IToken>
        {
            /// <summary>
            /// The parser that utilizes this error listener
            /// </summary>
            private Z80AsmParser Parser { get; }

            /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
            public Z80AsmErrorListener(Z80AsmParser parser)
            {
                Parser = parser;
            }

            /// <summary>Upon syntax error, notify any interested parties.</summary>
            /// <remarks>
            /// Upon syntax error, notify any interested parties. This is not how to
            /// recover from errors or compute error messages.
            /// <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy" />
            /// specifies how to recover from syntax errors and how to compute error
            /// messages. This listener's job is simply to emit a computed message,
            /// though it has enough information to create its own message in many cases.
            /// <p>The
            /// <see cref="T:Antlr4.Runtime.RecognitionException" />
            /// is non-null for all syntax errors except
            /// when we discover mismatched token errors that we can recover from
            /// in-line, without returning from the surrounding rule (via the single
            /// token insertion and deletion mechanism).</p>
            /// </remarks>
            /// <param name="recognizer">
            /// What parser got the error. From this
            /// object, you can access the context as well
            /// as the input stream.
            /// </param>
            /// <param name="offendingSymbol">
            /// The offending token in the input token
            /// stream, unless recognizer is a lexer (then it's null). If
            /// no viable alternative error,
            /// <paramref name="e" />
            /// has token at which we
            /// started production for the decision.
            /// </param>
            /// <param name="line">The line number in the input where the error occurred.</param>
            /// <param name="charPositionInLine">The character position within that line where the error occurred.</param>
            /// <param name="msg">The message to emit.</param>
            /// <param name="e">
            /// The exception generated by the parser that led to
            /// the reporting of an error. It is null in the case where
            /// the parser was able to recover in line without exiting the
            /// surrounding rule.
            /// </param>
            public void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg,
                RecognitionException e)
            {
                Parser.SyntaxErrors.Add(new Z80AsmParserErrorInfo
                {
                    SourceLine = line,
                    Position = charPositionInLine,
                    Token = offendingSymbol.Text,
                    ParserException = e
                });
            }
        }
    }
}
