<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/spectnetide/assets/css/style.css?v=">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,400i,700,700i|Roboto:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&amp;subset=greek,greek-ext" rel="stylesheet">

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU | SpectNet IDE</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As I mentioned in the previous post, the soul of the ZX Spectrum 48K microcomputer—what a surprise—is the Z80 CPU. Obviously, you need to emulate the CPU to get closer to a full Spectrum emulator. Believe it or not, CPU emulation is not a big challenge compared to other devices of the machine (video display generation, tape emulation, etc.), but it is laborious due to the richness of Z80’s instruction set." />
<meta property="og:description" content="As I mentioned in the previous post, the soul of the ZX Spectrum 48K microcomputer—what a surprise—is the Z80 CPU. Obviously, you need to emulate the CPU to get closer to a full Spectrum emulator. Believe it or not, CPU emulation is not a big challenge compared to other devices of the machine (video display generation, tape emulation, etc.), but it is laborious due to the richness of Z80’s instruction set." />
<link rel="canonical" href="http://localhost:4000/spectnetide/zx-spectrum/2018/01/23/zxspectrum-part-3.html" />
<meta property="og:url" content="http://localhost:4000/spectnetide/zx-spectrum/2018/01/23/zxspectrum-part-3.html" />
<meta property="og:site_name" content="SpectNet IDE" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-23T13:20:00+01:00" />
<script type="application/ld+json">
{"headline":"ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU","dateModified":"2018-01-23T13:20:00+01:00","datePublished":"2018-01-23T13:20:00+01:00","url":"http://localhost:4000/spectnetide/zx-spectrum/2018/01/23/zxspectrum-part-3.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/spectnetide/zx-spectrum/2018/01/23/zxspectrum-part-3.html"},"description":"As I mentioned in the previous post, the soul of the ZX Spectrum 48K microcomputer—what a surprise—is the Z80 CPU. Obviously, you need to emulate the CPU to get closer to a full Spectrum emulator. Believe it or not, CPU emulation is not a big challenge compared to other devices of the machine (video display generation, tape emulation, etc.), but it is laborious due to the richness of Z80’s instruction set.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <!-- HEADER -->
    <div class="outer">
        <header class="inner">
          <h1 class="post-title">ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU</h1>
        </header>
    </div>

    <!-- MAIN CONTENT -->

    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="main-columns">
            <section class="main-area">
              <div class="post-attrs">
                <span class="post-label">Published</span>
                <span class="post-value">23 Jan 2018</span>
                <span class="post-label">Category</span>
                <span class="post-value">ZX-Spectrum</span>
              </div>
              <!-- LINKS TO PREVIOUS/NEXT -->
              <div class="links-top">
                <div class="link">
                  
                    <a class="prev" href="/zx-spectrum/2018/01/23/zxspectrum-part-2.html">&laquo; ZX Spectrum IDE — Part #2: The ZX Specrum Emulator Challenge</a>
                  
                </div>
                <div class="link-right">
                  
                    <a class="next" href="/zx-spectrum/2018/01/26/zxspectrum-part-4.html">ZX Spectrum IDE — Part #4: Emulating the Z80 CPU &raquo;</a>
                  
                </div>
              </div>
              <div class="content-separator"></div>

              <p>As I mentioned in the previous post, the soul of the ZX Spectrum 48K microcomputer—what a surprise—is the Z80 CPU. Obviously, you need to emulate the CPU to get closer to a full Spectrum emulator. Believe it or not, CPU emulation is not a big challenge compared to other devices of the machine (video display generation, tape emulation, etc.), but it is laborious due to the richness of Z80’s instruction set.</p>

<p>Before going into the implementation details I used in <a href="https://github.com/Dotneteer/spectnetide">SpectNetIde</a>, I give you a brief overview of Z80A. Please, do not expect this article as a tutorial to learn about the CPU. I will focus on the aspects that are the most essential from the emulator design and development point of view.</p>

<p>The manufacturer of Z80A, Zilog, is an American manufacturer of microcontrollers. Its most known product is the Z80 family of chips. According to its simplicity from hardware interfacing point of view, it became popular right after its initial issue in 1976.</p>

<p>The Z80A version—the one used in ZX Spectrum 48K—is an improved model that increased the maximum speed of the original Z80 from 2.5 MHz to 4 MHz. The chip is an 8-bit CPU with 8-bit and 16-bit registers and provides over 1000 instructions.</p>

<p>Registers
As Figure 1 depicts, it has 8 main registers (<strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>, <strong>E</strong>, <strong>H</strong>, <strong>L</strong>, and <strong>F</strong>) with their corresponding alternate registers (<strong>A’</strong>, <strong>B’</strong>, <strong>C’</strong>, <strong>D’</strong>, <strong>E’</strong>, <strong>H’</strong>, <strong>L’</strong>, and <strong>F’</strong>); two index registers (<strong>IX</strong>, <strong>IY</strong>); a stack pointer (<strong>SP</strong>); a program counter (<strong>PC</strong>), and two special registers, <strong>I</strong> and <strong>R</strong>.</p>

<p><img src="/assets/images/zx-spectrum/f0201.png" alt="f0201" /></p>

<p><em><strong>Figure 1</strong>: The registers of the Z80A CPU</em></p>

<p>The <strong>A</strong> register is called <em>Accumulator</em>. From the programming point of view, this register is the most flexible, as it can be the operand of more instructions than any others. The <strong>F</strong> register is a set of 1-bit flags that are individually set by Z80 instructions. The CPU can use the state of flags as conditions for instructions that change the program flow.</p>

<p>The main 8-bit registers can be used in 16-bit pairs. Thus <strong>B</strong> and <strong>C</strong> compose <strong>BC</strong> (the 8 bits of <strong>B</strong> are the upper, the bits of <strong>C</strong> the lower parts of the resulting 16-bit register). Similarly, you have <strong>DE</strong> and <strong>HL</strong>.</p>

<p>The alternate register set can serve as a backup for the main registers. A Z80 instruction, <strong>EXX</strong>, swaps the main and alternate pairs.</p>

<p>The <strong>PC</strong> (<em>Program Counter</em>) points to the location the CPU should read the next byte of the operation code to execute. <strong>SP</strong> stands for <em>Stack Pointer</em>—as its name suggests, it points to the top of the stack used for subroutine calls and stack-saved values.</p>

<p><strong>IX</strong> and <strong>IY</strong> are index registers. You can use their contents as a memory pointer in tandem with an 8-bit displacement and read or write the composed address. For example, if <strong>IX</strong> contains <strong>$4000</strong>, an instruction reading the <strong>(IX+$2A)</strong> address—here, <strong>$2A</strong> is the displacement—will obtain the contents of address <strong>$402A</strong>.</p>

<p>There are two special registers, <strong>I</strong> and <strong>R</strong>. <strong>I</strong> (<em>Interrupt Page Address</em> register) is used in a particular interrupt mode as the high-order eight bits of the memory location that serves as the interrupt routine address—the device requesting the interrupt provides the low-order eight bits. <strong>R</strong> (<em>Memory Refresh</em> register) contains a memory refresh counter enabling dynamic memories to be used with the same ease as static memories.</p>

<h3 id="control-signals">Control Signals</h3>

<p>The CPU uses control signals to communicate with external devices. Vice-versa, it receives signals when the external world wants to notify the CPU about events. The Z80 has thirteen control pins, 8 of them send, five of them gets signals. From the emulator points of view, these three signals arriving at the CPU are essential:</p>

<ul>
  <li><strong>INT</strong>: interrupt request from devices. This request can be disabled (enabled) by with CPU instructions.</li>
  <li><strong>NMI</strong>: Non-maskable interrupt request (cannot be enabled or disabled)</li>
  <li><strong>RESET</strong>: Resets the CPU immediately just as if we turned the power off and then on again.
    <h3 id="instructions">Instructions</h3>
  </li>
</ul>

<p>The Z80 CPU has more than 1000 instructions. The most often used ones have a single-byte operation code. There are less frequently used instructions that use two or three bytes of operation codes. Besides these, instructions may have arguments. Each instruction starts with the operation code. These codes explicitly tell the CPU whether the instruction has arguments, or its code has multiple bytes.</p>

<ul>
  <li>The <strong>$ED</strong> operation code is a prefix that means a second byte specifies the extended operation.</li>
  <li><strong>$CB</strong> is another prefix code. In this case the second byte names a bit manipulation instruction.</li>
  <li><strong>$DD</strong> and <strong>$FD</strong> are prefixes for indexed operations. A second byte describes the instruction. <strong>$DD</strong> means that the <strong>IX</strong>, <strong>$FD</strong> implies that the <strong>IY</strong> index register should be used in the instruction.</li>
  <li>When a <strong>$CB</strong> prefix follows the <strong>$DD</strong> and <strong>$FD</strong> prefixes, a third byte names the bit manipulation instruction.</li>
  <li>When writing Z80 code, we use the Z80 Assembler language to define the instructions to execute. The compiler translates these very instructions to their machine code equivalent, to operation codes and arguments, respectively.</li>
</ul>

<p>Let’s see a few examples:</p>

<ul>
  <li>The <strong>INC BC</strong> instruction has a single operation code, <strong>$03</strong>. (This instruction increments the 16-value of the <strong>BC</strong> register pair with one.)</li>
  <li>The <strong>LD A,$4C</strong> instruction is a standard operation (code <strong>$3C</strong>) and has an argument, <strong>$4C</strong>. The entire operation is these two bytes, in this order: <strong>$3E</strong>, <strong>$4C</strong>. (This instruction loads the 8-bit value <strong>$4C</strong> into the Accumulator.)</li>
  <li>The <strong>LD ($4238),A</strong> instruction is a standard operation (code <strong>$32</strong>) and has a 16-bit argument of <strong>$4238</strong>. The argument follows the operation code in LSB/MSB order (the least significant byte then the most significant one), so the entire operation contains these three bytes: <strong>$32</strong>, <strong>$38</strong>, <strong>$42</strong>. (Stores the value of <strong>A</strong> in the <strong>$4238</strong> memory address.)</li>
  <li>The <strong>NEG</strong> instruction is an extended operation with the <strong>$ED</strong> prefix followed by the <strong>$44</strong> operation code, so it consists these two bytes: <strong>$ED</strong>, <strong>$44</strong>. (Calculates the two’s complement of <strong>A</strong>.)</li>
  <li>The <strong>BIT 0,E</strong> instruction tests the leftmost bit of the <strong>E</strong> register and sets status flags accordingly. It’s a bit manipulation operation (<strong>$CB</strong> prefix) with the operation code of <strong>$43</strong>. So, the entire operation is composed of these bytes: <strong>$CB</strong>, <strong>$43</strong>.</li>
  <li>The <strong>LD (IX+$3C),$87</strong> operation stores <strong>$87</strong> in the memory address calculated from the current value of <strong>IX</strong> plus the <strong>$3C</strong> displacement. It starts with the <strong>$DD</strong> prefix and the <strong>$36</strong> operation code. The entire operation contains the <strong>$3C</strong> displacement, and then <strong>$87</strong> argument. So, altogether it has four bytes: <strong>$DD</strong>, <strong>$36</strong>, <strong>$3C</strong>, and <strong>$87</strong>.</li>
  <li>The <strong>RLC (IY+$2F),C</strong> instruction starts with the <strong>$FD</strong> prefix (it is <strong>IY</strong>-indexed), then goes on with the <strong>$CB</strong> prefix (bit manipulation). There are two more bytes, <strong>$01</strong>, the operation code, and <strong>$2F</strong>, the displacement, respectively. The entire operation has these four bytes: <strong>$FD</strong>, <strong>$CB</strong>, <strong>$01</strong>, <strong>$2F</strong>.</li>
</ul>

<p class="note"><strong>Note</strong>: In this article, I do not intend to teach you Z80 instructions in details. If you’re interested in Z80 Assembler programming, you’ll find enough information. Here are two pages to start:
http://sgate.emt.bme.hu/patai/publications/z80guide/
http://z80-heaven.wikidot.com/system:tutorials</p>

<h3 id="undocumented-instructions-and-registers">Undocumented Instructions and Registers</h3>

<p>The official Z80 documentation—I do not know why—omits hundreds of operations the Z80 can execute. Many of these are related to the higher and lower eight bits of the <strong>IX</strong> and <strong>IY</strong> index registers (named <strong>XL</strong>, <strong>XH</strong>, <strong>YL</strong>, and <strong>YH</strong>; or sometimes <strong>IXL</strong>, <strong>IXH</strong>, <strong>IYL</strong>, and <strong>IYH</strong>).</p>

<p class="note"><strong>Note</strong>: Fortunately, you can find reliable documents on the internet, which give you those missing details. You need to know that many ZX Spectrum games utilize these undocumented instructions, so a high-fidelity emulator must implement them—this it what SpectNetIde does, too.</p>

<p>Figure 2, 3, 4, 5, and 6 show the entire instruction set of Z80. The reddish cells are the initially undocumented instructions of the CPU. Please note, Figure 5 and Figure 6 display the <strong>IX</strong>-indexed instructions. You can use the same instructions with the <strong>$FD</strong> prefix for the <strong>IY</strong> register.</p>

<p><img src="/assets/images/zx-spectrum/f0202.png" alt="f0202" /></p>

<p><em><strong>Figure 2</strong>: Z80 standard instruction set (source: clrhome.org)</em></p>

<p><img src="/assets/images/zx-spectrum/f0203.png" alt="f0203" /></p>

<p><em><strong>Figure 3</strong>: Z80 extended instruction set (source: clrhome.org)</em></p>

<p><img src="/assets/images/zx-spectrum/f0204.png" alt="f0204" /></p>

<p><em><strong>Figure 4</strong>: Z80 bit manipulation instruction (source: clrhome.org)</em></p>

<p><img src="/assets/images/zx-spectrum/f0205.png" alt="f0205" /></p>

<p><em><strong>Figure 5</strong>: Z80 indexed (IX) instructions (source: clrhome.org)</em></p>

<p><img src="/assets/images/zx-spectrum/f0206.png" alt="f0206" /></p>

<p><em><strong>Figure 6</strong>: Z80 indexed (IX) bit manipulation operations (source: clrhome.org)</em></p>

<h3 id="timings">Timings</h3>

<p>If you are about to write a ZX Spectrum emulator—or any computer emulator—you soon learn that taking care of timing is probably the most important thing. Without this, you won’t be able to create a high-fidelity emulation of real hardware.</p>

<p class="note"><strong>Note</strong>: In the future articles in this series I will treat particular aspects of timings in almost every post.</p>

<p>The Z80 CPU executes instructions as a series of subsequent machine cycles. To understand how it works, Figure 7 gives you the detailed timing of the <strong>INC (HL)</strong> instruction. <strong>INC (HL)</strong> increments the value stored at the memory address pointed by the <strong>HL</strong> register pair.</p>

<p>As the figure shows, the CPU executes this instruction in four machine cycles:</p>

<ul>
  <li><strong>M1</strong>: The CPU reads the opcode from the memory address pointed by <strong>PC</strong> (<em>Program Counter</em>). The execution logic understands what this instruction means, and how to process it.</li>
  <li><strong>M2</strong>: The CPU reads the contents of the memory address pointed by <strong>HL</strong> into some internal ALU register to be ready to process it.</li>
  <li><strong>M3</strong>: The CPU increments the value of the internal ALU register</li>
  <li><strong>M4</strong>: The CPU writes back the incremented value to the memory address pointed by <strong>HL</strong>.</li>
</ul>

<p><img src="/assets/images/zx-spectrum/f0207.png" alt="f0207" /></p>

<p><em><strong>Figure 7</strong>: Timing diagram of the INC (HL) instruction</em></p>

<p>Well, this concise description of the <strong>M1…M4</strong> cycles did not mention many subtle operation details. The real execution is more complicated. The diagram shows that the machine cycles utilize more than a single clock pulse (<em>T-cycle</em>) to carry out their tasks. The longest is <strong>M1</strong> with four T-cycles. Reading and writing memory takes three T-cycles, respectively. The fastest step is the increment, it consumes a single clock cycle.</p>

<p>The <strong>M1</strong> cycle is a special one, so I’d like to add some more details on it:</p>

<p>Every instruction starts with fetching the operation code. If the code is prefixed (such as in case of extended, indexed, and bit manipulation instructions), every opcode fetch is similar. The <strong>M1</strong> cycle takes for T-cycles, <strong>T1</strong>, <strong>T2</strong>, <strong>T3</strong>, and <strong>T4</strong>. This is what happens during M1:</p>

<ul>
  <li>As <strong>T1</strong> begins, the CPU puts the contents of <strong>PC</strong> to the address bus. About a half T-cycle later, the CPU sign the <strong>MREQ</strong> (<em>Memory Request</em>) control signal in tandem with <strong>RD</strong> (<em>Read</em>).</li>
  <li>In <strong>T2</strong>, the memory responds by placing the content of the memory addressed by <strong>PC</strong> to the data bus. (By this time, the memory address stabilizes on the address bus.)</li>
  <li>Just as <strong>T3</strong> begins, with the rising edge of the clock signal, the CPU reads the contents of the data bus—the opcode gets into one of the internal registers. The CPU revokes the <strong>RD</strong>, and <strong>MREQ</strong> signals and puts lower seven bit of <strong>R</strong> (<em>Refresh Page Register</em>) to the lower seven lines of the address bus. At the same time, the CPU places the contents of <strong>I</strong> (<em>Interrupt Register</em>), to the highest eight lines of the address bus, and signs <strong>RFSH</strong> (<em>Refresh</em> signal).</li>
  <li>During <strong>T3</strong> and <strong>T4</strong>, when the refresh page address is stabilized on the address bus, the CPU raises the <strong>MREQ</strong> signal again. The combination of <strong>MREQ</strong> and <strong>RFSH</strong> allows the DRAM chips to refresh the memory contents of the addressed page.</li>
  <li>By the end of <strong>T3</strong>, the CPU analyzes the opcode read and prepares for the subsequent machine cycles. Many operations, are simple and do not need any further memory or I/O access. The CPU executes these operations during <strong>T4</strong>.</li>
  <li>By the end of <strong>T4</strong>, <strong>MREQ</strong>, <strong>RD</strong> (and <strong>RFSH</strong>, a little bit later) go back to their inactive state. The CPU increments the last seven bits of R while keeping its most significant bit.</li>
</ul>

<p>As you can see, the <strong>M1</strong> machine cycle is significant, it is responsible for refreshing the DRAM memory. Without this periodic refresh cycle, the memory would forget its content. Just to have an idea about this time, every page should be refreshed in every 64 milliseconds or less.</p>

<p>To let peripherals and other devices know that the CPU executes <strong>M1</strong>, Z80 has a system control signal, <strong>M1</strong>, that goes active during <strong>T1</strong> and <strong>T2</strong>.</p>

<p>It may happen that during memory and I/O operations the CPU needs to wait while the memory or a device gets ready for a data transfer. The CPU has a <strong>WAIT</strong> input signal; devices may use it to sign that they are not prepared to let the CPU carry on the read or write operation.</p>

<p class="note"><strong>Note</strong>: Later, in another post, you will learn that the <strong>$4000–$7FFF</strong> range of memory in ZX Spectrum 48K is contended. Sometimes, when the CPU wants to read or write the memory, it’s forced to <strong>WAIT</strong>, as the ULA has priority to keep the electron ray in the cathode tub uninterrupted.</p>

<p>Memory read and write, I/O read and write machine cycles have their detailed timings—similarly to <strong>M1</strong>. Here I won’t detail them. If you are interested, check the official Zilog Z80 documentation here.</p>

<h3 id="interrupts">Interrupts</h3>

<p>The CPU cannot continuously poll devices whether they have something to tell. Devices can notify the CPU by generating an interrupt signal. Z80 receives that signal and suspends its normal execution. In response, it executes a routine, the interrupt routine. As that routine is completed, the CPU goes back and continues executing instructions right from the point it was before receiving the signal.</p>

<p>Z80 can handle two kinds of interrupts through the <strong>INT</strong> and <strong>NMI</strong> signals. <strong>NMI</strong> stands for Non-Maskable Interrupt. When the CPU receives an <strong>NMI</strong> request, it executes the interrupt routine starting at address <strong>$0066</strong>.</p>

<p><strong>INT</strong> raises a maskable interrupt. Maskable means that you can disable (and re-enable) it from software—with the <strong>DI</strong> (<em>Disable interrupt</em>), and <strong>EI</strong> (<em>Enable interrupt</em>) Z80 instructions, respectively.</p>

<p>Z80 offers three interrupt handling modes. You can activate these with the <strong>IM 0</strong>, <strong>IM 1</strong>, and <strong>IM 2</strong> instructions:</p>

<ul>
  <li><strong>IM 0</strong>: In this mode the interrupting device can force the CPU to execute a single machine operation. The device places the opcode to the address bus to let the CPU read it in. If the operation contains more bytes, the device should take care to provide those bytes according to the normal memory read timing sequence. No ZX Spectrum models use this interrupt mode.</li>
  <li><strong>IM 1</strong>: This is the simplest interrupt mode. When the CPU receives the request, it starts the interrupt routine at address <strong>$0038</strong>. By default, all ZX Spectrum models—I mean, their operating system—uses this mode.</li>
  <li><strong>IM 2</strong>: This mode is the most complex, often called vectored interrupt, for it allows an indirect call to any memory location by an 8-bit vector supplied from the peripheral device. This vector then becomes the least significant eight bits of the indirect pointer, while <strong>I</strong> (<em>Interrupt Register</em>) in the CPU provides the most significant eight bits. This address points to an address in a vector table that is the starting address for the interrupt service routine. ZX Spectrum games often use this mode to change the original interrupt handler routine entirely.
Of course, the CPU cannot stash its current operation at the very moment an interrupt request arrives. Z80 defines an interrupt request/acknowledge timing cycle:</li>
</ul>

<p>The CPU samples the <strong>INT</strong> signal with the rising edge of the final clock at the end of any instruction. The signal is not accepted unless the maskable interrupt is enabled. When the signal is accepted, the CPU generates a special <strong>M1</strong> cycle. During this cycle, the <strong>IORQ</strong> signal becomes active (instead of the normal <strong>MREQ</strong>) to indicate that the interrupting device can place an 8-bit vector on the data bus. Two wait states are automatically added to this cycle. These states are added so that a ripple priority interrupt scheme can be easily implemented. The two wait states allow sufficient time for the ripple signals to stabilize and identify which I/O device must insert the response vector.</p>

<h3 id="next-emulating-the-z80a-cpu">Next: Emulating the Z80A CPU</h3>

<p>By now, you know enough information about the Z80 CPU. You are prepared to understand the operation of the Z80 emulator. In the next posts of this series, you will learn about the concepts, design, implementation, and testing details.</p>


              <!-- LINKS TO PREVIOUS/NEXT -->
              <div class="links-bottom">
                  <div class="link">
                    
                      <a class="prev" href="/zx-spectrum/2018/01/23/zxspectrum-part-2.html">&laquo; ZX Spectrum IDE — Part #2: The ZX Specrum Emulator Challenge</a>
                    
                  </div>
                  <div class="link-right">
                    
                      <a class="next" href="/zx-spectrum/2018/01/26/zxspectrum-part-4.html">ZX Spectrum IDE — Part #4: Emulating the Z80 CPU &raquo;</a>
                    
                  </div>
              </div>
              <div id="disqus_thread"></div>
            </section>
            <aside class="sidebar">
              <div class="sidebar-title"><a href="/">Dotneteer's BLOG</a></div>
              <div class="sidebar-title">More in this category:</div>
              <ul class="sidebar-list">
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/02/01/zxspectrum-part-5.html">ZX Spectrum IDE — Part #5: Implementing Z80 instructions (1)</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/26/zxspectrum-part-4.html">ZX Spectrum IDE — Part #4: Emulating the Z80 CPU</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/23/zxspectrum-part-3.html">ZX Spectrum IDE — Part #3: A Brief Overview of the Z80 CPU</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/23/zxspectrum-part-2.html">ZX Spectrum IDE — Part #2: The ZX Specrum Emulator Challenge</a></li> 
                  
                   
                  
                   <li class="post-list-item"><a href="/zx-spectrum/2018/01/03/zxspectrum-part-1.html">ZX Spectrum IDE — Part #1: How I Started SpectNetIde</a></li> 
                  
                  
              </ul>
              <div class="sidebar-title">Other categories:</div>
              <ul class="sidebar-list">
                   
                   <li class="post-list-item"><a href="/category/zx-spectrum.html">ZX-Spectrum</a></li> 
                  
              </ul>
            </aside>
          </section>
        </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>&copy; Istvan Novak, 2016-2019</p>
      </footer>
    </div>


    

    <!-- DISQUS -->
<script>

  /**
   *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
   *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

  
  var disqus_config = function () {
  this.page.url = "http://localhost:4000/zx-spectrum/2018/01/23/zxspectrum-part-3.html";  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = "/zx-spectrum/2018/01/23/zxspectrum-part-3.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };

  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://dotneteer.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </body>
</html>