<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/spectnetide/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/spectnetide/" rel="alternate" type="text/html" /><updated>2019-03-07T07:53:44+01:00</updated><id>http://localhost:4000/spectnetide/feed.xml</id><title type="html">SpectNet IDE</title><subtitle>Visual Studio 2017/2019 integrated ZX Spectrum IDE for the Community</subtitle><entry><title type="html">Scripting the Audio</title><link href="http://localhost:4000/spectnetide/documents/scripting-audio" rel="alternate" type="text/html" title="Scripting the Audio" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-audio</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-audio">&lt;h1 id=&quot;the-iaudioconfiguration-interface&quot;&gt;The IAudioConfiguration interface&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Abstraction.Devices&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface IAudioSamplesDevice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This interface represents the configuration of the beeper/sound device. The object type that implements
it has these properties:&lt;/p&gt;

&lt;h2 id=&quot;audiosamplerate&quot;&gt;AudioSampleRate&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int AudioSampleRate { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The audio sample rate used to generate sound wave form.&lt;/p&gt;

&lt;h2 id=&quot;tactspersample&quot;&gt;TactsPerSample&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int TactsPerSample { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of ULA tacts per audio sample.&lt;/p&gt;

&lt;h2 id=&quot;samplesperframe&quot;&gt;SamplesPerFrame&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int SamplesPerFrame { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of samples per ULA video frame. It’s value is the quotient of &lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSampleRate&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;TacsPerSample&lt;/code&gt;. However, because it is an integer value, certain frames contain this 
amount of audio samples, while other frames may contain one more sample.&lt;/p&gt;

&lt;h1 id=&quot;the-audiosamples-class&quot;&gt;The AudioSamples class&lt;/h1&gt;

&lt;p&gt;This class stores audio samples for the currently rendered virtual machine frame.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class AudioSamples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count&quot;&gt;Count&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Count { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of samples stored&lt;/p&gt;

&lt;h2 id=&quot;thisint&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public float this[int index] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the sample at the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;. Each sample is a float value between &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0f&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0f&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">The IAudioConfiguration interface</summary></entry><entry><title type="html">Overview</title><link href="http://localhost:4000/spectnetide/documents/scripting-overview" rel="alternate" type="text/html" title="Overview" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-overview">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; is not just a simple ZX Spectrum emulator
and a set of development tools integrated with Visual Studio,
it offers a collection of .NET objects that you can use to automate
ZX Spectrum related tasks.&lt;/p&gt;

&lt;p&gt;Should it be looking for infinite
lives for a game, understanding the structure of a complex
application, finding out how a particular code works within 
special conditions — scripting makes it easy to automate
mechanical tasks.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt; namespace provides a dozen of object types suited for automation. You can use these
types from any .NET language, and scripting engines that support
directly.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Many popular scripting languages may support 
.NET objects through wrappers. Although &lt;strong&gt;SpectNetIde&lt;/strong&gt; does not
have any direct support for these languages, contributors are
welcomed to create such adapters. If you are interested, please
contact me at &lt;a href=&quot;mailto:dotneteer@hotmail.com&quot;&gt;dotneteer@hotmail.com&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;a-sample-script&quot;&gt;A Sample Script&lt;/h2&gt;

&lt;p&gt;Just for the sake of demonstration, here is a short sample that sets
the border to red, and checks that the screen is rendered accordingly:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Threading.Tasks;
using Spect.Net.SpectrumEmu.Scripting;

namespace MyFirstScript
{
  class Program
  {
    static async Task Main(string[] args)
    {
      var sm = SpectrumVmFactory.CreateSpectrum48Pal();
      Console.WriteLine(&quot;Setting the border to red&quot;);

      await sm.StartAndRunToMain();
      var entryAddr = sm.InjectCode(@&quot;
        .org #8000
        ld a,2       ; RED
        out (#FE),a  ; Set the border colour to red
        halt         ; Wait for 2 frames (rendering)
        halt
        ret          ; Finished
      &quot;);
      sm.CallCode(entryAddr);
      await sm.CompletionTask;

      var screen = sm.ScreenConfiguration;
      var redCount = 0;
      for (var i = 0; i &amp;lt; screen.ScreenLines; i++)
        for (var j = 0; j &amp;lt; screen.ScreenWidth; j++)
          redCount += sm.ScreenBitmap[i,j] == 0x02 ? 1 : 0;

      Console.WriteLine($&quot;#of red pixels: {redCount}&quot;);
      var borderPixels = screen.ScreenLines * screen.ScreenWidth
        - screen.DisplayLines * screen.DisplayWidth;
      Console.WriteLine($&quot;#of border pixels: {borderPixels}&quot;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The script starts with creating a ZX Spectrum 48 virtual machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the code starts the virtual machine (asynchronously in the background) and waits while it initializes the operating system, and enters into its main execution cycle:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;await sm.StartAndRunToMain();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As it reaches the desired state, the virtual machine pauses. At this point, it is ready for code injection. As the next code snippet shows,  _SpectNetIde__ makes it extremely easy to inject source code into the machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var entryAddr = sm.InjectCode(@&quot;
  .org #8000
  ld a,2       ; RED
  out (#FE),a  ; Set the border colour to red
  halt         ; Wait for 2 frames (rendering)
  halt
  ret          ; Finished
&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can utilize the &lt;a href=&quot;/spectnetide/documents/language-structure.html&quot;&gt;Z80 Assembler syntax&lt;/a&gt;
(the same as the IDE uses) to define the machine code to inject. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;InjectCode()&lt;/code&gt; method returns the entry address of the code, so
you can explicitly start the code in the virtual machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sm.CallCode(entryAddr);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CallCode()&lt;/code&gt; method continues the execution cycle of the machine and pauses it when the code returns. The &lt;code class=&quot;highlighter-rouge&quot;&gt;sm.CompletionTask&lt;/code&gt; provides an awaiter to wait while the machine gets paused.&lt;/p&gt;

&lt;p&gt;The last part of the code uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt; property to
get information about the screen. The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt; object can be used to check every pixel in the rendered screen (including the border pixels):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var screen = sm.ScreenConfiguration;
var redCount = 0;
for (var i = 0; i &amp;lt; screen.ScreenLines; i++)
    for (var j = 0; j &amp;lt; screen.ScreenWidth; j++)
        redCount += sm.ScreenBitmap[i,j] == 0x02 ? 1 : 0;

Console.WriteLine($&quot;#of red pixels: {redCount}&quot;);
var borderPixels = screen.ScreenLines * screen.ScreenWidth
    - screen.DisplayLines * screen.DisplayWidth;
Console.WriteLine($&quot;#of border pixels: {borderPixels}&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you start this code from Visual Studio, it produces this output:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Setting the border to red
#of red pixels: 52224
#of border pixels: 52224
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The result proves that the virtual machine renders all border pixels with red color.&lt;/p&gt;</content><author><name></name></author><summary type="html">SpectNetIde is not just a simple ZX Spectrum emulator and a set of development tools integrated with Visual Studio, it offers a collection of .NET objects that you can use to automate ZX Spectrum related tasks.</summary></entry><entry><title type="html">Scripting the Z80 CPU</title><link href="http://localhost:4000/spectnetide/documents/scripting-z80" rel="alternate" type="text/html" title="Scripting the Z80 CPU" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-z80</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-z80">&lt;h1 id=&quot;the-cpuz80-class&quot;&gt;The CpuZ80 class&lt;/h1&gt;

&lt;p&gt;This class represents the Z80 CPU of a Spectrum virtual machine. Using this class you can get and 
set the value of each register, register pair, flag, and other state holders. The class also provides
a few contol methods and events that are raised at different stages of the CPU’s execution cycle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class CpuZ80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;register-properties&quot;&gt;Register properties&lt;/h1&gt;

&lt;p&gt;The class has separate properties for all 8-bit registers and 16-bit register pairs of the CPU. 
An 8-bit register’s value is represented with a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Byte&lt;/code&gt;, while a 16-bit register pair’s value
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.UInt16&lt;/code&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;8-bit-registers&quot;&gt;8-bit registers&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Accummulator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;B&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;C&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;D&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;E&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;H&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;L&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Flags register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Interrupt Page Address Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Memory Refresh Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XH&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the IX index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the IX index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YH&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the IY index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the IY index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZh&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the internal WZ register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZl&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the internal WZ register&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;16-bit-register-pairs&quot;&gt;16-bit register pairs&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AF&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;AF&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;BC&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;DE&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;HL&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_AF_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;AF’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_BC_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;BC’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_DE_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;DE’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_HL_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;HL’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Program Counter Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Stack Pointer Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;I/R 8-bit registers as a register pair&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Index register &lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Index register &lt;strong&gt;IY&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZ&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The internal &lt;strong&gt;WZ&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;z80-cpu-flags&quot;&gt;Z80 CPU flags&lt;/h2&gt;

&lt;p&gt;With these properties, you can query the individual flags of the &lt;strong&gt;F&lt;/strong&gt; register. These properties
retrieve a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Boolean&lt;/code&gt; value.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;S&lt;/strong&gt; (Sign) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Z&lt;/strong&gt; (Zero) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R5Flag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;R5&lt;/strong&gt; Flag, Bit 5 of the &lt;strong&gt;F&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;H&lt;/strong&gt; (Half Carry) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R3Flag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;R3&lt;/strong&gt; Flag, Bit 3 of the &lt;strong&gt;F&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PVFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;P/V&lt;/strong&gt; (Parity/Overflow) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;N&lt;/strong&gt; (Add/Subtract) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;C&lt;/strong&gt; (Carry) Flag&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;cpu-state-properties&quot;&gt;CPU state properties&lt;/h1&gt;

&lt;p&gt;There are various properties that indicate the internal state of the CPU&lt;/p&gt;

&lt;h2 id=&quot;tacts&quot;&gt;Tacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long Tacts { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the current T-state tacts of the CPU — the clock cycles since 
the CPU was powered on/reset last time&lt;/p&gt;

&lt;h2 id=&quot;iff1&quot;&gt;IFF1&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IFF1 { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interrupt Enable Flip-Flop #1. Disables interrupts from being accepted.&lt;/p&gt;

&lt;h2 id=&quot;iff2&quot;&gt;IFF2&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IFF2 { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interrupt Enable Flip-Flop #2. Temporary storage location for IFF1.&lt;/p&gt;

&lt;h2 id=&quot;interruptmode&quot;&gt;InterruptMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte InterruptMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the current Interrupt mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;IM 0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IM 1&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;IM 2&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&quot;isinterruptblocked&quot;&gt;IsInterruptBlocked&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInterruptBlocked { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the CPU internally blocks the interrupts, even if the maskable interrupt is enabled.
When the CPU is within processing a multi-byte statement, this flag is set.&lt;/p&gt;

&lt;h2 id=&quot;isinopexecution&quot;&gt;IsInOpExecution&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInOpExecution { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the CPU still needs to read more bytes to decode a multi-byte operation.&lt;/p&gt;

&lt;h2 id=&quot;maskableinterruptmodeentered&quot;&gt;MaskableInterruptModeEntered&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool MaskableInterruptModeEntered { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the instructions the CPU is executing are the part of the maskable interrupt method.&lt;/p&gt;

&lt;h1 id=&quot;control-methods&quot;&gt;Control methods&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class provides a few control operation that you can use in the scripts.&lt;/p&gt;

&lt;h2 id=&quot;reset&quot;&gt;Reset()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Reset()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Issues a Reset (&lt;code class=&quot;highlighter-rouge&quot;&gt;RST&lt;/code&gt;) signal to the CPU.&lt;/p&gt;

&lt;h2 id=&quot;disableinterrupt&quot;&gt;DisableInterrupt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void DisableInterrupt()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Disables the maskable interrupt.&lt;/p&gt;

&lt;h2 id=&quot;enableinterrupt&quot;&gt;EnableInterrupt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void EnableInterrupt()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Enables the maskable interrupt.&lt;/p&gt;

&lt;h1 id=&quot;operation-tracking&quot;&gt;Operation tracking&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class allows you to track the addresses the CPU executes an operation for.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState OperationTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationTrackingState&lt;/code&gt; property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been read as a part of CPU’s M1 machine cycle.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetOperationTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ResetOperationTracking()&lt;/code&gt; method resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationTrackingState&lt;/code&gt; property as if no 
operations had been executed.&lt;/p&gt;

&lt;p&gt;The following sampe demonstrates how you can use these members of &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; to check which instructions
have been executed. (This code snippet is an extract for a unit test of &lt;strong&gt;SpectNetIde&lt;/strong&gt;.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationTrackingWorks()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.Breakpoints.AddBreakpoint(0x11CB);
    sm.StartDebug();
    await sm.CompletionTask;
    var pcBefore = sm.Cpu.PC;
    sm.ExecutionCompletionReason.ShouldBe(ExecutionCompletionReason.BreakpointReached);
    sm.MachineState.ShouldBe(VmState.Paused);

    // --- Act
    sm.Cpu.ResetOperationTracking();
    sm.Breakpoints.ClearAllBreakpoints();
    sm.Breakpoints.AddBreakpoint(0x11CE);
    sm.StartDebug();
    await sm.CompletionTask;
    var pcAfter = sm.Cpu.PC;

    // --- Assert
    pcBefore.ShouldBe((ushort)0x11CB);
    pcAfter.ShouldBe((ushort)0x11CE);
    sm.Cpu.OperationTrackingState.TouchedAny(0x0000, 0x11CA).ShouldBeFalse();
    sm.Cpu.OperationTrackingState[0x11CB].ShouldBeTrue();
    sm.Cpu.OperationTrackingState[0x11CC].ShouldBeTrue();
    sm.Cpu.OperationTrackingState[0x11CD].ShouldBeTrue();
    sm.Cpu.OperationTrackingState.TouchedAny(0x11CE, 0xFFFF).ShouldBeFalse();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;z80-cpu-events&quot;&gt;Z80 CPU events&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class provides about a dozen events that you can use in script.&lt;/p&gt;

&lt;h2 id=&quot;interruptexecuting&quot;&gt;InterruptExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler InterruptExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a maskable interrupt is about to execute.&lt;/p&gt;

&lt;h2 id=&quot;nmiexecuting&quot;&gt;NmiExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler NmiExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a non-maskable interrupt is about to execute.&lt;/p&gt;

&lt;h2 id=&quot;memoryreading&quot;&gt;MemoryReading&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressEventArgs&amp;gt; MemoryReading
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before the memory is being read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressEventArgs&lt;/code&gt;) 
has a property, &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; that tells the memory address going to be read.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this operation is being executed, the contents of the memory has not been read yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;memoryread&quot;&gt;MemoryRead&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryRead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised right after the memory has been read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) 
contains these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
public byte Data { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; keeps the address read, &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; holds the data byte resulted from the read operation.&lt;/p&gt;

&lt;h2 id=&quot;memorywriting&quot;&gt;MemoryWriting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryWriting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before the memory is being written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the memory address, and the data byte to write, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;memorywritten&quot;&gt;MemoryWritten&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryWritten
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after the memory has been written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the memory address, and the data byte written, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;portreading&quot;&gt;PortReading&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressEventArgs&amp;gt; PortReading
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a port is being read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressEventArgs&lt;/code&gt;) 
has a property, &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; that tells the port address going to be read.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this operation is being executed, the port has not been read yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;portread&quot;&gt;PortRead&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortRead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a port has been read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) 
contains these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
public byte Data { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; keeps the address of the port read, &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; holds the data byte resulted from the read operation.&lt;/p&gt;

&lt;h2 id=&quot;portwriting&quot;&gt;PortWriting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortWriting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a port is being written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the port address, and the data byte to write, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;portwritten&quot;&gt;PortWritten&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortWritten
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a port has been written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the port address, and the data byte written, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;operationexecuting&quot;&gt;OperationExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;Z80InstructionExecutionEventArgs&amp;gt; OperationExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a Z80 operation is being executed. The event arguments
instance (&lt;a href=&quot;Z80InstructionExecutionEventArgs.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;) provides 
properties you can check the operation being executed.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this event is raised, the CPU might not have read all operation code bytes, just those one that
are enough to decode the type of operation to execute. If the operation contains arguments that are
part of the operation code, those are not yet read.&lt;br /&gt;
For example when this event is signed, the opcode part for &lt;code class=&quot;highlighter-rouge&quot;&gt;#80&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,#80&lt;/code&gt;, or the #23 opcode part
of &lt;code class=&quot;highlighter-rouge&quot;&gt;LD (IX+#23),C&lt;/code&gt; operation is not read.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operationexecuted&quot;&gt;OperationExecuted&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;Z80InstructionExecutionEventArgs&amp;gt; OperationExecuted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a Z80 operation has been executed. The event arguments
instance (&lt;a href=&quot;Z80InstructionExecutionEventArgs.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;) provides 
properties you can check the operation executed.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this event is raised, the full operation is already read.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operationexecuting-and-operationexecuted-sample&quot;&gt;OperationExecuting and OperationExecuted sample&lt;/h2&gt;

&lt;p&gt;To demonstrate the difference between these events, the following sample code snippets (extracts from
&lt;strong&gt;SpectNetIde&lt;/strong&gt; unit tests) provide more details.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationExecutingIsInvoked()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.CachedVmStateFolder = STATE_FOLDER;
    await sm.StartAndRunToMain(true);
    var events = new List&amp;lt;Z80InstructionExecutionEventArgs&amp;gt;();

    // --- Act
    var entryAddress = sm.InjectCode(@&quot;
        .org #8000
        di;              8000: No prefix
        bit 3,a;         8001: CB prefix
        ld a,(ix+2);     8003: DD prefix
        ld a,(iy+6);     8006: FD prefix
        bit 2,(ix+2);    8009: DD CB prefixes
        bit 2,(iy+6);    800D: FD CB prefixes
        in d,(c);        8011: ED prefix
        ret
    &quot;);
    sm.Cpu.OperationExecuting += (s, e) =&amp;gt; { events.Add(e); };
    sm.CallCode(entryAddress);
    await sm.CompletionTask;

    // --- Assert
    var sampleIndex = events.Count - 1 - 7; // -1 for the RET operation, -7 for the 7 operations
    var op = events[sampleIndex];
    op.PcBefore.ShouldBe((ushort)0x8000);
    op.Instruction.SequenceEqual(new byte[] { 0xF3 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0xF3);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 1];
    op.PcBefore.ShouldBe((ushort)0x8001);
    op.Instruction.SequenceEqual(new byte []{ 0xCB, 0x5F}).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x5F);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 2];
    op.PcBefore.ShouldBe((ushort)0x8003);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0x7E }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 3];
    op.PcBefore.ShouldBe((ushort)0x8006);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0x7E }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 4];
    op.PcBefore.ShouldBe((ushort)0x8009);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0xCB, 0x56 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 5];
    op.PcBefore.ShouldBe((ushort)0x800D);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0xCB, 0x56 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 6];
    op.PcBefore.ShouldBe((ushort)0x8011);
    op.Instruction.SequenceEqual(new byte[] { 0xED, 0x50 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x50);
    op.PcAfter.ShouldBeNull();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can check that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Instruction&lt;/code&gt; property is tested against the partial opcode.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationExecutedIsInvoked()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.CachedVmStateFolder = STATE_FOLDER;
    await sm.StartAndRunToMain(true);
    var events = new List&amp;lt;Z80InstructionExecutionEventArgs&amp;gt;();

    // --- Act
    var entryAddress = sm.InjectCode(@&quot;
        .org #8000
        di;              8000: No prefix
        bit 3,a;         8001: CB prefix
        ld a,(ix+2);     8003: DD prefix
        ld a,(iy+6);     8006: FD prefix
        bit 2,(ix+2);    8009: DD CB prefixes
        bit 2,(iy+6);    800D: FD CB prefixes
        in d,(c);        8011: ED prefix
        ret
    &quot;);
    sm.Cpu.OperationExecuted += (s, e) =&amp;gt; { events.Add(e); };
    sm.CallCode(entryAddress);
            await sm.CompletionTask;

    // --- Assert
    var sampleIndex = events.Count - 1 - 7; 
        // -1 for the RET operation, -7 for the 7 operations
    var op = events[sampleIndex];
    op.PcBefore.ShouldBe((ushort)0x8000);
    op.Instruction.SequenceEqual(new byte[] { 0xF3 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0xF3);
    op.PcAfter.ShouldBe((ushort)0x8001);

    op = events[sampleIndex + 1];
    op.PcBefore.ShouldBe((ushort)0x8001);
    op.Instruction.SequenceEqual(new byte[] { 0xCB, 0x5F }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x5F);
    op.PcAfter.ShouldBe((ushort)0x8003);

    op = events[sampleIndex + 2];
    op.PcBefore.ShouldBe((ushort)0x8003);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0x7E, 0x02}).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBe((ushort)0x8006);

    op = events[sampleIndex + 3];
    op.PcBefore.ShouldBe((ushort)0x8006);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0x7E, 0x06 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBe((ushort)0x8009);

    op = events[sampleIndex + 4];
    op.PcBefore.ShouldBe((ushort)0x8009);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0xCB, 0x56, 0x02 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBe((ushort)0x800D);

    op = events[sampleIndex + 5];
    op.PcBefore.ShouldBe((ushort)0x800D);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0xCB, 0x56, 0x06 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBe((ushort)0x8011);

    op = events[sampleIndex + 6];
    op.PcBefore.ShouldBe((ushort)0x8011);
    op.Instruction.SequenceEqual(new byte[] { 0xED, 0x50 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x50);
    op.PcAfter.ShouldBe((ushort)0x8013);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;Instruction&lt;/code&gt; property is checked against the entire opcode.&lt;/p&gt;

&lt;h1 id=&quot;the-addresstrackingstate-class&quot;&gt;The AddressTrackingState class&lt;/h1&gt;

&lt;p&gt;This class represents tracking information regarding memory. The scripting engine 
(&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt; classes) use this type to track 
operation execution, memory reads and memory writes.&lt;/p&gt;

&lt;p&gt;This class stores a flag for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range. A false value 
means that the tracking event has not been signed for that particular address. The true value
says that the tracking event has happened.&lt;/p&gt;

&lt;p&gt;For example, when you start the Spectrum virtual machine, after executing the first 
instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;DI&lt;/code&gt;), the flag for #0000 is set to true, but all the others remains false.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class AddressTrackingState
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisushort&quot;&gt;this[ushort]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool this[ushort address] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the status bit of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;touchedallushort-ushort&quot;&gt;TouchedAll(ushort, ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool TouchedAll(ushort startAddr, ushort endAddr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checks if all tracking flag is set between &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddr&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endAddr&lt;/code&gt;&lt;/em&gt;.
Both addresses are inclusive. Returns true, if all flag is set; otherwise, false.&lt;/p&gt;

&lt;h2 id=&quot;touchedanyushort-ushort&quot;&gt;TouchedAny(ushort, ushort)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;public bool TouchedAny(ushort startAddr, ushort endAddr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checks if any tracking flag is set between &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddr&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endAddr&lt;/code&gt;&lt;/em&gt; at all.
Both addresses are inclusive. Returns true, if any of the flags is set; otherwise, false.&lt;/p&gt;

&lt;h1 id=&quot;the-z80instructionexecutioneventargs-class&quot;&gt;The Z80InstructionExecutionEventArgs class&lt;/h1&gt;

&lt;p&gt;This class provides event arguments the the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; 
events of the &lt;a href=&quot;CpuZ80.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;h2 id=&quot;pcbefore&quot;&gt;PcBefore&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort PcBefore { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of PC before the execution.&lt;/p&gt;

&lt;h2 id=&quot;instruction&quot;&gt;Instruction&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IList&amp;lt;byte&amp;gt; Instruction { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The opcode bytes available at the time of event. For example, if the operation is &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,(IX+2)&lt;/code&gt;,
this list contains &lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; event, but &lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt;, 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;#02&lt;/code&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; event.&lt;/p&gt;

&lt;h2 id=&quot;opcode&quot;&gt;OpCode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte OpCode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main operation code. For example, if the operation is &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,(IX+2)&lt;/code&gt;, this value is &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; from
the entire operation opcode (&lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;#02&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;pcafter&quot;&gt;PcAfter&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort? PcAfter { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of PC after the operation has been executed. It is null during &lt;code class=&quot;highlighter-rouge&quot;&gt;OerationExecuting&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">The CpuZ80 class</summary></entry><entry><title type="html">Managing Virtual machines</title><link href="http://localhost:4000/spectnetide/documents/scripting-vms" rel="alternate" type="text/html" title="Managing Virtual machines" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-vms</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-vms">&lt;h1 id=&quot;the-spectrumvmfactory-class&quot;&gt;The SpectrumVmFactory class&lt;/h1&gt;

&lt;p&gt;This class provides methods you can use to create ZX Spectrum virtual machine instances. 
Each factory methods retrieves a &lt;a href=&quot;SpectrumVm.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance you can use to control and query
the particular machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static class SpectrumVmFactory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;createstring-string&quot;&gt;Create(string, string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm Create(string modelKey, string editionKey)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance according to the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt;&lt;/em&gt; 
and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;&lt;/em&gt; values.&lt;/p&gt;

&lt;h3 id=&quot;arguments&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modelkey&lt;/code&gt;: The name of the Spectrum model.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;: The name of the Spectrum edition&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt; class defines several string constants that you can use for these arguments.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;returns&quot;&gt;Returns&lt;/h3&gt;

&lt;p&gt;The newly created ZX Spectrum virtual machine instance.&lt;/p&gt;

&lt;h3 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArgumentNullException&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;KeyNotFoundException&lt;/code&gt;: The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; class does not have a definition
for &lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt;, or the model does not have an edition for &lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;sample&quot;&gt;Sample&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = Create(SpectrumModels.ZX_SPECTRUM_48, SpectrumModels.NTSC);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;createspectrum48pal&quot;&gt;CreateSpectrum48Pal()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48Pal()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48palturbo&quot;&gt;CreateSpectrum48PalTurbo()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48PalTurbo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K PAL virtual machine with double CPU speed (7MHz) and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48ntsc&quot;&gt;CreateSpectrum48Ntsc()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48Ntsc()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K NTSC virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48ntscturbo&quot;&gt;CreateSpectrum48NtscTurbo()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48NtscTurbo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K NTSC virtual machine with double CPU speed (7MHz) and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum128&quot;&gt;CreateSpectrum128()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum128()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 128K PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrump3e&quot;&gt;CreateSpectrumP3E()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum128()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum +3E PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h1 id=&quot;provider-configuration&quot;&gt;Provider configuration&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; class allows to change providers to customize
the virtual machine to your needs. Doing this requires a bit deeper knowledge
of how the emulator in SpectNetIde works. Probably, you do not need to
use your own providers at all.&lt;/p&gt;

&lt;p&gt;Nonetheless, these are the methods you can use to change the default provider
configuration:&lt;/p&gt;

&lt;h2 id=&quot;reset&quot;&gt;Reset()&lt;/h2&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; class, clears the predefined providers.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void Reset()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After invoking &lt;code class=&quot;highlighter-rouge&quot;&gt;Reset()&lt;/code&gt; you need to set up your own providers.&lt;/p&gt;

&lt;h2 id=&quot;registerprovidertproviderfunctprovider&quot;&gt;RegisterProvider&amp;lt;TProvider&amp;gt;(Func&amp;lt;TProvider&amp;gt;)&lt;/h2&gt;

&lt;p&gt;Registers a factory method for the &lt;code class=&quot;highlighter-rouge&quot;&gt;TProvider&lt;/code&gt; type.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void RegisterProvider&amp;lt;TProvider&amp;gt;(Func&amp;lt;TProvider&amp;gt; factory)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can register your own &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;factory&lt;/code&gt;&lt;/em&gt; method that creates a provider for 
&lt;code class=&quot;highlighter-rouge&quot;&gt;TProvider&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;registerdefaultproviders&quot;&gt;RegisterDefaultProviders()&lt;/h2&gt;

&lt;p&gt;Allows you to register the default providers.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void RegisterDefaultProviders()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you need to restore the original behavior of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;,
use this code snippet:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SpectrumVmFactory.Reset();
SpectrumVmFactory.RegisterDefaultProviders();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By default, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; uses these provider registrations:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RegisterProvider&amp;lt;IRomProvider&amp;gt;(() 
    =&amp;gt; new ResourceRomProvider(typeof(RomResourcesPlaceHolder).Assembly));
RegisterProvider&amp;lt;IKeyboardProvider&amp;gt;(() 
    =&amp;gt; new ScriptingKeyboardProvider());
RegisterProvider&amp;lt;IBeeperProvider&amp;gt;(() 
    =&amp;gt; new NoAudioProvider());
RegisterProvider&amp;lt;ITapeProvider&amp;gt;(() 
    =&amp;gt; new ScriptingTapeProvider());
RegisterProvider&amp;lt;ISoundProvider&amp;gt;(() 
    =&amp;gt; new NoAudioProvider());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As the names suggest, the virtual machine created by &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; does not 
generate audio (neither for the beeper nor for the PSG).&lt;/p&gt;

&lt;h1 id=&quot;the-spectrumvm-class&quot;&gt;The SpectrumVm class&lt;/h1&gt;

&lt;p&gt;This class represents a Spectrum virtual machine. You cannot instantiate a machine
with the constructor of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;, for it is not accessible. To create a Spectrum machine,
use the &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt; is a pivotal type in the scripting feature of &lt;strong&gt;SpectNetIde&lt;/strong&gt;. When you have an
object instance in your code, it provides a plethora of properties and methods to access and control
the Spectrum virtual machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;public sealed class SpectrumVm: IDisposable, ISpectrumVmController
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the properties of this class, you can access all important components of the virtual machine.&lt;/p&gt;

&lt;h2 id=&quot;modelkey&quot;&gt;ModelKey&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string ModelKey { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gets the model key of the virtual machine (see &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;editionkey&quot;&gt;EditionKey&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string EditionKey { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gets the edition key of the virtual machine (see &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;cpu&quot;&gt;Cpu&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public CpuZ80 Cpu { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the object that represents the current state of the Z80 CPU. 
You can also use this instance to control the CPU (see also &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;roms&quot;&gt;Roms&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IReadOnlyList&amp;lt;ReadOnlyMemorySlice&amp;gt; Roms { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides access to the binary contents of each individual ROM of
the virtual machine. Each item of the list provides a ROM of the machine.
For example, in a ZX Spectrum 128K machine instance, there are two ROMs
with index 0, and 1. (see also &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-readonlymemoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlyMemorySlice&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;romcount&quot;&gt;RomCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RomCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves the number of ROMs.&lt;/p&gt;

&lt;h2 id=&quot;paginginfo&quot;&gt;PagingInfo&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public MemoryPagingInfo PagingInfo { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Allows you to obtain information about memory paging. There’s no reason
to use this property for a ZX Spectrum 48K virtual machine, as this model 
does not support memory paging. However, it is useful for other models. 
See &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memorypaginginfo-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemoryPagingInfo&lt;/code&gt;&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;memory&quot;&gt;Memory&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SpectrumMemoryContents Memory { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Represents the current contents of the addressable 64K memory of the
virtual machine. You can use this property to read and write the memory.
See &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-spectrummemorycontents-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumMemoryContents&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;rambanks&quot;&gt;RamBanks&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IReadOnlyList&amp;lt;MemorySlice&amp;gt; RamBanks { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this property, you can access the contents of each RAM bank, independently 
whether that particular bank is paged in. The elements of the list represent the
memory banks from #0 to #7. Check &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memoryslice-class&quot;&gt;MemorySlice&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;rambankcount&quot;&gt;RamBankCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RamBankCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of RAM banks available.&lt;/p&gt;

&lt;h2 id=&quot;keyboard&quot;&gt;Keyboard&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public KeyboardEmulator Keyboard { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can access the state of the virtual keyboard through this class. You can also
use it to emulate keystrokes. See &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-keyboardemulator-class&quot;&gt;KeyboardEmulator&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;screenconfiguration&quot;&gt;ScreenConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenConfiguration ScreenConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Allows access to the details of the screen configuration that determine the tacts 
of screen rendering, such as number of raster lines, non-visible screen area, border pixels
above and below the display area, and many more. Check &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt; 
for all available properties of the configuration object.&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingtable&quot;&gt;ScreenRenderingTable&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTable ScreenRenderingTable { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The virtual machine uses a table that contains an item for each screen
rendering tact. You can access the information about an individual tact
through this porperty. The &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtable-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTable&lt;/code&gt;&lt;/a&gt; contains more
details about the information you can access.&lt;/p&gt;

&lt;h2 id=&quot;screenbitmap&quot;&gt;ScreenBitmap&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenBitmap ScreenBitmap { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides access to each individual pixels of the visible screen. This object
represents not only the display area (the 256 x 192 pixels for a ZX Spectrum 48K 
model), but also the border area. To check the dimensions, use the properties of
&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt;. The reference documentation of
&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenbitmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt;&lt;/a&gt; offers more details about addressing the pixels
within this object.&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingstatus&quot;&gt;ScreenRenderingStatus&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingStatus ScreenRenderingStatus { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides information about the current screen rendering status. 
See &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingstatus-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingStatus&lt;/code&gt;&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;beeperconfiguration&quot;&gt;BeeperConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IAudioConfiguration BeeperConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the configuration of the beeper device (such as sampling frequency, and others).
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt; provides more details.&lt;/p&gt;

&lt;h2 id=&quot;beepersamples&quot;&gt;BeeperSamples&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AudioSamples BeeperSamples { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the beeper samples of the current screen rendering frame. The 
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt; type describes how you can access individual samples.&lt;/p&gt;

&lt;h2 id=&quot;soundconfiguration&quot;&gt;SoundConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IAudioConfiguration SoundConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the configuration of the PSG (AY-3-8912 chip) sound device (such as sampling frequency, and others).
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt; provides more details.&lt;/p&gt;

&lt;h2 id=&quot;audiosamples&quot;&gt;AudioSamples&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AudioSamples AudioSamples { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the PSG (AY-3-8912 chip) sound samples of the current screen rendering frame. The 
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt; type describes how you can access individual samples.&lt;/p&gt;

&lt;h2 id=&quot;breakpoints&quot;&gt;Breakpoints&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public CodeBreakpoints Breakpoints { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This property allows you to manage the breakpoints. When you run the virtual machine
in debug mode (see the &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug()&lt;/code&gt; method), the virtual machine is paused whenever
it reaches a breakpoint. The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-codebreakpoints-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBreakpoints&lt;/code&gt;&lt;/a&gt; documentation gives 
you more clues.&lt;/p&gt;

&lt;h2 id=&quot;timeoutinms&quot;&gt;TimeoutInMs&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutInMs { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can start the virtual machine with a timeout value. When the specified
timeout expires, the virtual machine pauses. With the &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; property,
you can set up this value given in milliseconds.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Internally, the virtual machine transforms this value into CPU T-states according to
the clock frequency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;timeouttacts&quot;&gt;TimeoutTacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutTacts { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this property, you can specify the timeout value in CPU T-states. Providing the CPU uses
a
3.5 MHz clock, setting &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutTacts&lt;/code&gt; to 3500 equals to set &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; to 1.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Specifying zero value for &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutTacts&lt;/code&gt; means that there’s no explicit
timeout, thus the virtual machine runs until explicitly stopped or paused in the code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;realtimemode&quot;&gt;RealTimeMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool RealTimeMode { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Normally, scripting runs the virtual machine in quick mode, so it continuously runs the
CPU and renders the screen. It does not sync the machine with the screen rendering
frequency. If you set this property to true, the virtual machine will run with the same speed
as a physical machine would do.&lt;/p&gt;

&lt;h2 id=&quot;disablescreenrendering&quot;&gt;DisableScreenRendering&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool DisableScreenRendering { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Setting this property to true would disable the screen rendering, and so the virtual
machine would faster. Nonetheless, in this mode — as the screen is not remdered
— you cannot use &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt; to check the contents of the rendered frame. 
After the machine starts, the contents remains the same.&lt;/p&gt;

&lt;h2 id=&quot;machinestate&quot;&gt;MachineState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public VmState MachineState { get; private set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This property allows you to check the current state of the virtual machine.
Take a look at the &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt; enumeration for details about the
possible states.&lt;/p&gt;

&lt;h2 id=&quot;executioncompletionreason&quot;&gt;ExecutionCompletionReason&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ExecutionCompletionReason ExecutionCompletionReason { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The virtual machine can go into paused or stopped state for many reasons.
The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executioncompletionreason-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutionCompletionReason&lt;/code&gt;&lt;/a&gt; enumeration allows you to check what
event has caused that the machine is in a specific state.&lt;/p&gt;

&lt;h2 id=&quot;runsindebugmode&quot;&gt;RunsInDebugMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool RunsInDebugMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtual machine runs in debug mode.&lt;/p&gt;

&lt;h2 id=&quot;completiontask&quot;&gt;CompletionTask&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Task CompletionTask { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After th virtual machine has been started, it runs in a background thread.
While it runs, you can use the UI thread for other activities. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property can be used to wait for the completion of
the virtual machine (it gets paused or stopped).&lt;/p&gt;

&lt;p&gt;For example, this sample starts the virtual machine id debug mode, does
some other activity on the UI thread, and then wait while the machine reaches
its firs breakpoint:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
// --- Set up breakpoints (omitted from code)
sm.StartDebug();
// --- Do something on UI thread (omitted from code)
await sm.CompletionTask;
// --- Go on on UI thread
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cachedvmstatefolder&quot;&gt;CachedVmStateFolder&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string CachedVmStateFolder { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can speed up the virtual machine startup by starting it from its
saved state. The scripting engine stores these state files (with &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmstate&lt;/code&gt; extension)
in a cache folder. By default, it is the current folder.
With setting &lt;code class=&quot;highlighter-rouge&quot;&gt;CachedVmStateFolder&lt;/code&gt;, you can specify the storage location
of these state files.&lt;/p&gt;

&lt;h1 id=&quot;control-methods-and-properties&quot;&gt;Control Methods and Properties&lt;/h1&gt;

&lt;p&gt;The Spectrum virtual machine’s execution cycle — the one that executes CPU instruction,
takes care of rendering the screen and sound — runs on a background thread. With the control
methods, you can start, pause, and stop the machine in multiple ways. When you need to wait for the
completion of the execution cycle, you can use the [CompletionTask] property.&lt;/p&gt;

&lt;h2 id=&quot;isfirststart&quot;&gt;IsFirstStart&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsFirstStart { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Signs that this is the very first start of the virtual machine.&lt;/p&gt;

&lt;h2 id=&quot;isfirstpause&quot;&gt;IsFirstPause&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsFirstPause { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Signs that this is the very first pause of the virtual machine after its first start.&lt;/p&gt;

&lt;h2 id=&quot;start&quot;&gt;Start()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine in continuous execution mode. It runs unless the script pauses or
stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;startexecutecycleoptions&quot;&gt;Start(ExecuteCycleOptions)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Start(ExecuteCycleOptions options)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine with the specified execution mode (see also &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executecycleoptions-class&quot;&gt;ExecuteCycleOptions&lt;/a&gt;).
The machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;startdebug&quot;&gt;StartDebug()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StartDebug()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine in debug mode and sets the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunsInDebugMode&lt;/code&gt; property to true. Whenever the execution flow reaches a breakpoint, the machine gets
paused. Additionally, the machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilhalt&quot;&gt;RunUntilHalt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilHalt();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until it reaches a HALT instruction, then is gets
paused. Otherwise, the machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilframecompletion&quot;&gt;RunUntilFrameCompletion()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilFrameCompletion()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until the current screen rendering frame is 
completed. Then it gets paused. Otherwise, the machine runs unless the script pauses or stops it, or 
the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilterminationpointushort-int&quot;&gt;RunUntilTerminationPoint(ushort, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilTerminationPoint(ushort address, int romIndex = 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until the CPU reaches the specified 
termination point (address). At that point the machine gets paused. Otherwise, the machine runs unless 
the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h3 id=&quot;arguments-1&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;: The address at which to pause the machine&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;romIndex&lt;/code&gt;: If the address is within the ROM, romIndex specified the index of the ROM that should 
be selected to pause the machine.&lt;/p&gt;

&lt;h3 id=&quot;sample-1&quot;&gt;Sample&lt;/h3&gt;

&lt;p&gt;You can start and run a ZX Spectrum 48K virtual machine while it reaches the main execution cycle
point (&lt;code class=&quot;highlighter-rouge&quot;&gt;#12A9&lt;/code&gt;) in the ROM:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
sm.RunUntilTerminationPoint(0x12A9);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;startandruntomainbool&quot;&gt;StartAndRunToMain(bool)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task StartAndRunToMain(bool spectrum48Mode = false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A convenience method that starts the virtual machine and pauses it when it reaches its main
execution cycle. The method can be used to wait while the machine pauses.&lt;/p&gt;

&lt;h3 id=&quot;arguments-2&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spectrum48Mode&lt;/code&gt;: Setting this flag to true, ZX Spectrum 128K and later models are started in
Spectrum 48 BASIC mode&lt;/p&gt;

&lt;h3 id=&quot;remarks&quot;&gt;Remarks&lt;/h3&gt;

&lt;p&gt;Behind the scenes, this method does a lot of things for you:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First it checks, if there’s a saved machine state image for the machine model. If there is, 
it simply loads that state and puts the machine into paused state.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Otherwise, according to the machine type and the &lt;code class=&quot;highlighter-rouge&quot;&gt;spectrum48Mode&lt;/code&gt; flag, it determines the 
termination point.
    &lt;ul&gt;
      &lt;li&gt;It starts the virtual machine and runs it to the desired termination point.&lt;/li&gt;
      &lt;li&gt;While doing this, the method emulates key strokes so that the machine could start
in the desired mode.&lt;/li&gt;
      &lt;li&gt;After the termination mode is reached, pauses the machine and saves its state so that the
next startup would be faster.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The method retrieves the &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property so that you can wait for completion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sample-2&quot;&gt;Sample&lt;/h3&gt;

&lt;p&gt;This code snippet starts a ZX Spectrum 128K virtual machine in 48 mode, and waits while the 
machine reaches the main execution cycle.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum128Pal();
await sm.StartAndRunToMain(true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pause&quot;&gt;Pause()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task Pause()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pauses the running Spectrum virtual machine. After it is paused, you can continue the execution
with any of these methods: &lt;code class=&quot;highlighter-rouge&quot;&gt;Start()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Start(ExecutionCycleOptions)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilHalt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilFrameCompletion()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilTerminationPoint()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stop&quot;&gt;Stop()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task Stop()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Stops the running or paused Spectrum virtual machine. After it is stopped, you can resttart 
the execution with any of these methods: &lt;code class=&quot;highlighter-rouge&quot;&gt;Start()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Start(ExecutionCycleOptions)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilHalt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilFrameCompletion()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilTerminationPoint()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stepinto&quot;&gt;StepInto()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StepInto()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Executes the subsequent Z80 instruction, and then pauses the machine. As the execution happens 
on a background thread, you should wait for the completion with the &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
// --- Do something with the machine and then pause (code omitted)
sm.StepInto();
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;stepover&quot;&gt;StepOver()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StepOver()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Executes the subsequent Z80 CALL, RST, or block instruction (such as LDIR, LDDR, CPIR, etc.) entirely.
For example, when the subsequent instruction is a CALL, the machine gets paused as the engine detects
that the control flow is right on the next instruction after CALL (when the subroutine returned). By
using it, you do not have to step through all instructions one-by-one with &lt;code class=&quot;highlighter-rouge&quot;&gt;StepInto()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This method has a potential issue. If the method does not return to the expected location, for example,
it manipulates the stack, the virtual machine would not pause. It is definitely an issue with &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #08&lt;/code&gt; on
a ZX Spectrum 128K model, or with &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #28&lt;/code&gt; on ZX Spectrum 48K. In the future, I am going to examine how
I can handle this issue — now, it is not perfect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;machine-state-management-methods&quot;&gt;Machine state management methods&lt;/h1&gt;

&lt;p&gt;The scripting provides simple methods to save and loade the current state of the virtual machine. This state
is composed from the state of each individual devices of the machine, including the CPU, memory, screen, 
beeper, sound devices, and all the others. WHile the machine is running, you cannot save the state, first you
should pause it.&lt;/p&gt;

&lt;p&gt;You can load the state when the machine is newly created, paused, or stopped.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are some limitations of state file handling. When you pause the machine while it’s loading a program 
from the tape and save its state, after restoring it cannot continue loading from the tape. The reason
behind this behavior is that the state file does not contain the data that represents the tape.
I’m investigating the possible resolutions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The virtual machine state files (with &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmstate&lt;/code&gt; extension) are simple JSON files, so you can open them
and check their structure to get more details on what’s within them. You can recognize that the contents 
of the memory is compressed. A Spectrum 48K state file takes about 25KBytes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;savemachinestatetostring&quot;&gt;SaveMachineStateTo(string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void SaveMachineStateTo(string filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Saves the state of the paused virtual machine to the specified file.&lt;/p&gt;

&lt;h3 id=&quot;arguments-3&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt;: Name of the file to save the machine state&lt;/p&gt;

&lt;h2 id=&quot;restoremachinestatestring&quot;&gt;RestoreMachineState(string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RestoreMachineState(string filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loads the state of the paused or stopped machine from the specified file. When you continue the 
execution, the machine will start from the freshly loaded state.&lt;/p&gt;

&lt;h3 id=&quot;arguments-4&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt;: Name of the file that contains the machine state&lt;/p&gt;

&lt;h1 id=&quot;code-manipulation-methods&quot;&gt;Code manipulation methods&lt;/h1&gt;

&lt;p&gt;While the virtual machine is stopped, you can inject code into the memory so that you can execute it.
You do not need to use the [Memory] property of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt; to do this. There are a few methods
that makes it extremely easy.&lt;/p&gt;

&lt;h2 id=&quot;injectcodeushort-byte-array&quot;&gt;InjectCode(ushort, byte array)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void InjectCode(ushort address, byte[] codeArray)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Injects code into the memory. Keeps the machine in paused state.&lt;/p&gt;

&lt;h3 id=&quot;arguments-5&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;: Start address of the injection&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;codeArray&lt;/code&gt;: A byte array that contains the machine code bytes in the order of injection&lt;/p&gt;

&lt;h2 id=&quot;injectcodestring-assembleroptions&quot;&gt;InjectCode(string, AssemblerOptions)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort InjectCode(string asmSource, AssemblerOptions options = null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This powerful method allows you to define the code to inject, in Z80 assembler language, using
all features the language provides. In the &lt;strong&gt;SpectNetIde&lt;/strong&gt; assembler, you can create multiple 
code segments, and this method injects all cade segments.&lt;/p&gt;

&lt;h3 id=&quot;arguments-6&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;asmSource&lt;/code&gt;: The Z80 Assembler source code&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;options&lt;/code&gt;: Optional options to compile the source code. See &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-assembleroptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AssemblerOptions&lt;/code&gt;&lt;/a&gt; more details.&lt;/p&gt;

&lt;h3 id=&quot;returns-1&quot;&gt;Returns&lt;/h3&gt;

&lt;p&gt;The address marked as the entry point (&lt;code class=&quot;highlighter-rouge&quot;&gt;ENT&lt;/code&gt; directive in the source code), or the start 
address (&lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; directive) of the first code block in the source code.&lt;/p&gt;

&lt;h2 id=&quot;callcodeushort-ushort&quot;&gt;CallCode(ushort, ushort?)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void CallCode(ushort startAddress, ushort? callStubAddress = null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Calls the code at the specified subroutine start address.&lt;/p&gt;

&lt;h3 id=&quot;arguments-7&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddress&lt;/code&gt;: Start address of the subroutine&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress&lt;/code&gt;: Optional address for the call stub&lt;/p&gt;

&lt;h3 id=&quot;remarks-1&quot;&gt;Remarks&lt;/h3&gt;

&lt;p&gt;This method creates a Z80 CALL instruction, and stores it to the specified &lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress&lt;/code&gt;.
If this parameter is omitted (set to &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;), the &lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA0&lt;/code&gt; address (empty area after system variables)
is used. Then, the virtual machine starts and pauses at the termination point of 
&lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress + 3&lt;/code&gt; (by default, &lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA3&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;sample-using-code-injection&quot;&gt;Sample using code injection&lt;/h2&gt;

&lt;p&gt;The following sample injects and executes code that sets the color of the background to blue.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
await sm.StartAndRunToMain();
var entryAddr = sm.InjectCode(@&quot;
    .org #8000
    ld a,1       ; BLUE
    out (#FE),a  ; Set the border colour to blue
    ret          ; Finished
&quot;);
sm.CallCode(entryAddr);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Instead of call, you can jump directly to the code. Nonetheless, in this case you cannot complete
your code with &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt;, you should jump back to the main execution cycle of the machine, as this
sample shows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
await sm.StartAndRunToMain();
var entryAddr = sm.InjectCode(@&quot;
    .org #8000
    ld a,1       ; BLUE
    out (#FE),a  ; Set the border colour to blue
    jp #12A2     ; Finished
&quot;);
sm.Cpu.PC = entryAddr;
// --- Set up breakpoints (omitted from code)
sm.StartDebug();
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;virtual-machine-events&quot;&gt;Virtual machine events&lt;/h1&gt;

&lt;p&gt;The virtual machine provides events you can use to examine and analyze the state of the machine.&lt;/p&gt;

&lt;h2 id=&quot;vmstatechanged&quot;&gt;VmStateChanged&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;VmStateChangedEventArgs&amp;gt; VmStateChanged;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised whenever the state of the virtual machine changes.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;VmStateChangedEventArgs&lt;/code&gt; class has these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public VmState OldState { get; }
public VmState NewState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As theor names suggest, you can obtain the old and the new state (&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt;) of the machine.&lt;/p&gt;

&lt;h2 id=&quot;vmstoppedwithexception&quot;&gt;VmStoppedWithException&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;VmStoppedWithExceptionEventArgs&amp;gt; VmStoppedWithException;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Whenever the Spectrum virtual machine stops because of an exception, this event is raised. Normally,
this event should not happen, it signs that there’s some unexpected issue (programming error) within
&lt;strong&gt;SpectNetIde&lt;/strong&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;VmStoppedWithExceptionEventArgs&lt;/code&gt; has this property to check what is the exception
that caused the machine stop:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Exception Exception { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vmframecompleted&quot;&gt;VmFrameCompleted&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler VmFrameCompleted;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To sign that the virtual machine just has completed a new screen rendering frame, this event is raised.&lt;/p&gt;

&lt;h1 id=&quot;the-assembleroptions-class&quot;&gt;The AssemblerOptions class&lt;/h1&gt;

&lt;p&gt;This class represents the options that can be used when the Z80 Assembler compiles
the source code to machine code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler.Assembler&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class AssemblerOptions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;predefinedsymbols&quot;&gt;PredefinedSymbols&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;string&amp;gt; PredefinedSymbols { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Predefined compilation symbols that can be checked with the &lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#ifndef&lt;/code&gt;, and other
directives.&lt;/p&gt;

&lt;h2 id=&quot;defaultstartaddress&quot;&gt;DefaultStartAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort? DefaultStartAddress { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The default start address of the compilation. If there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; pragma specified in 
the source code, this address is used.&lt;/p&gt;

&lt;h2 id=&quot;defaultdisplacement&quot;&gt;DefaultDisplacement&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int? DefaultDisplacement { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The default displacement of the compilation. If there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; pragma specified in 
the source code, this address is used. If set to null, no displacement is used.&lt;/p&gt;

&lt;h2 id=&quot;currentmodel&quot;&gt;CurrentModel&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SpectrumModelType CurrentModel { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Specifies the Spectrum model to use in the source code. By default it is set to Spectrum 48K. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelType&lt;/code&gt; enumeration has these values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Machine type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spectrum48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum 48K&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spectrum128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum 128K&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumP3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum +3E&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Next&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum Next&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-codebreakpoints-class&quot;&gt;The CodeBreakpoints class&lt;/h1&gt;

&lt;p&gt;Represents the breakpoint of the Spectrum virtual machine, at which execution should be
paused when running in debug mode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class CodeBreakpoints
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count&quot;&gt;Count&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Count { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of breakpoint defined.&lt;/p&gt;

&lt;h2 id=&quot;addbreakpointushort&quot;&gt;AddBreakpoint(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void AddBreakpoint(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Adds a breakpoint for the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;removebreakpointushort&quot;&gt;RemoveBreakpoint(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RemoveBreakpoint(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Removes the breakpoint from the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;clearallbreakpoints&quot;&gt;ClearAllBreakpoints()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ClearAllBreakpoints()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Clears all previously declared breakpoints.&lt;/p&gt;

&lt;h2 id=&quot;hasbreakpointatushort&quot;&gt;HasBreakpointAt(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool HasBreakpointAt(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checks if there is a breakpoint definied for the given &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-executecycleoptions-class&quot;&gt;The ExecuteCycleOptions class&lt;/h1&gt;

&lt;p&gt;This class provides options for the execution cycle of the Spectrum virtual machine. When you start
the cycle, you can pass execution options that influence the machine cycle and specifies when the
machine should be paused.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Machine&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ExecuteCycleOptions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;emulationmode&quot;&gt;EmulationMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public EmulationMode EmulationMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The emulation mode that should be used. The values of the &lt;code class=&quot;highlighter-rouge&quot;&gt;EmulationMode&lt;/code&gt; enumeration are these:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Continuous&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the virtual machine until stopped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Debugger&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the virtual machine in debug mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilHalt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Run the virtual machine until the CPU is halted&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilFrameEnds&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the machine until the current ULA rendering frame ends&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilExecutionPoint&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Run the machine until the specified value of the PC register is reached&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;debugstepmode&quot;&gt;DebugStepMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public DebugStepMode DebugStepMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the emulation mode is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;Debugger&lt;/code&gt;, this property specifies the mode to run a debug-mode
execution cycle. The values of &lt;code class=&quot;highlighter-rouge&quot;&gt;DebugStepMode&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StopAtBreakpoint&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops at the next breakpoint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StepInto&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops after the next instruction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StepOver&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops after the next instruction. If that should be a subroutine call or a block statement, the execution stops after returning from the subroutine or completing the block statement.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;fasttapemode&quot;&gt;FastTapeMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool FastTapeMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if fast loading from the tape is allowed.&lt;/p&gt;

&lt;h2 id=&quot;terminationrom&quot;&gt;TerminationRom&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int TerminationRom { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The index of the ROM when a termination point is defined.&lt;/p&gt;

&lt;h2 id=&quot;terminationpoint&quot;&gt;TerminationPoint&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort TerminationPoint { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of the PC register to reach when &lt;code class=&quot;highlighter-rouge&quot;&gt;EmulationMode&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;UntilExecutionPoint&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;skipinterruptroutine&quot;&gt;SkipInterruptRoutine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool SkipInterruptRoutine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Signs if the instructions within the maskable interrupt routine should be skipped during debugging.&lt;/p&gt;

&lt;h2 id=&quot;fastvmmode&quot;&gt;FastVmMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool FastVmMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This flag indicates that the virtual machine should run in hidden mode (no screen, no sound, no delays).&lt;/p&gt;

&lt;h2 id=&quot;disablescreenrendering-1&quot;&gt;DisableScreenRendering&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool DisableScreenRendering { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This flag shows whether the virtual machine should render the screen when runs in &lt;code class=&quot;highlighter-rouge&quot;&gt;FastVmMode&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;timeouttacts-1&quot;&gt;TimeoutTacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutTacts { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can specify a timeout value (given in CPU tacts). If this is set to zero, no timeout is applied.
If set to a value greater than zero, after the specified number of CPU cycles ellapsed, the execution of
the virtual machine is paused.&lt;/p&gt;

&lt;h1 id=&quot;the-executioncompletionreason-enum&quot;&gt;The ExecutionCompletionReason enum&lt;/h1&gt;

&lt;p&gt;The values of this enumeration tells the reason the virtual machine is in paused or in stopped state.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public enum ExecutionCompletionReason
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The machine is still executing, or it has not been ever started&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cancelled&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The execution has explicitly cancelled by the user or by the scripting code&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timeout&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The specified timeout period expired&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TerminationPointReached&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine reached its termintation point specified by its start&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BreakpointReached&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine reached a breakpoint during its execution in debug mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Halted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtaul machine reached a &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; statement and paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameCompleted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has just rendered a new screen frame and paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine stopped because of an unexpected exception&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-keyboardemulator-class&quot;&gt;The KeyboardEmulator class&lt;/h1&gt;

&lt;p&gt;This class is reserved for future extension. Right now, id does not offer any property or method for scripting.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class KeyboardEmulator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;the-vmstate-enum&quot;&gt;The VmState enum&lt;/h1&gt;

&lt;p&gt;The values of this enumeration show the possible states of a ZX Spectrum virtual machine.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has just been created, but has not run yet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnig&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine is successfully started in the background&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pausing&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The pause request has been sent to the virtual machine, now it prepares to get paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Paused&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has been paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stopping&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The stop request has been sent to the virtual machine, now it prepares to get stopped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stopped&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has been stopped&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-spectrummodels-class&quot;&gt;The SpectrumModels class&lt;/h1&gt;

&lt;p&gt;This class is a repository of all Spectrum models and editions supported 
by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static class SpectrumModels
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-stockmodels-property&quot;&gt;The StockModels property&lt;/h2&gt;

&lt;p&gt;You can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;StockModels&lt;/code&gt; property to access the dictionary of
available ZX Spectrum models.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static IReadOnlyDictionary&amp;lt;string, SpectrumModelEditions&amp;gt; StockModels;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each model has a unique name to look up the associated editions in the dictionary.
A &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEditions&lt;/code&gt; instance is a collection of all editions of the 
particular model. A single edition is represented by a &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEdition&lt;/code&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;constants-used-for-models-and-editions&quot;&gt;Constants used for models and editions&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; class provides these constants for the unique model names and editions:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Constant value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum 48K&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum 128K&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_P3_E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum +3E&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_NEXT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum Next&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAL&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NTSC&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL_2_X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAL2X&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC_2_X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NTSC2X&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;model-access&quot;&gt;Model access&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; provides properties to directly access the 
&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEdition&lt;/code&gt; instances of frequently used machine types:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumEdition ZxSpectrum48Pal;
public static SpectrumEdition ZxSpectrum48Ntsc;
public static SpectrumEdition ZxSpectrum48Pal2X;
public static SpectrumEdition ZxSpectrum48Ntsc2X;
public static SpectrumEdition ZxSpectrum128Pal;
public static SpectrumEdition ZxSpectrumP3EPal;
public static SpectrumEdition ZxSpectrumNextPal;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These properties are associated with these model and edition key constants:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Property&lt;/th&gt;
      &lt;th&gt;Model key&lt;/th&gt;
      &lt;th&gt;Edition key&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Pal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Ntsc&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Pal2X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL2X&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Ntsc2X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC2X&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum128Pal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrumP3EPal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrumNext&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_NEXT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">The SpectrumVmFactory class</summary></entry><entry><title type="html">Scripting the Screen</title><link href="http://localhost:4000/spectnetide/documents/scripting-screen" rel="alternate" type="text/html" title="Scripting the Screen" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-screen</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-screen">&lt;h1 id=&quot;the-screenconfiguration-class&quot;&gt;The ScreenConfiguration class&lt;/h1&gt;

&lt;p&gt;This class represents the configuration of the virtual machine’s screen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ScreenConfiguration : IScreenConfiguration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen rendering mechanism uses a large number of configuration options that provides
the timing so that the CPU and the rendering hardware can work in tandem. The software 
emulation implements the same mechanism.&lt;/p&gt;

&lt;p&gt;As the following figure shows, the screen has visible and non-visible areas, just as in the
case of the real hardware. Originally, the non-visible area was required by the cathode-ray tube
so that the electron beam could sync the screen rendering properly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/scripting/spectrum-screen.png&quot; alt=&quot;Screen Dimensions&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;screenwidth&quot;&gt;ScreenWidth&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenWidth { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The width of the visible screen area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;screenlines&quot;&gt;ScreenLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The height of the visible screen area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;displaywidth&quot;&gt;DisplayWidth&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayWidth { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The width of the display area in pixels (256).&lt;/p&gt;

&lt;h2 id=&quot;displaylines&quot;&gt;DisplayLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The height of the display area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;nonvisiblebordertoplines&quot;&gt;NonVisibleBorderTopLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderTopLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of top border lines that are not visible when rendering the screen.&lt;/p&gt;

&lt;h2 id=&quot;bordertoplines&quot;&gt;BorderTopLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderTopLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border lines above the display area.&lt;/p&gt;

&lt;h2 id=&quot;borderbottomlines&quot;&gt;BorderBottomLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderBottomLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border lines below the display area.&lt;/p&gt;

&lt;h2 id=&quot;nonvisibleborderbottomlines&quot;&gt;NonVisibleBorderBottomLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderBottomLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of bottom border lines that are not visible when rendering the screen.&lt;/p&gt;

&lt;h2 id=&quot;verticalsynclines&quot;&gt;VerticalSyncLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int VerticalSyncLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Number of lines used for vertical synch.&lt;/p&gt;

&lt;h2 id=&quot;borderlefttime&quot;&gt;BorderLeftTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderLeftTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPY T-cycles of displaying the left part of the border.&lt;/p&gt;

&lt;h2 id=&quot;borderleftpixels&quot;&gt;BorderLeftPixels&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderLeftPixels { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border pixels to the left of the display (&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * BorderLeftTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;borderrighttime&quot;&gt;BorderRightTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderRightTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPY T-cycles of displaying the right part of the border.&lt;/p&gt;

&lt;h2 id=&quot;borderrightpixels&quot;&gt;BorderRightPixels&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderRightPixels { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border pixels to the right of the display (&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * BorderRightTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;nonvisibleborderrighttime&quot;&gt;NonVisibleBorderRightTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderRightTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time given in CPY T-cycles to render the nonvisible right part of the border.&lt;/p&gt;

&lt;h2 id=&quot;horizontalblankingtime&quot;&gt;HorizontalBlankingTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int HorizontalBlankingTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Horizontal blanking time (HSync + blanking) given in CPU T-cycles.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt; class provides other properties that are related to screen rendering.&lt;/p&gt;

&lt;h2 id=&quot;interrupttact&quot;&gt;InterruptTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int InterruptTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact index of the interrupt signal relative to the top-left screen pixel&lt;/p&gt;

&lt;h2 id=&quot;firstdisplayline&quot;&gt;FirstDisplayLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstDisplayLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen line number of the first display line (`VerticalSyncLines&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;NonVisibleBorderTopLines + BorderTopLines`).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lastdisplayline&quot;&gt;LastDisplayLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int LastDisplayLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen line number of the last display line (&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine + DisplayLines - 1&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;displaylinetime&quot;&gt;DisplayLineTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayLineTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time of rendering a display pixel row, given in CPU T-cycles.&lt;/p&gt;

&lt;h2 id=&quot;screenlinetime&quot;&gt;ScreenLineTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenLineTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time of rendering an entire raster line, given in CPU T-cycles (&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderLeftTime + 
DisplayLineTime + BorderRightTime + NonVisibleBorderRightTime + HorizontalBlankingTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;rasterlines&quot;&gt;RasterLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RasterLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of raster lines in the screen (&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine + DisplayLines + BorderBottomLines + NonVisibleBorderBottomLines&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;firstdisplaypixeltact&quot;&gt;FirstDisplayPixelTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstDisplayPixelTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact in which the top left display pixel should be rendered, given in CPU T-cycles
(&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine * ScreenLineTime + BorderLeftTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;firstscreenpixeltact&quot;&gt;FirstScreenPixelTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstScreenPixelTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact in which the top left screen pixel (border) should be displayed
(&lt;code class=&quot;highlighter-rouge&quot;&gt;[VerticalSyncLines + NonVisibleBorderTopLines] * ScreenLineTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingframetactcount&quot;&gt;ScreenRenderingFrameTactCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenRenderingFrameTactCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPU T-cycles used for the full rendering of the screen
(&lt;code class=&quot;highlighter-rouge&quot;&gt;RasterLines * ScreenLineTime&lt;/code&gt;).&lt;/p&gt;

&lt;h1 id=&quot;methods&quot;&gt;Methods&lt;/h1&gt;

&lt;p&gt;The class provides a few helper methods.&lt;/p&gt;

&lt;h2 id=&quot;istactvisibleint-int&quot;&gt;IsTactVisible(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsTactVisible(int line, int tactInLine)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tests whether the specified tact is in the visible area of the screen. Returns true, if
the tact renders the visible part of the screen; otherwise, false.&lt;/p&gt;

&lt;h3 id=&quot;arguments&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;line&lt;/code&gt;: Raster line index&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tactInLine&lt;/code&gt;: Tact index within the line&lt;/p&gt;

&lt;h2 id=&quot;istactindisplayareaint-int&quot;&gt;IsTactInDisplayArea(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsTactInDisplayArea(int line, int tactInLine)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tests whether the specified tact is in the display area of the screen. Returns true, if
the tact renders the display part of the screen; otherwise, false.&lt;/p&gt;

&lt;h3 id=&quot;arguments-1&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;line&lt;/code&gt;: Raster line index&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tactInLine&lt;/code&gt;: Tact index within the line&lt;/p&gt;

&lt;h1 id=&quot;the-screenbitmap-class&quot;&gt;The ScreenBitmap class&lt;/h1&gt;

&lt;p&gt;This class represents the current screen’s pixels, including the border. Every byte stands for a palette
index. The value of a pixel can be &lt;code class=&quot;highlighter-rouge&quot;&gt;#00&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#0F&lt;/code&gt; on a Spectrum 48K, 128K, and +3E model. On ZX Spectrum Next,
the value is the entire byte range from &lt;code class=&quot;highlighter-rouge&quot;&gt;#00&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#FF&lt;/code&gt;. The content is read-only, you cannot change it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenBitmap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisint&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte[] this[int lineNo] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves a byte array for the raster line specified in &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lineNo&lt;/code&gt;&lt;/em&gt;. The value at zero index represent 
the leftmost border pixel of the line. The last item in the array is the rightmost pixel in the line.&lt;/p&gt;

&lt;h2 id=&quot;thisint-int&quot;&gt;this[int, int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int row, int column] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves the byte for the screen pixel in the given &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;&lt;/em&gt; of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;row&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;getdisplaypixelint-int&quot;&gt;GetDisplayPixel(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte GetDisplayPixel(int row, int col)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;this[int, int]&lt;/code&gt; retrieves the specified screen pixel, this method obtains the display pixel of 
(&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;row&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;&lt;/em&gt;).&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingstatus-class&quot;&gt;The ScreenRenderingStatus class&lt;/h1&gt;

&lt;p&gt;Provides properties about the current screen rendering status of the machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingStatus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;currentframetact&quot;&gt;CurrentFrameTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int CurrentFrameTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of the current tact within the frame being rendered.&lt;/p&gt;

&lt;h2 id=&quot;rasterline&quot;&gt;RasterLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RasterLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of the current raster line in the frame being rendered.&lt;/p&gt;

&lt;h2 id=&quot;currentrenderingtact&quot;&gt;CurrentRenderingTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTact CurrentRenderingTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets details about the current tact in the frame being rendered. See more details
in the description of &lt;a href=&quot;ScreenRenderingTact.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingtable-class&quot;&gt;The ScreenRenderingTable class&lt;/h1&gt;

&lt;p&gt;Represents the screen rendering table of the virtual machine&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingTable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count&quot;&gt;Count&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Count { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of items in the screen rendering table.&lt;/p&gt;

&lt;h2 id=&quot;thisint-1&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTact this[int index] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the entry of the screen rendering table specified by &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;. See more details
in the description of &lt;a href=&quot;ScreenRenderingTact.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingtact-class&quot;&gt;The ScreenRenderingTact class&lt;/h1&gt;

&lt;p&gt;Provides details about a screen rendering tact.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingTact
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;phase&quot;&gt;Phase&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingPhase Phase { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The rendering phase to be applied for the particular tact. The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingPhase&lt;/code&gt; enum
has these values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA does not do any rendering&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Border&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderFetchPixel&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel. It prepares to display the fist pixel in the row with prefetching the corresponding byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderFetchPixelAttr&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel. It has already fetched the 8 pixel bits to display. It carries on preparing to display the fist pixel in the row with prefetching the corresponding attribute byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte1 sequentially during a single Z80 clock cycle.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB1FetchB2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding attribute from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2FetchB1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2FetchA1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding attribute from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;contentiondelay&quot;&gt;ContentionDelay&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte ContentionDelay { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Contention delay during the particular screen rendering tact, provided, the CPU is reading 
or writing data in the screen memory area (&lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#7FFF&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;pixelbytetofetchaddress&quot;&gt;PixelByteToFetchAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort PixelByteToFetchAddress { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Display memory address used in the particular tact to fetch the pixel value.&lt;/p&gt;

&lt;h2 id=&quot;attributetofetchaddress&quot;&gt;AttributeToFetchAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort AttributeToFetchAddress { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Display memory address used in the particular tact to fetch the attribute of a pixel.&lt;/p&gt;

&lt;h2 id=&quot;xpos&quot;&gt;XPos&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort XPos { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The X position of the pixel in screen coordinates.&lt;/p&gt;

&lt;h2 id=&quot;ypos&quot;&gt;YPos&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort YPos { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Y position of the pixel in screen coordinates.&lt;/p&gt;</content><author><name></name></author><summary type="html">The ScreenConfiguration class</summary></entry><entry><title type="html">Scripting Object Model</title><link href="http://localhost:4000/spectnetide/documents/scripting-object-model" rel="alternate" type="text/html" title="Scripting Object Model" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-object-model</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-object-model">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; offers a set of .NET objects that you can use to create scripts that automate
everyday tasks with ZX Spectrum virtual machines. You can use these objects in any .NET Framework
application, or in scripting languages that allow accessing .NET Framework objects.&lt;/p&gt;

&lt;p&gt;To use &lt;strong&gt;SpectNetIde&lt;/strong&gt; scripting, add these assemblies to your projects:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Assembly&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The Z80 Assembler of &lt;strong&gt;SpectNetIde&lt;/strong&gt;. With the help of this component, you can use Z80 source code in scripts.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.RomResources&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;This assembly stores the ROMs of the Spectrum models supported by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectNet.SpectrumEmu&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;This assembly implements the ZX Spectrum emulator and the scripting object model.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;zx-spectrum-virtual-machines&quot;&gt;ZX Spectrum virtual machines&lt;/h2&gt;

&lt;p&gt;The scripting object model supports these ZX Spectrum models:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ZX Spectrum 48K&lt;/li&gt;
  &lt;li&gt;ZX Spectrum 128K&lt;/li&gt;
  &lt;li&gt;ZX Spectrum +3E&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ZX Spectrum Next (still in development)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The virtual machines use a background thread for their execution cycle. You can run the machine
with synchronous methods, but you need to pause or stop them, or waiting while their cycle completes
with the &lt;code class=&quot;highlighter-rouge&quot;&gt;async/await&lt;/code&gt; pattern.&lt;/p&gt;

&lt;h2 id=&quot;scripting-objects&quot;&gt;Scripting objects&lt;/h2&gt;

&lt;p&gt;The table below contains a summary of the .NET types that constitute the ZX Spectrum scripting
object model. To get the shortest path to learn using them, I suggest starting with these documentations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Object type&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents tracking information regarding memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-assembleroptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AssemblerOptions&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the options that can be used when the Z80 Assembler compiles the source code to machine code.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class stores audio samples for the currently rendered virtual machine frame.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-codebreakpoints-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBreakpoints&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Represents the breakpoint of the Spectrum virtual machine, at which execution should pause when running in debug mode.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the Z80 CPU of a Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executecycleoptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecuteCycleOptions&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides options for the execution cycle of the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executioncompletionreason-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutionCompletionReason&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;The values of this enumeration tell the reason why the virtual machine is in a paused or stopped state.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This interface represents the configuration of the beeper/sound device.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-keyboardemulator-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;KeyboardEmulator&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class is reserved for future extension. Right now, id does not offer any property or method for scripting.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memorypaginginfo-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemoryPagingInfo&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides properties and methods to obtain information about ROM and RAM paging.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemorySlice&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a slice of the memory in the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-readonlymemoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlyMemorySlice&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a read-only slice of the memory in the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenbitmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the current screen’s pixels, including the border area.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the configuration of the virtual machine’s screen&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingstatus-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingStatus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Provides properties about the current screen rendering status of the machine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtable-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTable&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Represents the screen rendering table of the virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtact-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Provides details about a screen rendering tact.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-spectrummemorycontents-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumMemoryContents&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides access to the addressable 64KBytes memory contents of the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class is a repository of all Spectrum models and editions supported by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides methods you can use to create ZX Spectrum virtual machine instances.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;The values of this enumeration show the possible states of a ZX Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-z80instructionexecutioneventargs-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides event arguments the the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; events of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">SpectNetIde offers a set of .NET objects that you can use to create scripts that automate everyday tasks with ZX Spectrum virtual machines. You can use these objects in any .NET Framework application, or in scripting languages that allow accessing .NET Framework objects.</summary></entry><entry><title type="html">Scripting the Memory</title><link href="http://localhost:4000/spectnetide/documents/scripting-memory" rel="alternate" type="text/html" title="Scripting the Memory" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-memory</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-memory">&lt;h1 id=&quot;the-memorypaginginfo-class&quot;&gt;The MemoryPagingInfo class&lt;/h1&gt;

&lt;p&gt;This class provides properties and methods to obtain information about ROM and RAM paging.
Though it works with ZX Spectrum 48K model, it provides benefits only for higher models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class MemoryPagingInfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;selectedromindex&quot;&gt;SelectedRomIndex&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int SelectedRomIndex { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the index of the currently selected ROM.&lt;/p&gt;

&lt;h2 id=&quot;selectedrambankindex&quot;&gt;SelectedRamBankIndex&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int SelectedRamBankIndex { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the index of the selecter RAM bank for the &lt;code class=&quot;highlighter-rouge&quot;&gt;#C000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; address range.&lt;/p&gt;

&lt;h2 id=&quot;getbankindexforslotint&quot;&gt;GetBankIndexForSlot(int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int GetBankIndexForSlot(int slot)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the RAM bank index for the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slot&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are four slots, for the pages starting at &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#8000&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;#C000&lt;/code&gt;, respectively.
Slot index should be set accordingly, from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;usesshadowscreen&quot;&gt;UsesShadowScreen&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool UsesShadowScreen { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtual machine uses the shadow screen (Bit 3 of port #7FFD). If false, the normal
screen (Bank #5) is used. If true, the shadow screen (Bank #7) is displayed.&lt;/p&gt;

&lt;h2 id=&quot;isinallrammode&quot;&gt;IsInAllRamMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInAllRamMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtul machine (ZX Spectrum +3E and ZX Spectrum Next) machine is
in the special ALL RAM mode (Bit 0 of port #1FFD).&lt;/p&gt;

&lt;h1 id=&quot;the-memoryslice-class&quot;&gt;The MemorySlice class&lt;/h1&gt;

&lt;p&gt;This class represents a slice of the memory in the Spectrum virtual machine. Right now, it is used to
represent the contents of a RAM bank.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class MemorySlice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;size&quot;&gt;Size&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Size { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The size of the memory slice, given in number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;thisint&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int index] { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can get and set the byte at the &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; position in the memory slice.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Be aware, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; is not the absolute memory address of the byte, but a relative address from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;Size - 1&lt;/code&gt;. For RAM banks, &lt;code class=&quot;highlighter-rouge&quot;&gt;Size&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, thus you can address bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;the-readonlymemoryslice-class&quot;&gt;The ReadOnlyMemorySlice class&lt;/h1&gt;

&lt;p&gt;This class represents a read-only slice of the memory in the Spectrum virtual machine. Right now, it is used to
represent the contents of a ROM pages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ReadOnlyMemorySlice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;size-1&quot;&gt;Size&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Size { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The size of the memory slice, given in number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;thisint-1&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int index] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can get the byte at the &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; position in the memory slice. As the name of the class suggest,
you cannot change the contents of a read-only memory slice.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Be aware, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; is not the absolute memory address of the byte, but a relative address from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;Size - 1&lt;/code&gt;. For RAM banks, &lt;code class=&quot;highlighter-rouge&quot;&gt;Size&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, thus you can address bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;the-spectrummemorycontents-class&quot;&gt;The SpectrumMemoryContents class&lt;/h1&gt;

&lt;p&gt;This class provides access to the addressable 64KBytes memory contents of the Spectrum virtual machine.
An instance of the class allows reading and writeng the memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class SpectrumMemoryContents
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisushort&quot;&gt;this[ushort]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[ushort address] { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets or sets the contents of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;. Setting the content behaves as
in the real hardware: if you try to set a ROM address, the contents of the particular
memory address won’t change after the write operation.&lt;/p&gt;

&lt;h2 id=&quot;readtrackingstate&quot;&gt;ReadTrackingState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState ReadTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been read during a CPU operation.&lt;/p&gt;

&lt;h2 id=&quot;resetreadtracking&quot;&gt;ResetReadTracking()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetReadTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadTrackingState&lt;/code&gt; property as if no memory had been read.&lt;/p&gt;

&lt;h2 id=&quot;writetrackingstate&quot;&gt;WriteTrackingState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState WriteTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been written during a CPU operation.&lt;/p&gt;

&lt;h2 id=&quot;resetwritetracking&quot;&gt;ResetWriteTracking()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetWriteTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;WriteTrackingState&lt;/code&gt; property as if no memory had been read.&lt;/p&gt;</content><author><name></name></author><summary type="html">The MemoryPagingInfo class</summary></entry><entry><title type="html">Watch Samples</title><link href="http://localhost:4000/spectnetide/documents/watch-samples" rel="alternate" type="text/html" title="Watch Samples" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-samples</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-samples">&lt;p&gt;These samples help you to understand how powerful the watch expressions are:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[XPOS:W]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Displays the two bytes stored in the memory at the address pointed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;XPOS&lt;/code&gt; symbol.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[`Z ? XPOS : YPOS :W]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the Z flag is set, reads the two bytes stored at the &lt;code class=&quot;highlighter-rouge&quot;&gt;XPOS&lt;/code&gt; address; otherwise retrieves
the two bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;YPOS&lt;/code&gt; address.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DE*HL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Displays the value of DE and HL registers multiplied. The result is a double word (32 bits).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[#4000:DW] &amp;amp; [MASK:DW] :%32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Reads the four bytes stored at the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address. Uses the four bytes store at the 
address pointed by &lt;code class=&quot;highlighter-rouge&quot;&gt;MASK&lt;/code&gt; and executes a bitwise AND operation on these two 32-bit values.
Displays the result as a 32-bit binary vector.&lt;/p&gt;</content><author><name></name></author><summary type="html">These samples help you to understand how powerful the watch expressions are:</summary></entry><entry><title type="html">Watch Expressions</title><link href="http://localhost:4000/spectnetide/documents/watch-expressions" rel="alternate" type="text/html" title="Watch Expressions" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-expressions</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-expressions">&lt;p&gt;Although its name suggests that the Watch Memory window can display only values in the memory, the capabilities of this
tool are richer.&lt;/p&gt;

&lt;p&gt;You can define &lt;em&gt;watch expressions&lt;/em&gt; and define their &lt;em&gt;display format&lt;/em&gt;. For example, if you want to display for consecutive
bytes in the memory pointed by the HL register in bitvector format (32 bits), you can do this with this command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [HL :DW] :%32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Later, you need to display the 16-bit value in the memory address pointed by HL plus BC. You can use this command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [HL + BC :W] :W
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Watch expressions are arithmetic expression using C-like expression syntax. The engine behind the Watch Memory window
continuously evalutes these expressions, formats them and displays their values.&lt;/p&gt;

&lt;h2 id=&quot;expression-types&quot;&gt;Expression Types&lt;/h2&gt;

&lt;p&gt;When working with expressions, the engine uses for integral types, and automatically converts them:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Boolean&lt;/strong&gt;: Simple &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;. Any non-zero value is converted to &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;, zero is &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Byte&lt;/strong&gt;: 8-bit unsigned value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Word&lt;/strong&gt;: 16-bit unsigned value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Double word&lt;/strong&gt;: 32-bit unsigned value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When working with values, the expression engine automatically converts operation result to keep all valuable bits.
For example, when you multiply two bytes, the result will be a word. Multiplying a byte and a word results a double word.
Nonetheless, when you multiply two double words, the result will be a double word, so only the last 32 bits are kept.&lt;/p&gt;

&lt;p&gt;Comparisons and other logical operations result in booleans.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You do not need to deal with types, the evaluation engine does it for you. Sometimes you need signed types. With the
help of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:-B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;:-W&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;:-DW&lt;/code&gt; format specifiers, as you will learn later, you can display values in signed form.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;value-sources&quot;&gt;Value Sources&lt;/h2&gt;

&lt;p&gt;You have several value sources that you can use in expressions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Literal values (decimal, hexadecimal, binary, character)&lt;/li&gt;
  &lt;li&gt;Compilation symbols&lt;/li&gt;
  &lt;li&gt;Z80 register values&lt;/li&gt;
  &lt;li&gt;Z80 CPU flag values&lt;/li&gt;
  &lt;li&gt;ZX Spectrum memory contents&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the future you may use ULA-specific values, or memory values of non-paged memory banks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;literals&quot;&gt;Literals&lt;/h2&gt;

&lt;p&gt;The expression syntax provides these types of literals:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Decimal numbers.&lt;/strong&gt; You can use up to 5 digits (0..9) to declare a decimal number. Examples:
16, 32768, 2354.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hexadecimal numbers.&lt;/strong&gt; You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare
a hexadecimal literal. The engine recognizes one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0x&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; prefix, or one of 
the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; suffixes. If you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;
suffixes, the hexadecimal number should start with a decimal digit &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;…&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12AC
0x12ac
$12Ac
12ACh
12acH
0AC34H
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Binary numbers.&lt;/strong&gt; Literal starting with the one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0b&lt;/code&gt; prefix are taken into 
account as binary literals. You can follow the prefix with up to 16 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; digits. To make
them more readable, you can separate adjacent digits with the underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;) character. These 
are all valid binary literals:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%01011111
0b01011111
0b_0101_1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use negative number with the minus sign in front of them. Actually, the sign is not
the part of the numeric literal, it is an operator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Characters&lt;/strong&gt;. You can put a character between single quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;'Q'&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can use escape sequences to define non-visible or control characters:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Escape&lt;/th&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Character&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;INK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x11&lt;/td&gt;
      &lt;td&gt;PAPER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x12&lt;/td&gt;
      &lt;td&gt;FLASH&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x13&lt;/td&gt;
      &lt;td&gt;BRIGHT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x14&lt;/td&gt;
      &lt;td&gt;INVERSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x15&lt;/td&gt;
      &lt;td&gt;OVER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x16&lt;/td&gt;
      &lt;td&gt;AT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x17&lt;/td&gt;
      &lt;td&gt;TAB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x60&lt;/td&gt;
      &lt;td&gt;pound sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x7F&lt;/td&gt;
      &lt;td&gt;copyright sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x5C&lt;/td&gt;
      &lt;td&gt;backslash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\'&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x27&lt;/td&gt;
      &lt;td&gt;single quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x22&lt;/td&gt;
      &lt;td&gt;double quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;binary zero&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To declare a character by its binary code, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;\xH&lt;/code&gt; or&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;\xHH&lt;/code&gt; sequences (&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; is a hexadecimal digit). For example, these
escape sequence pairs are equivalent:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'\i'
'\x10'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;symbols&quot;&gt;Symbols&lt;/h3&gt;

&lt;p&gt;You can use symbols to refer to labels and other constants used in Z80 programs. Identifiers must start with 
a letter (a..z or A..Z) or the underscore character (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;). The subsequent characters 
letters, digits, or underscores. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyCycle
ERR_NO
Cycle_4_Wait  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;There are strings that can be both identifiers or hexadecimal literals with the &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; suffix, like
&lt;code class=&quot;highlighter-rouge&quot;&gt;AC0Fh&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;FADH&lt;/code&gt;. The engine considers such strings as symbols. To use hexadecimal literal, use a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;
prefix: &lt;code class=&quot;highlighter-rouge&quot;&gt;0FADH&lt;/code&gt; is a hexadecimal literal, while &lt;code class=&quot;highlighter-rouge&quot;&gt;FADH&lt;/code&gt; is an identifier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The engine usus the symbols within the Z80 program you compile, inject, run or debug.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The SpecteNetIde Z80 Assembler handles symbols with string values. These symbols retrieve
0 (word) value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;z80-registers&quot;&gt;Z80 Registers&lt;/h3&gt;

&lt;p&gt;The expression engine recognizes the standard 8-bit and 16-bit register names, as specified in the official 
Zilog Z80 documentation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8-bit registers: &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;16-bit registers: &lt;code class=&quot;highlighter-rouge&quot;&gt;AF&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;For the 8-bit halves of the &lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt; index registers, the engine uses these names:
&lt;code class=&quot;highlighter-rouge&quot;&gt;XL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;XH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;YL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;YH&lt;/code&gt;. Alternatively, the compiler accepts these names, too: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;IXL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IXH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYH&lt;/code&gt;. As a kind of exception to general naming conventions, 
these mixed-case names are also accepted: &lt;code class=&quot;highlighter-rouge&quot;&gt;IXl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IXh&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IYh&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The engine recognizes the &lt;code class=&quot;highlighter-rouge&quot;&gt;WZ&lt;/code&gt; (internal Z80 register, not accessible programmatically) register, too.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;z80-flags&quot;&gt;Z80 Flags&lt;/h3&gt;

&lt;p&gt;The expression engine can access the Z80 CPU flags individually, and it also has tokens for the inverted flag values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Token&lt;/th&gt;
      &lt;th&gt;Flag&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;P&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;S&lt;/strong&gt; flag (Bit 7) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;M&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;S&lt;/strong&gt; flag (Bit 7) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;Z&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;Z&lt;/strong&gt; flag (Bit 6) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NZ&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;Z&lt;/strong&gt; flag (Bit 6) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R5&lt;/strong&gt; flag (Bit 5) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N5&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R5&lt;/strong&gt; flag (Bit 5) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;H&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;H&lt;/strong&gt; flag (Bit 4) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NH&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;H&lt;/strong&gt; flag (Bit 4) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R3&lt;/strong&gt; flag (Bit 3) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;R3&lt;/strong&gt; flag (Bit 3) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;PE&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;PV&lt;/strong&gt; flag (Bit 2) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;PO&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;PV&lt;/strong&gt; flag (Bit 2) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;N&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;N&lt;/strong&gt; flag (Bit 1) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NN&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;N&lt;/strong&gt; flag (Bit 1) is reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;C&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;C&lt;/strong&gt; flag (Bit 0) is set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;` &lt;strong&gt;NC&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;True, if &lt;strong&gt;C&lt;/strong&gt; flag (Bit 0) is reset&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;zx-spectrum-memory-contents&quot;&gt;ZX Spectrum Memory Contents&lt;/h3&gt;

&lt;p&gt;You can query the entire 64K memory available by the Z80 CPU. With a memory indirection expression, 
you can query byte, word, and double word values, respectively:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt; [&lt;code class=&quot;highlighter-rouge&quot;&gt;access specifier&lt;/code&gt;] &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You wrap an &lt;em&gt;expression&lt;/em&gt; and an optional &lt;em&gt;access specifier&lt;/em&gt; between square brackets. 
The expression specifies the memory address, the &lt;em&gt;access specifier&lt;/em&gt; sets the number of bytes to
query from the memory:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt; — A single byte stored in the specified memory address.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt; — Two consequtive bytes stored in the specified address and the next one.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt; — Four consequtive bytes stored in the specified memory address and the next three.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you omit the access specifier, the default is &lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When you query multiple bytes from the memory, the first byte is the LSB (least significant byte), 
the last is the MSB (most significant byte). Lets assume, you store these four bytes at the address #4000:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12, #4A, #C3, #78
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000]&lt;/code&gt; (and &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B]&lt;/code&gt;) expressions retrieve &lt;code class=&quot;highlighter-rouge&quot;&gt;#12&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W]&lt;/code&gt; expression results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#4A12&lt;/code&gt; (16 bits).&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW]&lt;/code&gt; expression results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#78C34A12&lt;/code&gt; (32 bits).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;operators&quot;&gt;Operators&lt;/h2&gt;

&lt;p&gt;You can use about a dozen operators, including unary, binary and ternary ones. In this section
you will learn about them. I will introduce them in descending order of their precendence.&lt;/p&gt;

&lt;h3 id=&quot;conditional-operator&quot;&gt;Conditional Operator&lt;/h3&gt;

&lt;p&gt;The engine supports using only one ternary operator, the conditional operator:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;conditional-expression&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;true-value&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;false-value&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This operation results in -1:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 &amp;gt; 3 ? 2 : -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When &lt;em&gt;conditional-expression&lt;/em&gt; evaluates to true, the operation results 
in &lt;em&gt;true-value&lt;/em&gt;; otherwise in &lt;em&gt;false-value&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Conditional expressions are evaluated from right to left, in contrast to binary operators,
which use left-to-right evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;binary-bitwise-operators&quot;&gt;Binary Bitwise Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Bitwise OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Bitwise XOR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Bitwise AND&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;relational-operators&quot;&gt;Relational Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Non-equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than or equal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;shift-operators&quot;&gt;Shift Operators&lt;/h3&gt;

&lt;p&gt;The bits of the left operand are shifted by the number of bits given by the right operand.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift left&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift right&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;basic-arithmetic-operators&quot;&gt;Basic Arithmetic Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Addition&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Subtraction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Multiplication&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Division&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Modulo calculation&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;unary-operators&quot;&gt;Unary operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary plus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary minus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary bitwise NOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary logical NOT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Do not forget, you can change the default precendence with &lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;, for example:
&lt;code class=&quot;highlighter-rouge&quot;&gt;(4 + 2) * 3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;format-specifiers&quot;&gt;Format Specifiers&lt;/h2&gt;

&lt;p&gt;With format specifiers, you can declare how would you like to display the results of watch expressions.
These are optional, if you do not use them, the engine will select the format according to the type of 
the expressions’s value:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:F&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Byte values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Word values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
  &lt;li&gt;Double word values — &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt; format&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This table lists the format specifiers supported by the watch engine:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Specifier&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:F&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Flag format. When the value is zero, the output is &lt;code class=&quot;highlighter-rouge&quot;&gt;FALSE&lt;/code&gt;; otherwise, &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Byte format. The engine displays both the hexadecimal value in two hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#7C (124)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-B&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed byte format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:B&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:C&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Character format. The value is converted to a byte, and the ASCII character value of the byte is displayed. When the character code is between 32 and 126, the character is displayed, otherwise a hexadecimal character escape is used. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#41&lt;/code&gt; results in &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'A'&lt;/code&gt;&lt;/strong&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;#8D&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;'\0x8D'&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Word format. The engine displays both the hexadecimal value in four hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#317C (12668)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-W&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed word format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:W&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Double word format. The engine displays both the hexadecimal value in eight hexadecimal digits, plus the decimal value. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;#43CA317C (‭1137324412‬)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:-DW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Signed double word format. Similar to &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:DW&lt;/code&gt;&lt;/strong&gt;, nonetheless, the decimal value is signed. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFFFFFE (-2)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;4 hexadecimal digits. The result is converted to a word and displayed in hexadecimal format, bytes in LSB/MSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4F3C&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#3C #4F&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;8 hexadecimal digits. The result is converted to a double word and displayed in hexadecimal format, bytes in LSB/MSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#67D24F3C&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;#3C #4F #D2 #67&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%8&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;8 binary digits. The result is converted to a byte and displayed in binary format. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%16&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;16 binary digits. The result is converted to a word and displayed in binary format, bytes in MSB/LSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#324F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;00110010 01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%32&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;32 binary digits. The result is converted to a double word and displayed in binary format, bytes in MSB/LSB order. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;#AA55324F&lt;/code&gt; results in &lt;code class=&quot;highlighter-rouge&quot;&gt;10101010 01010101 00110010 01001111&lt;/code&gt;.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the future, the list of format specifiers may extend.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Please note, while &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt; use LSB/MSB byte order, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%8&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%16&lt;/code&gt;&lt;/strong&gt;,
and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%32&lt;/code&gt;&lt;/strong&gt; apply MSB/LSB order. You may use the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H4&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:H8&lt;/code&gt;&lt;/strong&gt; formats to display memory
contents in the order of bytes as they are stored in the memory. Lets assume, you store these
four bytes at the address #4000:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#12, #4A, #C3, #78
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is how watch expressions display the content:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 (18)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 (18)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:B] :H4&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #00&lt;/code&gt; (Do not forget, the expression reads only a single byte from the memory!)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#4A12 (18962)&lt;/code&gt; (This expression reads two bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:W] :H4&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #4A&lt;/code&gt; (This expression reads two bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW]&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#78C34A12 (‭2026064402‬)&lt;/code&gt; (This expression reads four bytes from the memory)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[#4000:DW] :H8&lt;/code&gt; — &lt;code class=&quot;highlighter-rouge&quot;&gt;#12 #4A #C3 #78&lt;/code&gt; (This expression reads four bytes from the memory)&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Although its name suggests that the Watch Memory window can display only values in the memory, the capabilities of this tool are richer.</summary></entry><entry><title type="html">Watch Commands</title><link href="http://localhost:4000/spectnetide/documents/watch-commands" rel="alternate" type="text/html" title="Watch Commands" /><published>2019-01-03T00:00:00+01:00</published><updated>2019-01-03T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/watch-commands</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/watch-commands">&lt;p&gt;With these commands, you can manage the list of items in the &lt;strong&gt;Watch Memory&lt;/strong&gt; tool window:&lt;/p&gt;

&lt;h2 id=&quot;add-a-new-watch-item-command&quot;&gt;Add a New Watch Item Command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;&lt;/em&gt; [&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Appends a new watch expression to the watch list.&lt;/p&gt;

&lt;h2 id=&quot;remove-a-watch-item-command&quot;&gt;Remove a Watch Item command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Removes the watch item with the specified index from the list. Automatically renumbers the indexes of
remaining items.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can access this command from the context menu of a watch item (&lt;strong&gt;Remove&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;modify-a-watch-item-command&quot;&gt;Modify a Watch Item command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;&lt;/em&gt; [&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Modifies the watch item with the specified index to the provided &lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt; and optional &lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can access this command from the context menu of a watch item (&lt;strong&gt;Modify&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;exchange-watch-items-command&quot;&gt;Exchange Watch Items command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XW&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index1&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index2&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Exchanges the watch items specified by the two indexes in the list.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can move up or down watch items with the commands available from the context menu of an item
(&lt;strong&gt;Move up&lt;/strong&gt;, &lt;strong&gt;Move down&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;erase-the-watch-item-list-command&quot;&gt;Erase the Watch Item List command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EW&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Erases the entire watch item list.&lt;/p&gt;

&lt;h2 id=&quot;set-watch-item-label-width-command&quot;&gt;Set Watch Item Label Width command&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sets the width of the label that displays the watch expression to the value specified by &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;. Here index is
used as a width in pixels.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Instead of using the command line, you can use a sizing grip between the watch item’s expression and its displayed
value to change the width with the mouse.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">With these commands, you can manage the list of items in the Watch Memory tool window:</summary></entry></feed>