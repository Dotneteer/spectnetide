<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/spectnetide/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/spectnetide/" rel="alternate" type="text/html" /><updated>2019-03-09T15:58:42+01:00</updated><id>http://localhost:4000/spectnetide/feed.xml</id><title type="html">SpectNet IDE</title><subtitle>Visual Studio 2017/2019 integrated ZX Spectrum IDE for the Community</subtitle><entry><title type="html">Syntax Basics</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-basics" rel="alternate" type="text/html" title="Syntax Basics" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-basics</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-basics">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; provides a somple programming language to describe Z80-related unit tests. You can add the 
&lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; files to your project and run the test in the &lt;strong&gt;Unit Test Explorer&lt;/strong&gt; tool window. This document
treats the syntax and semantics of the language.&lt;/p&gt;

&lt;h2 id=&quot;syntax-basics&quot;&gt;Syntax Basics&lt;/h2&gt;

&lt;p&gt;The test language uses a special way of case-sensitivity. You can write the reserved
keywords on lowercase. When you refer to Z80 CPU registers or flags, you can use either with lowercase or
uppercase letters, but you cannot mix these cases. You can mix cases for identifiers, though they are
searched for a case-insensitive manner.&lt;/p&gt;

&lt;h2 id=&quot;test-structure&quot;&gt;Test Structure&lt;/h2&gt;

&lt;p&gt;A ZX Spectrum project may have zero, one, or more test files (files with &lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; extension). Before 
running them, the engine collects all &lt;code class=&quot;highlighter-rouge&quot;&gt;.z80test&lt;/code&gt; files from the current project, and compiles them all.&lt;/p&gt;

&lt;p&gt;A single test file may contain one or more &lt;em&gt;test set&lt;/em&gt;. A test set is a collection of cohesive tests that 
all use the very same source code, as the basis of testing:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    // --- Other testset attributes    

    test AddAAndBWorksAsExpected
    {
        // --- Other test attributes

        act call AddAAndB;

        assert
        {
            // --- Here we describe the test assertions
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A &lt;em&gt;test&lt;/em&gt; can have a default &lt;em&gt;act&lt;/em&gt;, such as in the sample above, or may have parameterized test cases:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// --- Wrapping test set omitted
test AddAAndBCallWorksAsExpected2
{
    params parA, parB, Z;
    case 1, 2, 0;
    case 2, 3, 0;
    case -6, 6, 1;

    arrange
    {
        a: parA;
        b: parB;
    }

    act call AddAAndB;

    assert
    {
        a == parA + parB;
        b == parB;
        .z == Z;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This test has three cases, as declared by the lines starting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; keyword.
When running them, the engine substitutes the &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; values with the
values after &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; (fore each &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;To summarize:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Concept&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test file&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A single container for &lt;em&gt;test sets&lt;/em&gt;. Besides keeping test sets together in a single file, there’s no additional semantics.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test set&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A cohesive set of tests. A test set has a single source code file — this contains the code to test — shared between the test within the set.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;A single test that runs a piece of the source code to test. It may nest test cases.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;test case&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Parameterized test. It runs the same code (although you can run different code) with the case-related parameters.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;syntax-elements&quot;&gt;Syntax Elements&lt;/h2&gt;

&lt;p&gt;The test language contains several constituting elements that you can use in many 
places within the code, such as comments, expressions, identifiers, and so on. Here 
you can learn about them.&lt;/p&gt;

&lt;h3 id=&quot;comments&quot;&gt;Comments&lt;/h3&gt;

&lt;p&gt;Comments can be single line or multi-line comments with the same syntax construct as you may 
use them in many curly-brace-languages, such as C++, Java, C#, etc.:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// --- This is a single line comment you can add to the end of the code lines

/* This is a multi-line comment the spans accross multiple lines, 
   including empty ones

*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;literals&quot;&gt;Literals&lt;/h3&gt;

&lt;p&gt;The language syntax provides these types of literals:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Decimal numbers.&lt;/strong&gt; You can use adjacent digits (0..9) to declare a decimal number. Examples:
16, 32768, 2354.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hexadecimal numbers.&lt;/strong&gt; You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare
a hexadecimal literal. The compiler looks for one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0x&lt;/code&gt; prefix, or one of 
the &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; suffixes to recognize them as hexadecimal. Here are a few samples:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #12AC
    0x12ac
    12ACh
    12acH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Binary numbers.&lt;/strong&gt; Literal starting with the one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0b&lt;/code&gt; prefix are taken into 
account as binary literals. You can follow the prefix with up to 16 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; digits. To make
them more readable, you can separate adjacent digits with the underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;) character. These 
are all valid binary literals:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    %01011111
    0b01011111
    0b_0101_1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can use negative number with the minus sign in front of them. Actually, the sign is not
the part of the numeric literal, it is an operator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Characters&lt;/strong&gt;. You can put a character between double quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Q&quot;&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Strings&lt;/strong&gt;. You can put a series of character between double quotes (for example: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Sinclair&quot;&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;This is a string. The next sample is a single character&quot;
&quot;c&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;character-and-string-escapes&quot;&gt;Character and String Escapes&lt;/h3&gt;

&lt;p&gt;ZX Spectrum has a character set with special control characters such as AT, INK, PAPER, and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; allows you to utilize special escape sequences to define ZX Spectrum-specific characters:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Escape&lt;/th&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Character&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;INK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x11&lt;/td&gt;
      &lt;td&gt;PAPER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x12&lt;/td&gt;
      &lt;td&gt;FLASH&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x13&lt;/td&gt;
      &lt;td&gt;BRIGHT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x14&lt;/td&gt;
      &lt;td&gt;INVERSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x15&lt;/td&gt;
      &lt;td&gt;OVER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x16&lt;/td&gt;
      &lt;td&gt;AT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x17&lt;/td&gt;
      &lt;td&gt;TAB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x60&lt;/td&gt;
      &lt;td&gt;pound sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x7F&lt;/td&gt;
      &lt;td&gt;copyright sign&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x5C&lt;/td&gt;
      &lt;td&gt;backslash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\'&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x27&lt;/td&gt;
      &lt;td&gt;single quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x22&lt;/td&gt;
      &lt;td&gt;double quote&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;binary zero&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observe, some of these sequences have different values than their corresponding
pairs in other languages, such as C, C++, C#, or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To declare a character by its binary code, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;\xH&lt;/code&gt; or&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;\xHH&lt;/code&gt; sequences (&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; is a hexadecimal digit). For example, these
escape sequence pairs are equivalent:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;\i&quot;
&quot;\x10&quot;

&quot;\C by me&quot;
&quot;\x7f \x62y me&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;identifiers&quot;&gt;Identifiers&lt;/h3&gt;

&lt;p&gt;You can use identifiers to refer to labels and other constants. Identifiers must start with 
a letter (a..z or A..Z) or the underscore character (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;). The subsequent characters 
can be digits (0..9), too. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyCycle
ERR_NO
Cycle_4_Wait  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Theoretically, you can use as long identifiers as you want. I suggest you to make them no longer than
32 characters so that readers may read your code easily.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">SpectNetIde provides a somple programming language to describe Z80-related unit tests. You can add the .z80test files to your project and run the test in the Unit Test Explorer tool window. This document treats the syntax and semantics of the language.</summary></entry><entry><title type="html">The Testing Process</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-process" rel="alternate" type="text/html" title="The Testing Process" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-process</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-process">&lt;h1 id=&quot;the-testing-process&quot;&gt;The Testing Process&lt;/h1&gt;

&lt;p&gt;You already learned that tests are organized into a hierarchy of &lt;em&gt;test files&lt;/em&gt;, &lt;em&gt;test sets&lt;/em&gt;, &lt;em&gt;tests&lt;/em&gt;, and parameterized
&lt;em&gt;test cases&lt;/em&gt;. In this section you will learn how the test engine manages these tests.&lt;/p&gt;

&lt;p&gt;The testing process start with the compilation of tests. During this step, all tests are turned into execution plans.
If there is any compilation error, the engine won’t start running the tests.&lt;/p&gt;

&lt;p&gt;The unit of execution is the &lt;strong&gt;test set&lt;/strong&gt;. Test sets are entirelly independent of each other. You can run them in any
sequence; the order won’t change whether they fail or succeed. SpectNetIde loops through all test files declared in the
project (you cannot assume deterministic order), and runs all test sets in their declaration order within a file.&lt;/p&gt;

&lt;p&gt;Each test sets creates and starts a Spectrum virtual machine, and pauses it when the machine reaches its main execution 
cycle. The point a machine is paused depends on its type (different for Spectrum 48K, 128K, +3E), and also the mode the machine
runs. For example, in a Spectrum 128K machine you can run tests in BASIC 128 mode or in Spectrum 48K mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Right now, the unit test engine supports only Spectrum 48K mode, but soon you will be able to use the other modes, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;running-a-test-set&quot;&gt;Running a Test Set&lt;/h2&gt;

&lt;p&gt;Every test within a test set uses this virtual machine. This machine is paused every time a test completes 
(either successfully, with a failure, or in aborted state). &lt;em&gt;If a test disrupts the machine’s memory (for example, it changes
the code being tested), the behavior of a particular test may prevent the subsequent test from running properly.&lt;/em&gt; This demeanor
of test sets is intentional.&lt;/p&gt;

&lt;p&gt;The engine uses these steps to run the tests defined within a tes set:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;After the Spectrum machine reaches its startup state and pauses, the engine copies the compiled source code into
the memory.&lt;/li&gt;
  &lt;li&gt;If the test set declares an &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; section, the engine sets up the registers and flags accordingly, copies byte array
values into the memory. While initializing, it follows the order of &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; assignments.&lt;/li&gt;
  &lt;li&gt;The engine loops through the nested &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; blocks in their declaration order, and executes them.&lt;/li&gt;
  &lt;li&gt;When all tests are completed, the engine stops the virtual machine and disposes its state.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;running-a-test-and-parameterized-cases&quot;&gt;Running a Test and Parameterized Cases&lt;/h2&gt;

&lt;p&gt;To run a single test, the engine follows these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the test has a &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; declaration, the engine invokes the Setup code. If that code fails 
— it exceeds the timeout — the engine aborts the test.&lt;/li&gt;
  &lt;li&gt;If the test has a single default case, the engine runs that case. If the test has multiple cases, 
the engine iterates through all cases in their declaration order.&lt;/li&gt;
  &lt;li&gt;Provided the test has a &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; section, the engine invokes the Cleanup code. If this code 
exceeds the timeout, the Cleanup code aborts the test.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;According to this method, it might happen that all tests run successfully and still the test is
aborted, because its Cleanup code fails. This behavior is intentional: a faulty cleanup code may influence
the subsequent tests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The engine carries out the same steps for a default test case and parameterized test cases. If there are 
more cases, these steps are executed in a loop:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Provided there are &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; declarations, the engine sets up the registers and flags accordingly, 
copies byte array values into the memory — in the order of their declaration. If any &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; 
assignment fails, the test is aborted.&lt;/li&gt;
  &lt;li&gt;The engine invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; code. If it completes within the timeout, the testing process goes on;
otherwise, the test is aborted.&lt;/li&gt;
  &lt;li&gt;If there is no &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; section, the test is successful.&lt;/li&gt;
  &lt;li&gt;If there’s an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; section, the engine evaluates all expresssions within until it iterates through 
all or one of the expression evaluates to false.&lt;/li&gt;
  &lt;li&gt;A false assertion value completes the test as failed. If all assertions are true, the test is successful.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;side-effects&quot;&gt;Side effects&lt;/h2&gt;

&lt;p&gt;A test can have test options (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;di&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;ei&lt;/code&gt;). The engine uses these values whenever
it invokes Z80 code, independently whether that is &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt;. Between these 
code invocations, the engine simply pauses the Spectrum virtual machine and starts it again. There is one
special action the test engine takes: if a code is invoked with &lt;code class=&quot;highlighter-rouge&quot;&gt;halt&lt;/code&gt;, the test removes the CPU from its
halted state before the next test.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Again, the code is injected into the virtual machine only once, at the start of a test set. If any code
changes the memory, it may disrupt the test code, and thus remaining test cases in the test set may fail of
even may be aborted. Nonetheless, these tests won’t cause any harm in your project, they just cause tests fail.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, the following code disrupts the Spectrum virtual machine, because it restarts it, and so it causes
the clearing the RAM:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Crashing
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    test CrashingCode
    {
        with timeout 1000;
        act call #0000;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running it will abort the test after a second.&lt;/p&gt;

&lt;h2 id=&quot;using-callstub&quot;&gt;Using Callstub&lt;/h2&gt;

&lt;p&gt;When you invoke the code with the &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction, the test engine generates a stub
that call your subroutine. By default, the engine places three bytes with a Z80 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt;
instruction to the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA0&lt;/code&gt;&lt;/strong&gt; address, that is an empty area within the ZX Spectrum system
variables (printer buffer in ZX Spectrum 48K). If you do not want to use this address for a
stub, you can change it with the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt;&lt;/strong&gt; attribute of a test set:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    callstub #8000;

    // --- Other test code omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This sample code instructs the engine to use the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#8000&lt;/code&gt;&lt;/strong&gt; address to generate the stub.
Be careful with using your custom stub!&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;First, do not forget to provide 3 bytes that the test engine can override.&lt;/li&gt;
  &lt;li&gt;Second, take care that you do not declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; code invocation that addresses a routine
starting at the &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt; + 3 address. The test engine checks if your call is completed so
that it compares &lt;strong&gt;PC&lt;/strong&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt; + 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a pattern you can use with your own custom &lt;code class=&quot;highlighter-rouge&quot;&gt;callstub&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.org #8000

; --- Here is some code

; --- We reserve 4 bytes
CallstubAddress:
    .defs 4;
; --- SomeRoutine starts at CallstubAddress + 4
SomeRoutine:
; --- Add routine code here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, you can define a test line this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    callstub CallstubAddress;

    test 
    {
        // ...
        act call SomeRoutine;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">The Testing Process</summary></entry><entry><title type="html">Expressions</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-expressions" rel="alternate" type="text/html" title="Expressions" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-expressions</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-expressions">&lt;p&gt;The test language has a rich syntax for evaluating expressions. You can use operands 
and operators just like in most programming languages. Nevertheless, the test language
implementation has its particular semantics of evaluating expression, as you will learn soon.&lt;/p&gt;

&lt;h2 id=&quot;operands&quot;&gt;Operands&lt;/h2&gt;
&lt;p&gt;You can use the following operands in epressions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Decimal and hexadecimal literals&lt;/li&gt;
  &lt;li&gt;Character literals&lt;/li&gt;
  &lt;li&gt;Identifiers&lt;/li&gt;
  &lt;li&gt;Test language specific constructs, such as the register, flag, and memory access operands&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;String literals cannot be used as operands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operators&quot;&gt;Operators&lt;/h2&gt;

&lt;p&gt;You can use about a dozen operators, including unary, binary and ternary ones. In this section
you will learn about them. I will introduce them in descending order of their precendence.&lt;/p&gt;

&lt;h3 id=&quot;conditional-operator&quot;&gt;Conditional Operator&lt;/h3&gt;

&lt;p&gt;The assembler supports using only one ternary operator, the conditional operator:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;conditional-expression&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;true-value&lt;/em&gt; &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;false-value&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This operation results in -1:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 &amp;gt; 3 ? 2 : -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When the &lt;em&gt;conditional-expression&lt;/em&gt; evaluates to true, the operation results 
in &lt;em&gt;true-value&lt;/em&gt;; otherwise in &lt;em&gt;false-value&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Conditional expressions are evaluated from right to left, in contrast to binary operators,
which use left-to-right evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;binary-bitwise-operators&quot;&gt;Binary Bitwise Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Bitwise OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Bitwise XOR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Bitwise AND&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;relational-operators&quot;&gt;Relational Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Non-equality&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Less than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Greater than or equal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;shift-operators&quot;&gt;Shift Operators&lt;/h3&gt;

&lt;p&gt;The bits of the left operand are shifted by the number of bits given by the right operand.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift left&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Shift right&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;basic-arithmetic-operators&quot;&gt;Basic Arithmetic Operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Addition&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Subtraction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Multiplication&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Division&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Modulo calculation&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;unary-operators&quot;&gt;Unary operators&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator token&lt;/th&gt;
      &lt;th&gt;Precedence&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary plus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary minus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary bitwise NOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;Unary logical NOT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Do not forget, you can change the defult precendence with &lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;type-semantics&quot;&gt;Type semantics&lt;/h2&gt;

&lt;p&gt;Expression values can be one of these types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Boolean&lt;/li&gt;
  &lt;li&gt;Number&lt;/li&gt;
  &lt;li&gt;Byte array&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are implicit conversions amont these types. The test language compiler automatically applies
these conversions, knowing the types to operate on.&lt;/p&gt;

&lt;p&gt;Internally, values are stored either as 64-bit numbers, or byte arrays. The compiler utilizes these 
conversions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;When a byte array value is required but a numeric value is found, the numeric value is converted 
into an array of a single byte using the rightmost 8 bits of the number stored in the memory.&lt;/li&gt;
  &lt;li&gt;When a number is required but a byte array is found, the conversion goes like this: A byte array 
of all 0 bytes results 0, any other values retrieve 1.&lt;/li&gt;
  &lt;li&gt;When the compiler needs a boolean number, the zero numeric value results 0 (false), any other value 
values retrieve 1 (true).&lt;/li&gt;
  &lt;li&gt;When the compiler needs a boolean number but it finds a byte array, the conversion takes two steps.
First, it turns the byte array into a number if first converts a byte array into a number (rule #1), 
and then these number into a Boolean (rule #3).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;operator-specific-behavior&quot;&gt;Operator-Specific Behavior&lt;/h2&gt;

&lt;p&gt;The compiler does not apply the conversion rules above automatically for all operators to avoid
unintended programming errors, instead retrieves an error:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No binary operators (including relational operators) accept mixing numeric and byte array values&lt;/li&gt;
  &lt;li&gt;Binary operators (except binary &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;) do not allow two byte array operands&lt;/li&gt;
  &lt;li&gt;The conditional operator ( &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; ) does not allow a byte array as the condition&lt;/li&gt;
  &lt;li&gt;Unary operators except &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; allow only numbers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are a few operators that work with byte arrays:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The binary &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; operator concatenates two byte arrays.&lt;/li&gt;
  &lt;li&gt;The bitwise logical operators work with two byte array operands. The result will be
a byte array with the shorter size of the operands. The elements of the result array are the
corresponding bitwise operations on the bits of the operand arrays.&lt;/li&gt;
  &lt;li&gt;The bitwise NOT unary operation inverts all bits in the byte array.&lt;/li&gt;
  &lt;li&gt;The logical NOT unary operator converts the byte array to a number and applies the logical NOT&lt;/li&gt;
  &lt;li&gt;operator on that number.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">The test language has a rich syntax for evaluating expressions. You can use operands and operators just like in most programming languages. Nevertheless, the test language implementation has its particular semantics of evaluating expression, as you will learn soon.</summary></entry><entry><title type="html">Detailed Syntax</title><link href="http://localhost:4000/spectnetide/documents/unit-testing-details" rel="alternate" type="text/html" title="Detailed Syntax" /><published>2019-01-05T00:00:00+01:00</published><updated>2019-01-05T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/unit-testing-details</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/unit-testing-details">&lt;p&gt;In the following section, I will use a kind of abstract syntax notation to describe the grammar of the 
SpectNetIde test language. Bold characters mark terminal symbols (keywords and other tokens), while 
italic strings ara non-terminal symbols. The &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; after a symbol means that it’s optional. A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 
means zero, one, or more occurrence. &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; means one or more occurrence. The &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; character separates options, exactly one of them can be used.
The language uses parantheses to specify groups of tokens.&lt;/p&gt;

&lt;h2 id=&quot;compilation-units&quot;&gt;Compilation Units&lt;/h2&gt;

&lt;p&gt;Each file is a compilation unit that contains zero, one, or more test sets:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;compileUnit:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testSet*&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;test-sets&quot;&gt;Test Sets&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testSet:&lt;/code&gt;** 
    &lt;strong&gt;testset&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
    &lt;em&gt;&lt;strong&gt;sp48mode&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sourceContext&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlock?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initSettings?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testBlock*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;using-sp48mode&quot;&gt;Using sp48mode&lt;/h3&gt;

&lt;p&gt;When you work with Spectrum 128K, Spectrum ++, or Spectrum Next, you can specify that you intend to
start the Spectrum virtual machine in Spectrum 48K mode:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    sp48mode;
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this mode, you can be sure that the Spectrum 48K ROM is paged into the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt; address range,
and memory paging is forbidden —, and thus, the test behaves exactly as if it were run on a Spectrum 48K model.&lt;/p&gt;

&lt;h3 id=&quot;the-source-context&quot;&gt;The Source Context&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sourceContext:&lt;/code&gt;&lt;/em&gt;	 &lt;strong&gt;source&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;symbols&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier+)?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Each test set is named with a unique identifier. The only mandatory element of a &lt;strong&gt;testset&lt;/strong&gt; declaration is 
the source context that names the source file used within the test set. You can add optional conditional symbols
that to compile the source code. Here are a few samples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset MyFirstSet
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
}

testset MySecondSet
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot; symbols DEBUG SP128;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both test sets use the &lt;code class=&quot;highlighter-rouge&quot;&gt;../Z80CodeFiles/CodeSamples.z80asm&lt;/code&gt; source code file (path relative to the test file).
Nonetheless, &lt;code class=&quot;highlighter-rouge&quot;&gt;MySecondSet&lt;/code&gt; passes the &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SP128&lt;/code&gt; pre-defined symbols to the Z80 Assembler.&lt;/p&gt;

&lt;p&gt;The test engine recognizes the symbols you declare in the source context. For example, if you has a &lt;code class=&quot;highlighter-rouge&quot;&gt;MyRoutine&lt;/code&gt; 
symbol in the source code, you can use it within the test file. The compiler will understand it, and replaces the
symbol with its value.&lt;/p&gt;

&lt;h3 id=&quot;the-callstub-option&quot;&gt;The Callstub Option&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callstub:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;callstub&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This option defines the address to use for a three-byte call stub when running unit tests. You will learn about 
this option later when I treat the semantics of test execution.&lt;/p&gt;

&lt;h3 id=&quot;defining-data-blocks&quot;&gt;Defining Data Blocks&lt;/h3&gt;

&lt;p&gt;A test set’s data block is to define values and byte array patterns that represent a block of the memory. Data block 
entries have unique identifiers you can use in the tests to reference them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlock:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;data&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlockBody*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dataBlockBody:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueDef&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPattern&lt;/code&gt;&lt;/em&gt; 
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueDef:&lt;/code&gt;&lt;/em&gt;	&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPattern:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPatternBody+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memPatternBody:&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(byteSet&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wordSet&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text)&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;byteSet:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;byte&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wordSet:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;word&lt;/strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;text:&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;text&lt;/strong&gt; *&lt;code class=&quot;highlighter-rouge&quot;&gt;?*&lt;/code&gt; ) *&lt;code class=&quot;highlighter-rouge&quot;&gt;string*&lt;/code&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As the abstract syntax notation shows, it’s pretty easy to define values:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data
{
     four: 1 + 3;
     helloWorld: &quot;hello&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;four&lt;/code&gt; identifier represents the constant 4; &lt;code class=&quot;highlighter-rouge&quot;&gt;helloWorld&lt;/code&gt; represents an array of 5 bytes, each 
byte stands for the corresponding character.&lt;/p&gt;

&lt;p&gt;You can define more complex byte arrays with the &lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;, and optional &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; keywords:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data
{
    myMemBlock
    {
        byte #12, #34, #36;
        word #AC38, #23;
        &quot;012&quot;; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, &lt;code class=&quot;highlighter-rouge&quot;&gt;myMemblock&lt;/code&gt; is a 10 bytes long array with these values:
#12, #34, #36, #38, #AC, #23, #00, #30, #31, #32.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observe, words are stored in LSB/MSB order. The word #23 is two bytes: #23 and #00.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;test-set-initialization-settings&quot;&gt;Test Set Initialization Settings&lt;/h3&gt;

&lt;p&gt;Before running tests, you can initialize a test set by assigning values to Z80 registers, 
setting or reseting flags, copying values into the memory.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initSettings:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;init&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment:&lt;/code&gt;&lt;/em&gt; ( &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regAssignment&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flagStatus&lt;/code&gt;&lt;/em&gt; | &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment&lt;/code&gt;&lt;/em&gt; ) &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regAssignment:&lt;/code&gt;&lt;/em&gt;  &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerSpec&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;a&lt;/strong&gt; | &lt;strong&gt;A&lt;/strong&gt; | &lt;strong&gt;b&lt;/strong&gt; | &lt;strong&gt;B&lt;/strong&gt; | &lt;strong&gt;c&lt;/strong&gt; | &lt;strong&gt;C&lt;/strong&gt; | &lt;strong&gt;d&lt;/strong&gt; | &lt;strong&gt;D&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;e&lt;/strong&gt; | &lt;strong&gt;E&lt;/strong&gt;	| &lt;strong&gt;h&lt;/strong&gt; | &lt;strong&gt;H&lt;/strong&gt; | &lt;strong&gt;l&lt;/strong&gt; | &lt;strong&gt;L&lt;/strong&gt; | &lt;strong&gt;xl&lt;/strong&gt; | &lt;strong&gt;XL&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;xh&lt;/strong&gt; | &lt;strong&gt;XH&lt;/strong&gt; |	&lt;strong&gt;yl&lt;/strong&gt; | &lt;strong&gt;YL&lt;/strong&gt; | &lt;strong&gt;yh&lt;/strong&gt; | &lt;strong&gt;YH&lt;/strong&gt; |	&lt;strong&gt;ixl&lt;/strong&gt;| &lt;strong&gt;IXL&lt;/strong&gt; | &lt;strong&gt;IXl&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;ixh&lt;/strong&gt;| &lt;strong&gt;IXH&lt;/strong&gt; | &lt;strong&gt;IXh&lt;/strong&gt; | &lt;strong&gt;iyl&lt;/strong&gt; | &lt;strong&gt;IYL&lt;/strong&gt; | &lt;strong&gt;IYl&lt;/strong&gt; | &lt;strong&gt;iyh&lt;/strong&gt; | &lt;strong&gt;IYH&lt;/strong&gt; | &lt;strong&gt;IYh&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;i&lt;/strong&gt; | &lt;strong&gt;I&lt;/strong&gt; | &lt;strong&gt;r&lt;/strong&gt; | &lt;strong&gt;R&lt;/strong&gt; | &lt;strong&gt;bc&lt;/strong&gt; | &lt;strong&gt;BC&lt;/strong&gt; |	&lt;strong&gt;de&lt;/strong&gt; | &lt;strong&gt;DE&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;hl&lt;/strong&gt; | &lt;strong&gt;HL&lt;/strong&gt; | &lt;strong&gt;sp&lt;/strong&gt; | &lt;strong&gt;SP&lt;/strong&gt; | &lt;strong&gt;ix&lt;/strong&gt; | &lt;strong&gt;IX&lt;/strong&gt; | &lt;strong&gt;iy&lt;/strong&gt; | &lt;strong&gt;IY&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;af’&lt;/strong&gt; | &lt;strong&gt;AF’&lt;/strong&gt; | &lt;strong&gt;bc’&lt;/strong&gt; | &lt;strong&gt;BC’&lt;/strong&gt;	| &lt;strong&gt;de’&lt;/strong&gt; | &lt;strong&gt;DE’&lt;/strong&gt; | &lt;strong&gt;hl’&lt;/strong&gt; | &lt;strong&gt;HL’&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flagStatus:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;.z&lt;/strong&gt; | &lt;strong&gt;.Z&lt;/strong&gt; | &lt;strong&gt;.nz&lt;/strong&gt; | &lt;strong&gt;.NZ&lt;/strong&gt; |	&lt;strong&gt;.c&lt;/strong&gt; | &lt;strong&gt;.C&lt;/strong&gt; | &lt;strong&gt;.nc&lt;/strong&gt; | &lt;strong&gt;.NC&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.pe&lt;/strong&gt; | &lt;strong&gt;.PE&lt;/strong&gt; | &lt;strong&gt;.po&lt;/strong&gt; | &lt;strong&gt;.PO&lt;/strong&gt;	| &lt;strong&gt;.p&lt;/strong&gt; | &lt;strong&gt;.P&lt;/strong&gt; | &lt;strong&gt;.m&lt;/strong&gt; | &lt;strong&gt;.M&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.n&lt;/strong&gt;| &lt;strong&gt;.N&lt;/strong&gt; | &lt;strong&gt;.a&lt;/strong&gt; | &lt;strong&gt;.A&lt;/strong&gt; | &lt;strong&gt;.h&lt;/strong&gt; | &lt;strong&gt;.H&lt;/strong&gt; | &lt;strong&gt;.nh&lt;/strong&gt; | &lt;strong&gt;.NH&lt;/strong&gt;&lt;br /&gt;
    | &lt;strong&gt;.3&lt;/strong&gt; | &lt;strong&gt;.n3&lt;/strong&gt; | &lt;strong&gt;.N3&lt;/strong&gt; | &lt;strong&gt;.5&lt;/strong&gt; | &lt;strong&gt;.n5&lt;/strong&gt;| &lt;strong&gt;.N5&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment:&lt;/code&gt;&lt;/em&gt;	 &lt;strong&gt;[&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;]&lt;/strong&gt; &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;:&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is a short sample:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
{
    bc: 0;
    hl: CustomBuffer;
    .z;
    .nc;
    [#4000]: myLogoArray;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; declaration sets the valuu of the &lt;strong&gt;BC&lt;/strong&gt; and &lt;strong&gt;HL&lt;/strong&gt; register pairs to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CustomBuffer&lt;/code&gt;, respectively.
The Zero flag is set, while Carry is reset. The declaration copies the contents of the &lt;code class=&quot;highlighter-rouge&quot;&gt;myLogoArray&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address.&lt;/p&gt;

&lt;p&gt;With an alternative &lt;code class=&quot;highlighter-rouge&quot;&gt;memAssignment&lt;/code&gt; syntax, you can declare the length of a byte array before copying it into the memory.
For example, the following code snippet copies only the first 32 bytes to the &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt; address:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
{
    [#4000]: myLogoArray:32;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test-blocks&quot;&gt;Test Blocks&lt;/h2&gt;

&lt;p&gt;You can declare default and parameterized test cases within test blocks:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testBlock:&lt;/code&gt;&lt;/em&gt;	&lt;strong&gt;test&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
    ( &lt;strong&gt;category&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOptions?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setupCode?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testParams?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testCase*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrange?*&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanupCode?&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
    &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Each test must have a uniuque indentifier, and may declare a category, which is reserved for future extension. Of course,
multiple tests may have the same category. The only required part of a test is the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; declaration that describes what code
to run within the test.&lt;/p&gt;

&lt;h3 id=&quot;test-options&quot;&gt;Test Options&lt;/h3&gt;

&lt;p&gt;Tests may have options the engine uses when running them:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOptions:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;with&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption&lt;/code&gt;&lt;/em&gt;)&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testOption:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;timeout&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;di&lt;/strong&gt; | &lt;strong&gt;ei&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The timeout option sets the timeout value for the specified test. When it expires, the engine aborts the test, and thus 
you can even create code with infinite loops, it does not freezes the test engine.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The default timeout value in 100 milliseconds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With the &lt;code class=&quot;highlighter-rouge&quot;&gt;ei&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;di&lt;/code&gt; options you can enable or disable interrupts explicitly before running any code. These 
options are just helpers. For tighter control, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;EI&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DI&lt;/code&gt; Z80 instructions explicitly in your code.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;By default, interrupts are enabled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The following options run a test case with 40 milliseconds of timeout and disable the interrupt before starting the code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with timeout 40, di;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;running-code-in-tests&quot;&gt;Running Code in Tests&lt;/h3&gt;

&lt;p&gt;You can declare three kinds of code to run in a single test. Setup code runs once before each test cases, Cleanup code once 
after all cases completed (either successfully or failed). The Act code runs for every test cases.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setupCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;setup&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;act:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;act&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanupCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;cleanup&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeCode:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;call&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;start&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;stop&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; | &lt;strong&gt;halt&lt;/strong&gt; )&lt;/p&gt;

&lt;p&gt;You have three ways to invoke code:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;&lt;/strong&gt; uses the Z80 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt; instruction to call the code with the specified address. Your code should have 
a &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; instruction. When the code successfully executes the &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; statement, the engine completes the test code.&lt;/li&gt;
  &lt;li&gt;With the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;&lt;/strong&gt; combination, you can explicitly specify a start and a stop address. The engine jumps
to the start address, and completes the test code as soon as it reaches the stop address. It does not executes the instruction
at the stop address.&lt;/li&gt;
  &lt;li&gt;With the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;halt&lt;/code&gt;&lt;/strong&gt; combination the test engine starts the code at the specified address, and completes it
when it reaches a &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; statement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-parameters-and-test-cases&quot;&gt;Test Parameters and Test Cases&lt;/h3&gt;

&lt;p&gt;You can define parameterized test cases. You name test parameters, and test cases declare values to substitute a
particular parameter:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testParams:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;params&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;identifier&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;testCase:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;case&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;,&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of course, the number of parameters and expressions after the &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; keyword must match for each test cases.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Soon, you will see a complete sample that demonstrates these concepts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;arrange-declarations&quot;&gt;Arrange Declarations&lt;/h3&gt;

&lt;p&gt;Each test block has an &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; declaration that runs before the engine invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;act&lt;/code&gt; code of a test case.
It has the same assignment syntax, as the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; construct of a test set:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrange:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;arrange&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assignment+&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;assertions&quot;&gt;Assertions&lt;/h3&gt;

&lt;p&gt;After the test code ran, you can run assertions. Assertions are a list of Boolean expressions, and the test engine 
evaluates them in their declaration order. All of them should be true to make the test case successful:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;assert&lt;/strong&gt; &lt;strong&gt;{&lt;/strong&gt; ( &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;;&lt;/strong&gt;)*&lt;code class=&quot;highlighter-rouge&quot;&gt;+*&lt;/code&gt; &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can use special assertion expressions:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addrSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;[&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;]&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reachSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;.&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;.&amp;gt;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memReadSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;|&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;|&amp;gt;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memWriteSpec:&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&amp;lt;||&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt; ( &lt;strong&gt;..&lt;/strong&gt; &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;&lt;/em&gt;) &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;||&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;These assertions retrieves a byte array. This may contain only a single byte (only one address specified)
or a sequence of bytes (both a start address and an inclusive end address is specified).&lt;/p&gt;

&lt;p&gt;An &lt;code class=&quot;highlighter-rouge&quot;&gt;addrSpec&lt;/code&gt; retrives the contenst of memory specified by the address range. Each byte in the array is the
copy of the corresponding memory address.&lt;/p&gt;

&lt;p&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;reachSpec&lt;/code&gt; byte array each byte indicates if the test’s control flow reached that address 
(the instruction at that address was executed) with a Boolean value. Similarly, the arrays retrieved by 
&lt;code class=&quot;highlighter-rouge&quot;&gt;memReadSpec&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;memWriteSpec&lt;/code&gt; indicate if the specified memory address was read, or written, respectively.&lt;/p&gt;

&lt;p&gt;Let’s see an example of using these assertions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;
    data
    {
        str100: &quot;00100&quot;;
        str1000:  &quot;001000&quot;;
        str12345: &quot;12345&quot;;
        str11211: &quot;11211&quot;;
        str23456: &quot;23456&quot;;
    }

    test BufferIncEachByteWorks
    {
        params value, result;
        case str100, str11211;
        case str12345, str23456;
        case str1000, str11211;
        arrange
        {
            hl: ConversionBuffer;
            b: 5;
            [ConversionBuffer]:value;
        }

        act call IncLoop;

        assert
        {
            [ConversionBuffer..ConversionBuffer+4] == result;
            &amp;lt;. IncLoop .&amp;gt;;
            &amp;lt;| ConversionBuffer .. ConversionBuffer + 4 |&amp;gt;;
            &amp;lt;|| ConversionBuffer .. ConversionBuffer + 4 ||&amp;gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; method accepts a bufferr address in &lt;strong&gt;HL&lt;/strong&gt; and 
a byte count in &lt;strong&gt;B&lt;/strong&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; increments each byte by 1 within the
buffer. As you can see, the assert section checks these conditions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The contents of the conversion buffer is the one specified in &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The code executions reaches the &lt;code class=&quot;highlighter-rouge&quot;&gt;IncLoop&lt;/code&gt; address.&lt;/li&gt;
  &lt;li&gt;The contents of the buffer (5 bytes starting from &lt;code class=&quot;highlighter-rouge&quot;&gt;ConversionBuffer&lt;/code&gt;) is read.&lt;/li&gt;
  &lt;li&gt;The contents of the buffer is written.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-sample&quot;&gt;Test Sample&lt;/h3&gt;

&lt;p&gt;Here is a short sample that demonstrates the concepts you learned:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testset Introduction
{
    source &quot;../Z80CodeFiles/CodeSamples.z80asm&quot;;

    test AddAAndBCallWorksAsExpected
    {
        params parA, parB, parExpected;
        case 1, 2, 3;
        case 2, 3, 5;
        case 6, 8, 14;

        arrange
        {
            a: parA;
            b: parB;
        }

        act call AddAAndB;

        assert 
        {
            a == parExpected;
        }
    }

    test AddAAndBWithStartWorksAsExpected
    {
        arrange
        {
            a: 3;
            b: 5;
        }

        act start AddAAndBWithStop stop StopPoint;

        assert 
        {
            a == 8;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The code file behind this test is the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Start:
	.org #8000

; You can invoke this test with 'call AddAAndB'
AddAAndB:
    add a,b
    ret

; You can invoke this test with 'start AddAAndBWithStop stop StopPoint'
AddAAndBWithStop:
    add a,b
StopPoint:
    nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first test, &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndBCallWorksAsExpected&lt;/code&gt;, has three test cases with parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;, 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;parExpected&lt;/code&gt;, respectively. The engine executes each test case with these steps:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sets the &lt;strong&gt;A&lt;/strong&gt; and &lt;strong&gt;B&lt;/strong&gt; CPU registers with the current value of &lt;code class=&quot;highlighter-rouge&quot;&gt;parA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;parB&lt;/code&gt;. For the first case, 
these are 1, and 2. The second case runs with 2, and 3.&lt;/li&gt;
  &lt;li&gt;Calls the &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndB&lt;/code&gt; subroutine, that executes the &lt;code class=&quot;highlighter-rouge&quot;&gt;add a,b&lt;/code&gt; instruction, and then completes the 
call with &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Checks if the content of &lt;strong&gt;A&lt;/strong&gt; equals with the expected result, as declared in &lt;code class=&quot;highlighter-rouge&quot;&gt;parExpected&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The second test has only a default case. It sets up &lt;strong&gt;A&lt;/strong&gt; and &lt;strong&gt;B&lt;/strong&gt; explicitly in the &lt;code class=&quot;highlighter-rouge&quot;&gt;arrange&lt;/code&gt; section 
and checks the result in &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;. You can observe that it does not call into the code, instead, it the test 
jumps to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAAndBWithStop&lt;/code&gt; address, and completes when it reaches &lt;code class=&quot;highlighter-rouge&quot;&gt;StopPoint&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">In the following section, I will use a kind of abstract syntax notation to describe the grammar of the SpectNetIde test language. Bold characters mark terminal symbols (keywords and other tokens), while italic strings ara non-terminal symbols. The ? after a symbol means that it’s optional. A * means zero, one, or more occurrence. + means one or more occurrence. The | character separates options, exactly one of them can be used. The language uses parantheses to specify groups of tokens.</summary></entry><entry><title type="html">Overview</title><link href="http://localhost:4000/spectnetide/documents/scripting-overview" rel="alternate" type="text/html" title="Overview" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-overview">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; is not just a simple ZX Spectrum emulator
and a set of development tools integrated with Visual Studio,
it offers a collection of .NET objects that you can use to automate
ZX Spectrum related tasks.&lt;/p&gt;

&lt;p&gt;Should it be looking for infinite
lives for a game, understanding the structure of a complex
application, finding out how a particular code works within 
special conditions — scripting makes it easy to automate
mechanical tasks.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt; namespace provides a dozen of object types suited for automation. You can use these
types from any .NET language, and scripting engines that support
directly.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Many popular scripting languages may support 
.NET objects through wrappers. Although &lt;strong&gt;SpectNetIde&lt;/strong&gt; does not
have any direct support for these languages, contributors are
welcomed to create such adapters. If you are interested, please
contact me at &lt;a href=&quot;mailto:dotneteer@hotmail.com&quot;&gt;dotneteer@hotmail.com&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;a-sample-script&quot;&gt;A Sample Script&lt;/h2&gt;

&lt;p&gt;Just for the sake of demonstration, here is a short sample that sets
the border to red, and checks that the screen is rendered accordingly:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Threading.Tasks;
using Spect.Net.SpectrumEmu.Scripting;

namespace MyFirstScript
{
  class Program
  {
    static async Task Main(string[] args)
    {
      var sm = SpectrumVmFactory.CreateSpectrum48Pal();
      Console.WriteLine(&quot;Setting the border to red&quot;);

      await sm.StartAndRunToMain();
      var entryAddr = sm.InjectCode(@&quot;
        .org #8000
        ld a,2       ; RED
        out (#FE),a  ; Set the border colour to red
        halt         ; Wait for 2 frames (rendering)
        halt
        ret          ; Finished
      &quot;);
      sm.CallCode(entryAddr);
      await sm.CompletionTask;

      var screen = sm.ScreenConfiguration;
      var redCount = 0;
      for (var i = 0; i &amp;lt; screen.ScreenLines; i++)
        for (var j = 0; j &amp;lt; screen.ScreenWidth; j++)
          redCount += sm.ScreenBitmap[i,j] == 0x02 ? 1 : 0;

      Console.WriteLine($&quot;#of red pixels: {redCount}&quot;);
      var borderPixels = screen.ScreenLines * screen.ScreenWidth
        - screen.DisplayLines * screen.DisplayWidth;
      Console.WriteLine($&quot;#of border pixels: {borderPixels}&quot;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The script starts with creating a ZX Spectrum 48 virtual machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the code starts the virtual machine (asynchronously in the background) and waits while it initializes the operating system, and enters into its main execution cycle:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;await sm.StartAndRunToMain();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As it reaches the desired state, the virtual machine pauses. At this point, it is ready for code injection. As the next code snippet shows,  _SpectNetIde__ makes it extremely easy to inject source code into the machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var entryAddr = sm.InjectCode(@&quot;
  .org #8000
  ld a,2       ; RED
  out (#FE),a  ; Set the border colour to red
  halt         ; Wait for 2 frames (rendering)
  halt
  ret          ; Finished
&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can utilize the &lt;a href=&quot;/spectnetide/documents/language-structure.html&quot;&gt;Z80 Assembler syntax&lt;/a&gt;
(the same as the IDE uses) to define the machine code to inject. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;InjectCode()&lt;/code&gt; method returns the entry address of the code, so
you can explicitly start the code in the virtual machine:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sm.CallCode(entryAddr);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CallCode()&lt;/code&gt; method continues the execution cycle of the machine and pauses it when the code returns. The &lt;code class=&quot;highlighter-rouge&quot;&gt;sm.CompletionTask&lt;/code&gt; provides an awaiter to wait while the machine gets paused.&lt;/p&gt;

&lt;p&gt;The last part of the code uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt; property to
get information about the screen. The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt; object can be used to check every pixel in the rendered screen (including the border pixels):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var screen = sm.ScreenConfiguration;
var redCount = 0;
for (var i = 0; i &amp;lt; screen.ScreenLines; i++)
    for (var j = 0; j &amp;lt; screen.ScreenWidth; j++)
        redCount += sm.ScreenBitmap[i,j] == 0x02 ? 1 : 0;

Console.WriteLine($&quot;#of red pixels: {redCount}&quot;);
var borderPixels = screen.ScreenLines * screen.ScreenWidth
    - screen.DisplayLines * screen.DisplayWidth;
Console.WriteLine($&quot;#of border pixels: {borderPixels}&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you start this code from Visual Studio, it produces this output:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Setting the border to red
#of red pixels: 52224
#of border pixels: 52224
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The result proves that the virtual machine renders all border pixels with red color.&lt;/p&gt;</content><author><name></name></author><summary type="html">SpectNetIde is not just a simple ZX Spectrum emulator and a set of development tools integrated with Visual Studio, it offers a collection of .NET objects that you can use to automate ZX Spectrum related tasks.</summary></entry><entry><title type="html">Scripting the Z80 CPU</title><link href="http://localhost:4000/spectnetide/documents/scripting-z80" rel="alternate" type="text/html" title="Scripting the Z80 CPU" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-z80</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-z80">&lt;h1 id=&quot;the-cpuz80-class&quot;&gt;The CpuZ80 class&lt;/h1&gt;

&lt;p&gt;This class represents the Z80 CPU of a Spectrum virtual machine. Using this class you can get and 
set the value of each register, register pair, flag, and other state holders. The class also provides
a few contol methods and events that are raised at different stages of the CPU’s execution cycle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class CpuZ80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;register-properties&quot;&gt;Register properties&lt;/h1&gt;

&lt;p&gt;The class has separate properties for all 8-bit registers and 16-bit register pairs of the CPU. 
An 8-bit register’s value is represented with a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Byte&lt;/code&gt;, while a 16-bit register pair’s value
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.UInt16&lt;/code&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;8-bit-registers&quot;&gt;8-bit registers&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Accummulator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;B&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;C&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;D&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;E&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;H&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register &lt;strong&gt;L&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Flags register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Interrupt Page Address Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Memory Refresh Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XH&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the IX index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the IX index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YH&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the IY index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the IY index register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZh&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Higher 8 bits of the internal WZ register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZl&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Lower 8 bits of the internal WZ register&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;16-bit-register-pairs&quot;&gt;16-bit register pairs&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AF&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;AF&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;BC&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;DE&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;HL&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_AF_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;AF’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_BC_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;BC’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_DE_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;DE’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_HL_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Register pair &lt;strong&gt;HL’&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Program Counter Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Stack Pointer Register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;I/R 8-bit registers as a register pair&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Index register &lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IY&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Index register &lt;strong&gt;IY&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WZ&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The internal &lt;strong&gt;WZ&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;z80-cpu-flags&quot;&gt;Z80 CPU flags&lt;/h2&gt;

&lt;p&gt;With these properties, you can query the individual flags of the &lt;strong&gt;F&lt;/strong&gt; register. These properties
retrieve a &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Boolean&lt;/code&gt; value.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;S&lt;/strong&gt; (Sign) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Z&lt;/strong&gt; (Zero) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R5Flag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;R5&lt;/strong&gt; Flag, Bit 5 of the &lt;strong&gt;F&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;H&lt;/strong&gt; (Half Carry) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R3Flag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;R3&lt;/strong&gt; Flag, Bit 3 of the &lt;strong&gt;F&lt;/strong&gt; register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PVFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;P/V&lt;/strong&gt; (Parity/Overflow) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;N&lt;/strong&gt; (Add/Subtract) Flag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CFlag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;C&lt;/strong&gt; (Carry) Flag&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;cpu-state-properties&quot;&gt;CPU state properties&lt;/h1&gt;

&lt;p&gt;There are various properties that indicate the internal state of the CPU&lt;/p&gt;

&lt;h2 id=&quot;tacts&quot;&gt;Tacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long Tacts { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the current T-state tacts of the CPU — the clock cycles since 
the CPU was powered on/reset last time&lt;/p&gt;

&lt;h2 id=&quot;iff1&quot;&gt;IFF1&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IFF1 { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interrupt Enable Flip-Flop #1. Disables interrupts from being accepted.&lt;/p&gt;

&lt;h2 id=&quot;iff2&quot;&gt;IFF2&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IFF2 { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interrupt Enable Flip-Flop #2. Temporary storage location for IFF1.&lt;/p&gt;

&lt;h2 id=&quot;interruptmode&quot;&gt;InterruptMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte InterruptMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the current Interrupt mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;IM 0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IM 1&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;IM 2&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&quot;isinterruptblocked&quot;&gt;IsInterruptBlocked&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInterruptBlocked { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the CPU internally blocks the interrupts, even if the maskable interrupt is enabled.
When the CPU is within processing a multi-byte statement, this flag is set.&lt;/p&gt;

&lt;h2 id=&quot;isinopexecution&quot;&gt;IsInOpExecution&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInOpExecution { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the CPU still needs to read more bytes to decode a multi-byte operation.&lt;/p&gt;

&lt;h2 id=&quot;maskableinterruptmodeentered&quot;&gt;MaskableInterruptModeEntered&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool MaskableInterruptModeEntered { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates that the instructions the CPU is executing are the part of the maskable interrupt method.&lt;/p&gt;

&lt;h1 id=&quot;control-methods&quot;&gt;Control methods&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class provides a few control operation that you can use in the scripts.&lt;/p&gt;

&lt;h2 id=&quot;reset&quot;&gt;Reset()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Reset()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Issues a Reset (&lt;code class=&quot;highlighter-rouge&quot;&gt;RST&lt;/code&gt;) signal to the CPU.&lt;/p&gt;

&lt;h2 id=&quot;disableinterrupt&quot;&gt;DisableInterrupt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void DisableInterrupt()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Disables the maskable interrupt.&lt;/p&gt;

&lt;h2 id=&quot;enableinterrupt&quot;&gt;EnableInterrupt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void EnableInterrupt()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Enables the maskable interrupt.&lt;/p&gt;

&lt;h1 id=&quot;operation-tracking&quot;&gt;Operation tracking&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class allows you to track the addresses the CPU executes an operation for.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState OperationTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationTrackingState&lt;/code&gt; property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been read as a part of CPU’s M1 machine cycle.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetOperationTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ResetOperationTracking()&lt;/code&gt; method resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationTrackingState&lt;/code&gt; property as if no 
operations had been executed.&lt;/p&gt;

&lt;p&gt;The following sampe demonstrates how you can use these members of &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; to check which instructions
have been executed. (This code snippet is an extract for a unit test of &lt;strong&gt;SpectNetIde&lt;/strong&gt;.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationTrackingWorks()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.Breakpoints.AddBreakpoint(0x11CB);
    sm.StartDebug();
    await sm.CompletionTask;
    var pcBefore = sm.Cpu.PC;
    sm.ExecutionCompletionReason.ShouldBe(ExecutionCompletionReason.BreakpointReached);
    sm.MachineState.ShouldBe(VmState.Paused);

    // --- Act
    sm.Cpu.ResetOperationTracking();
    sm.Breakpoints.ClearAllBreakpoints();
    sm.Breakpoints.AddBreakpoint(0x11CE);
    sm.StartDebug();
    await sm.CompletionTask;
    var pcAfter = sm.Cpu.PC;

    // --- Assert
    pcBefore.ShouldBe((ushort)0x11CB);
    pcAfter.ShouldBe((ushort)0x11CE);
    sm.Cpu.OperationTrackingState.TouchedAny(0x0000, 0x11CA).ShouldBeFalse();
    sm.Cpu.OperationTrackingState[0x11CB].ShouldBeTrue();
    sm.Cpu.OperationTrackingState[0x11CC].ShouldBeTrue();
    sm.Cpu.OperationTrackingState[0x11CD].ShouldBeTrue();
    sm.Cpu.OperationTrackingState.TouchedAny(0x11CE, 0xFFFF).ShouldBeFalse();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;z80-cpu-events&quot;&gt;Z80 CPU events&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class provides about a dozen events that you can use in script.&lt;/p&gt;

&lt;h2 id=&quot;interruptexecuting&quot;&gt;InterruptExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler InterruptExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a maskable interrupt is about to execute.&lt;/p&gt;

&lt;h2 id=&quot;nmiexecuting&quot;&gt;NmiExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler NmiExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a non-maskable interrupt is about to execute.&lt;/p&gt;

&lt;h2 id=&quot;memoryreading&quot;&gt;MemoryReading&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressEventArgs&amp;gt; MemoryReading
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before the memory is being read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressEventArgs&lt;/code&gt;) 
has a property, &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; that tells the memory address going to be read.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this operation is being executed, the contents of the memory has not been read yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;memoryread&quot;&gt;MemoryRead&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryRead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised right after the memory has been read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) 
contains these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
public byte Data { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; keeps the address read, &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; holds the data byte resulted from the read operation.&lt;/p&gt;

&lt;h2 id=&quot;memorywriting&quot;&gt;MemoryWriting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryWriting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before the memory is being written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the memory address, and the data byte to write, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;memorywritten&quot;&gt;MemoryWritten&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; MemoryWritten
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after the memory has been written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the memory address, and the data byte written, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;portreading&quot;&gt;PortReading&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressEventArgs&amp;gt; PortReading
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a port is being read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressEventArgs&lt;/code&gt;) 
has a property, &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; that tells the port address going to be read.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this operation is being executed, the port has not been read yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;portread&quot;&gt;PortRead&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortRead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a port has been read. The event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) 
contains these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort Address { get; }
public byte Data { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; keeps the address of the port read, &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; holds the data byte resulted from the read operation.&lt;/p&gt;

&lt;h2 id=&quot;portwriting&quot;&gt;PortWriting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortWriting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a port is being written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the port address, and the data byte to write, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;portwritten&quot;&gt;PortWritten&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;AddressAndDataEventArgs&amp;gt; PortWritten
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a port has been written. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; properties of the
event argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressAndDataEventArgs&lt;/code&gt;) contain the port address, and the data byte written, 
respectively.&lt;/p&gt;

&lt;h2 id=&quot;operationexecuting&quot;&gt;OperationExecuting&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;Z80InstructionExecutionEventArgs&amp;gt; OperationExecuting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just before a Z80 operation is being executed. The event arguments
instance (&lt;a href=&quot;Z80InstructionExecutionEventArgs.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;) provides 
properties you can check the operation being executed.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this event is raised, the CPU might not have read all operation code bytes, just those one that
are enough to decode the type of operation to execute. If the operation contains arguments that are
part of the operation code, those are not yet read.&lt;br /&gt;
For example when this event is signed, the opcode part for &lt;code class=&quot;highlighter-rouge&quot;&gt;#80&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,#80&lt;/code&gt;, or the #23 opcode part
of &lt;code class=&quot;highlighter-rouge&quot;&gt;LD (IX+#23),C&lt;/code&gt; operation is not read.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operationexecuted&quot;&gt;OperationExecuted&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;Z80InstructionExecutionEventArgs&amp;gt; OperationExecuted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised just after a Z80 operation has been executed. The event arguments
instance (&lt;a href=&quot;Z80InstructionExecutionEventArgs.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;) provides 
properties you can check the operation executed.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this event is raised, the full operation is already read.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;operationexecuting-and-operationexecuted-sample&quot;&gt;OperationExecuting and OperationExecuted sample&lt;/h2&gt;

&lt;p&gt;To demonstrate the difference between these events, the following sample code snippets (extracts from
&lt;strong&gt;SpectNetIde&lt;/strong&gt; unit tests) provide more details.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationExecutingIsInvoked()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.CachedVmStateFolder = STATE_FOLDER;
    await sm.StartAndRunToMain(true);
    var events = new List&amp;lt;Z80InstructionExecutionEventArgs&amp;gt;();

    // --- Act
    var entryAddress = sm.InjectCode(@&quot;
        .org #8000
        di;              8000: No prefix
        bit 3,a;         8001: CB prefix
        ld a,(ix+2);     8003: DD prefix
        ld a,(iy+6);     8006: FD prefix
        bit 2,(ix+2);    8009: DD CB prefixes
        bit 2,(iy+6);    800D: FD CB prefixes
        in d,(c);        8011: ED prefix
        ret
    &quot;);
    sm.Cpu.OperationExecuting += (s, e) =&amp;gt; { events.Add(e); };
    sm.CallCode(entryAddress);
    await sm.CompletionTask;

    // --- Assert
    var sampleIndex = events.Count - 1 - 7; // -1 for the RET operation, -7 for the 7 operations
    var op = events[sampleIndex];
    op.PcBefore.ShouldBe((ushort)0x8000);
    op.Instruction.SequenceEqual(new byte[] { 0xF3 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0xF3);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 1];
    op.PcBefore.ShouldBe((ushort)0x8001);
    op.Instruction.SequenceEqual(new byte []{ 0xCB, 0x5F}).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x5F);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 2];
    op.PcBefore.ShouldBe((ushort)0x8003);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0x7E }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 3];
    op.PcBefore.ShouldBe((ushort)0x8006);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0x7E }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 4];
    op.PcBefore.ShouldBe((ushort)0x8009);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0xCB, 0x56 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 5];
    op.PcBefore.ShouldBe((ushort)0x800D);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0xCB, 0x56 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBeNull();

    op = events[sampleIndex + 6];
    op.PcBefore.ShouldBe((ushort)0x8011);
    op.Instruction.SequenceEqual(new byte[] { 0xED, 0x50 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x50);
    op.PcAfter.ShouldBeNull();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can check that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Instruction&lt;/code&gt; property is tested against the partial opcode.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TestMethod]
public async Task OperationExecutedIsInvoked()
{
    // --- Arrange
    var sm = SpectrumVmFactory.CreateSpectrum48Pal();
    sm.CachedVmStateFolder = STATE_FOLDER;
    await sm.StartAndRunToMain(true);
    var events = new List&amp;lt;Z80InstructionExecutionEventArgs&amp;gt;();

    // --- Act
    var entryAddress = sm.InjectCode(@&quot;
        .org #8000
        di;              8000: No prefix
        bit 3,a;         8001: CB prefix
        ld a,(ix+2);     8003: DD prefix
        ld a,(iy+6);     8006: FD prefix
        bit 2,(ix+2);    8009: DD CB prefixes
        bit 2,(iy+6);    800D: FD CB prefixes
        in d,(c);        8011: ED prefix
        ret
    &quot;);
    sm.Cpu.OperationExecuted += (s, e) =&amp;gt; { events.Add(e); };
    sm.CallCode(entryAddress);
            await sm.CompletionTask;

    // --- Assert
    var sampleIndex = events.Count - 1 - 7; 
        // -1 for the RET operation, -7 for the 7 operations
    var op = events[sampleIndex];
    op.PcBefore.ShouldBe((ushort)0x8000);
    op.Instruction.SequenceEqual(new byte[] { 0xF3 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0xF3);
    op.PcAfter.ShouldBe((ushort)0x8001);

    op = events[sampleIndex + 1];
    op.PcBefore.ShouldBe((ushort)0x8001);
    op.Instruction.SequenceEqual(new byte[] { 0xCB, 0x5F }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x5F);
    op.PcAfter.ShouldBe((ushort)0x8003);

    op = events[sampleIndex + 2];
    op.PcBefore.ShouldBe((ushort)0x8003);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0x7E, 0x02}).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBe((ushort)0x8006);

    op = events[sampleIndex + 3];
    op.PcBefore.ShouldBe((ushort)0x8006);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0x7E, 0x06 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x7E);
    op.PcAfter.ShouldBe((ushort)0x8009);

    op = events[sampleIndex + 4];
    op.PcBefore.ShouldBe((ushort)0x8009);
    op.Instruction.SequenceEqual(new byte[] { 0xDD, 0xCB, 0x56, 0x02 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBe((ushort)0x800D);

    op = events[sampleIndex + 5];
    op.PcBefore.ShouldBe((ushort)0x800D);
    op.Instruction.SequenceEqual(new byte[] { 0xFD, 0xCB, 0x56, 0x06 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x56);
    op.PcAfter.ShouldBe((ushort)0x8011);

    op = events[sampleIndex + 6];
    op.PcBefore.ShouldBe((ushort)0x8011);
    op.Instruction.SequenceEqual(new byte[] { 0xED, 0x50 }).ShouldBeTrue();
    op.OpCode.ShouldBe((byte)0x50);
    op.PcAfter.ShouldBe((ushort)0x8013);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;highlighter-rouge&quot;&gt;Instruction&lt;/code&gt; property is checked against the entire opcode.&lt;/p&gt;

&lt;h1 id=&quot;the-addresstrackingstate-class&quot;&gt;The AddressTrackingState class&lt;/h1&gt;

&lt;p&gt;This class represents tracking information regarding memory. The scripting engine 
(&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt; classes) use this type to track 
operation execution, memory reads and memory writes.&lt;/p&gt;

&lt;p&gt;This class stores a flag for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range. A false value 
means that the tracking event has not been signed for that particular address. The true value
says that the tracking event has happened.&lt;/p&gt;

&lt;p&gt;For example, when you start the Spectrum virtual machine, after executing the first 
instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;DI&lt;/code&gt;), the flag for #0000 is set to true, but all the others remains false.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class AddressTrackingState
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisushort&quot;&gt;this[ushort]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool this[ushort address] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the status bit of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;touchedallushort-ushort&quot;&gt;TouchedAll(ushort, ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool TouchedAll(ushort startAddr, ushort endAddr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checks if all tracking flag is set between &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddr&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endAddr&lt;/code&gt;&lt;/em&gt;.
Both addresses are inclusive. Returns true, if all flag is set; otherwise, false.&lt;/p&gt;

&lt;h2 id=&quot;touchedanyushort-ushort&quot;&gt;TouchedAny(ushort, ushort)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;public bool TouchedAny(ushort startAddr, ushort endAddr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checks if any tracking flag is set between &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddr&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endAddr&lt;/code&gt;&lt;/em&gt; at all.
Both addresses are inclusive. Returns true, if any of the flags is set; otherwise, false.&lt;/p&gt;

&lt;h1 id=&quot;the-z80instructionexecutioneventargs-class&quot;&gt;The Z80InstructionExecutionEventArgs class&lt;/h1&gt;

&lt;p&gt;This class provides event arguments the the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; 
events of the &lt;a href=&quot;CpuZ80.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;h2 id=&quot;pcbefore&quot;&gt;PcBefore&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort PcBefore { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of PC before the execution.&lt;/p&gt;

&lt;h2 id=&quot;instruction&quot;&gt;Instruction&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IList&amp;lt;byte&amp;gt; Instruction { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The opcode bytes available at the time of event. For example, if the operation is &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,(IX+2)&lt;/code&gt;,
this list contains &lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; event, but &lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt;, 
and &lt;code class=&quot;highlighter-rouge&quot;&gt;#02&lt;/code&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; event.&lt;/p&gt;

&lt;h2 id=&quot;opcode&quot;&gt;OpCode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte OpCode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main operation code. For example, if the operation is &lt;code class=&quot;highlighter-rouge&quot;&gt;LD A,(IX+2)&lt;/code&gt;, this value is &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; from
the entire operation opcode (&lt;code class=&quot;highlighter-rouge&quot;&gt;#DD&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;#7E&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;#02&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;pcafter&quot;&gt;PcAfter&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort? PcAfter { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of PC after the operation has been executed. It is null during &lt;code class=&quot;highlighter-rouge&quot;&gt;OerationExecuting&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">The CpuZ80 class</summary></entry><entry><title type="html">Managing Virtual machines</title><link href="http://localhost:4000/spectnetide/documents/scripting-vms" rel="alternate" type="text/html" title="Managing Virtual machines" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-vms</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-vms">&lt;h1 id=&quot;the-spectrumvmfactory-class&quot;&gt;The SpectrumVmFactory class&lt;/h1&gt;

&lt;p&gt;This class provides methods you can use to create ZX Spectrum virtual machine instances. 
Each factory methods retrieves a &lt;a href=&quot;SpectrumVm.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance you can use to control and query
the particular machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static class SpectrumVmFactory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;createstring-string&quot;&gt;Create(string, string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm Create(string modelKey, string editionKey)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance according to the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt;&lt;/em&gt; 
and &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;&lt;/em&gt; values.&lt;/p&gt;

&lt;h3 id=&quot;arguments&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modelkey&lt;/code&gt;: The name of the Spectrum model.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;: The name of the Spectrum edition&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt; class defines several string constants that you can use for these arguments.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;returns&quot;&gt;Returns&lt;/h3&gt;

&lt;p&gt;The newly created ZX Spectrum virtual machine instance.&lt;/p&gt;

&lt;h3 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArgumentNullException&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;KeyNotFoundException&lt;/code&gt;: The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; class does not have a definition
for &lt;code class=&quot;highlighter-rouge&quot;&gt;modelKey&lt;/code&gt;, or the model does not have an edition for &lt;code class=&quot;highlighter-rouge&quot;&gt;editionKey&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;sample&quot;&gt;Sample&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = Create(SpectrumModels.ZX_SPECTRUM_48, SpectrumModels.NTSC);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;createspectrum48pal&quot;&gt;CreateSpectrum48Pal()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48Pal()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48palturbo&quot;&gt;CreateSpectrum48PalTurbo()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48PalTurbo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K PAL virtual machine with double CPU speed (7MHz) and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48ntsc&quot;&gt;CreateSpectrum48Ntsc()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48Ntsc()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K NTSC virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum48ntscturbo&quot;&gt;CreateSpectrum48NtscTurbo()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum48NtscTurbo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 48K NTSC virtual machine with double CPU speed (7MHz) and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrum128&quot;&gt;CreateSpectrum128()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum128()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum 128K PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;createspectrump3e&quot;&gt;CreateSpectrumP3E()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumVm CreateSpectrum128()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Creates a new ZX Spectrum +3E PAL virtual machine and retrieves it as 
a &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;h1 id=&quot;provider-configuration&quot;&gt;Provider configuration&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; class allows to change providers to customize
the virtual machine to your needs. Doing this requires a bit deeper knowledge
of how the emulator in SpectNetIde works. Probably, you do not need to
use your own providers at all.&lt;/p&gt;

&lt;p&gt;Nonetheless, these are the methods you can use to change the default provider
configuration:&lt;/p&gt;

&lt;h2 id=&quot;reset&quot;&gt;Reset()&lt;/h2&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; class, clears the predefined providers.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void Reset()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After invoking &lt;code class=&quot;highlighter-rouge&quot;&gt;Reset()&lt;/code&gt; you need to set up your own providers.&lt;/p&gt;

&lt;h2 id=&quot;registerprovidertproviderfunctprovider&quot;&gt;RegisterProvider&amp;lt;TProvider&amp;gt;(Func&amp;lt;TProvider&amp;gt;)&lt;/h2&gt;

&lt;p&gt;Registers a factory method for the &lt;code class=&quot;highlighter-rouge&quot;&gt;TProvider&lt;/code&gt; type.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void RegisterProvider&amp;lt;TProvider&amp;gt;(Func&amp;lt;TProvider&amp;gt; factory)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can register your own &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;factory&lt;/code&gt;&lt;/em&gt; method that creates a provider for 
&lt;code class=&quot;highlighter-rouge&quot;&gt;TProvider&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;registerdefaultproviders&quot;&gt;RegisterDefaultProviders()&lt;/h2&gt;

&lt;p&gt;Allows you to register the default providers.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void RegisterDefaultProviders()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you need to restore the original behavior of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;,
use this code snippet:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SpectrumVmFactory.Reset();
SpectrumVmFactory.RegisterDefaultProviders();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By default, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; uses these provider registrations:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RegisterProvider&amp;lt;IRomProvider&amp;gt;(() 
    =&amp;gt; new ResourceRomProvider(typeof(RomResourcesPlaceHolder).Assembly));
RegisterProvider&amp;lt;IKeyboardProvider&amp;gt;(() 
    =&amp;gt; new ScriptingKeyboardProvider());
RegisterProvider&amp;lt;IBeeperProvider&amp;gt;(() 
    =&amp;gt; new NoAudioProvider());
RegisterProvider&amp;lt;ITapeProvider&amp;gt;(() 
    =&amp;gt; new ScriptingTapeProvider());
RegisterProvider&amp;lt;ISoundProvider&amp;gt;(() 
    =&amp;gt; new NoAudioProvider());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As the names suggest, the virtual machine created by &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt; does not 
generate audio (neither for the beeper nor for the PSG).&lt;/p&gt;

&lt;h1 id=&quot;the-spectrumvm-class&quot;&gt;The SpectrumVm class&lt;/h1&gt;

&lt;p&gt;This class represents a Spectrum virtual machine. You cannot instantiate a machine
with the constructor of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;, for it is not accessible. To create a Spectrum machine,
use the &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt; is a pivotal type in the scripting feature of &lt;strong&gt;SpectNetIde&lt;/strong&gt;. When you have an
object instance in your code, it provides a plethora of properties and methods to access and control
the Spectrum virtual machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;public sealed class SpectrumVm: IDisposable, ISpectrumVmController
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the properties of this class, you can access all important components of the virtual machine.&lt;/p&gt;

&lt;h2 id=&quot;modelkey&quot;&gt;ModelKey&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string ModelKey { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gets the model key of the virtual machine (see &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;editionkey&quot;&gt;EditionKey&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string EditionKey { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gets the edition key of the virtual machine (see &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;cpu&quot;&gt;Cpu&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public CpuZ80 Cpu { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the object that represents the current state of the Z80 CPU. 
You can also use this instance to control the CPU (see also &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;roms&quot;&gt;Roms&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IReadOnlyList&amp;lt;ReadOnlyMemorySlice&amp;gt; Roms { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides access to the binary contents of each individual ROM of
the virtual machine. Each item of the list provides a ROM of the machine.
For example, in a ZX Spectrum 128K machine instance, there are two ROMs
with index 0, and 1. (see also &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-readonlymemoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlyMemorySlice&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;romcount&quot;&gt;RomCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RomCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves the number of ROMs.&lt;/p&gt;

&lt;h2 id=&quot;paginginfo&quot;&gt;PagingInfo&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public MemoryPagingInfo PagingInfo { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Allows you to obtain information about memory paging. There’s no reason
to use this property for a ZX Spectrum 48K virtual machine, as this model 
does not support memory paging. However, it is useful for other models. 
See &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memorypaginginfo-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemoryPagingInfo&lt;/code&gt;&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;memory&quot;&gt;Memory&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SpectrumMemoryContents Memory { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Represents the current contents of the addressable 64K memory of the
virtual machine. You can use this property to read and write the memory.
See &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-spectrummemorycontents-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumMemoryContents&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;rambanks&quot;&gt;RamBanks&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IReadOnlyList&amp;lt;MemorySlice&amp;gt; RamBanks { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this property, you can access the contents of each RAM bank, independently 
whether that particular bank is paged in. The elements of the list represent the
memory banks from #0 to #7. Check &lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memoryslice-class&quot;&gt;MemorySlice&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;rambankcount&quot;&gt;RamBankCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RamBankCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of RAM banks available.&lt;/p&gt;

&lt;h2 id=&quot;keyboard&quot;&gt;Keyboard&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public KeyboardEmulator Keyboard { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can access the state of the virtual keyboard through this class. You can also
use it to emulate keystrokes. See &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-keyboardemulator-class&quot;&gt;KeyboardEmulator&lt;/a&gt; for details.&lt;/p&gt;

&lt;h2 id=&quot;screenconfiguration&quot;&gt;ScreenConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenConfiguration ScreenConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Allows access to the details of the screen configuration that determine the tacts 
of screen rendering, such as number of raster lines, non-visible screen area, border pixels
above and below the display area, and many more. Check &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt; 
for all available properties of the configuration object.&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingtable&quot;&gt;ScreenRenderingTable&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTable ScreenRenderingTable { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The virtual machine uses a table that contains an item for each screen
rendering tact. You can access the information about an individual tact
through this porperty. The &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtable-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTable&lt;/code&gt;&lt;/a&gt; contains more
details about the information you can access.&lt;/p&gt;

&lt;h2 id=&quot;screenbitmap&quot;&gt;ScreenBitmap&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenBitmap ScreenBitmap { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides access to each individual pixels of the visible screen. This object
represents not only the display area (the 256 x 192 pixels for a ZX Spectrum 48K 
model), but also the border area. To check the dimensions, use the properties of
&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt;. The reference documentation of
&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenbitmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt;&lt;/a&gt; offers more details about addressing the pixels
within this object.&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingstatus&quot;&gt;ScreenRenderingStatus&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingStatus ScreenRenderingStatus { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provides information about the current screen rendering status. 
See &lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingstatus-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingStatus&lt;/code&gt;&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;beeperconfiguration&quot;&gt;BeeperConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IAudioConfiguration BeeperConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the configuration of the beeper device (such as sampling frequency, and others).
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt; provides more details.&lt;/p&gt;

&lt;h2 id=&quot;beepersamples&quot;&gt;BeeperSamples&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AudioSamples BeeperSamples { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the beeper samples of the current screen rendering frame. The 
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt; type describes how you can access individual samples.&lt;/p&gt;

&lt;h2 id=&quot;soundconfiguration&quot;&gt;SoundConfiguration&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public IAudioConfiguration SoundConfiguration { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the configuration of the PSG (AY-3-8912 chip) sound device (such as sampling frequency, and others).
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt; provides more details.&lt;/p&gt;

&lt;h2 id=&quot;audiosamples&quot;&gt;AudioSamples&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AudioSamples AudioSamples { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the PSG (AY-3-8912 chip) sound samples of the current screen rendering frame. The 
&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt; type describes how you can access individual samples.&lt;/p&gt;

&lt;h2 id=&quot;breakpoints&quot;&gt;Breakpoints&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public CodeBreakpoints Breakpoints { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This property allows you to manage the breakpoints. When you run the virtual machine
in debug mode (see the &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug()&lt;/code&gt; method), the virtual machine is paused whenever
it reaches a breakpoint. The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-codebreakpoints-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBreakpoints&lt;/code&gt;&lt;/a&gt; documentation gives 
you more clues.&lt;/p&gt;

&lt;h2 id=&quot;timeoutinms&quot;&gt;TimeoutInMs&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutInMs { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can start the virtual machine with a timeout value. When the specified
timeout expires, the virtual machine pauses. With the &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; property,
you can set up this value given in milliseconds.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Internally, the virtual machine transforms this value into CPU T-states according to
the clock frequency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;timeouttacts&quot;&gt;TimeoutTacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutTacts { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this property, you can specify the timeout value in CPU T-states. Providing the CPU uses
a
3.5 MHz clock, setting &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutTacts&lt;/code&gt; to 3500 equals to set &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; to 1.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Specifying zero value for &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutInMs&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutTacts&lt;/code&gt; means that there’s no explicit
timeout, thus the virtual machine runs until explicitly stopped or paused in the code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;realtimemode&quot;&gt;RealTimeMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool RealTimeMode { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Normally, scripting runs the virtual machine in quick mode, so it continuously runs the
CPU and renders the screen. It does not sync the machine with the screen rendering
frequency. If you set this property to true, the virtual machine will run with the same speed
as a physical machine would do.&lt;/p&gt;

&lt;h2 id=&quot;disablescreenrendering&quot;&gt;DisableScreenRendering&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool DisableScreenRendering { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Setting this property to true would disable the screen rendering, and so the virtual
machine would faster. Nonetheless, in this mode — as the screen is not remdered
— you cannot use &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt; to check the contents of the rendered frame. 
After the machine starts, the contents remains the same.&lt;/p&gt;

&lt;h2 id=&quot;machinestate&quot;&gt;MachineState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public VmState MachineState { get; private set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This property allows you to check the current state of the virtual machine.
Take a look at the &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt; enumeration for details about the
possible states.&lt;/p&gt;

&lt;h2 id=&quot;executioncompletionreason&quot;&gt;ExecutionCompletionReason&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ExecutionCompletionReason ExecutionCompletionReason { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The virtual machine can go into paused or stopped state for many reasons.
The &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executioncompletionreason-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutionCompletionReason&lt;/code&gt;&lt;/a&gt; enumeration allows you to check what
event has caused that the machine is in a specific state.&lt;/p&gt;

&lt;h2 id=&quot;runsindebugmode&quot;&gt;RunsInDebugMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool RunsInDebugMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtual machine runs in debug mode.&lt;/p&gt;

&lt;h2 id=&quot;completiontask&quot;&gt;CompletionTask&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Task CompletionTask { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After th virtual machine has been started, it runs in a background thread.
While it runs, you can use the UI thread for other activities. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property can be used to wait for the completion of
the virtual machine (it gets paused or stopped).&lt;/p&gt;

&lt;p&gt;For example, this sample starts the virtual machine id debug mode, does
some other activity on the UI thread, and then wait while the machine reaches
its firs breakpoint:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
// --- Set up breakpoints (omitted from code)
sm.StartDebug();
// --- Do something on UI thread (omitted from code)
await sm.CompletionTask;
// --- Go on on UI thread
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cachedvmstatefolder&quot;&gt;CachedVmStateFolder&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public string CachedVmStateFolder { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can speed up the virtual machine startup by starting it from its
saved state. The scripting engine stores these state files (with &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmstate&lt;/code&gt; extension)
in a cache folder. By default, it is the current folder.
With setting &lt;code class=&quot;highlighter-rouge&quot;&gt;CachedVmStateFolder&lt;/code&gt;, you can specify the storage location
of these state files.&lt;/p&gt;

&lt;h1 id=&quot;control-methods-and-properties&quot;&gt;Control Methods and Properties&lt;/h1&gt;

&lt;p&gt;The Spectrum virtual machine’s execution cycle — the one that executes CPU instruction,
takes care of rendering the screen and sound — runs on a background thread. With the control
methods, you can start, pause, and stop the machine in multiple ways. When you need to wait for the
completion of the execution cycle, you can use the [CompletionTask] property.&lt;/p&gt;

&lt;h2 id=&quot;isfirststart&quot;&gt;IsFirstStart&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsFirstStart { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Signs that this is the very first start of the virtual machine.&lt;/p&gt;

&lt;h2 id=&quot;isfirstpause&quot;&gt;IsFirstPause&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsFirstPause { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Signs that this is the very first pause of the virtual machine after its first start.&lt;/p&gt;

&lt;h2 id=&quot;start&quot;&gt;Start()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine in continuous execution mode. It runs unless the script pauses or
stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;startexecutecycleoptions&quot;&gt;Start(ExecuteCycleOptions)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Start(ExecuteCycleOptions options)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine with the specified execution mode (see also &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executecycleoptions-class&quot;&gt;ExecuteCycleOptions&lt;/a&gt;).
The machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;startdebug&quot;&gt;StartDebug()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StartDebug()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the virtual machine in debug mode and sets the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunsInDebugMode&lt;/code&gt; property to true. Whenever the execution flow reaches a breakpoint, the machine gets
paused. Additionally, the machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilhalt&quot;&gt;RunUntilHalt()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilHalt();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until it reaches a HALT instruction, then is gets
paused. Otherwise, the machine runs unless the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilframecompletion&quot;&gt;RunUntilFrameCompletion()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilFrameCompletion()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until the current screen rendering frame is 
completed. Then it gets paused. Otherwise, the machine runs unless the script pauses or stops it, or 
the specified timeout expires.&lt;/p&gt;

&lt;h2 id=&quot;rununtilterminationpointushort-int&quot;&gt;RunUntilTerminationPoint(ushort, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RunUntilTerminationPoint(ushort address, int romIndex = 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starts the Spectrum machine and runs it on a background thread until the CPU reaches the specified 
termination point (address). At that point the machine gets paused. Otherwise, the machine runs unless 
the script pauses or stops it, or the specified timeout expires.&lt;/p&gt;

&lt;h3 id=&quot;arguments-1&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;: The address at which to pause the machine&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;romIndex&lt;/code&gt;: If the address is within the ROM, romIndex specified the index of the ROM that should 
be selected to pause the machine.&lt;/p&gt;

&lt;h3 id=&quot;sample-1&quot;&gt;Sample&lt;/h3&gt;

&lt;p&gt;You can start and run a ZX Spectrum 48K virtual machine while it reaches the main execution cycle
point (&lt;code class=&quot;highlighter-rouge&quot;&gt;#12A9&lt;/code&gt;) in the ROM:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
sm.RunUntilTerminationPoint(0x12A9);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;startandruntomainbool&quot;&gt;StartAndRunToMain(bool)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task StartAndRunToMain(bool spectrum48Mode = false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A convenience method that starts the virtual machine and pauses it when it reaches its main
execution cycle. The method can be used to wait while the machine pauses.&lt;/p&gt;

&lt;h3 id=&quot;arguments-2&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spectrum48Mode&lt;/code&gt;: Setting this flag to true, ZX Spectrum 128K and later models are started in
Spectrum 48 BASIC mode&lt;/p&gt;

&lt;h3 id=&quot;remarks&quot;&gt;Remarks&lt;/h3&gt;

&lt;p&gt;Behind the scenes, this method does a lot of things for you:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First it checks, if there’s a saved machine state image for the machine model. If there is, 
it simply loads that state and puts the machine into paused state.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Otherwise, according to the machine type and the &lt;code class=&quot;highlighter-rouge&quot;&gt;spectrum48Mode&lt;/code&gt; flag, it determines the 
termination point.
    &lt;ul&gt;
      &lt;li&gt;It starts the virtual machine and runs it to the desired termination point.&lt;/li&gt;
      &lt;li&gt;While doing this, the method emulates key strokes so that the machine could start
in the desired mode.&lt;/li&gt;
      &lt;li&gt;After the termination mode is reached, pauses the machine and saves its state so that the
next startup would be faster.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The method retrieves the &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property so that you can wait for completion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sample-2&quot;&gt;Sample&lt;/h3&gt;

&lt;p&gt;This code snippet starts a ZX Spectrum 128K virtual machine in 48 mode, and waits while the 
machine reaches the main execution cycle.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum128Pal();
await sm.StartAndRunToMain(true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pause&quot;&gt;Pause()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task Pause()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pauses the running Spectrum virtual machine. After it is paused, you can continue the execution
with any of these methods: &lt;code class=&quot;highlighter-rouge&quot;&gt;Start()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Start(ExecutionCycleOptions)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilHalt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilFrameCompletion()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilTerminationPoint()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stop&quot;&gt;Stop()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public async Task Stop()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Stops the running or paused Spectrum virtual machine. After it is stopped, you can resttart 
the execution with any of these methods: &lt;code class=&quot;highlighter-rouge&quot;&gt;Start()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Start(ExecutionCycleOptions)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;StartDebug&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilHalt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilFrameCompletion()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RunUntilTerminationPoint()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stepinto&quot;&gt;StepInto()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StepInto()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Executes the subsequent Z80 instruction, and then pauses the machine. As the execution happens 
on a background thread, you should wait for the completion with the &lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionTask&lt;/code&gt; property:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
// --- Do something with the machine and then pause (code omitted)
sm.StepInto();
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;stepover&quot;&gt;StepOver()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void StepOver()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Executes the subsequent Z80 CALL, RST, or block instruction (such as LDIR, LDDR, CPIR, etc.) entirely.
For example, when the subsequent instruction is a CALL, the machine gets paused as the engine detects
that the control flow is right on the next instruction after CALL (when the subroutine returned). By
using it, you do not have to step through all instructions one-by-one with &lt;code class=&quot;highlighter-rouge&quot;&gt;StepInto()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This method has a potential issue. If the method does not return to the expected location, for example,
it manipulates the stack, the virtual machine would not pause. It is definitely an issue with &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #08&lt;/code&gt; on
a ZX Spectrum 128K model, or with &lt;code class=&quot;highlighter-rouge&quot;&gt;RST #28&lt;/code&gt; on ZX Spectrum 48K. In the future, I am going to examine how
I can handle this issue — now, it is not perfect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;machine-state-management-methods&quot;&gt;Machine state management methods&lt;/h1&gt;

&lt;p&gt;The scripting provides simple methods to save and loade the current state of the virtual machine. This state
is composed from the state of each individual devices of the machine, including the CPU, memory, screen, 
beeper, sound devices, and all the others. WHile the machine is running, you cannot save the state, first you
should pause it.&lt;/p&gt;

&lt;p&gt;You can load the state when the machine is newly created, paused, or stopped.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are some limitations of state file handling. When you pause the machine while it’s loading a program 
from the tape and save its state, after restoring it cannot continue loading from the tape. The reason
behind this behavior is that the state file does not contain the data that represents the tape.
I’m investigating the possible resolutions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The virtual machine state files (with &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmstate&lt;/code&gt; extension) are simple JSON files, so you can open them
and check their structure to get more details on what’s within them. You can recognize that the contents 
of the memory is compressed. A Spectrum 48K state file takes about 25KBytes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;savemachinestatetostring&quot;&gt;SaveMachineStateTo(string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void SaveMachineStateTo(string filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Saves the state of the paused virtual machine to the specified file.&lt;/p&gt;

&lt;h3 id=&quot;arguments-3&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt;: Name of the file to save the machine state&lt;/p&gt;

&lt;h2 id=&quot;restoremachinestatestring&quot;&gt;RestoreMachineState(string)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RestoreMachineState(string filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loads the state of the paused or stopped machine from the specified file. When you continue the 
execution, the machine will start from the freshly loaded state.&lt;/p&gt;

&lt;h3 id=&quot;arguments-4&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt;: Name of the file that contains the machine state&lt;/p&gt;

&lt;h1 id=&quot;code-manipulation-methods&quot;&gt;Code manipulation methods&lt;/h1&gt;

&lt;p&gt;While the virtual machine is stopped, you can inject code into the memory so that you can execute it.
You do not need to use the [Memory] property of &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt; to do this. There are a few methods
that makes it extremely easy.&lt;/p&gt;

&lt;h2 id=&quot;injectcodeushort-byte-array&quot;&gt;InjectCode(ushort, byte array)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void InjectCode(ushort address, byte[] codeArray)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Injects code into the memory. Keeps the machine in paused state.&lt;/p&gt;

&lt;h3 id=&quot;arguments-5&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;: Start address of the injection&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;codeArray&lt;/code&gt;: A byte array that contains the machine code bytes in the order of injection&lt;/p&gt;

&lt;h2 id=&quot;injectcodestring-assembleroptions&quot;&gt;InjectCode(string, AssemblerOptions)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort InjectCode(string asmSource, AssemblerOptions options = null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This powerful method allows you to define the code to inject, in Z80 assembler language, using
all features the language provides. In the &lt;strong&gt;SpectNetIde&lt;/strong&gt; assembler, you can create multiple 
code segments, and this method injects all cade segments.&lt;/p&gt;

&lt;h3 id=&quot;arguments-6&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;asmSource&lt;/code&gt;: The Z80 Assembler source code&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;options&lt;/code&gt;: Optional options to compile the source code. See &lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-assembleroptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AssemblerOptions&lt;/code&gt;&lt;/a&gt; more details.&lt;/p&gt;

&lt;h3 id=&quot;returns-1&quot;&gt;Returns&lt;/h3&gt;

&lt;p&gt;The address marked as the entry point (&lt;code class=&quot;highlighter-rouge&quot;&gt;ENT&lt;/code&gt; directive in the source code), or the start 
address (&lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; directive) of the first code block in the source code.&lt;/p&gt;

&lt;h2 id=&quot;callcodeushort-ushort&quot;&gt;CallCode(ushort, ushort?)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void CallCode(ushort startAddress, ushort? callStubAddress = null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Calls the code at the specified subroutine start address.&lt;/p&gt;

&lt;h3 id=&quot;arguments-7&quot;&gt;Arguments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startAddress&lt;/code&gt;: Start address of the subroutine&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress&lt;/code&gt;: Optional address for the call stub&lt;/p&gt;

&lt;h3 id=&quot;remarks-1&quot;&gt;Remarks&lt;/h3&gt;

&lt;p&gt;This method creates a Z80 CALL instruction, and stores it to the specified &lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress&lt;/code&gt;.
If this parameter is omitted (set to &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;), the &lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA0&lt;/code&gt; address (empty area after system variables)
is used. Then, the virtual machine starts and pauses at the termination point of 
&lt;code class=&quot;highlighter-rouge&quot;&gt;callStubAddress + 3&lt;/code&gt; (by default, &lt;code class=&quot;highlighter-rouge&quot;&gt;#5BA3&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;sample-using-code-injection&quot;&gt;Sample using code injection&lt;/h2&gt;

&lt;p&gt;The following sample injects and executes code that sets the color of the background to blue.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
await sm.StartAndRunToMain();
var entryAddr = sm.InjectCode(@&quot;
    .org #8000
    ld a,1       ; BLUE
    out (#FE),a  ; Set the border colour to blue
    ret          ; Finished
&quot;);
sm.CallCode(entryAddr);
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Instead of call, you can jump directly to the code. Nonetheless, in this case you cannot complete
your code with &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt;, you should jump back to the main execution cycle of the machine, as this
sample shows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sm = SpectrumVmFactory.CreateSpectrum48Pal();
await sm.StartAndRunToMain();
var entryAddr = sm.InjectCode(@&quot;
    .org #8000
    ld a,1       ; BLUE
    out (#FE),a  ; Set the border colour to blue
    jp #12A2     ; Finished
&quot;);
sm.Cpu.PC = entryAddr;
// --- Set up breakpoints (omitted from code)
sm.StartDebug();
await sm.CompletionTask;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;virtual-machine-events&quot;&gt;Virtual machine events&lt;/h1&gt;

&lt;p&gt;The virtual machine provides events you can use to examine and analyze the state of the machine.&lt;/p&gt;

&lt;h2 id=&quot;vmstatechanged&quot;&gt;VmStateChanged&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;VmStateChangedEventArgs&amp;gt; VmStateChanged;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This event is raised whenever the state of the virtual machine changes.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;VmStateChangedEventArgs&lt;/code&gt; class has these properties:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public VmState OldState { get; }
public VmState NewState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As theor names suggest, you can obtain the old and the new state (&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt;) of the machine.&lt;/p&gt;

&lt;h2 id=&quot;vmstoppedwithexception&quot;&gt;VmStoppedWithException&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler&amp;lt;VmStoppedWithExceptionEventArgs&amp;gt; VmStoppedWithException;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Whenever the Spectrum virtual machine stops because of an exception, this event is raised. Normally,
this event should not happen, it signs that there’s some unexpected issue (programming error) within
&lt;strong&gt;SpectNetIde&lt;/strong&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;VmStoppedWithExceptionEventArgs&lt;/code&gt; has this property to check what is the exception
that caused the machine stop:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Exception Exception { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vmframecompleted&quot;&gt;VmFrameCompleted&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public event EventHandler VmFrameCompleted;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To sign that the virtual machine just has completed a new screen rendering frame, this event is raised.&lt;/p&gt;

&lt;h1 id=&quot;the-assembleroptions-class&quot;&gt;The AssemblerOptions class&lt;/h1&gt;

&lt;p&gt;This class represents the options that can be used when the Z80 Assembler compiles
the source code to machine code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler.Assembler&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class AssemblerOptions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;predefinedsymbols&quot;&gt;PredefinedSymbols&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;string&amp;gt; PredefinedSymbols { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Predefined compilation symbols that can be checked with the &lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#ifndef&lt;/code&gt;, and other
directives.&lt;/p&gt;

&lt;h2 id=&quot;defaultstartaddress&quot;&gt;DefaultStartAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort? DefaultStartAddress { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The default start address of the compilation. If there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; pragma specified in 
the source code, this address is used.&lt;/p&gt;

&lt;h2 id=&quot;defaultdisplacement&quot;&gt;DefaultDisplacement&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int? DefaultDisplacement { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The default displacement of the compilation. If there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;ORG&lt;/code&gt; pragma specified in 
the source code, this address is used. If set to null, no displacement is used.&lt;/p&gt;

&lt;h2 id=&quot;currentmodel&quot;&gt;CurrentModel&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SpectrumModelType CurrentModel { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Specifies the Spectrum model to use in the source code. By default it is set to Spectrum 48K. 
The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelType&lt;/code&gt; enumeration has these values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Machine type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spectrum48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum 48K&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spectrum128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum 128K&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumP3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum +3E&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Next&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ZX Spectrum Next&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-codebreakpoints-class&quot;&gt;The CodeBreakpoints class&lt;/h1&gt;

&lt;p&gt;Represents the breakpoint of the Spectrum virtual machine, at which execution should be
paused when running in debug mode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class CodeBreakpoints
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count&quot;&gt;Count&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Count { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of breakpoint defined.&lt;/p&gt;

&lt;h2 id=&quot;addbreakpointushort&quot;&gt;AddBreakpoint(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void AddBreakpoint(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Adds a breakpoint for the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;removebreakpointushort&quot;&gt;RemoveBreakpoint(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void RemoveBreakpoint(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Removes the breakpoint from the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;clearallbreakpoints&quot;&gt;ClearAllBreakpoints()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ClearAllBreakpoints()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Clears all previously declared breakpoints.&lt;/p&gt;

&lt;h2 id=&quot;hasbreakpointatushort&quot;&gt;HasBreakpointAt(ushort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool HasBreakpointAt(ushort address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checks if there is a breakpoint definied for the given &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-executecycleoptions-class&quot;&gt;The ExecuteCycleOptions class&lt;/h1&gt;

&lt;p&gt;This class provides options for the execution cycle of the Spectrum virtual machine. When you start
the cycle, you can pass execution options that influence the machine cycle and specifies when the
machine should be paused.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Machine&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ExecuteCycleOptions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;emulationmode&quot;&gt;EmulationMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public EmulationMode EmulationMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The emulation mode that should be used. The values of the &lt;code class=&quot;highlighter-rouge&quot;&gt;EmulationMode&lt;/code&gt; enumeration are these:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Continuous&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the virtual machine until stopped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Debugger&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the virtual machine in debug mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilHalt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Run the virtual machine until the CPU is halted&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilFrameEnds&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Runs the machine until the current ULA rendering frame ends&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UntilExecutionPoint&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Run the machine until the specified value of the PC register is reached&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;debugstepmode&quot;&gt;DebugStepMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public DebugStepMode DebugStepMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the emulation mode is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;Debugger&lt;/code&gt;, this property specifies the mode to run a debug-mode
execution cycle. The values of &lt;code class=&quot;highlighter-rouge&quot;&gt;DebugStepMode&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StopAtBreakpoint&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops at the next breakpoint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StepInto&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops after the next instruction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StepOver&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Execution stops after the next instruction. If that should be a subroutine call or a block statement, the execution stops after returning from the subroutine or completing the block statement.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;fasttapemode&quot;&gt;FastTapeMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool FastTapeMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if fast loading from the tape is allowed.&lt;/p&gt;

&lt;h2 id=&quot;terminationrom&quot;&gt;TerminationRom&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int TerminationRom { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The index of the ROM when a termination point is defined.&lt;/p&gt;

&lt;h2 id=&quot;terminationpoint&quot;&gt;TerminationPoint&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort TerminationPoint { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value of the PC register to reach when &lt;code class=&quot;highlighter-rouge&quot;&gt;EmulationMode&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;UntilExecutionPoint&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;skipinterruptroutine&quot;&gt;SkipInterruptRoutine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool SkipInterruptRoutine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Signs if the instructions within the maskable interrupt routine should be skipped during debugging.&lt;/p&gt;

&lt;h2 id=&quot;fastvmmode&quot;&gt;FastVmMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool FastVmMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This flag indicates that the virtual machine should run in hidden mode (no screen, no sound, no delays).&lt;/p&gt;

&lt;h2 id=&quot;disablescreenrendering-1&quot;&gt;DisableScreenRendering&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool DisableScreenRendering { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This flag shows whether the virtual machine should render the screen when runs in &lt;code class=&quot;highlighter-rouge&quot;&gt;FastVmMode&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;timeouttacts-1&quot;&gt;TimeoutTacts&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public long TimeoutTacts { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can specify a timeout value (given in CPU tacts). If this is set to zero, no timeout is applied.
If set to a value greater than zero, after the specified number of CPU cycles ellapsed, the execution of
the virtual machine is paused.&lt;/p&gt;

&lt;h1 id=&quot;the-executioncompletionreason-enum&quot;&gt;The ExecutionCompletionReason enum&lt;/h1&gt;

&lt;p&gt;The values of this enumeration tells the reason the virtual machine is in paused or in stopped state.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public enum ExecutionCompletionReason
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The machine is still executing, or it has not been ever started&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cancelled&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The execution has explicitly cancelled by the user or by the scripting code&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timeout&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The specified timeout period expired&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TerminationPointReached&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine reached its termintation point specified by its start&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BreakpointReached&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine reached a breakpoint during its execution in debug mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Halted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtaul machine reached a &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; statement and paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameCompleted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has just rendered a new screen frame and paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine stopped because of an unexpected exception&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-keyboardemulator-class&quot;&gt;The KeyboardEmulator class&lt;/h1&gt;

&lt;p&gt;This class is reserved for future extension. Right now, id does not offer any property or method for scripting.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class KeyboardEmulator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;the-vmstate-enum&quot;&gt;The VmState enum&lt;/h1&gt;

&lt;p&gt;The values of this enumeration show the possible states of a ZX Spectrum virtual machine.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has just been created, but has not run yet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnig&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine is successfully started in the background&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pausing&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The pause request has been sent to the virtual machine, now it prepares to get paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Paused&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has been paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stopping&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The stop request has been sent to the virtual machine, now it prepares to get stopped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stopped&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The virtual machine has been stopped&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;the-spectrummodels-class&quot;&gt;The SpectrumModels class&lt;/h1&gt;

&lt;p&gt;This class is a repository of all Spectrum models and editions supported 
by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static class SpectrumModels
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-stockmodels-property&quot;&gt;The StockModels property&lt;/h2&gt;

&lt;p&gt;You can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;StockModels&lt;/code&gt; property to access the dictionary of
available ZX Spectrum models.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static IReadOnlyDictionary&amp;lt;string, SpectrumModelEditions&amp;gt; StockModels;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each model has a unique name to look up the associated editions in the dictionary.
A &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEditions&lt;/code&gt; instance is a collection of all editions of the 
particular model. A single edition is represented by a &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEdition&lt;/code&gt; instance.&lt;/p&gt;

&lt;h2 id=&quot;constants-used-for-models-and-editions&quot;&gt;Constants used for models and editions&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; class provides these constants for the unique model names and editions:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Constant value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum 48K&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum 128K&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_P3_E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum +3E&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_NEXT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ZX Spectrum Next&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAL&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NTSC&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL_2_X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAL2X&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC_2_X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NTSC2X&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;model-access&quot;&gt;Model access&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt; provides properties to directly access the 
&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModelEdition&lt;/code&gt; instances of frequently used machine types:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SpectrumEdition ZxSpectrum48Pal;
public static SpectrumEdition ZxSpectrum48Ntsc;
public static SpectrumEdition ZxSpectrum48Pal2X;
public static SpectrumEdition ZxSpectrum48Ntsc2X;
public static SpectrumEdition ZxSpectrum128Pal;
public static SpectrumEdition ZxSpectrumP3EPal;
public static SpectrumEdition ZxSpectrumNextPal;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These properties are associated with these model and edition key constants:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Property&lt;/th&gt;
      &lt;th&gt;Model key&lt;/th&gt;
      &lt;th&gt;Edition key&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Pal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Ntsc&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Pal2X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL2X&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum48Ntsc2X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NTSC2X&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrum128Pal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrumP3EPal&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_128&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZxSpectrumNext&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SPECTRUM_NEXT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PAL&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">The SpectrumVmFactory class</summary></entry><entry><title type="html">Scripting the Screen</title><link href="http://localhost:4000/spectnetide/documents/scripting-screen" rel="alternate" type="text/html" title="Scripting the Screen" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-screen</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-screen">&lt;h1 id=&quot;the-screenconfiguration-class&quot;&gt;The ScreenConfiguration class&lt;/h1&gt;

&lt;p&gt;This class represents the configuration of the virtual machine’s screen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ScreenConfiguration : IScreenConfiguration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen rendering mechanism uses a large number of configuration options that provides
the timing so that the CPU and the rendering hardware can work in tandem. The software 
emulation implements the same mechanism.&lt;/p&gt;

&lt;p&gt;As the following figure shows, the screen has visible and non-visible areas, just as in the
case of the real hardware. Originally, the non-visible area was required by the cathode-ray tube
so that the electron beam could sync the screen rendering properly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/spectnetide/assets/images/scripting/spectrum-screen.png&quot; alt=&quot;Screen Dimensions&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;screenwidth&quot;&gt;ScreenWidth&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenWidth { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The width of the visible screen area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;screenlines&quot;&gt;ScreenLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The height of the visible screen area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;displaywidth&quot;&gt;DisplayWidth&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayWidth { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The width of the display area in pixels (256).&lt;/p&gt;

&lt;h2 id=&quot;displaylines&quot;&gt;DisplayLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The height of the display area in pixels.&lt;/p&gt;

&lt;h2 id=&quot;nonvisiblebordertoplines&quot;&gt;NonVisibleBorderTopLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderTopLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of top border lines that are not visible when rendering the screen.&lt;/p&gt;

&lt;h2 id=&quot;bordertoplines&quot;&gt;BorderTopLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderTopLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border lines above the display area.&lt;/p&gt;

&lt;h2 id=&quot;borderbottomlines&quot;&gt;BorderBottomLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderBottomLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border lines below the display area.&lt;/p&gt;

&lt;h2 id=&quot;nonvisibleborderbottomlines&quot;&gt;NonVisibleBorderBottomLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderBottomLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of bottom border lines that are not visible when rendering the screen.&lt;/p&gt;

&lt;h2 id=&quot;verticalsynclines&quot;&gt;VerticalSyncLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int VerticalSyncLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Number of lines used for vertical synch.&lt;/p&gt;

&lt;h2 id=&quot;borderlefttime&quot;&gt;BorderLeftTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderLeftTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPY T-cycles of displaying the left part of the border.&lt;/p&gt;

&lt;h2 id=&quot;borderleftpixels&quot;&gt;BorderLeftPixels&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderLeftPixels { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border pixels to the left of the display (&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * BorderLeftTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;borderrighttime&quot;&gt;BorderRightTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderRightTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPY T-cycles of displaying the right part of the border.&lt;/p&gt;

&lt;h2 id=&quot;borderrightpixels&quot;&gt;BorderRightPixels&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int BorderRightPixels { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of border pixels to the right of the display (&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * BorderRightTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;nonvisibleborderrighttime&quot;&gt;NonVisibleBorderRightTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int NonVisibleBorderRightTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time given in CPY T-cycles to render the nonvisible right part of the border.&lt;/p&gt;

&lt;h2 id=&quot;horizontalblankingtime&quot;&gt;HorizontalBlankingTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int HorizontalBlankingTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Horizontal blanking time (HSync + blanking) given in CPU T-cycles.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt; class provides other properties that are related to screen rendering.&lt;/p&gt;

&lt;h2 id=&quot;interrupttact&quot;&gt;InterruptTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int InterruptTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact index of the interrupt signal relative to the top-left screen pixel&lt;/p&gt;

&lt;h2 id=&quot;firstdisplayline&quot;&gt;FirstDisplayLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstDisplayLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen line number of the first display line (`VerticalSyncLines&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;NonVisibleBorderTopLines + BorderTopLines`).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lastdisplayline&quot;&gt;LastDisplayLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int LastDisplayLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The screen line number of the last display line (&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine + DisplayLines - 1&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;displaylinetime&quot;&gt;DisplayLineTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int DisplayLineTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time of rendering a display pixel row, given in CPU T-cycles.&lt;/p&gt;

&lt;h2 id=&quot;screenlinetime&quot;&gt;ScreenLineTime&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenLineTime { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time of rendering an entire raster line, given in CPU T-cycles (&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderLeftTime + 
DisplayLineTime + BorderRightTime + NonVisibleBorderRightTime + HorizontalBlankingTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;rasterlines&quot;&gt;RasterLines&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RasterLines { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of raster lines in the screen (&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine + DisplayLines + BorderBottomLines + NonVisibleBorderBottomLines&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;firstdisplaypixeltact&quot;&gt;FirstDisplayPixelTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstDisplayPixelTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact in which the top left display pixel should be rendered, given in CPU T-cycles
(&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstDisplayLine * ScreenLineTime + BorderLeftTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;firstscreenpixeltact&quot;&gt;FirstScreenPixelTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int FirstScreenPixelTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tact in which the top left screen pixel (border) should be displayed
(&lt;code class=&quot;highlighter-rouge&quot;&gt;[VerticalSyncLines + NonVisibleBorderTopLines] * ScreenLineTime&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;screenrenderingframetactcount&quot;&gt;ScreenRenderingFrameTactCount&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int ScreenRenderingFrameTactCount { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of CPU T-cycles used for the full rendering of the screen
(&lt;code class=&quot;highlighter-rouge&quot;&gt;RasterLines * ScreenLineTime&lt;/code&gt;).&lt;/p&gt;

&lt;h1 id=&quot;methods&quot;&gt;Methods&lt;/h1&gt;

&lt;p&gt;The class provides a few helper methods.&lt;/p&gt;

&lt;h2 id=&quot;istactvisibleint-int&quot;&gt;IsTactVisible(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsTactVisible(int line, int tactInLine)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tests whether the specified tact is in the visible area of the screen. Returns true, if
the tact renders the visible part of the screen; otherwise, false.&lt;/p&gt;

&lt;h3 id=&quot;arguments&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;line&lt;/code&gt;: Raster line index&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tactInLine&lt;/code&gt;: Tact index within the line&lt;/p&gt;

&lt;h2 id=&quot;istactindisplayareaint-int&quot;&gt;IsTactInDisplayArea(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsTactInDisplayArea(int line, int tactInLine)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tests whether the specified tact is in the display area of the screen. Returns true, if
the tact renders the display part of the screen; otherwise, false.&lt;/p&gt;

&lt;h3 id=&quot;arguments-1&quot;&gt;Arguments&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;line&lt;/code&gt;: Raster line index&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tactInLine&lt;/code&gt;: Tact index within the line&lt;/p&gt;

&lt;h1 id=&quot;the-screenbitmap-class&quot;&gt;The ScreenBitmap class&lt;/h1&gt;

&lt;p&gt;This class represents the current screen’s pixels, including the border. Every byte stands for a palette
index. The value of a pixel can be &lt;code class=&quot;highlighter-rouge&quot;&gt;#00&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#0F&lt;/code&gt; on a Spectrum 48K, 128K, and +3E model. On ZX Spectrum Next,
the value is the entire byte range from &lt;code class=&quot;highlighter-rouge&quot;&gt;#00&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#FF&lt;/code&gt;. The content is read-only, you cannot change it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenBitmap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisint&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte[] this[int lineNo] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves a byte array for the raster line specified in &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lineNo&lt;/code&gt;&lt;/em&gt;. The value at zero index represent 
the leftmost border pixel of the line. The last item in the array is the rightmost pixel in the line.&lt;/p&gt;

&lt;h2 id=&quot;thisint-int&quot;&gt;this[int, int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int row, int column] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Retrieves the byte for the screen pixel in the given &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;&lt;/em&gt; of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;row&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;getdisplaypixelint-int&quot;&gt;GetDisplayPixel(int, int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte GetDisplayPixel(int row, int col)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;this[int, int]&lt;/code&gt; retrieves the specified screen pixel, this method obtains the display pixel of 
(&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;row&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;&lt;/em&gt;).&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingstatus-class&quot;&gt;The ScreenRenderingStatus class&lt;/h1&gt;

&lt;p&gt;Provides properties about the current screen rendering status of the machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingStatus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;currentframetact&quot;&gt;CurrentFrameTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int CurrentFrameTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of the current tact within the frame being rendered.&lt;/p&gt;

&lt;h2 id=&quot;rasterline&quot;&gt;RasterLine&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int RasterLine { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of the current raster line in the frame being rendered.&lt;/p&gt;

&lt;h2 id=&quot;currentrenderingtact&quot;&gt;CurrentRenderingTact&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTact CurrentRenderingTact { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets details about the current tact in the frame being rendered. See more details
in the description of &lt;a href=&quot;ScreenRenderingTact.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingtable-class&quot;&gt;The ScreenRenderingTable class&lt;/h1&gt;

&lt;p&gt;Represents the screen rendering table of the virtual machine&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingTable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count&quot;&gt;Count&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Count { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the number of items in the screen rendering table.&lt;/p&gt;

&lt;h2 id=&quot;thisint-1&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingTact this[int index] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the entry of the screen rendering table specified by &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt;. See more details
in the description of &lt;a href=&quot;ScreenRenderingTact.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-screenrenderingtact-class&quot;&gt;The ScreenRenderingTact class&lt;/h1&gt;

&lt;p&gt;Provides details about a screen rendering tact.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Devices.Screen&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ScreenRenderingTact
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;phase&quot;&gt;Phase&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ScreenRenderingPhase Phase { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The rendering phase to be applied for the particular tact. The &lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingPhase&lt;/code&gt; enum
has these values:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA does not do any rendering&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Border&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderFetchPixel&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel. It prepares to display the fist pixel in the row with prefetching the corresponding byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BorderFetchPixelAttr&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA sets the border color to display the current pixel. It has already fetched the 8 pixel bits to display. It carries on preparing to display the fist pixel in the row with prefetching the corresponding attribute byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte1 sequentially during a single Z80 clock cycle.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB1FetchB2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding attribute from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2FetchB1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding byte from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DisplayB2FetchA1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The ULA displays the next two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row with prefetching the corresponding attribute from the display memory.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;contentiondelay&quot;&gt;ContentionDelay&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte ContentionDelay { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Contention delay during the particular screen rendering tact, provided, the CPU is reading 
or writing data in the screen memory area (&lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#7FFF&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;pixelbytetofetchaddress&quot;&gt;PixelByteToFetchAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort PixelByteToFetchAddress { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Display memory address used in the particular tact to fetch the pixel value.&lt;/p&gt;

&lt;h2 id=&quot;attributetofetchaddress&quot;&gt;AttributeToFetchAddress&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort AttributeToFetchAddress { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Display memory address used in the particular tact to fetch the attribute of a pixel.&lt;/p&gt;

&lt;h2 id=&quot;xpos&quot;&gt;XPos&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort XPos { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The X position of the pixel in screen coordinates.&lt;/p&gt;

&lt;h2 id=&quot;ypos&quot;&gt;YPos&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ushort YPos { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Y position of the pixel in screen coordinates.&lt;/p&gt;</content><author><name></name></author><summary type="html">The ScreenConfiguration class</summary></entry><entry><title type="html">Scripting Object Model</title><link href="http://localhost:4000/spectnetide/documents/scripting-object-model" rel="alternate" type="text/html" title="Scripting Object Model" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-object-model</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-object-model">&lt;p&gt;&lt;strong&gt;SpectNetIde&lt;/strong&gt; offers a set of .NET objects that you can use to create scripts that automate
everyday tasks with ZX Spectrum virtual machines. You can use these objects in any .NET Framework
application, or in scripting languages that allow accessing .NET Framework objects.&lt;/p&gt;

&lt;p&gt;To use &lt;strong&gt;SpectNetIde&lt;/strong&gt; scripting, add these assemblies to your projects:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Assembly&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.Assembler&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;The Z80 Assembler of &lt;strong&gt;SpectNetIde&lt;/strong&gt;. With the help of this component, you can use Z80 source code in scripts.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.RomResources&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;This assembly stores the ROMs of the Spectrum models supported by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectNet.SpectrumEmu&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;This assembly implements the ZX Spectrum emulator and the scripting object model.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;zx-spectrum-virtual-machines&quot;&gt;ZX Spectrum virtual machines&lt;/h2&gt;

&lt;p&gt;The scripting object model supports these ZX Spectrum models:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ZX Spectrum 48K&lt;/li&gt;
  &lt;li&gt;ZX Spectrum 128K&lt;/li&gt;
  &lt;li&gt;ZX Spectrum +3E&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ZX Spectrum Next (still in development)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The virtual machines use a background thread for their execution cycle. You can run the machine
with synchronous methods, but you need to pause or stop them, or waiting while their cycle completes
with the &lt;code class=&quot;highlighter-rouge&quot;&gt;async/await&lt;/code&gt; pattern.&lt;/p&gt;

&lt;h2 id=&quot;scripting-objects&quot;&gt;Scripting objects&lt;/h2&gt;

&lt;p&gt;The table below contains a summary of the .NET types that constitute the ZX Spectrum scripting
object model. To get the shortest path to learn using them, I suggest starting with these documentations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Object type&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents tracking information regarding memory.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-assembleroptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AssemblerOptions&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the options that can be used when the Z80 Assembler compiles the source code to machine code.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-audiosamples-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AudioSamples&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class stores audio samples for the currently rendered virtual machine frame.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-codebreakpoints-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBreakpoints&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Represents the breakpoint of the Spectrum virtual machine, at which execution should pause when running in debug mode.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-cpuz80-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the Z80 CPU of a Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executecycleoptions-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecuteCycleOptions&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides options for the execution cycle of the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-executioncompletionreason-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutionCompletionReason&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;The values of this enumeration tell the reason why the virtual machine is in a paused or stopped state.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-audio.html#the-iaudioconfiguration-interface&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAudioConfiguration&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This interface represents the configuration of the beeper/sound device.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-keyboardemulator-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;KeyboardEmulator&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class is reserved for future extension. Right now, id does not offer any property or method for scripting.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memorypaginginfo-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemoryPagingInfo&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides properties and methods to obtain information about ROM and RAM paging.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-memoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemorySlice&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a slice of the memory in the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-readonlymemoryslice-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlyMemorySlice&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a read-only slice of the memory in the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenbitmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenBitmap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the current screen’s pixels, including the border area.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenconfiguration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenConfiguration&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents the configuration of the virtual machine’s screen&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingstatus-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingStatus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Provides properties about the current screen rendering status of the machine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtable-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTable&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Represents the screen rendering table of the virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-screen.html#the-screenrenderingtact-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ScreenRenderingTact&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Provides details about a screen rendering tact.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-memory.html#the-spectrummemorycontents-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumMemoryContents&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides access to the addressable 64KBytes memory contents of the Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrummodels-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumModels&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class is a repository of all Spectrum models and editions supported by &lt;strong&gt;SpectNetIde&lt;/strong&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvm-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVm&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class represents a Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-spectrumvmfactory-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpectrumVmFactory&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides methods you can use to create ZX Spectrum virtual machine instances.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-vms.html#the-vmstate-enum&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VmState&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;The values of this enumeration show the possible states of a ZX Spectrum virtual machine.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-z80instructionexecutioneventargs-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z80InstructionExecutionEventArgs&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;This class provides event arguments the the &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuting&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationExecuted&lt;/code&gt; events of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CpuZ80&lt;/code&gt; class&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">SpectNetIde offers a set of .NET objects that you can use to create scripts that automate everyday tasks with ZX Spectrum virtual machines. You can use these objects in any .NET Framework application, or in scripting languages that allow accessing .NET Framework objects.</summary></entry><entry><title type="html">Scripting the Memory</title><link href="http://localhost:4000/spectnetide/documents/scripting-memory" rel="alternate" type="text/html" title="Scripting the Memory" /><published>2019-01-04T00:00:00+01:00</published><updated>2019-01-04T00:00:00+01:00</updated><id>http://localhost:4000/spectnetide/documents/scripting-memory</id><content type="html" xml:base="http://localhost:4000/spectnetide/documents/scripting-memory">&lt;h1 id=&quot;the-memorypaginginfo-class&quot;&gt;The MemoryPagingInfo class&lt;/h1&gt;

&lt;p&gt;This class provides properties and methods to obtain information about ROM and RAM paging.
Though it works with ZX Spectrum 48K model, it provides benefits only for higher models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class MemoryPagingInfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;selectedromindex&quot;&gt;SelectedRomIndex&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int SelectedRomIndex { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the index of the currently selected ROM.&lt;/p&gt;

&lt;h2 id=&quot;selectedrambankindex&quot;&gt;SelectedRamBankIndex&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int SelectedRamBankIndex { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the index of the selecter RAM bank for the &lt;code class=&quot;highlighter-rouge&quot;&gt;#C000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; address range.&lt;/p&gt;

&lt;h2 id=&quot;getbankindexforslotint&quot;&gt;GetBankIndexForSlot(int)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int GetBankIndexForSlot(int slot)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets the RAM bank index for the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slot&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are four slots, for the pages starting at &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;#8000&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;#C000&lt;/code&gt;, respectively.
Slot index should be set accordingly, from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;usesshadowscreen&quot;&gt;UsesShadowScreen&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool UsesShadowScreen { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtual machine uses the shadow screen (Bit 3 of port #7FFD). If false, the normal
screen (Bank #5) is used. If true, the shadow screen (Bank #7) is displayed.&lt;/p&gt;

&lt;h2 id=&quot;isinallrammode&quot;&gt;IsInAllRamMode&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool IsInAllRamMode { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Indicates if the virtul machine (ZX Spectrum +3E and ZX Spectrum Next) machine is
in the special ALL RAM mode (Bit 0 of port #1FFD).&lt;/p&gt;

&lt;h1 id=&quot;the-memoryslice-class&quot;&gt;The MemorySlice class&lt;/h1&gt;

&lt;p&gt;This class represents a slice of the memory in the Spectrum virtual machine. Right now, it is used to
represent the contents of a RAM bank.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class MemorySlice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;size&quot;&gt;Size&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Size { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The size of the memory slice, given in number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;thisint&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int index] { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can get and set the byte at the &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; position in the memory slice.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Be aware, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; is not the absolute memory address of the byte, but a relative address from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;Size - 1&lt;/code&gt;. For RAM banks, &lt;code class=&quot;highlighter-rouge&quot;&gt;Size&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, thus you can address bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;the-readonlymemoryslice-class&quot;&gt;The ReadOnlyMemorySlice class&lt;/h1&gt;

&lt;p&gt;This class represents a read-only slice of the memory in the Spectrum virtual machine. Right now, it is used to
represent the contents of a ROM pages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class ReadOnlyMemorySlice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;size-1&quot;&gt;Size&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int Size { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The size of the memory slice, given in number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;thisint-1&quot;&gt;this[int]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[int index] { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can get the byte at the &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; position in the memory slice. As the name of the class suggest,
you cannot change the contents of a read-only memory slice.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Be aware, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;&lt;/em&gt; is not the absolute memory address of the byte, but a relative address from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;Size - 1&lt;/code&gt;. For RAM banks, &lt;code class=&quot;highlighter-rouge&quot;&gt;Size&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;#4000&lt;/code&gt;, thus you can address bytes from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;#3FFF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;the-spectrummemorycontents-class&quot;&gt;The SpectrumMemoryContents class&lt;/h1&gt;

&lt;p&gt;This class provides access to the addressable 64KBytes memory contents of the Spectrum virtual machine.
An instance of the class allows reading and writeng the memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespace&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu.Scripting&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Assembly&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Spect.Net.SpectrumEmu&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public sealed class SpectrumMemoryContents
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisushort&quot;&gt;this[ushort]&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public byte this[ushort address] { get; set; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gets or sets the contents of the specified &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address&lt;/code&gt;&lt;/em&gt;. Setting the content behaves as
in the real hardware: if you try to set a ROM address, the contents of the particular
memory address won’t change after the write operation.&lt;/p&gt;

&lt;h2 id=&quot;readtrackingstate&quot;&gt;ReadTrackingState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState ReadTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been read during a CPU operation.&lt;/p&gt;

&lt;h2 id=&quot;resetreadtracking&quot;&gt;ResetReadTracking()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetReadTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadTrackingState&lt;/code&gt; property as if no memory had been read.&lt;/p&gt;

&lt;h2 id=&quot;writetrackingstate&quot;&gt;WriteTrackingState&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AddressTrackingState WriteTrackingState { get; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The property’s value is an &lt;a href=&quot;/spectnetide/documents/scripting-z80.html#the-addresstrackingstate-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddressTrackingState&lt;/code&gt;&lt;/a&gt; 
instance. It provides a bit for each memory address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;#0000&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;#FFFF&lt;/code&gt; range to check if the 
particular byte in the memory has been written during a CPU operation.&lt;/p&gt;

&lt;h2 id=&quot;resetwritetracking&quot;&gt;ResetWriteTracking()&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ResetWriteTracking()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resets the &lt;code class=&quot;highlighter-rouge&quot;&gt;WriteTrackingState&lt;/code&gt; property as if no memory had been read.&lt;/p&gt;</content><author><name></name></author><summary type="html">The MemoryPagingInfo class</summary></entry></feed>