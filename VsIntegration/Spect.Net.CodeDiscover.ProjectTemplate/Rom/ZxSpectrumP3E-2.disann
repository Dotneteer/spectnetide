{
  "Labels": {
    "102": "NMI",
    "104": "DISK_MOT_TO",
    "149": "DISK_MOT_TO_2",
    "424": "DOS_INITIALISE",
    "476": "DOS_VERSION",
    "492": "DOS_GET_1346",
    "452": "DOS_INIT_2",
    "498": "DOS_SET_1346",
    "527": "COPY_PAGED_BYTES",
    "534": "COPY_PB_2",
    "539": "PAGE_IN_A",
    "563": "FIND_BUFF_ADDR",
    "581": "COPY_BYTES",
    "591": "COPY_BYTES_2",
    "635": "SAVE_TO_BUFF",
    "650": "SAVE_TO_BUFF_2",
    "656": "COPY_VIA_BUFF",
    "668": "COPY_VIA_BUFF_2",
    "670": "COPY_VIA_BUFF_3",
    "716": "CALC_BYTE_COUNT",
    "741": "CALC_BYTE_CNT_2",
    "750": "CALC_BYTE_CNT_3",
    "752": "DOS_SET_MESSAGE",
    "758": "DOS_SETM_2",
    "767": "ALERT_MSG",
    "778": "ALERT_MSG_2",
    "973": "ERR_MSG_TABLE",
    "799": "ALERT_MSG_HL",
    "805": "ALERT_MSG_ID10",
    "813": "GEN_MSG_HL",
    "828": "GEN_MSG_IX",
    "837": "GEN_MSG_IX_2",
    "842": "GEN_MSG_IX_3",
    "844": "GEN_MSG_IX_4",
    "856": "PROC_MSG_CH",
    "967": "PROC_MSG_CH_RET",
    "966": "PROC_MSG_DRV",
    "919": "PROC_MSG_TRC",
    "916": "PROC_MSG_SEC",
    "945": "GEN_DIGIT",
    "947": "GEN_DIGIT_2",
    "956": "GEN_DIGIT_3",
    "893": "PROC_MSG_CH_2",
    "912": "PROC_MSG_CH_3",
    "914": "PROC_MSG_CH_4",
    "920": "PROC_MSG_CH_5",
    "962": "PROC_MSG_CH_6",
    "1259": "SHR_DE_A",
    "1261": "SHR_DE_A_2",
    "1269": "SHL_DE_A",
    "1272": "SHL_DE_A_2",
    "1278": "CALL_HLi",
    "1279": "TO_UPCASE",
    "1288": "SET_DEF_DRIVE",
    "1291": "SET_DEF_DRV_2",
    "1303": "SET_DEF_DRV_3",
    "1340": "CLEAR_FCB",
    "1368": "GET_FCB",
    "1384": "GET_FCB_2",
    "1313": "OPEN_FCB_READ",
    "1321": "OPEN_FCB_WRITE",
    "1330": "OPEN_FCB",
    "1395": "GET_FCB_3",
    "1398": "CHECK_OPEN",
    "1414": "CHECK_OPEN_2",
    "1419": "CHECK_OPEN_3",
    "1456": "CHECK_OPEN_4",
    "1476": "CHECK_OPEN_5",
    "1487": "DOS_FLUSH",
    "1494": "DOS_FLUSH_2",
    "1500": "DOS_FLUSH_3",
    "1521": "DOS_FLUSH_4",
    "1531": "DOS_FLUSH_5",
    "1533": "GET_SECT_BUFF",
    "1538": "GET_SECT_BUFF_2",
    "1575": "GET_SECT_BUFF_3",
    "1582": "GET_SECT_BUFF_4",
    "1589": "DOS_OPEN",
    "1639": "DOS_OPEN_2",
    "1650": "DOS_OPEN_3",
    "1662": "DOS_OPEN_4",
    "1669": "DOS_OPEN_5",
    "1671": "DOS_OPEN_6",
    "1687": "DOS_OPEN_7",
    "1694": "DOS_OPEN_8",
    "1699": "DOS_OPEN_9",
    "1701": "DOS_OPEN_10",
    "1713": "SETUP_DIR_ENT",
    "1740": "FIND_EXT_ENT",
    "1760": "FIND_EXT_ENT_2",
    "1768": "ERASE_BAK",
    "1806": "DOS_OPEN_DRIVE",
    "1866": "DOS_CLOSE",
    "1878": "ENSURE_UTD",
    "1899": "DOS_ABANDON",
    "1943": "DOSH_SIGN",
    "1953": "UPD_FHEADER",
    "1977": "UPD_FHEADER_2",
    "2012": "CPY_BYTES_TOF",
    "2022": "CRE_HEADER",
    "2039": "CRE_HEADER_2",
    "2051": "CRE_HEADER_3",
    "2059": "OPEN_RHEAD",
    "2071": "OPEN_RHEAD_2",
    "2098": "OPEN_RHEAD_3",
    "2117": "OPEN_RHEAD_4",
    "2135": "OPEN_RHEAD_5",
    "2140": "OPEN_RHEAD_6",
    "2199": "UPD_RECNO",
    "2147": "OPEN_RHEAD_7",
    "2231": "UPD_RECNO_2",
    "2235": "DOS_REF_HEAD",
    "2253": "DOS_SET_ACCESS",
    "2293": "DOS_SET_ACC_2",
    "2297": "DOS_SET_ACC_3",
    "2300": "DOS_FREE_SPACE",
    "2310": "DOS_SET_USER",
    "2324": "DOS_SET_USER_2",
    "2329": "DOS_SET_DRIVE",
    "2345": "DOS_SET_DRV_2",
    "2350": "DOS_DELETE",
    "2373": "DEL_MATCH_DIR",
    "2360": "DOS_DELETE_2",
    "2403": "DOS_SET_ATTRIBUT",
    "2425": "DOS_RENAME",
    "2445": "DOS_RENAME_2",
    "2481": "DOS_RENAME_3",
    "2487": "DOS_RENAME_4",
    "2505": "CHANGE_DIR_ATTR",
    "2530": "SET_CLR_ATTR",
    "2543": "SET_CLR_ATTR_2",
    "2554": "SET_CLR_ATTR_3",
    "2558": "RENAME_SYSFCB",
    "2595": "DOS_CATALOG",
    "2586": "RENAME_SYSFCB_2",
    "2631": "ADD_DIRENT_CAT",
    "2639": "PROC_DIRENT_CAT",
    "2658": "PROC_DIRENT_2",
    "2670": "PROC_DIRENT_3",
    "2683": "PROC_DIRENT_4",
    "2729": "PROC_DIRENT_5",
    "2731": "PROC_DIRENT_6",
    "2755": "PROC_DIRENT_7",
    "2771": "COMP_FNAMES",
    "2777": "COMP_FNAMES_2",
    "2789": "COMP_FNAMES_3",
    "2793": "PARSE_FSPEC",
    "2803": "PARSE_FSPEC_2",
    "2815": "PARSE_WFSPEC",
    "2818": "SET_UA_DL",
    "2828": "CHECK_UA",
    "2853": "CHECK_UA_2",
    "2859": "CHECK_DL",
    "2882": "ISDIGIT_A",
    "2889": "PARSE_FNAME_FCB",
    "2897": "DO_PARSE_FNAME",
    "2918": "DO_PARSE_FN_2",
    "2928": "DO_PARSE_FN_3",
    "2948": "DO_PARSE_FN_4",
    "2954": "DO_PARSE_FN_5",
    "2976": "DO_PARSE_FN_6",
    "3005": "DO_PARSE_FN_7",
    "3014": "FILL_FN_CH",
    "3016": "FILL_FN_CH_2",
    "3017": "FILL_FN_CH_3",
    "3023": "SKIP_FN_CHAR",
    "3027": "GET_NEXT_FNCHAR",
    "3030": "GET_NEXT_FNCH_2",
    "3037": "GET_NEXT_FNCH_3",
    "3042": "GET_CUR_FNCHAR",
    "3065": "INV_FNAME_CHARS",
    "3084": "LOGIN_DISK",
    "3091": "LOGIN_DISK_2",
    "3149": "ADM_DIRENT",
    "3155": "ADM_DIRENT_2",
    "3168": "CPY_DIRENT_XDPB",
    "3181": "FIND_EXTENT_HL",
    "3191": "FIND_EXTENT_HL_2",
    "3220": "GET_NEW_EXT",
    "3236": "GET_NEW_EXT_2",
    "3242": "GET_NEW_EXT_3",
    "3254": "ENS_DIR_UTD",
    "3285": "ENS_DIR_UTD_2",
    "3299": "ENS_DIR_UTD_3",
    "3304": "ENS_DIR_UTD_4",
    "3307": "UPD_DIR_FCB",
    "3333": "CHK_EXT_FCB",
    "3358": "CHK_FCB_2",
    "3382": "CHK_FCB_3",
    "3386": "FN_DE_BY_FNEC",
    "3408": "CHK_DE_IN_FCB",
    "3432": "CHK_DE_IN_FCB_2",
    "3442": "CHK_DE_IN_FCB_3",
    "3444": "COMP_FCBS",
    "3450": "COMP_FCBS_2",
    "3452": "COMP_FCBS_3",
    "3458": "COMP_FCBS_4",
    "3463": "COMP_FCBS_W",
    "3470": "COMP_FCBS_W_2",
    "3480": "COMP_FCBS_W_3",
    "3484": "COMP_FCBS_W_4",
    "3486": "FOREACH_DE",
    "3496": "FOREACH_DE_2",
    "3507": "FOREACH_DE_3",
    "3543": "FOREACH_DE_4",
    "3549": "CALL_DIRENT_HL",
    "3557": "INC_DIRENT",
    "3567": "GET_DE_SECT",
    "3577": "GET_DE_SECT_2",
    "3596": "GET_DE_SECT_3",
    "3613": "GET_DE_SECT_4",
    "3617": "GET_DE_SECT_5",
    "3620": "COPY_DIRENTRY",
    "3670": "COPY_DIRENTRY_2",
    "3674": "CALC_DE_OFFS",
    "3681": "CALC_DE_OFFS_2",
    "3685": "CALC_DE_OFFS_3",
    "3693": "FN_SECT_ADDR",
    "3729": "FN_SECT_ADDR_2",
    "3763": "CHECK_READONLY",
    "3777": "INIT_ALLOC_BM",
    "3787": "INIT_ALLOC_BM_2",
    "3806": "ALLOC_BLOCK",
    "3828": "ALLOC_BL_2",
    "3842": "ALLOC_NEW_BL",
    "3847": "ALLOC_NEW_BL_2",
    "3850": "ALLOC_NEW_BL_3",
    "3868": "ALLOC_NEW_BL_4",
    "3890": "ALLOC_NEW_BL_5",
    "3893": "DEALLOC_ALL_BL",
    "3896": "ALLOC_ALL_DE",
    "3912": "ALLOC_ALL_DE_2",
    "3924": "ALLOC_ALL_DE_3",
    "3941": "ALLOC_ALL_DE_4",
    "3943": "ALLOC_ALL_DE_5",
    "3946": "CALC_EXT_SIZEK",
    "3963": "CALC_EXTS_2",
    "3974": "CALC_EXTS_3",
    "3978": "CALC_EXTS_4",
    "3982": "CALC_EXTS_5",
    "3983": "CALC_EXTS_6",
    "3988": "CALC_EXTS_7",
    "3994": "CALC_EXTS_8",
    "3998": "CALC_FREE_K",
    "4005": "CALC_FK_2",
    "4008": "CALC_FK_3",
    "4015": "CALC_FK_4",
    "4027": "CALC_FK_5",
    "4030": "GET_ALLOC_INFO",
    "4043": "CHECK_NEW_DE",
    "4073": "CHECK_NDE_2",
    "4075": "GET_NEW_DE",
    "4119": "GET_NEW_DE_2",
    "4128": "GET_NEW_DE_3",
    "4136": "TEST_DE_FREE",
    "4134": "GET_NEW_DE_4",
    "4141": "ADM_NEW_ENTRY",
    "4149": "ADM_NEWE_2",
    "4158": "CHECK_DSTAMP",
    "4169": "CHECK_DSTAMP_2",
    "4173": "CHECK_DSTAMP_3",
    "4185": "CHECK_DSTAMP_4",
    "4189": "CHECK_DSTAMP_5",
    "4191": "DOS_GET_POSITION",
    "4195": "DOS_GETPOS_2",
    "4200": "DOS_GET_EOF",
    "4207": "DOS_GETPOS_3",
    "4219": "DOS_SET_POSITION"
  },
  "Comments": {
    "8": "\"PLUS3DOS\"",
    "61": "increment FRAMES",
    "69": "increment high byte of FRAMES",
    "74": "scan the keyboard",
    "77": "test for disk motor timeout",
    "102": "do nothing",
    "112": "page in page 7",
    "118": "exit if motor already off",
    "125": "only decrement count every other frame",
    "130": "decrement timeout count",
    "134": "exit if not yet zero",
    "147": "turn motor off",
    "155": "restore memory configuration",
    "495": "get cache info & exit",
    "492": "get RAMdisk info",
    "1637": "mark file as open & exit",
    "2243": "IX points to header data",
    "2249": "does file have header?",
    "2238": "exit if not",
    "274": "DOS_READ",
    "277": "DOS_WRITE",
    "280": "DOS_BYTE_READ",
    "283": "DOS_BYTE_WRITE",
    "286": "DOS_CATALOG",
    "289": "DOS_FREE_SPACE",
    "292": "DOS_DELETE",
    "295": "DOS_RENAME",
    "298": "DOS_BOOT",
    "301": "DOS_SET_DRIVE",
    "304": "DOS_SET_USER",
    "307": "DOS_GET_POSITION",
    "310": "DOS_SET_POSITION",
    "313": "DOS_GET_EOF",
    "499": "HL=new RAMdisk info",
    "498": "save new cache info",
    "1631": "find first entry (open action 1)",
    "325": "DOS_SET_ACCESS",
    "328": "DOS_SET_ATTRIBUTES",
    "2235": "get FCB & check file is open",
    "1634": "open file, reading any header",
    "337": "DOS_REF_XDPB",
    "340": "DOS_MAP_B",
    "343": "DD_INTERFACE",
    "346": "DD_INIT",
    "349": "DD_SETUP",
    "352": "DD_SET_RETRY",
    "355": "DD_READ_SECTOR",
    "358": "DD_WRITE_SECTOR",
    "361": "DD_CHECK_SECTOR",
    "364": "DD_FORMAT",
    "367": "DD_READ_ID",
    "370": "DD_TEST_UNSUITABLE",
    "373": "DD_LOGIN",
    "376": "DD_SEL_FORMAT",
    "379": "DD_ASK_1",
    "382": "DD_DRIVE_STATUS",
    "385": "DD_EQUIPMENT",
    "388": "DD_ENCODE",
    "391": "DD_L_XDPB",
    "394": "DD_L_DPB",
    "397": "DD_L_SEEK",
    "400": "DD_L_READ",
    "403": "DD_L_WRITE",
    "406": "DD_L_ON_MOTOR",
    "409": "DD_L_T_OFF_MOTOR",
    "412": "DD_L_OFF_MOTOR",
    "439": "clear DOS workspace variables",
    "452": "$78 RAMdisk buffers, $08 cache buffers",
    "459": "initialise RAMdisk",
    "483": "A=BC=0",
    "484": "DE=version info",
    "487": "HL=?",
    "490": "signal success",
    "500": "get HL=old RAMdisk info",
    "504": "set Z if no change in RAMdisk",
    "507": "set success flag",
    "508": "change RAMdisk if necessary",
    "511": "restore new cache info",
    "512": "exit if error changing RAMdisk",
    "514": "get old cache info",
    "519": "set Z if no change in cache",
    "523": "change cache if necessary",
    "533": "exit if no bytes to copy",
    "534": "page in A",
    "537": "copy bytes, then following routine pages back original bank & exits",
    "548": "stack previous bank",
    "557": "page in new bank",
    "559": "restore previous bank",
    "563": "A=offset/256",
    "567": "H=high byte",
    "569": "L=start of buffer",
    "574": "A=bank 0,2,4 or 6",
    "578": "exit if 4 or 6",
    "579": "else use 1 or 3",
    "583": "move on if pages different",
    "588": "else just copy within page (now in A)",
    "592": "get #bytes to move if page C below $c000",
    "595": "move them",
    "600": "get #bytes to move if page B below $c000",
    "601": "opposite direction",
    "602": "calculate number",
    "606": "move them",
    "615": "exit if all moved",
    "616": "get interrupt status",
    "618": "disable interrupts",
    "621": "save $20 bytes at $bfe0",
    "624": "copy bytes via buffer at $bfe0",
    "628": "restore $20 bytes at $bfe0",
    "633": "restore interrupts if necessary",
    "649": "; exchange if required",
    "661": "move on if >=$100 bytes left",
    "666": "move up to $20 bytes at a time",
    "670": "save page numbers",
    "675": "reduce #bytes left to copy",
    "677": "restore page numbers",
    "682": "exit if no more bytes to copy",
    "689": "A=page to copy from, BC=#bytes",
    "694": "copy bytes to $bfe0",
    "704": "A=page to copy to, BC=#bytes",
    "709": "copy bytes from $bfe0",
    "714": "loop back until copied all",
    "717": "move zero bytes if dest in top segment",
    "726": "exit if destination in top segment",
    "732": "BC=#bytes",
    "737": "move on if space for all bytes ",
    "739": "else use space available",
    "748": "IX=bytes left to move after this    ",
    "755": "use $0000 to disable",
    "758": "get old routine address",
    "762": "set new routine address",
    "774": "if ALERT routine exists, go to do it",
    "776": "otherwise exit with HL=1",
    "778": "save drive",
    "973": "$8b&\"not ready\"&$8f&$ff",
    "985": "$8c&\"write protected\"&$8f&$ff",
    "1003": "$8d&\"seek fail\"&$8f&$ff",
    "1015": "$8e&\"data error\"&$8f&$ff",
    "1028": "$8e&\"no data\"&$8f&$ff",
    "1038": "$8e&\"missing address mark\"&$8f&$ff",
    "1061": "$8b&\"bad format\"&$8f&$ff",
    "1074": "$8e&\"unknown error\"&$8f&$ff",
    "1090": "$8c&\"changed, please replace\"&$8f&$ff",
    "1116": "$8c&\"unsuitable\"&$8f&$ff",
    "1129": "\"Please put the disk for \"&$fe&\": into the drive then press any key\"&$ff",
    "1190": "\"Drive \"&$fe&\": \"&$ff",
    "1200": "$8b&\"disk \"&$ff",
    "1207": "$8b&\"track \"&$fd&\", \"&$ff",
    "1218": "$8d&\"sector \"&$fc&\", \"&$ff",
    "1230": "\" - Retry, Ignore or Cancel? \"&$ff",
    "785": "generate error message",
    "805": "message 10",
    "813": "address to place message",
    "819": "generate it",
    "822": "add a terminator",
    "826": "restore address",
    "828": "mask off bit 7",
    "830": "address of message 0",
    "835": "go to find address",
    "840": "skip next message",
    "842": "back until at correct message",
    "844": "get next char",
    "848": "exit if end of message",
    "850": "process next char",
    "854": "back for more chars",
    "857": "move on if standard ASCII value",
    "862": "go to insert drive letter",
    "866": "go to insert track number",
    "870": "go to insert sector",
    "919": "track=D",
    "916": "sector=E",
    "929": "generate 100s digit",
    "926": "BC=-100",
    "932": "BC=-10",
    "935": "generate 10s digit",
    "939": "\"0\", generate digit",
    "943": "insert units digit",
    "945": "A=-1",
    "954": "loop back until value in A",
    "966": "C=Drive letter",
    "967": "add character to message",
    "958": "move on if zero",
    "962": "form character",
    "963": "exit if none",
    "1260": "exit if A=0",
    "1261": "shift right",
    "1266": "back for more",
    "1270": "exit if A=0",
    "1272": "shift left",
    "1274": "back for more",
    "1279": "\"a\"",
    "1282": "\"z\"+1",
    "1285": "if lowercase, convert to uppercase",
    "1288": "16 drives, A: to P:",
    "1292": "get XDPB for drive",
    "1296": "jump if XDPB available",
    "1298": "increment drive letter",
    "1299": "back for more",
    "1301": "\"A\"",
    "1303": "Store default drive information",
    "1313": "get FCB & test if open",
    "1316": "exit if error",
    "1317": "test if open for read",
    "1318": "error \"file not open\"",
    "1321": "get FCB & test if open",
    "1324": "exit if error",
    "1325": "test if open for write",
    "1327": "error \"file not open\"",
    "1330": "get FCB & access mode",
    "1333": "exit if error",
    "1335": "bit 7 to carry",
    "1336": "return with success if open",
    "1337": "file not open error",
    "1340": "get FCB & access mode",
    "1343": "exit if error",
    "1345": "inverted bit 7 to carry",
    "1346": "file not open",
    "1348": "return with error if open",
    "1349": "save registers",
    "1362": "clear FCB",
    "1368": "save registers",
    "1370": "get file number",
    "1375": "if >$0f, exit with bad parameter error",
    "1377": "fcbs-$0038",
    "1388": "BC=address of FCB",
    "1393": "get access mode",
    "1394": "success",
    "1395": "restore registers",
    "1402": "save access mode",
    "1403": "signal \"not opened\"",
    "1407": "check if file opened in any other FCB",
    "1412": "restore access mode",
    "1417": "18 files to check",
    "1425": "D=file access mode",
    "1427": "A=file drive",
    "1432": "move on if file not open",
    "1441": "move on if different drive",
    "1444": "check if current file is open drive",
    "1449": "or file we are checking",
    "1451": "if not, check if files are the same",
    "1454": "if not, move on",
    "1461": "get access mode of current file",
    "1466": "H=1 if open shared",
    "1471": "Z set if legal access",
    "1472": "access denied error",
    "1483": "loop back to test more FCBs",
    "1487": "make drive uppercase",
    "1490": "ensure disk logged in",
    "1493": "exit if error",
    "1495": "first FCB",
    "1498": "18 files",
    "1510": "is it on same drive?",
    "1506": "skip if file not open",
    "1515": "ensure file header & directory up to date",
    "1519": "exit if error",
    "1526": "get to next FCB",
    "1528": "back for more",
    "1530": "success",
    "1533": "first FCB",
    "1536": "check 18 FCBs (16 user+2 system)",
    "1540": "A=drive",
    "1546": "is drive the same?",
    "1579": "BC=next FCB",
    "1547": "move on if not",
    "1550": "is a sector number in +$2b?",
    "1552": "move on if not",
    "1559": "check low byte of absolute sector",
    "1560": "move on if different",
    "1564": "check high byte of absolute sector",
    "1565": "move on if different",
    "1567": "ensure correct disk logged in",
    "1570": "if no error, get sector to buffer",
    "1581": "success",
    "1584": "exit if error",
    "1573": "if error, go to exit",
    "1586": "loop back for more FCBs",
    "1591": "clear FCB for file B (& ensure closed)",
    "1594": "parse filename to FCB,disallowing wildcards",
    "1597": "ensure correct disk logged in",
    "1602": "exit if error",
    "1609": "set access mode",
    "1610": "ensure file can be opened in this mode",
    "1616": "find first extent of file",
    "1620": "exit if error",
    "1621": "move on if not found",
    "1623": "check open action",
    "1627": "\"file exists\" error for open action 0",
    "1629": "move on for actions 2-4",
    "1640": "move on for actions 3 & 4",
    "1642": "find first entry (open action 2)",
    "1645": "open file, skipping any header",
    "1648": "mark file as open & exit",
    "1652": "move on for action 4",
    "1654": "for open action 3, erase any existing .BAK",
    "1657": "and rename file to .BAK",
    "1660": "go to follow create action",
    "1663": "bad parameter if not action 4",
    "1666": "for action 4, erase file then do create",
    "1670": "exit if error",
    "1675": "error \"file not found\" for create action 0",
    "1677": "move on for create action 2",
    "1679": "for action 1, create an entry",
    "1682": "and add a header",
    "1688": "\"bad parameter\" for create actions > 2",
    "1691": "for action 2, just create an entry",
    "1694": "exit if error",
    "1695": "A=0 if file was created",
    "1699": "exit if error",
    "1700": "A=$ff if file was opened",
    "1706": "mark FCB as containing an open file",
    "1708": "increment # open files on drive",
    "1719": "check bit 1 of FCB flags",
    "1720": "\"access denied\" error",
    "1722": "check disk can be written to",
    "1728": "set up clean extent",
    "1731": "exit if error",
    "1736": "signal \"directory valid\"",
    "1740": "find directory entry of required extent",
    "1743": "move on if not found",
    "1752": "exit with success if new entry not needed",
    "1753": "check file can be written to",
    "1756": "check disk can be written to",
    "1760": "error \"end of file\"",
    "1764": "exit unless finding first extent",
    "1765": "error \"file not found\"",
    "1777": "copy FCB to SYSFCB0",
    "1782": "sysfcb+9",
    "1788": "sysfcb+0a, set extension in SYSFCB0 to \"BAK\"",
    "1780": "\"B\"",
    "1785": "\"KA\"",
    "1795": "erase any existing .BAK file",
    "1799": "exit if success",
    "1803": "or with success if error was \"file not found\"",
    "1806": "make drive letter uppercase",
    "1809": "save letter",
    "1810": "& access mode",
    "1811": "clear FCB for file B (ensure closed)",
    "1814": "exit if error",
    "1817": "\"open drive\"",
    "1822": "access mode",
    "1824": "drive letter",
    "1826": "get XDPB for drive",
    "1829": "check can open in required access mode",
    "1832": "exit if error",
    "1853": "DE=\"file\" length (high bytes)",
    "1861": "set file length",
    "1863": "set file open & exit",
    "1866": "get FCB & see if open",
    "1869": "ensure correct disk logged in",
    "1872": "ensure file header & directory up-to-date",
    "1875": "exit if error",
    "1876": "go to abandon FCB",
    "1885": "exit with success if file not in write mode",
    "1886": "update any +3DOS header with file length",
    "1889": "get sector to buffer",
    "1892": "write all changed data on this disk",
    "1895": "ensure directory up to date for this file",
    "1899": "get FCB & see if open",
    "1902": "ensure correct disk logged in",
    "1905": "exit if error",
    "1912": "move on if not open in write mode",
    "1918": "move on if new directory entry not needed",
    "1920": "clear flag & increment free entries",
    "1923": "deallocate blocks in FCB",
    "1926": "move all inuse BCBs for file to free list",
    "1933": "signal \"file not open\"",
    "1935": "decrement files open on disk",
    "1938": "low-level logout disk if none left",
    "1941": "success",
    "1943": "\"PLUS3DOS\"&$1a&$01",
    "1960": "exit with success if file has no header",
    "1961": "get DEHL=file position",
    "1966": "update header with filelength",
    "1972": "restore file position",
    "1981": "set file position to header file length",
    "1990": "copy filelength from FCB to file header",
    "1993": "exit if error",
    "1995": "MSB of filelength is zero",
    "1998": "exit if error",
    "2005": "copy +3 BASIC header data from FCB to file",
    "2008": "exit if error",
    "2009": "update header checksum & exit",
    "2012": "get next byte",
    "2014": "copy byte into file",
    "2017": "exit if error",
    "2019": "back for more",
    "2024": "header signature",
    "2027": "copy header signature into file",
    "2033": "version 0",
    "2040": "fill rest of header with nulls",
    "2047": "set checksum & place filepointer after it",
    "2055": "set \"file has header\" flag",
    "2059": "check if valid header checksum",
    "2062": "move on if error",
    "2064": "if not, move on (no header)",
    "2066": "header signature length",
    "2068": "header signature",
    "2071": "get byte from file",
    "2074": "move on if error",
    "2078": "move on if doesn't match header signature",
    "2081": "back for more chars",
    "2083": "get version",
    "2086": "move on if error",
    "2090": "no header if higher version than 0",
    "2102": "copy filelength from header",
    "2107": "skip high byte of length",
    "2121": "copy +3 BASIC data from header",
    "2130": "set filepointer past header record",
    "2133": "exit, setting \"file has header\" flag",
    "2139": "error unless \"end of file\"",
    "2144": "set filepointer to start of file",
    "2150": "filerecs+1",
    "2154": "filerecs+2",
    "2160": "get last record+1 in file",
    "2171": "DEHL=2*filelength",
    "2164": "filerecs+1",
    "2168": "filerecs-1",
    "2179": "DEHL=filelength",
    "2183": "\"file too big\" error if >8M",
    "2191": "store filelength in FCB",
    "2202": "exit if filenames don't match",
    "2206": "get ADE=last record number+1",
    "2210": "test against largest found so far",
    "2217": "filerecs+2",
    "2221": "move on unless larger",
    "2228": "filerecs+2, set size from current extent",
    "2233": "success",
    "2251": "success",
    "2253": "E=required access mode",
    "2255": "get FCB & current access mode",
    "2258": "if ok, ensure correct disk logged in",
    "2261": "ensure file header & directory up-to-date",
    "2265": "exit if error",
    "2270": "get old access mode",
    "2271": "store new (as closed)",
    "2274": "check if can open in this mode",
    "2279": "if not, go to restore old mode & exit",
    "2283": "move on if not opening for write",
    "2285": "check file can be written to",
    "2288": "check disk can be written to",
    "2291": "exit, restoring mode, if error",
    "2293": "set file open",
    "2295": "success",
    "2297": "restore old mode",
    "2300": "make drive letter uppercase",
    "2303": "ensure allocation bitmap up-to-date",
    "2306": "exit if error",
    "2307": "move on to calculate free space",
    "2312": "move on to return current default user area",
    "2314": "check in range 0-15",
    "2319": "error 21 - bad parameter if not",
    "2321": "set default user area",
    "2324": "get default user area",
    "2327": "success",
    "2329": "make letter uppercase",
    "2334": "move on if current default drive required",
    "2337": "check drive has an XDPB",
    "2340": "exit with error if not",
    "2342": "set default drive",
    "2345": "get default drive",
    "2348": "success",
    "2353": "parse filespec, allowing wildcards",
    "2356": "ensure correct disk logged in",
    "2360": "check no source files open by any FCBs",
    "2363": "check disk can be written to",
    "2366": "exit if error",
    "2367": "routine to delete extents",
    "2376": "exit if entry doesn't match",
    "2380": "or if file read-only",
    "2384": "deallocate blocks in entry",
    "2389": "set \"deleted\" mark in FCB",
    "2391": "copy \"direntry\" to directory entry DE",
    "2395": "increment #free entries",
    "2399": "set \"success\" flag",
    "2403": "store attribs to set/clear",
    "2410": "parse filespec, allowing wildcards",
    "2413": "ensure correct disk logged in",
    "2416": "check disk can be written to",
    "2419": "exit if error",
    "2420": "routine to change attributes",
    "2429": "parse source filespec, ensuring no wildcards",
    "2432": "ensure correct disk logged in",
    "2440": "parse dest filespec, ensuring no wildcards",
    "2444": "exit if error",
    "2452": "check drives are the same",
    "2449": "sysfcb0+$21",
    "2455": "error \"cannot rename between drives\"",
    "2456": "check disk can be written to",
    "2463": "check dest file not open by any FCB",
    "2469": "check if dest file exists in directory",
    "2486": "exit if error",
    "2477": "file already exists error",
    "2473": "exit if error",
    "2488": "set \"no extents changed\"",
    "2491": "rename/delete all extents of file",
    "2498": "check if any extents changed",
    "2499": "file not found error",
    "2508": "exit if no match",
    "2510": "get attribs to set",
    "2513": "set mask",
    "2516": "set them",
    "2520": "get attribs to clear",
    "2523": "clear mask",
    "2524": "clear them",
    "2528": "go to update directory entry",
    "2530": "discard bit 7",
    "2534": "bits 6->3 on first four chars of filename",
    "2541": "bits 2->0 on extension",
    "2544": "move on if attribute not to be affected",
    "2546": "reset it",
    "2552": "set it if mask=$ff",
    "2555": "back for more",
    "2561": "exit if names don't match",
    "2565": "exit if file readonly",
    "2572": "also rename password control entries",
    "2582": "copy new filename to direntry",
    "2586": "copy \"direntry\" to directory entry DE",
    "2591": "if no error, set successful rename flag",
    "2595": "store buffer address",
    "2599": "store filter & buffer size",
    "2605": "store \"1 entry completed\"",
    "2611": "parse filespec to SYSFCB0, wildcards allowed",
    "2614": "ensure correct disk logged in",
    "2617": "flush drive",
    "2623": "generate catalog",
    "2626": "get B=#completed entries",
    "2632": "process the entry",
    "2637": "set A=$ff, set carry for success",
    "2642": "exit if doesn't match filespec",
    "2647": "move on if we should include system files",
    "2657": "exit if system file",
    "2662": "is it alphabetically less than preloaded?",
    "2666": "C=buffer size, B=#completed entries",
    "2674": "get to next entry in buffer",
    "2677": "decrement buffer size",
    "2678": "move on if more entries to check",
    "2680": "exit if no space left in buffer",
    "2681": "else move to add",
    "2683": "does filespec match next buffer entry?",
    "2686": "loop back if alphabetically greater",
    "2688": "move on if the same",
    "2697": "HL=#catalog buffer entries-1",
    "2704": "HL=13*(#catalog buffer entries-1)",
    "2709": "HL=address of last entry in catalog buffer",
    "2715": "BC=distance between last & current entries",
    "2722": "DE=address of end of catalog buffer",
    "2727": "shift catalog entries down one (may lose one)",
    "2737": "copy entry into buffer",
    "2742": "set zero size",
    "2750": "increment # completed entries (max=bufsize)",
    "2755": "calculate extent size in K",
    "2764": "add extent size into directory entry size",
    "2774": "11 chars to check",
    "2782": "compare chars without attribute bits",
    "2783": "if different, exit",
    "2787": "back for more",
    "2793": "parse filespec",
    "2796": "exit if error",
    "2805": "\"?\", check for wildcard characters",
    "2809": "exit with \"bad filename\" if found",
    "2811": "back for more",
    "2818": "set user area if specified",
    "2823": "set drive letter if specified",
    "2828": "check if char is digit",
    "2831": "exit if not",
    "2832": "save digit",
    "2833": "get next char",
    "2836": "check if its a digit",
    "2839": "if not, use single digit",
    "2841": "save ls digit",
    "2849": "E=user area",
    "2850": "get next char",
    "2856": "exit if invalid user area",
    "2857": "save user area in FCB",
    "2859": "get next char",
    "2862": "exit if none",
    "2866": "or if <\"A\"",
    "2869": "or if >\"P\"",
    "2867": "\"Q\"",
    "2863": "\"A\"",
    "2875": "save as drive letter in FCB",
    "2877": "get next char",
    "2882": "\"0\"",
    "2884": "error if <\"0\"",
    "2886": "set carry if user area",
    "2890": "parse filename",
    "2894": "error \"bad filename\"",
    "2905": "set drive as default",
    "2910": "set user area as default",
    "2911": "get next filename char",
    "2914": "move on if none",
    "2916": "save char",
    "2918": "\":\"",
    "2921": "if drive/user spec found, move on",
    "2923": "get next char",
    "2926": "back if found",
    "2929": "A=last drive/user char",
    "2930": "but skip if no drive/user spec",
    "2932": "set user area and/or drive in FCB",
    "2935": "exit if not found",
    "2936": "get char",
    "2942": "exit if not \":\"",
    "2940": "\":\"",
    "2943": "get char after \":\"",
    "2948": "if no filename, point to start",
    "2949": "with 11 chars to blank",
    "2954": "move to filename in FCB",
    "2957": "exit if first char is \".\"",
    "2960": "get up to 8 filename chars",
    "2964": "and up to 3 extension chars",
    "2970": "exit if no extension",
    "2971": "skip \".\" and get next char",
    "2974": "move on if none",
    "2982": "check if char legal",
    "2986": "if not, fill rest with spaces",
    "2989": "exit with error if filename too long",
    "2992": "fill rest with ? if \"*\" wildcard",
    "2990": "\"*\"",
    "2995": "else, store character",
    "2997": "get next",
    "3000": "loop back if more",
    "3002": "skip any spaces",
    "3008": "fill rest with spaces",
    "3012": "set carry (success)",
    "3014": "\"?\"",
    "3018": "exit if done",
    "3019": "fill",
    "3023": "get next char",
    "3026": "exit if end",
    "3027": "check for end of filename",
    "3030": "exit if not",
    "3031": "check if ended by space or $ff",
    "3034": "skip until $ff encountered",
    "3040": "exit if end of filename",
    "3041": "next character",
    "3042": "get next char",
    "3045": "exit if end of filename",
    "3046": "mask to ASCII code",
    "3048": "convert to uppercase",
    "3051": "space?",
    "3053": "set \"not $ff\"",
    "3055": "test against next illegal char",
    "3057": "exit if illegal",
    "3058": "get to next char in list",
    "3061": "move back for more",
    "3063": "clear carry & reset Z (character legal)",
    "3065": "\"!&()+,-./:;<=>[\\]|\"&$80",
    "3089": "get drive from FCB",
    "3091": "possibly re-log drive",
    "3094": "exit if error",
    "3100": "exit if disk logged in",
    "3104": "initialise allocation bitmap",
    "3107": "set \"collecting sector checksums\"",
    "3115": "set no free directory entries",
    "3118": "copy last dir entry number to ext XDPB info",
    "3127": "generate allocation bitmap & get free entries",
    "3133": "set last used directory entry number",
    "3139": "exit if error",
    "3140": "drive logged in",
    "3144": "just check sector checksums",
    "3156": "is entry unused?",
    "3158": "if so, inc #free directory entries & exit",
    "3161": "BC=directory entry number",
    "3163": "add to allocation bitmap",
    "3165": "add entry's blocks into bitmap",
    "3181": "is correct extent in FCB?",
    "3184": "exit if so",
    "3186": "ensure directory up to date for this file",
    "3190": "exit if error",
    "3196": "store low 5 bits of extent counter in FCB",
    "3199": "store high 8 bits of extent counter in FCB",
    "3204": "clear allocation list & records in extent",
    "3208": "find entry",
    "3211": "exit if success",
    "3216": "signal \"new extent required\"",
    "3220": "check if correct extent in FCB",
    "3223": "move on if not",
    "3231": "move on if new extent required",
    "3234": "else success",
    "3237": "ensure directory up to date for this file",
    "3242": "set up FCB with clean extent",
    "3246": "error \"end of file\"",
    "3250": "exit with error except new extent required",
    "3251": "get new directory entry",
    "3258": "get FCB flags",
    "3262": "exit with success if directory up to date",
    "3265": "move on if new entry flag set but not needed",
    "3270": "move on if need new entry",
    "3275": "search directory for correct extent",
    "3278": "exit if error",
    "3279": "extent missing error",
    "3282": "exit with error if extent not found",
    "3283": "update directory from FCB & exit",
    "3285": "get new directory entry number (DE)",
    "3288": "exit if error",
    "3292": "check if datestamps in use",
    "3295": "move on if not",
    "3299": "else zeroise date stamp",
    "3315": "copy directory entry from FCB to \"direntry\"",
    "3319": "copy \"direntry\" to directory entry DE",
    "3322": "write all changed buffers back on this disk",
    "3329": "flag \"directory up to date\"",
    "3334": "A=EXM extent mask",
    "3340": "B=low 5 bits of extent mask (inverted)",
    "3348": "L=high 8 bits of required extent counter",
    "3354": "H=low 5 bits of required extent counter",
    "3370": "A=high 8 bits of extent counter from FCB",
    "3372": "if not same, exit",
    "3376": "A=low 5 bits of extent counter from FCB",
    "3379": "if not same, exit",
    "3381": "signal \"correct extent\"",
    "3389": "find entry with correct extent counter",
    "3392": "exit if error",
    "3396": "error \"end of file\" if not found",
    "3403": "copy entry into FCB",
    "3412": "check user area",
    "3413": "and filename",
    "3416": "move on if no match",
    "3418": "get EX",
    "3420": "move on if don't care about extent",
    "3426": "B=inverse EXM",
    "3430": "move on if wrong extent",
    "3436": "get S2",
    "3439": "move on if don't care about extent",
    "3442": "exit with Z set if match",
    "3446": "mask off user area flag $20",
    "3451": "check if user areas match",
    "3455": "check if filenames match",
    "3466": "DE points to FCB's name",
    "3467": "HL points to directory entry's name",
    "3468": "11 bytes to check",
    "3473": "? matches anything",
    "3471": "\"?\"",
    "3475": "compare chars",
    "3476": "mask off attributes",
    "3478": "move on if no match",
    "3482": "loop back for more chars",
    "3486": "store subroutine address",
    "3489": "free buffers referencing directory sectors",
    "3492": "DE=first directory entry",
    "3497": "only get a sector every 16th entry",
    "3502": "get sector & get/set checksum",
    "3505": "exit if error",
    "3518": "calc offset of entry in sector",
    "3521": "copy entry to page 7",
    "3529": "call subroutine rt_dirent",
    "3534": "move on if error",
    "3536": "or if done",
    "3538": "increment dir entry number",
    "3541": "loop back if more",
    "3543": "HL points to last entry obtained",
    "3547": "drop original AF from stack",
    "3552": "stack routine address",
    "3553": "address of directory entry",
    "3556": "\"return\" to call routine",
    "3557": "increment",
    "3565": "test against last",
    "3571": "DE=logical usable record number",
    "3574": "DE=absolute logical sector number",
    "3577": "get AHL=page & address of buffer",
    "3580": "exit if error",
    "3582": "save buffer details",
    "3584": "get sector checksum & address to place",
    "3587": "skip reserved sectors",
    "3593": "move on if just checking",
    "3595": "save checksum",
    "3596": "set Z if checksum matches",
    "3597": "set success",
    "3598": "if checksums match, exit",
    "3600": "free buffers referencing unchanged sectors",
    "3605": "recoverable error 8 - disk changed",
    "3608": "exit if didn't recover",
    "3611": "else loop back to retry",
    "3613": "restore buffer address to AHL",
    "3614": "but don't overwrite an error code",
    "3623": "save low byte of directory entry number",
    "3626": "DE=directory record number",
    "3629": "get DE=absolute logical sector",
    "3633": "dummy FCB address",
    "3636": "get buffer to AHL, and flag changed",
    "3640": "exit if error",
    "3642": "save buffer page",
    "3649": "get address of directory entry",
    "3655": "copy \"direntry\" into directory",
    "3663": "calculate sector checksum",
    "3668": "update checksum vector",
    "3674": "16 entries per sector",
    "3695": "HL=abs logical sector",
    "3704": "DE=#directory records",
    "3713": "test logical sector",
    "3710": "DE=first non-directory sector",
    "3718": "exit if not after directory",
    "3721": "page in bank containing buffer",
    "3729": "A=8-bit checksum of sector",
    "3736": "save checksum",
    "3738": "page back original bank",
    "3744": "HL=address of checksum table",
    "3747": "+abs logical sector",
    "3752": "DE=first non-reserved sector",
    "3756": "HL=address of sector checksum",
    "3761": "restore checksum",
    "3769": "get read-only bit",
    "3770": "move to carry",
    "3773": "carry is inverse of read-only bit",
    "3774": "\"read-only file\" error",
    "3777": "get HL=allocation bitmap, DE=last block #",
    "3787": "zero allocation for 8 blocks",
    "3785": "DE=(last block #)/8+1",
    "3793": "loop back for more",
    "3796": "store directory bitmaps",
    "3811": "DE=block/8",
    "3815": "get HL=address of allocation bitmap",
    "3819": "HL points to correct allocation byte",
    "3824": "B=bit within byte",
    "3831": "B=bitmask",
    "3833": "C=bit if allocating, 0 if deallocating",
    "3838": "update bit in allocation bitmap",
    "3844": "get HL=allocation bitmap & DE=last block",
    "3847": "bit counter & mask",
    "3850": "get byte from allocation bitmap",
    "3852": "move on if found free block",
    "3854": "shift bit mask",
    "3860": "move on if no blocks left",
    "3863": "loop back for more blocks in allocation byte",
    "3866": "back for more allocation bytes",
    "3870": "allocate this block",
    "3880": "calculate DE=allocated block",
    "3887": "signal directory contains valid FCB data",
    "3893": "HL=FCB address",
    "3895": "deallocate",
    "3896": "save BC",
    "3897": "C=allocate/deallocate flag",
    "3901": "exit if not a file entry",
    "3906": "HL points to allocation list",
    "3907": "16 allocation entries to consider",
    "3910": "go to start loop",
    "3912": "E=next allocation entry",
    "3914": "more than 256 blocks on disk?",
    "3918": "DE=block number if 8-bit block numbers",
    "3922": "DE=16-bit block number",
    "3926": "move on if allocation entry null",
    "3936": "test against last block number",
    "3937": "if in range, allocate/deallocate block",
    "3941": "loop back",
    "3946": "Subroutine to calculate extent size in K (to HL)",
    "3949": "test user area",
    "3951": "zero blocks so far",
    "3954": "skip calculation if password entry",
    "3959": "point to allocation list",
    "3960": "D=#bytes to test,E=#blocks found",
    "3966": "more than 255 blocks?",
    "3967": "get block number",
    "3969": "if not move on",
    "3971": "else incorporate 2nd byte",
    "3972": "and move over",
    "3977": "increment #blocks if not null",
    "3979": "loop back for rest of allocation list",
    "3981": "HL=#blocks, to be converted to K next",
    "3983": "get block size",
    "3989": "move on when HL=size in K",
    "3991": "double it",
    "3992": "loop back",
    "3995": "set Z if HL=0",
    "3996": "success",
    "3998": "0 free blocks so far",
    "4001": "stack it",
    "4002": "HL=alloc bitmap, DE=last block number",
    "4005": "bit count & mask",
    "4009": "check if block free",
    "4013": "increment #free if so",
    "4015": "shift bit mask",
    "4019": "move on if no more blocks",
    "4022": "loop back for rest of allocation byte",
    "4025": "loop back",
    "4027": "HL=#free blocks",
    "4028": "convert blocks to K & exit",
    "4033": "HL=address of allocation bitmap",
    "4039": "DE=last block number",
    "4051": "error \"directory full\" if no new entries",
    "4056": "new directory entry needed",
    "4058": "extent now created",
    "4063": "decrement #free directory entries",
    "4079": "BC=last used directory entry number",
    "4082": "set last used=last entry",
    "4088": "find first unused entry",
    "4091": "exit if error",
    "4101": "reset \"new directory entry\" flag",
    "4107": "if no free entry found, cause error",
    "4115": "move on if entry lower than last used",
    "4118": "else last used=this entry",
    "4122": "set last used entry",
    "4125": "success",
    "4128": "re-increment free directory entries",
    "4131": "\"extent missing\" error",
    "4137": "set Z if free",
    "4139": "success",
    "4146": "we don't need a new entry",
    "4149": "success",
    "4150": "increment # free directory entries",
    "4169": "generate HL=address of last entry in record",
    "4174": "check if datestamp entry",
    "4176": "exit if not",
    "4191": "get FCB",
    "4194": "exit if error",
    "4195": "offset for file position",
    "4198": "move on",
    "4200": "get FCB",
    "4203": "exit if error",
    "4204": "offset for EOF",
    "4215": "DEHL=file position/EOF",
    "4217": "success"
  },
  "PrefixComments": {
    "56": "The maskable interrupt routine",
    "102": "The Non-maskable interrupt",
    "104": "The disk motor timeout subroutine",
    "424": "Initialise +3DOS",
    "476": "Get +3DOS issue and version numbers",
    "492": "Get memory usage in pages 1, 3, 4, 6",
    "498": "Re-allocate memory usage in pages 1, 3, 4, 6",
    "527": "Subroutine to copy BC bytes from HL to DE within page A, then page back original page",
    "539": "Subroutine to page in bank A (gives A=previous bank)",
    "563": "Subroutine to find address of buffer A in 1346 area. On exit, HL=address, A=bank",
    "581": "Subroutine to copy IX bytes from HL in page C to DE in page B",
    "635": "Subroutine to copy $20 bytes from pg_buffer to $bfe0 (or vice-versa if carry set)",
    "656": "Subroutine to copy IX bytes from HL in page C to DE in page B, using a $20-byte buffer at $bfe0",
    "716": "Subroutine to calculate BC=#bytes that can be moved to DE. If DE is in the top segment, no bytes can be moved. IX initially contains total #bytes to move, and on exit contains #bytes that will be left after this move",
    "752": "Enable/disable error messages. A=0: disable A!=0:enable, HL=Alert routine address.",
    "767": "Subroutine to do an ALERT message for error A on drive C",
    "973": "Recoverable error message table",
    "799": "Subroutine to call ALERT subroutine with error message in HL",
    "805": "Subroutine to generate change disk message",
    "813": "Subroutine to generate recoverable error message A, returns address in HL",
    "828": "Subroutine to put recoverable error message address for error A at IX",
    "856": "Subroutine to process a character in the error message generator",
    "945": "Generates a decimal digit from HL, subtracting BC in a loop, counting in A",
    "1259": "Subroutine to shift DE right A times",
    "1269": "Subroutine to shift DE left A times",
    "1278": "Subroutine to call routine address in HL",
    "1279": "Subroutine to convert lowercase drive letters to uppercase",
    "1288": "Sets default drive to first found with XDPB. If none, A: is set as default",
    "1313": "Subroutine to get FCB for file B & test if open for reading",
    "1321": "Subroutine to get FCB for file B & test if open for writing",
    "1340": "Subroutine to clear FCB for closed file B",
    "1368": "Subroutine to get FCB (in BC) of file B. Returns access mode/flags in A.",
    "1398": "Subroutine to check if file in BC is opened by any other FCB",
    "1414": "Subroutine to check if file in BC can be opened in required access mode",
    "1487": "Bring disk up to date",
    "1533": "Subroutine to get sector HL to buffer, ensuring all FCBs on same drive referencing this sector are up to date. On entry, D=drive, HL=abs logical sector of a buffer",
    "1589": "Create and/or open a file",
    "1713": "Subroutine to set up clean directory entry for new file",
    "1740": "Subroutine to find entry for required extent of file",
    "1768": "Subroutine to erase any .BAK file existing for file in current FCB",
    "1806": "Open a drive as a single file",
    "1866": "Close a file",
    "1878": "Subroutine to ensure file's +3DOS header & directory entry are up-to-date",
    "1899": "Abandon a file",
    "1943": "+3DOS file header signature (issue 1)",
    "1953": "Subroutine to update any +3DOS file header with filelength if necessary",
    "1977": "Subroutine to update +3DOS file header with filelength & +3 BASIC header. Leaves filepointer positioned after header.",
    "2012": "Subroutine to copy E bytes from HL into file at current filepointer",
    "2022": "Subroutine to create a header for a newly-created file",
    "2059": "Subroutine to open file & read any header",
    "2199": "Subroutine to update largest rec# with one from current extent if larger",
    "2235": "Point at the header data for this file",
    "2253": "Change open file's access mode",
    "2300": "Free space on disk",
    "2310": "Set/get default user number",
    "2329": "Set/get default drive",
    "2350": "Delete a file",
    "2373": "Subroutine to delete any directory entry matching one in FCB",
    "2403": "Change a file's attributes",
    "2505": "Subroutine to change attributes for directory entries matching filespec",
    "2530": "Subroutine to set/clear attributes. HL points to directory entry, A contains attributes to set/clear & C contains set/clear mask",
    "2558": "Subroutine to rename any directory entry matching filename in SYSFCB1 to name in SYSFCB0",
    "2631": "Subroutine to add directory entry to catalog if suitable",
    "2639": "Subroutine to process a directory entry & add to catalog if suitable",
    "2771": "Subroutine to compare filenames at DE & HL (ignoring attributes) and setting Z if they match. Carry set if filename at HL > one at DE",
    "2793": "Subroutine to parse filespec at HL into FCB at BC, giving error if filespec illegal or contains wildcards",
    "2815": "Subroutine to parse filespecs, allowing wildcards",
    "2818": "Subroutine to set user area & drive letter specified in filename. Should exit with HL pointing to \":\". On exit, carry reset if neither found",
    "2828": "Subroutine to check if chars at HL are a user area. If so, exits with user area set, carry set & HL pointing after user area in filename.",
    "2859": "Subroutine to check if char at HL is a drive letter. If so, exits with drive letter set, carry set & HL pointing after drive letter in filename.",
    "2882": "Subroutine to test if A is a digit ('0'-'9'). If so, exits with carry set & A=value",
    "2889": "Subroutine to parse filename at HL to FCB in BC (preserved). Carry reset & error $14 if illegal filespec.",
    "3014": "Subroutine to fill E+1 chars in filename with \"?\" wildcard chars. Or enter at L0BC8 to fill with char in A.",
    "3023": "Subroutine to skip char in filename & get next one",
    "3027": "Subroutine to get next filename char in A, Z set if end-of-filename",
    "3037": "Subroutine to get next filename char (exits with C reset if already end of filename)",
    "3042": "Subroutine to get current filename char as uppercase in A, checking for end of filename ($ff or space), setting Z if so",
    "3055": "Subroutine to check for illegal chars in filenames. On entry, A=char & on exit carry & Z set if illegal.",
    "3084": "Subroutine to ensure disk for FCB in BC is logged in, if necessary building checksum vector, allocation bitmap & directory entry information for a drive",
    "3149": "Subroutine to process a directory entry, either incrementing the number of free entries, or updating the allocation bitmap for the files blocks.",
    "3168": "Subroutine to copy last directory entry number to extended XDPB info",
    "3181": "Subroutine to find extent HL for current file",
    "3220": "Subroutine to get new extent for file if required",
    "3254": "Subroutine to ensure directory is up-to-date for current file",
    "3307": "Subroutine to update directory with current FCB info",
    "3333": "Subroutine to check if correct extent for record is in FCB. On entry, DE=record number On exit, carry set if record is within this extent",
    "3386": "Subroutine to find directory entry with filename & extent counter in FCB",
    "3408": "Subroutine to check if directory entry found (HL) matches one in FCB. FCB can contain wildcards & $ff for extent bytes (match any extent) Z set if match found",
    "3444": "Subroutine to check if current file (BC) and file HL are the same. Enter at L0D74 if user area flag $20 should be ignored, or at L0D7A if user areas must exactly match. Z set if match.",
    "3463": "Subroutine to check if filename in directory entry at HL matches one in FCB at BC (may contain ? wildcards). Z set if match. On exit, HL points to directory entry after filename & DE points to FCB after filename (or at failed chars).",
    "3486": "Subroutine to call subroutine HL with every directory entry in turn. The subroutine it calls should set Z if it doesn't require any more entries. On exit, this routine leaves address of last-accessed entry in HL.",
    "3549": "Subroutine to call the subroutine whose address is at rt_dirent. It enters with HL=address of directory entry (direntry)",
    "3557": "Subroutine to increment DE (current directory entry). On exit, carry is set if no more entries",
    "3567": "Subroutine to get sector for directory entry DE, and get/set checksum. On exit, AHL=sector buffer address. Error if checksums didn't match",
    "3620": "Subroutine to copy \"direntry\" to directory entry (DE), marking buffer as changed & updating checksum",
    "3674": "Subroutine to calculate an offset into a sector buffer for a directory entry. On entry, A=lowbyte of entry number, HL=buffer address. On exit, DE=direntry, HL=entry address, IX=$20",
    "3693": "Subroutine to find address of sector DE (abs log) within checksum table (returned in HL) returning sector checksum in B On entry, BHL=sector buffer address",
    "3763": "Subroutine to check if file (HL=FCB) is read-only, giving error if so.",
    "3777": "Subroutine to initialise the allocation bitmap of a drive with the directory bitmaps",
    "3806": "Subroutine to allocate/deallocate a block. On entry, DE=block number and C=$00 to remove block from allocation bitmap. or $ff to add block to allocation bitmap",
    "3842": "Subroutine to allocate a new block for a file (returned in DE)",
    "3893": "Subroutine to deallocate all blocks in current FCB",
    "3896": "Subroutine to add/remove all the blocks in a directory entry to the allocation bitmap. On entry, HL=address of directory entry, A=$ff to add or $00 to remove.",
    "3983": "Subroutine to convert HL=blocks to K",
    "3998": "Subroutine to calculate HL=free space (in K) on current drive",
    "4030": "Subroutine to get HL=allocation bitmap & DE=last block number from XDPB",
    "4043": "Subroutine to check if new directory entry available.",
    "4075": "Subroutine to get a new directory entry (DE)",
    "4136": "Subroutine to check if directory entry at HL is free",
    "4141": "Subroutine to clear new entry flag & increment # free entries ",
    "4158": "Subroutine to check for datestamps, and if present to exit with Z set and HL pointing to address to place datestamp for entry DE",
    "4191": "Get file pointer for random access",
    "4200": "Get end of file position for random access",
    "4219": "Set file pointer for random access"
  },
  "Literals": {
    "23672": [
      "FRAMES"
    ],
    "58880": [
      "timeout"
    ],
    "23388": [
      "BANKM"
    ],
    "23399": [
      "BANK678"
    ],
    "56064": [
      "pg_buffer"
    ],
    "56065": [
      "pg_buffer_p_1"
    ],
    "56096": [
      "rt_alert"
    ],
    "56098": [
      "alert_resp"
    ],
    "56105": [
      "al_mess"
    ],
    "57236": [
      "def_drv"
    ],
    "23417": [
      "LODDRV"
    ],
    "23418": [
      "SAVDRV"
    ],
    "56224": [
      "fcbs"
    ],
    "57120": [
      "sysfcb0"
    ],
    "57232": [
      "filerecs"
    ],
    "57235": [
      "def_user"
    ],
    "57237": [
      "extchg"
    ],
    "57238": [
      "att_clr"
    ],
    "57239": [
      "att_set"
    ],
    "57240": [
      "cat_buff"
    ],
    "57242": [
      "cat_filt"
    ],
    "57244": [
      "cat_ents"
    ],
    "57243": [
      "cat_size"
    ],
    "57248": [
      "rt_dirent"
    ],
    "57250": [
      "direntry"
    ]
  },
  "LiteralReplacements": {
    "58": "FRAMES",
    "62": "FRAMES",
    "114": "timeout",
    "107": "BANKM",
    "120": "FRAMES",
    "127": "timeout",
    "131": "timeout",
    "139": "BANK678",
    "144": "BANK678",
    "152": "BANKM",
    "428": "pg_buffer",
    "431": "pg_buffer_p_1",
    "542": "BANKM",
    "758": "rt_alert",
    "762": "rt_alert",
    "768": "rt_alert",
    "782": "alert_resp",
    "779": "ERR_MSG_TABLE",
    "800": "rt_alert",
    "807": "ERR_MSG_TABLE",
    "810": "alert_resp",
    "813": "al_mess",
    "830": "alert_resp",
    "1303": "def_drv",
    "1306": "LODDRV",
    "1309": "SAVDRV",
    "1414": "fcbs",
    "1495": "fcbs",
    "1533": "fcbs",
    "1771": "sysfcb0",
    "2024": "DOSH_SIGN",
    "2068": "DOSH_SIGN",
    "2157": "UPD_RECNO",
    "2211": "filerecs",
    "2321": "def_user",
    "2324": "def_user",
    "2342": "def_drv",
    "2345": "def_drv",
    "2350": "sysfcb0",
    "2367": "DEL_MATCH_DIR",
    "2399": "extchg",
    "2403": "att_clr",
    "2407": "sysfcb0",
    "2488": "extchg",
    "2495": "extchg",
    "2510": "att_set",
    "2520": "att_clr",
    "2478": "RENAME_SYSFCB",
    "2591": "extchg",
    "2568": "sysfcb0",
    "2595": "cat_buff",
    "2599": "cat_filt",
    "2605": "cat_ents",
    "2608": "sysfcb0",
    "2626": "cat_size",
    "2643": "cat_filt",
    "2658": "cat_buff",
    "2666": "cat_size",
    "2692": "cat_size",
    "2705": "cat_buff",
    "2743": "cat_size",
    "2750": "cat_ents",
    "2902": "def_drv",
    "2907": "def_user",
    "3124": "PROC_DIRENT",
    "3386": "CHK_DE_IN_FCB",
    "3486": "rt_dirent",
    "3543": "direntry",
    "3549": "rt_dirent",
    "3553": "direntry",
    "3685": "direntry",
    "4085": "TEST_DE_FREE"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 7,
      "SectionType": 0,
      "Lenght": 8
    },
    {
      "StartAddress": 8,
      "EndAddress": 15,
      "SectionType": 2,
      "Lenght": 8
    },
    {
      "StartAddress": 16,
      "EndAddress": 55,
      "SectionType": 0,
      "Lenght": 40
    },
    {
      "StartAddress": 56,
      "EndAddress": 85,
      "SectionType": 1,
      "Lenght": 30
    },
    {
      "StartAddress": 86,
      "EndAddress": 101,
      "SectionType": 0,
      "Lenght": 16
    },
    {
      "StartAddress": 102,
      "EndAddress": 972,
      "SectionType": 1,
      "Lenght": 871
    },
    {
      "StartAddress": 973,
      "EndAddress": 984,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 985,
      "EndAddress": 1002,
      "SectionType": 2,
      "Lenght": 18
    },
    {
      "StartAddress": 1003,
      "EndAddress": 1014,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1015,
      "EndAddress": 1027,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1028,
      "EndAddress": 1037,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1038,
      "EndAddress": 1060,
      "SectionType": 2,
      "Lenght": 23
    },
    {
      "StartAddress": 1061,
      "EndAddress": 1073,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1074,
      "EndAddress": 1089,
      "SectionType": 2,
      "Lenght": 16
    },
    {
      "StartAddress": 1090,
      "EndAddress": 1115,
      "SectionType": 2,
      "Lenght": 26
    },
    {
      "StartAddress": 1116,
      "EndAddress": 1128,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1129,
      "EndAddress": 1189,
      "SectionType": 2,
      "Lenght": 61
    },
    {
      "StartAddress": 1190,
      "EndAddress": 1199,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1200,
      "EndAddress": 1206,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 1207,
      "EndAddress": 1217,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 1218,
      "EndAddress": 1229,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1230,
      "EndAddress": 1258,
      "SectionType": 2,
      "Lenght": 29
    },
    {
      "StartAddress": 1259,
      "EndAddress": 1942,
      "SectionType": 1,
      "Lenght": 684
    },
    {
      "StartAddress": 1943,
      "EndAddress": 1952,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1953,
      "EndAddress": 3064,
      "SectionType": 1,
      "Lenght": 1112
    },
    {
      "StartAddress": 3065,
      "EndAddress": 3083,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 3084,
      "EndAddress": 16383,
      "SectionType": 1,
      "Lenght": 13300
    }
  ],
  "DisassemblyFlags": 4
}