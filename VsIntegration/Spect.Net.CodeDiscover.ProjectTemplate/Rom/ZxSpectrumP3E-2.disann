{
  "Labels": {
    "102": "NMI",
    "104": "DISK_MOT_TO",
    "149": "DISK_MOT_TO_2",
    "424": "DOS_INITIALISE",
    "476": "DOS_VERSION",
    "492": "DOS_GET_1346",
    "452": "DOS_INIT_2",
    "498": "DOS_SET_1346",
    "527": "COPY_PAGED_BYTES",
    "534": "COPY_PB_2",
    "539": "PAGE_IN_A",
    "563": "FIND_BUFF_ADDR",
    "581": "COPY_BYTES",
    "591": "COPY_BYTES_2",
    "635": "SAVE_TO_BUFF",
    "650": "SAVE_TO_BUFF_2",
    "656": "COPY_VIA_BUFF",
    "668": "COPY_VIA_BUFF_2",
    "670": "COPY_VIA_BUFF_3",
    "716": "CALC_BYTE_COUNT",
    "741": "CALC_BYTE_CNT_2",
    "750": "CALC_BYTE_CNT_3",
    "752": "DOS_SET_MESSAGE",
    "758": "DOS_SETM_2",
    "767": "ALERT_MSG",
    "778": "ALERT_MSG_2",
    "973": "ERR_MSG_TABLE",
    "799": "ALERT_MSG_HL",
    "805": "ALERT_MSG_ID10",
    "813": "GEN_MSG_HL",
    "828": "GEN_MSG_IX",
    "837": "GEN_MSG_IX_2",
    "842": "GEN_MSG_IX_3",
    "844": "GEN_MSG_IX_4",
    "856": "PROC_MSG_CH",
    "967": "PROC_MSG_CH_RET",
    "966": "PROC_MSG_DRV",
    "919": "PROC_MSG_TRC",
    "916": "PROC_MSG_SEC",
    "945": "GEN_DIGIT",
    "947": "GEN_DIGIT_2",
    "956": "GEN_DIGIT_3",
    "893": "PROC_MSG_CH_2",
    "912": "PROC_MSG_CH_3",
    "914": "PROC_MSG_CH_4",
    "920": "PROC_MSG_CH_5",
    "962": "PROC_MSG_CH_6",
    "1259": "SHR_DE_A",
    "1261": "SHR_DE_A_2",
    "1269": "SHL_DE_A",
    "1272": "SHL_DE_A_2",
    "1278": "CALL_HLi",
    "1279": "TO_UPCASE",
    "1288": "SET_DEF_DRIVE",
    "1291": "SET_DEF_DRV_2",
    "1303": "SET_DEF_DRV_3",
    "1340": "CLEAR_FCB",
    "1368": "GET_FCB",
    "1384": "GET_FCB_2",
    "1313": "OPEN_FCB_READ",
    "1321": "OPEN_FCB_WRITE",
    "1330": "OPEN_FCB",
    "1395": "GET_FCB_3",
    "1398": "CHECK_OPEN",
    "1414": "CHECK_OPEN_2",
    "1419": "CHECK_OPEN_3",
    "1456": "CHECK_OPEN_4",
    "1476": "CHECK_OPEN_5",
    "1487": "DOS_FLUSH",
    "1494": "DOS_FLUSH_2",
    "1500": "DOS_FLUSH_3",
    "1521": "DOS_FLUSH_4",
    "1531": "DOS_FLUSH_5",
    "1533": "GET_SECT_BUFF",
    "1538": "GET_SECT_BUFF_2",
    "1575": "GET_SECT_BUFF_3",
    "1582": "GET_SECT_BUFF_4",
    "1589": "DOS_OPEN",
    "1639": "DOS_OPEN_2",
    "1650": "DOS_OPEN_3",
    "1662": "DOS_OPEN_4",
    "1669": "DOS_OPEN_5",
    "1671": "DOS_OPEN_6",
    "1687": "DOS_OPEN_7",
    "1694": "DOS_OPEN_8",
    "1699": "DOS_OPEN_9",
    "1701": "DOS_OPEN_10",
    "1713": "SETUP_DIR_ENT",
    "1740": "FIND_EXT_ENT",
    "1760": "FIND_EXT_ENT_2",
    "1768": "ERASE_BAK",
    "1806": "DOS_OPEN_DRIVE",
    "1866": "DOS_CLOSE",
    "1878": "ENSURE_UTD",
    "1899": "DOS_ABANDON",
    "1943": "DOSH_SIGN",
    "1953": "UPD_FHEADER",
    "1977": "UPD_FHEADER_2",
    "2012": "CPY_BYTES_TOF",
    "2022": "CRE_HEADER",
    "2039": "CRE_HEADER_2",
    "2051": "CRE_HEADER_3",
    "2059": "OPEN_RHEAD",
    "2071": "OPEN_RHEAD_2",
    "2098": "OPEN_RHEAD_3",
    "2117": "OPEN_RHEAD_4",
    "2135": "OPEN_RHEAD_5",
    "2140": "OPEN_RHEAD_6",
    "2199": "UPD_RECNO",
    "2147": "OPEN_RHEAD_7",
    "2231": "UPD_RECNO_2",
    "2235": "DOS_REF_HEAD",
    "2253": "DOS_SET_ACCESS",
    "2293": "DOS_SET_ACC_2",
    "2297": "DOS_SET_ACC_3",
    "2300": "DOS_FREE_SPACE",
    "2310": "DOS_SET_USER",
    "2324": "DOS_SET_USER_2",
    "2329": "DOS_SET_DRIVE",
    "2345": "DOS_SET_DRV_2",
    "2350": "DOS_DELETE",
    "2373": "DEL_MATCH_DIR",
    "2360": "DOS_DELETE_2",
    "2403": "DOS_SET_ATTRIBUT",
    "2425": "DOS_RENAME",
    "2445": "DOS_RENAME_2",
    "2481": "DOS_RENAME_3",
    "2487": "DOS_RENAME_4",
    "2505": "CHANGE_DIR_ATTR",
    "2530": "SET_CLR_ATTR",
    "2543": "SET_CLR_ATTR_2",
    "2554": "SET_CLR_ATTR_3",
    "2558": "RENAME_SYSFCB",
    "2595": "DOS_CATALOG",
    "2586": "RENAME_SYSFCB_2",
    "2631": "ADD_DIRENT_CAT",
    "2639": "PROC_DIRENT_CAT",
    "2658": "PROC_DIRENT_2",
    "2670": "PROC_DIRENT_3",
    "2683": "PROC_DIRENT_4",
    "2729": "PROC_DIRENT_5",
    "2731": "PROC_DIRENT_6",
    "2755": "PROC_DIRENT_7",
    "2771": "COMP_FNAMES",
    "2777": "COMP_FNAMES_2",
    "2789": "COMP_FNAMES_3",
    "2793": "PARSE_FSPEC",
    "2803": "PARSE_FSPEC_2",
    "2815": "PARSE_WFSPEC",
    "2818": "SET_UA_DL",
    "2828": "CHECK_UA",
    "2853": "CHECK_UA_2",
    "2859": "CHECK_DL",
    "2882": "ISDIGIT_A",
    "2889": "PARSE_FNAME_FCB",
    "2897": "DO_PARSE_FNAME",
    "2918": "DO_PARSE_FN_2",
    "2928": "DO_PARSE_FN_3",
    "2948": "DO_PARSE_FN_4",
    "2954": "DO_PARSE_FN_5",
    "2976": "DO_PARSE_FN_6",
    "3005": "DO_PARSE_FN_7",
    "3014": "FILL_FN_CH",
    "3016": "FILL_FN_CH_2",
    "3017": "FILL_FN_CH_3",
    "3023": "SKIP_FN_CHAR",
    "3027": "GET_NEXT_FNCHAR",
    "3030": "GET_NEXT_FNCH_2",
    "3037": "GET_NEXT_FNCH_3",
    "3042": "GET_CUR_FNCHAR",
    "3065": "INV_FNAME_CHARS",
    "3084": "LOGIN_DISK",
    "3091": "LOGIN_DISK_2",
    "3149": "ADM_DIRENT",
    "3155": "ADM_DIRENT_2",
    "3168": "CPY_DIRENT_XDPB",
    "3181": "FIND_EXTENT_HL",
    "3191": "FIND_EXTENT_HL_2",
    "3220": "GET_NEW_EXT",
    "3236": "GET_NEW_EXT_2",
    "3242": "GET_NEW_EXT_3",
    "3254": "ENS_DIR_UTD",
    "3285": "ENS_DIR_UTD_2",
    "3299": "ENS_DIR_UTD_3",
    "3304": "ENS_DIR_UTD_4",
    "3307": "UPD_DIR_FCB",
    "3333": "CHK_EXT_FCB",
    "3358": "CHK_FCB_2",
    "3382": "CHK_FCB_3",
    "3386": "FN_DE_BY_FNEC",
    "3408": "CHK_DE_IN_FCB",
    "3432": "CHK_DE_IN_FCB_2",
    "3442": "CHK_DE_IN_FCB_3",
    "3444": "COMP_FCBS",
    "3450": "COMP_FCBS_2",
    "3452": "COMP_FCBS_3",
    "3458": "COMP_FCBS_4",
    "3463": "COMP_FCBS_W",
    "3470": "COMP_FCBS_W_2",
    "3480": "COMP_FCBS_W_3",
    "3484": "COMP_FCBS_W_4",
    "3486": "FOREACH_DE",
    "3496": "FOREACH_DE_2",
    "3507": "FOREACH_DE_3",
    "3543": "FOREACH_DE_4",
    "3549": "CALL_DIRENT_HL",
    "3557": "INC_DIRENT",
    "3567": "GET_DE_SECT",
    "3577": "GET_DE_SECT_2",
    "3596": "GET_DE_SECT_3",
    "3613": "GET_DE_SECT_4",
    "3617": "GET_DE_SECT_5",
    "3620": "COPY_DIRENTRY",
    "3670": "COPY_DIRENTRY_2",
    "3674": "CALC_DE_OFFS",
    "3681": "CALC_DE_OFFS_2",
    "3685": "CALC_DE_OFFS_3",
    "3693": "FN_SECT_ADDR",
    "3729": "FN_SECT_ADDR_2",
    "3763": "CHECK_READONLY",
    "3777": "INIT_ALLOC_BM",
    "3787": "INIT_ALLOC_BM_2",
    "3806": "ALLOC_BLOCK",
    "3828": "ALLOC_BL_2",
    "3842": "ALLOC_NEW_BL",
    "3847": "ALLOC_NEW_BL_2",
    "3850": "ALLOC_NEW_BL_3",
    "3868": "ALLOC_NEW_BL_4",
    "3890": "ALLOC_NEW_BL_5",
    "3893": "DEALLOC_ALL_BL",
    "3896": "ALLOC_ALL_DE",
    "3912": "ALLOC_ALL_DE_2",
    "3924": "ALLOC_ALL_DE_3",
    "3941": "ALLOC_ALL_DE_4",
    "3943": "ALLOC_ALL_DE_5",
    "3946": "CALC_EXT_SIZEK",
    "3963": "CALC_EXTS_2",
    "3974": "CALC_EXTS_3",
    "3978": "CALC_EXTS_4",
    "3982": "CALC_EXTS_5",
    "3983": "CALC_EXTS_6",
    "3988": "CALC_EXTS_7",
    "3994": "CALC_EXTS_8",
    "3998": "CALC_FREE_K",
    "4005": "CALC_FK_2",
    "4008": "CALC_FK_3",
    "4015": "CALC_FK_4",
    "4027": "CALC_FK_5",
    "4030": "GET_ALLOC_INFO",
    "4043": "CHECK_NEW_DE",
    "4073": "CHECK_NDE_2",
    "4075": "GET_NEW_DE",
    "4119": "GET_NEW_DE_2",
    "4128": "GET_NEW_DE_3",
    "4136": "TEST_DE_FREE",
    "4134": "GET_NEW_DE_4",
    "4141": "ADM_NEW_ENTRY",
    "4149": "ADM_NEWE_2",
    "4158": "CHECK_DSTAMP",
    "4169": "CHECK_DSTAMP_2",
    "4173": "CHECK_DSTAMP_3",
    "4185": "CHECK_DSTAMP_4",
    "4189": "CHECK_DSTAMP_5",
    "4191": "DOS_GET_POSITION",
    "4195": "DOS_GETPOS_2",
    "4200": "DOS_GET_EOF",
    "4207": "DOS_GETPOS_3",
    "4219": "DOS_SET_POSITION",
    "4223": "DOS_SETPOS_2",
    "4232": "INC_FP_BY80",
    "4236": "INC_FP_BY1",
    "4238": "INC_FP_BYA",
    "4250": "INC_FP_2",
    "4252": "INC_FP_3",
    "4268": "INC_FP_4",
    "4274": "INC_FP_5",
    "4283": "ENS_FLEN",
    "4297": "ENS_FLEN_2",
    "4310": "ENS_FLEN_3",
    "4313": "READ_FILE_BYTE",
    "4342": "READ_REC",
    "4393": "DOS_BYTE_READ",
    "4410": "DOS_BREAD_2",
    "4428": "READ_BYTE",
    "4443": "READ_BYTE_2",
    "4476": "READ_BYTE_3",
    "4479": "DOS_WRITE",
    "4511": "WRITE_DE_BYTES",
    "4512": "WRITE_DEB_2",
    "4528": "WRITE_DEB_3",
    "4541": "WRITE_DEB_4",
    "4548": "WRITE_BYTE",
    "4578": "WRITE_REC",
    "4633": "DOS_BYTE_WRITE",
    "4646": "WRITE_A",
    "4666": "WRITE_A_2",
    "4700": "WRITE_A_3",
    "4703": "TEST_HEAD_CHKS",
    "4711": "UPD_HEAD_CHKS",
    "4728": "GET_CHECKSUMS",
    "4747": "GET_CHKS_2",
    "4765": "GET_CHKS_3",
    "4779": "GET_SECT_TOBUFF",
    "4808": "GET_SECT_TOB_2",
    "4813": "GET_SECT_TOB_3",
    "4815": "GET_ABS_SECT",
    "4828": "FIND_ABS_SECTOR",
    "4853": "GET_FILE_SECT",
    "4862": "GET_CUR_REC",
    "4873": "GET_CUR_REC_2",
    "4899": "GET_CUR_REC_3",
    "4937": "GET_CUR_REC_4",
    "4947": "GET_REC_NUM",
    "4957": "GET_REN_NUM_FP",
    "4977": "GET_REC_ADDR",
    "5000": "GET_RECADR_2",
    "5003": "GET_RECADR_3",
    "5010": "GET_RECADR_4",
    "5012": "GET_RECADR_5",
    "5022": "GETSECT_DE_TOBUF",
    "5028": "FIND_ABS_SECT",
    "5042": "FIND_ABS_SECT_2",
    "5046": "FIND_ABS_SECT_3",
    "5053": "CALC_ABS_SECT",
    "5084": "CALC_BLOCK_NO",
    "5123": "CALC_BLOCK_NO_2",
    "5129": "CALC_BLOCK_NO_3",
    "5138": "CALC_BLOCK_NO_4",
    "5142": "SET_EXT_INFO",
    "5171": "ISREC_IN_CUR_EXT",
    "5186": "ISREC_IN_CEXT_2",
    "5189": "CALC_LREC_IN_EXT",
    "5211": "CALC_LREC_EXT_2",
    "5230": "GET_DRIVE_SECT",
    "5276": "GET_CACHE_INFO",
    "5281": "SET_CACHE_INFO",
    "5285": "SET_CACHEI_2",
    "5311": "SET_CACHEI_3",
    "5325": "SET_CACHEI_4",
    "5358": "FIND_BCB",
    "5361": "FIND_BCB_2",
    "5388": "FIND_BCB_3",
    "5393": "GET_BUFF_FORS",
    "5401": "GET_BUFF_S_2",
    "5424": "GET_BUFF_S_3",
    "5447": "GET_SECT_BCB",
    "5472": "GET_PAGE",
    "5494": "GET_PAGE_2",
    "5496": "GET_PAGE_WCRE",
    "5513": "GET_PAGE_WCRE_2",
    "5520": "GET_PAGE_INFO",
    "5551": "GET_PAGE_INFO_2",
    "5564": "GET_PAGE_INFO_3",
    "5567": "FREE_UNCH_SECTS",
    "5592": "FREE_UNCH_S_2",
    "5598": "FREE_UNCH_S_3",
    "5603": "FREE_UNCH_S_4",
    "5604": "FREE_UNCH_S_5",
    "5648": "FREE_UNCH_S_6",
    "5651": "FREE_DRV_BCBS",
    "5657": "FREE_DRV_BCBS_2",
    "5658": "FREE_DRV_BCBS_3",
    "5682": "FREE_FILE_BCBS",
    "5688": "FREE_FILE_BCB_2",
    "5689": "FREE_FILE_BCB_3",
    "5716": "FREE_FILE_BCB_4",
    "5720": "REL_INUSE_CBUFF",
    "5742": "REL_INUSE_2",
    "5746": "CLEAR_CACHE",
    "5751": "CLEAR_CACHE_2",
    "5762": "CLEAR_CACHE_3",
    "5765": "WRITE_BACK",
    "5768": "WRITE_BACK_2",
    "5779": "WRITE_BACK_3",
    "5788": "WRITE_BACK_4",
    "5794": "WRITE_BACK_5",
    "5798": "FIND_SMALLER_BCB",
    "5833": "FIND_SMALLBCB_2",
    "5838": "WRITE_BUFFER",
    "5860": "READ_BUFFER",
    "5873": "GET_BUFF_INFO",
    "5892": "GET_LBCB_ADDR",
    "5895": "GET_LBCB_ADDR_2",
    "5903": "IS_BCB_LAST",
    "5910": "MOVE_BCB",
    "5918": "MOVE_BCB_2",
    "5924": "MOVE_BCB_3",
    "5935": "TRANSF_WORD_VAL",
    "5943": "SET_EXT_XDPB_AB",
    "5998": "EXT_XDPB_A",
    "6019": "EXT_XDPB_B",
    "6062": "EXT_XDPB_M",
    "6040": "INIT_RAMD",
    "6083": "RAMD_NO_OP",
    "6085": "DOS_REF_XDPB",
    "6091": "DOS_REFXDPB_2",
    "6123": "DOS_REFXDPB_3",
    "6127": "LOGOUT_DRV",
    "6149": "LL_LOGIN_DISK",
    "6157": "LOGOUT_DISK",
    "6171": "LL_LOGOUT_DISK",
    "6185": "TEST_LAST_ACC",
    "6207": "TEST_LACC_2",
    "6222": "TEST_LACC_3",
    "6252": "TEST_LACC_4",
    "6267": "TEST_DISK_WE",
    "6294": "CONV_REC_SECT",
    "6316": "CON_RECSECT_2",
    "6318": "CONV_RECSECT_3",
    "6257": "TEST_DISK_WE_2",
    "6326": "FIND_LOG_TRACK",
    "6344": "FIND_LOG_TRACK_2",
    "6355": "LL_LOGIN_DISK_2",
    "6367": "READ_SECTOR",
    "6376": "WRITE_SECTOR",
    "6383": "WRITE_SECTOR_2",
    "6387": "WRITE_SECTOR_3",
    "6403": "CALL_RT_TEMP",
    "6409": "CALL_HLi_2",
    "6410": "CHECK_CH_DISK",
    "6439": "CHECK_CHDISK_2",
    "6441": "CHANGE_DISK",
    "6453": "DOS_MAP_B",
    "6468": "DOS_MAP_B_2",
    "6499": "DOS_MAP_B_3",
    "6502": "DD_SET_RETRY",
    "6592": "DOS_READ",
    "6621": "READ_DE_BYTES",
    "6662": "READ_DE_BYTES_2",
    "6666": "READ_DE_BYTES_3",
    "16102": "DD_L_OFF_MOTOR",
    "6813": "DO_ALERT_MSG",
    "6957": "DISK_M_SPEC",
    "7285": "DD_READ_SECTOR",
    "7293": "TRY_READ_SECTOR",
    "7121": "SETUP_BL_FOR_R",
    "7128": "SETUP_BL_FOR_SR",
    "7135": "SETUP_PAR_LL_OP",
    "7186": "SETUP_PAR_LL_2",
    "7211": "GET_TRACK_INFO",
    "7230": "GET_TRACKI_2",
    "7242": "GET_TRACKI_3",
    "7248": "DD_ENCODE",
    "7254": "DD_ENCODE_2",
    "7263": "READ_SECTOR_A",
    "7279": "TRY_RSEC_A",
    "7299": "DD_WRITE_SECTOR",
    "7308": "DD_CHECK_SECTOR",
    "7110": "SETUP_PAR_CHECK",
    "7322": "DD_FORMAT",
    "7329": "DD_FORMAT_2",
    "7334": "TRY_DD_FORMAT",
    "7078": "SETUP_PAR_FORM",
    "7340": "DD_READ_ID",
    "7351": "READ_ID",
    "7359": "TRY_READ_ID",
    "7374": "SPECT_P3_FORMAT",
    "7384": "CPC_SYS_FORMAT",
    "7394": "CPC_DATA_FORMAT",
    "7404": "PCW_FORMAT",
    "7414": "DD_LOGIN",
    "7439": "DD_LOGIN_2",
    "7445": "DD_LOGIN_3",
    "7472": "DD_LOGIN_4",
    "7478": "DD_LOGIN_5",
    "7488": "DD_LOGIN_6",
    "7497": "DD_LOGIN_7",
    "7505": "DD_SEL_FORMAT",
    "7524": "DD_L_XDPB",
    "7539": "DD_L_XDPB_2",
    "7590": "DD_L_DPB",
    "7663": "DL_L_DPB_2",
    "7669": "DL_L_DPB_3",
    "7694": "DL_L_DPB_4",
    "7725": "DL_L_DPB_5",
    "7729": "DL_L_DPB_6",
    "7780": "UPD_DRV_INFO",
    "7800": "UPD_DRVI_2",
    "7810": "UPD_DRVI_3",
    "7814": "TEST_DRV_EQV",
    "7834": "TEST_DRVEQ_2",
    "7855": "TEST_DRVEQ_3",
    "7879": "TEST_DRVEQ_4",
    "7881": "TEST_DRVEQ_5",
    "7889": "TEST_DRVEQ_6",
    "7895": "TEST_DRVEQ_7",
    "7899": "DD_TEST_UNSUIT",
    "7915": "DD_EQUIPMENT",
    "7922": "DO_RETRY",
    "7926": "DO_RETRY_2",
    "7966": "DO_RETRY_3",
    "7970": "POS_HEAD",
    "7988": "POS_HEAD_2",
    "7998": "POS_HEAD_3",
    "8015": "DD_ASK_1",
    "8027": "DD_DRIVE_STATUS",
    "8036": "CALC_2_POW_A_M1",
    "8041": "CALC_2POWA_2",
    "8046": "MUL_HL_BY_2POWB",
    "8049": "MUL_HL_2POWB_2",
    "8053": "DIV_HL_BY_2POWB",
    "8056": "DIV_HL_2POWB_2",
    "8063": "DATA_DD_INIT",
    "8070": "DD_INTERFACE",
    "8081": "DD_INIT",
    "8086": "DD_INIT_2",
    "8102": "DD_SETUP",
    "8137": "CALC_EQV_ADDR",
    "8149": "DD_L_SEEK",
    "8158": "SEEK_TRACK",
    "8162": "SEEK_TRACK_2",
    "8177": "SEEK_TRACK_3",
    "8191": "SEEK_TRACK_4",
    "8194": "SEEK_TRACK_5",
    "8199": "SEEK_TRACK_6",
    "8204": "SEEK_TRACK_7",
    "8214": "SEEK_TRACK_ZERO",
    "8218": "SEEK_TRACK0_2",
    "8236": "SEEK_TRACK0_3",
    "8246": "SEEK_TRACK_HGS",
    "8250": "SEEK_TRACK_D",
    "8259": "SEEK_TRACK_D_2",
    "8285": "COMPL_SEEK",
    "8289": "COMPL_SEEK_2",
    "8315": "DELAY_A_MS",
    "8317": "DELAY_A_MS_2",
    "8324": "WAIT_SEEK",
    "8351": "WAIT_SEEK_2",
    "8357": "WAIT_SEEK_3",
    "8361": "PROC_RES_BUFF",
    "8398": "WAIT_FDC_READY",
    "8403": "WAIT_FREADY_2",
    "8415": "SENSE_INT_STAT",
    "8422": "GET_UNIT_STAT",
    "8431": "GET_FDC_STRING",
    "8434": "GET_FDCSTR_2",
    "8443": "GET_FDCSTR_3",
    "8466": "GET_FDCSTR_4",
    "8473": "READ_E_BYTES",
    "8482": "DD_L_WRITE",
    "8491": "DD_L_WRITE_2"
  },
  "Comments": {
    "8": "\"PLUS3DOS\"",
    "61": "increment FRAMES",
    "69": "increment high byte of FRAMES",
    "74": "scan the keyboard",
    "77": "test for disk motor timeout",
    "102": "do nothing",
    "112": "page in page 7",
    "118": "exit if motor already off",
    "125": "only decrement count every other frame",
    "130": "decrement timeout count",
    "134": "exit if not yet zero",
    "147": "turn motor off",
    "155": "restore memory configuration",
    "495": "get cache info & exit",
    "492": "get RAMdisk info",
    "1637": "mark file as open & exit",
    "2243": "IX points to header data",
    "2249": "does file have header?",
    "2238": "exit if not",
    "6818": "turn motor off",
    "16112": "change the value to switch off motor",
    "16110": "get current BANK678 value & mask motor bit",
    "16104": "zero timeout value",
    "4340": "success",
    "4339": "decrement #bytes to read",
    "4338": "set Z if finished",
    "4333": "update address to read to",
    "298": "DOS_BOOT",
    "4329": "page back original bank",
    "4328": "store byte",
    "4325": "page in bank",
    "4316": "exit if error",
    "4313": "read a byte",
    "499": "HL=new RAMdisk info",
    "498": "save new cache info",
    "1631": "find first entry (open action 1)",
    "4347": "exit if error",
    "4343": "get record to buffer & update FCB",
    "2235": "get FCB & check file is open",
    "1634": "open file, reading any header",
    "6843": "IX=XDPB for M:",
    "6824": "run the ALERT routine",
    "343": "DD_INTERFACE",
    "346": "DD_INIT",
    "349": "DD_SETUP",
    "6821": "C=drive",
    "7964": "error 8 - disk changed",
    "7962": "different CPC format than expected)",
    "7960": "compare to XDPB sector ID (detect if",
    "7954": "fdc_res+6, get sector ID found",
    "7953": "exit if non-recoverable error",
    "7951": "move on if recoverable error",
    "7945": "process results",
    "7942": "read a sector ID",
    "379": "DD_ASK_1",
    "382": "DD_DRIVE_STATUS",
    "7939": "flags (for modulation mode)",
    "7934": "move on if not \"no data\" error",
    "7931": "exit for success or unrecoverable error",
    "7927": "try the operation",
    "397": "DD_L_SEEK",
    "400": "DD_L_READ",
    "403": "DD_L_WRITE",
    "406": "DD_L_ON_MOTOR",
    "409": "DD_L_T_OFF_MOTOR",
    "7925": "B=retry count",
    "439": "clear DOS workspace variables",
    "452": "$78 RAMdisk buffers, $08 cache buffers",
    "459": "initialise RAMdisk",
    "483": "A=BC=0",
    "484": "DE=version info",
    "487": "HL=?",
    "490": "signal success",
    "500": "get HL=old RAMdisk info",
    "504": "set Z if no change in RAMdisk",
    "507": "set success flag",
    "508": "change RAMdisk if necessary",
    "511": "restore new cache info",
    "512": "exit if error changing RAMdisk",
    "514": "get old cache info",
    "519": "set Z if no change in cache",
    "523": "change cache if necessary",
    "533": "exit if no bytes to copy",
    "534": "page in A",
    "537": "copy bytes, then following routine pages back original bank & exits",
    "548": "stack previous bank",
    "557": "page in new bank",
    "559": "restore previous bank",
    "563": "A=offset/256",
    "567": "H=high byte",
    "569": "L=start of buffer",
    "574": "A=bank 0,2,4 or 6",
    "578": "exit if 4 or 6",
    "579": "else use 1 or 3",
    "583": "move on if pages different",
    "588": "else just copy within page (now in A)",
    "592": "get #bytes to move if page C below $c000",
    "595": "move them",
    "600": "get #bytes to move if page B below $c000",
    "601": "opposite direction",
    "602": "calculate number",
    "606": "move them",
    "615": "exit if all moved",
    "616": "get interrupt status",
    "618": "disable interrupts",
    "621": "save $20 bytes at $bfe0",
    "624": "copy bytes via buffer at $bfe0",
    "628": "restore $20 bytes at $bfe0",
    "633": "restore interrupts if necessary",
    "649": "; exchange if required",
    "661": "move on if >=$100 bytes left",
    "666": "move up to $20 bytes at a time",
    "670": "save page numbers",
    "675": "reduce #bytes left to copy",
    "677": "restore page numbers",
    "682": "exit if no more bytes to copy",
    "689": "A=page to copy from, BC=#bytes",
    "694": "copy bytes to $bfe0",
    "704": "A=page to copy to, BC=#bytes",
    "709": "copy bytes from $bfe0",
    "714": "loop back until copied all",
    "717": "move zero bytes if dest in top segment",
    "726": "exit if destination in top segment",
    "732": "BC=#bytes",
    "737": "move on if space for all bytes ",
    "739": "else use space available",
    "748": "IX=bytes left to move after this    ",
    "755": "use $0000 to disable",
    "758": "get old routine address",
    "762": "set new routine address",
    "774": "if ALERT routine exists, go to do it",
    "776": "otherwise exit with HL=1",
    "778": "save drive",
    "973": "$8b&\"not ready\"&$8f&$ff",
    "985": "$8c&\"write protected\"&$8f&$ff",
    "1003": "$8d&\"seek fail\"&$8f&$ff",
    "1015": "$8e&\"data error\"&$8f&$ff",
    "1028": "$8e&\"no data\"&$8f&$ff",
    "1038": "$8e&\"missing address mark\"&$8f&$ff",
    "1061": "$8b&\"bad format\"&$8f&$ff",
    "1074": "$8e&\"unknown error\"&$8f&$ff",
    "1090": "$8c&\"changed, please replace\"&$8f&$ff",
    "1116": "$8c&\"unsuitable\"&$8f&$ff",
    "1129": "\"Please put the disk for \"&$fe&\": into the drive then press any key\"&$ff",
    "1190": "\"Drive \"&$fe&\": \"&$ff",
    "1200": "$8b&\"disk \"&$ff",
    "1207": "$8b&\"track \"&$fd&\", \"&$ff",
    "1218": "$8d&\"sector \"&$fc&\", \"&$ff",
    "1230": "\" - Retry, Ignore or Cancel? \"&$ff",
    "785": "generate error message",
    "805": "message 10",
    "813": "address to place message",
    "819": "generate it",
    "822": "add a terminator",
    "826": "restore address",
    "828": "mask off bit 7",
    "830": "address of message 0",
    "835": "go to find address",
    "840": "skip next message",
    "842": "back until at correct message",
    "844": "get next char",
    "848": "exit if end of message",
    "850": "process next char",
    "854": "back for more chars",
    "857": "move on if standard ASCII value",
    "862": "go to insert drive letter",
    "866": "go to insert track number",
    "870": "go to insert sector",
    "919": "track=D",
    "916": "sector=E",
    "929": "generate 100s digit",
    "926": "BC=-100",
    "932": "BC=-10",
    "935": "generate 10s digit",
    "939": "\"0\", generate digit",
    "943": "insert units digit",
    "945": "A=-1",
    "954": "loop back until value in A",
    "966": "C=Drive letter",
    "967": "add character to message",
    "958": "move on if zero",
    "962": "form character",
    "963": "exit if none",
    "1260": "exit if A=0",
    "1261": "shift right",
    "1266": "back for more",
    "1270": "exit if A=0",
    "1272": "shift left",
    "1274": "back for more",
    "1279": "\"a\"",
    "1282": "\"z\"+1",
    "1285": "if lowercase, convert to uppercase",
    "1288": "16 drives, A: to P:",
    "1292": "get XDPB for drive",
    "1296": "jump if XDPB available",
    "1298": "increment drive letter",
    "1299": "back for more",
    "1301": "\"A\"",
    "1303": "Store default drive information",
    "1313": "get FCB & test if open",
    "1316": "exit if error",
    "1317": "test if open for read",
    "1318": "error \"file not open\"",
    "1321": "get FCB & test if open",
    "1324": "exit if error",
    "1325": "test if open for write",
    "1327": "error \"file not open\"",
    "1330": "get FCB & access mode",
    "1333": "exit if error",
    "1335": "bit 7 to carry",
    "1336": "return with success if open",
    "1337": "file not open error",
    "1340": "get FCB & access mode",
    "1343": "exit if error",
    "1345": "inverted bit 7 to carry",
    "1346": "file not open",
    "1348": "return with error if open",
    "1349": "save registers",
    "1362": "clear FCB",
    "1368": "save registers",
    "1370": "get file number",
    "1375": "if >$0f, exit with bad parameter error",
    "1377": "fcbs-$0038",
    "1388": "BC=address of FCB",
    "1393": "get access mode",
    "1394": "success",
    "1395": "restore registers",
    "1402": "save access mode",
    "1403": "signal \"not opened\"",
    "1407": "check if file opened in any other FCB",
    "1412": "restore access mode",
    "1417": "18 files to check",
    "1425": "D=file access mode",
    "1427": "A=file drive",
    "1432": "move on if file not open",
    "1441": "move on if different drive",
    "1444": "check if current file is open drive",
    "1449": "or file we are checking",
    "1451": "if not, check if files are the same",
    "1454": "if not, move on",
    "1461": "get access mode of current file",
    "1466": "H=1 if open shared",
    "1471": "Z set if legal access",
    "1472": "access denied error",
    "1483": "loop back to test more FCBs",
    "1487": "make drive uppercase",
    "1490": "ensure disk logged in",
    "1493": "exit if error",
    "1495": "first FCB",
    "1498": "18 files",
    "1510": "is it on same drive?",
    "1506": "skip if file not open",
    "1515": "ensure file header & directory up to date",
    "1519": "exit if error",
    "1526": "get to next FCB",
    "1528": "back for more",
    "1530": "success",
    "1533": "first FCB",
    "1536": "check 18 FCBs (16 user+2 system)",
    "1540": "A=drive",
    "1546": "is drive the same?",
    "1579": "BC=next FCB",
    "1547": "move on if not",
    "1550": "is a sector number in +$2b?",
    "1552": "move on if not",
    "1559": "check low byte of absolute sector",
    "1560": "move on if different",
    "1564": "check high byte of absolute sector",
    "1565": "move on if different",
    "1567": "ensure correct disk logged in",
    "1570": "if no error, get sector to buffer",
    "1581": "success",
    "1584": "exit if error",
    "1573": "if error, go to exit",
    "1586": "loop back for more FCBs",
    "1591": "clear FCB for file B (& ensure closed)",
    "1594": "parse filename to FCB,disallowing wildcards",
    "1597": "ensure correct disk logged in",
    "1602": "exit if error",
    "1609": "set access mode",
    "1610": "ensure file can be opened in this mode",
    "1616": "find first extent of file",
    "1620": "exit if error",
    "1621": "move on if not found",
    "1623": "check open action",
    "1627": "\"file exists\" error for open action 0",
    "1629": "move on for actions 2-4",
    "1640": "move on for actions 3 & 4",
    "1642": "find first entry (open action 2)",
    "1645": "open file, skipping any header",
    "1648": "mark file as open & exit",
    "1652": "move on for action 4",
    "1654": "for open action 3, erase any existing .BAK",
    "1657": "and rename file to .BAK",
    "1660": "go to follow create action",
    "1663": "bad parameter if not action 4",
    "1666": "for action 4, erase file then do create",
    "1670": "exit if error",
    "1675": "error \"file not found\" for create action 0",
    "1677": "move on for create action 2",
    "1679": "for action 1, create an entry",
    "1682": "and add a header",
    "1688": "\"bad parameter\" for create actions > 2",
    "1691": "for action 2, just create an entry",
    "1694": "exit if error",
    "1695": "A=0 if file was created",
    "1699": "exit if error",
    "1700": "A=$ff if file was opened",
    "1706": "mark FCB as containing an open file",
    "1708": "increment # open files on drive",
    "1719": "check bit 1 of FCB flags",
    "1720": "\"access denied\" error",
    "1722": "check disk can be written to",
    "1728": "set up clean extent",
    "1731": "exit if error",
    "1736": "signal \"directory valid\"",
    "1740": "find directory entry of required extent",
    "1743": "move on if not found",
    "1752": "exit with success if new entry not needed",
    "1753": "check file can be written to",
    "1756": "check disk can be written to",
    "1760": "error \"end of file\"",
    "1764": "exit unless finding first extent",
    "1765": "error \"file not found\"",
    "1777": "copy FCB to SYSFCB0",
    "1782": "sysfcb+9",
    "1788": "sysfcb+0a, set extension in SYSFCB0 to \"BAK\"",
    "1780": "\"B\"",
    "1785": "\"KA\"",
    "1795": "erase any existing .BAK file",
    "1799": "exit if success",
    "1803": "or with success if error was \"file not found\"",
    "1806": "make drive letter uppercase",
    "1809": "save letter",
    "1810": "& access mode",
    "1811": "clear FCB for file B (ensure closed)",
    "1814": "exit if error",
    "1817": "\"open drive\"",
    "1822": "access mode",
    "1824": "drive letter",
    "1826": "get XDPB for drive",
    "1829": "check can open in required access mode",
    "1832": "exit if error",
    "1853": "DE=\"file\" length (high bytes)",
    "1861": "set file length",
    "1863": "set file open & exit",
    "1866": "get FCB & see if open",
    "1869": "ensure correct disk logged in",
    "1872": "ensure file header & directory up-to-date",
    "1875": "exit if error",
    "1876": "go to abandon FCB",
    "1885": "exit with success if file not in write mode",
    "1886": "update any +3DOS header with file length",
    "1889": "get sector to buffer",
    "1892": "write all changed data on this disk",
    "1895": "ensure directory up to date for this file",
    "1899": "get FCB & see if open",
    "1902": "ensure correct disk logged in",
    "1905": "exit if error",
    "1912": "move on if not open in write mode",
    "1918": "move on if new directory entry not needed",
    "1920": "clear flag & increment free entries",
    "1923": "deallocate blocks in FCB",
    "1926": "move all inuse BCBs for file to free list",
    "1933": "signal \"file not open\"",
    "1935": "decrement files open on disk",
    "1938": "low-level logout disk if none left",
    "1941": "success",
    "1943": "\"PLUS3DOS\"&$1a&$01",
    "1960": "exit with success if file has no header",
    "1961": "get DEHL=file position",
    "1966": "update header with filelength",
    "1972": "restore file position",
    "1981": "set file position to header file length",
    "1990": "copy filelength from FCB to file header",
    "1993": "exit if error",
    "1995": "MSB of filelength is zero",
    "1998": "exit if error",
    "2005": "copy +3 BASIC header data from FCB to file",
    "2008": "exit if error",
    "2009": "update header checksum & exit",
    "2012": "get next byte",
    "2014": "copy byte into file",
    "2017": "exit if error",
    "2019": "back for more",
    "2024": "header signature",
    "2027": "copy header signature into file",
    "2033": "version 0",
    "2040": "fill rest of header with nulls",
    "2047": "set checksum & place filepointer after it",
    "2055": "set \"file has header\" flag",
    "2059": "check if valid header checksum",
    "2062": "move on if error",
    "2064": "if not, move on (no header)",
    "2066": "header signature length",
    "2068": "header signature",
    "2071": "get byte from file",
    "2074": "move on if error",
    "2078": "move on if doesn't match header signature",
    "2081": "back for more chars",
    "2083": "get version",
    "2086": "move on if error",
    "2090": "no header if higher version than 0",
    "2102": "copy filelength from header",
    "2107": "skip high byte of length",
    "2121": "copy +3 BASIC data from header",
    "2130": "set filepointer past header record",
    "2133": "exit, setting \"file has header\" flag",
    "2139": "error unless \"end of file\"",
    "2144": "set filepointer to start of file",
    "2150": "filerecs+1",
    "2154": "filerecs+2",
    "2160": "get last record+1 in file",
    "2171": "DEHL=2*filelength",
    "2164": "filerecs+1",
    "2168": "filerecs-1",
    "2179": "DEHL=filelength",
    "2183": "\"file too big\" error if >8M",
    "2191": "store filelength in FCB",
    "2202": "exit if filenames don't match",
    "2206": "get ADE=last record number+1",
    "2210": "test against largest found so far",
    "2217": "filerecs+2",
    "2221": "move on unless larger",
    "2228": "filerecs+2, set size from current extent",
    "2233": "success",
    "2251": "success",
    "2253": "E=required access mode",
    "2255": "get FCB & current access mode",
    "2258": "if ok, ensure correct disk logged in",
    "2261": "ensure file header & directory up-to-date",
    "2265": "exit if error",
    "2270": "get old access mode",
    "2271": "store new (as closed)",
    "2274": "check if can open in this mode",
    "2279": "if not, go to restore old mode & exit",
    "2283": "move on if not opening for write",
    "2285": "check file can be written to",
    "2288": "check disk can be written to",
    "2291": "exit, restoring mode, if error",
    "2293": "set file open",
    "2295": "success",
    "2297": "restore old mode",
    "2300": "make drive letter uppercase",
    "2303": "ensure allocation bitmap up-to-date",
    "2306": "exit if error",
    "2307": "move on to calculate free space",
    "2312": "move on to return current default user area",
    "2314": "check in range 0-15",
    "2319": "error 21 - bad parameter if not",
    "2321": "set default user area",
    "2324": "get default user area",
    "2327": "success",
    "2329": "make letter uppercase",
    "2334": "move on if current default drive required",
    "2337": "check drive has an XDPB",
    "2340": "exit with error if not",
    "2342": "set default drive",
    "2345": "get default drive",
    "2348": "success",
    "2353": "parse filespec, allowing wildcards",
    "2356": "ensure correct disk logged in",
    "2360": "check no source files open by any FCBs",
    "2363": "check disk can be written to",
    "2366": "exit if error",
    "2367": "routine to delete extents",
    "2376": "exit if entry doesn't match",
    "2380": "or if file read-only",
    "2384": "deallocate blocks in entry",
    "2389": "set \"deleted\" mark in FCB",
    "2391": "copy \"direntry\" to directory entry DE",
    "2395": "increment #free entries",
    "2399": "set \"success\" flag",
    "2403": "store attribs to set/clear",
    "2410": "parse filespec, allowing wildcards",
    "2413": "ensure correct disk logged in",
    "2416": "check disk can be written to",
    "2419": "exit if error",
    "2420": "routine to change attributes",
    "2429": "parse source filespec, ensuring no wildcards",
    "2432": "ensure correct disk logged in",
    "2440": "parse dest filespec, ensuring no wildcards",
    "2444": "exit if error",
    "2452": "check drives are the same",
    "2449": "sysfcb0+$21",
    "2455": "error \"cannot rename between drives\"",
    "2456": "check disk can be written to",
    "2463": "check dest file not open by any FCB",
    "2469": "check if dest file exists in directory",
    "2486": "exit if error",
    "2477": "file already exists error",
    "2473": "exit if error",
    "2488": "set \"no extents changed\"",
    "2491": "rename/delete all extents of file",
    "2498": "check if any extents changed",
    "2499": "file not found error",
    "2508": "exit if no match",
    "2510": "get attribs to set",
    "2513": "set mask",
    "2516": "set them",
    "2520": "get attribs to clear",
    "2523": "clear mask",
    "2524": "clear them",
    "2528": "go to update directory entry",
    "2530": "discard bit 7",
    "2534": "bits 6->3 on first four chars of filename",
    "2541": "bits 2->0 on extension",
    "2544": "move on if attribute not to be affected",
    "2546": "reset it",
    "2552": "set it if mask=$ff",
    "2555": "back for more",
    "2561": "exit if names don't match",
    "2565": "exit if file readonly",
    "2572": "also rename password control entries",
    "2582": "copy new filename to direntry",
    "2586": "copy \"direntry\" to directory entry DE",
    "2591": "if no error, set successful rename flag",
    "2595": "store buffer address",
    "2599": "store filter & buffer size",
    "2605": "store \"1 entry completed\"",
    "2611": "parse filespec to SYSFCB0, wildcards allowed",
    "2614": "ensure correct disk logged in",
    "2617": "flush drive",
    "2623": "generate catalog",
    "2626": "get B=#completed entries",
    "2632": "process the entry",
    "2637": "set A=$ff, set carry for success",
    "2642": "exit if doesn't match filespec",
    "2647": "move on if we should include system files",
    "2657": "exit if system file",
    "2662": "is it alphabetically less than preloaded?",
    "2666": "C=buffer size, B=#completed entries",
    "2674": "get to next entry in buffer",
    "2677": "decrement buffer size",
    "2678": "move on if more entries to check",
    "2680": "exit if no space left in buffer",
    "2681": "else move to add",
    "2683": "does filespec match next buffer entry?",
    "2686": "loop back if alphabetically greater",
    "2688": "move on if the same",
    "2697": "HL=#catalog buffer entries-1",
    "2704": "HL=13*(#catalog buffer entries-1)",
    "2709": "HL=address of last entry in catalog buffer",
    "2715": "BC=distance between last & current entries",
    "2722": "DE=address of end of catalog buffer",
    "2727": "shift catalog entries down one (may lose one)",
    "2737": "copy entry into buffer",
    "2742": "set zero size",
    "2750": "increment # completed entries (max=bufsize)",
    "2755": "calculate extent size in K",
    "2764": "add extent size into directory entry size",
    "2774": "11 chars to check",
    "2782": "compare chars without attribute bits",
    "2783": "if different, exit",
    "2787": "back for more",
    "2793": "parse filespec",
    "2796": "exit if error",
    "2805": "\"?\", check for wildcard characters",
    "2809": "exit with \"bad filename\" if found",
    "2811": "back for more",
    "2818": "set user area if specified",
    "2823": "set drive letter if specified",
    "2828": "check if char is digit",
    "2831": "exit if not",
    "2832": "save digit",
    "2833": "get next char",
    "2836": "check if its a digit",
    "2839": "if not, use single digit",
    "2841": "save ls digit",
    "2849": "E=user area",
    "2850": "get next char",
    "2856": "exit if invalid user area",
    "2857": "save user area in FCB",
    "2859": "get next char",
    "2862": "exit if none",
    "2866": "or if <\"A\"",
    "2869": "or if >\"P\"",
    "2867": "\"Q\"",
    "2863": "\"A\"",
    "2875": "save as drive letter in FCB",
    "2877": "get next char",
    "2882": "\"0\"",
    "2884": "error if <\"0\"",
    "2886": "set carry if user area",
    "2890": "parse filename",
    "2894": "error \"bad filename\"",
    "2905": "set drive as default",
    "2910": "set user area as default",
    "2911": "get next filename char",
    "2914": "move on if none",
    "2916": "save char",
    "2918": "\":\"",
    "2921": "if drive/user spec found, move on",
    "2923": "get next char",
    "2926": "back if found",
    "2929": "A=last drive/user char",
    "2930": "but skip if no drive/user spec",
    "2932": "set user area and/or drive in FCB",
    "2935": "exit if not found",
    "2936": "get char",
    "2942": "exit if not \":\"",
    "2940": "\":\"",
    "2943": "get char after \":\"",
    "2948": "if no filename, point to start",
    "2949": "with 11 chars to blank",
    "2954": "move to filename in FCB",
    "2957": "exit if first char is \".\"",
    "2960": "get up to 8 filename chars",
    "2964": "and up to 3 extension chars",
    "2970": "exit if no extension",
    "2971": "skip \".\" and get next char",
    "2974": "move on if none",
    "2982": "check if char legal",
    "2986": "if not, fill rest with spaces",
    "2989": "exit with error if filename too long",
    "2992": "fill rest with ? if \"*\" wildcard",
    "2990": "\"*\"",
    "2995": "else, store character",
    "2997": "get next",
    "3000": "loop back if more",
    "3002": "skip any spaces",
    "3008": "fill rest with spaces",
    "3012": "set carry (success)",
    "3014": "\"?\"",
    "3018": "exit if done",
    "3019": "fill",
    "3023": "get next char",
    "3026": "exit if end",
    "3027": "check for end of filename",
    "3030": "exit if not",
    "3031": "check if ended by space or $ff",
    "3034": "skip until $ff encountered",
    "3040": "exit if end of filename",
    "3041": "next character",
    "3042": "get next char",
    "3045": "exit if end of filename",
    "3046": "mask to ASCII code",
    "3048": "convert to uppercase",
    "3051": "space?",
    "3053": "set \"not $ff\"",
    "3055": "test against next illegal char",
    "3057": "exit if illegal",
    "3058": "get to next char in list",
    "3061": "move back for more",
    "3063": "clear carry & reset Z (character legal)",
    "3065": "\"!&()+,-./:;<=>[\\]|\"&$80",
    "3089": "get drive from FCB",
    "3091": "possibly re-log drive",
    "3094": "exit if error",
    "3100": "exit if disk logged in",
    "3104": "initialise allocation bitmap",
    "3107": "set \"collecting sector checksums\"",
    "3115": "set no free directory entries",
    "3118": "copy last dir entry number to ext XDPB info",
    "3127": "generate allocation bitmap & get free entries",
    "3133": "set last used directory entry number",
    "3139": "exit if error",
    "3140": "drive logged in",
    "3144": "just check sector checksums",
    "3156": "is entry unused?",
    "3158": "if so, inc #free directory entries & exit",
    "3161": "BC=directory entry number",
    "3163": "add to allocation bitmap",
    "3165": "add entry's blocks into bitmap",
    "3181": "is correct extent in FCB?",
    "3184": "exit if so",
    "3186": "ensure directory up to date for this file",
    "3190": "exit if error",
    "3196": "store low 5 bits of extent counter in FCB",
    "3199": "store high 8 bits of extent counter in FCB",
    "3204": "clear allocation list & records in extent",
    "3208": "find entry",
    "3211": "exit if success",
    "3216": "signal \"new extent required\"",
    "3220": "check if correct extent in FCB",
    "3223": "move on if not",
    "3231": "move on if new extent required",
    "3234": "else success",
    "3237": "ensure directory up to date for this file",
    "3242": "set up FCB with clean extent",
    "3246": "error \"end of file\"",
    "3250": "exit with error except new extent required",
    "3251": "get new directory entry",
    "3258": "get FCB flags",
    "3262": "exit with success if directory up to date",
    "3265": "move on if new entry flag set but not needed",
    "3270": "move on if need new entry",
    "3275": "search directory for correct extent",
    "3278": "exit if error",
    "3279": "extent missing error",
    "3282": "exit with error if extent not found",
    "3283": "update directory from FCB & exit",
    "3285": "get new directory entry number (DE)",
    "3288": "exit if error",
    "3292": "check if datestamps in use",
    "3295": "move on if not",
    "3299": "else zeroise date stamp",
    "3315": "copy directory entry from FCB to \"direntry\"",
    "3319": "copy \"direntry\" to directory entry DE",
    "3322": "write all changed buffers back on this disk",
    "3329": "flag \"directory up to date\"",
    "3334": "A=EXM extent mask",
    "3340": "B=low 5 bits of extent mask (inverted)",
    "3348": "L=high 8 bits of required extent counter",
    "3354": "H=low 5 bits of required extent counter",
    "3370": "A=high 8 bits of extent counter from FCB",
    "3372": "if not same, exit",
    "3376": "A=low 5 bits of extent counter from FCB",
    "3379": "if not same, exit",
    "3381": "signal \"correct extent\"",
    "3389": "find entry with correct extent counter",
    "3392": "exit if error",
    "3396": "error \"end of file\" if not found",
    "3403": "copy entry into FCB",
    "3412": "check user area",
    "3413": "and filename",
    "3416": "move on if no match",
    "3418": "get EX",
    "3420": "move on if don't care about extent",
    "3426": "B=inverse EXM",
    "3430": "move on if wrong extent",
    "3436": "get S2",
    "3439": "move on if don't care about extent",
    "3442": "exit with Z set if match",
    "3446": "mask off user area flag $20",
    "3451": "check if user areas match",
    "3455": "check if filenames match",
    "3466": "DE points to FCB's name",
    "3467": "HL points to directory entry's name",
    "3468": "11 bytes to check",
    "3473": "? matches anything",
    "3471": "\"?\"",
    "3475": "compare chars",
    "3476": "mask off attributes",
    "3478": "move on if no match",
    "3482": "loop back for more chars",
    "3486": "store subroutine address",
    "3489": "free buffers referencing directory sectors",
    "3492": "DE=first directory entry",
    "3497": "only get a sector every 16th entry",
    "3502": "get sector & get/set checksum",
    "3505": "exit if error",
    "3518": "calc offset of entry in sector",
    "3521": "copy entry to page 7",
    "3529": "call subroutine rt_dirent",
    "3534": "move on if error",
    "3536": "or if done",
    "3538": "increment dir entry number",
    "3541": "loop back if more",
    "3543": "HL points to last entry obtained",
    "3547": "drop original AF from stack",
    "3552": "stack routine address",
    "3553": "address of directory entry",
    "3556": "\"return\" to call routine",
    "3557": "increment",
    "3565": "test against last",
    "3571": "DE=logical usable record number",
    "3574": "DE=absolute logical sector number",
    "3577": "get AHL=page & address of buffer",
    "3580": "exit if error",
    "3582": "save buffer details",
    "3584": "get sector checksum & address to place",
    "3587": "skip reserved sectors",
    "3593": "move on if just checking",
    "3595": "save checksum",
    "3596": "set Z if checksum matches",
    "3597": "set success",
    "3598": "if checksums match, exit",
    "3600": "free buffers referencing unchanged sectors",
    "3605": "recoverable error 8 - disk changed",
    "3608": "exit if didn't recover",
    "3611": "else loop back to retry",
    "3613": "restore buffer address to AHL",
    "3614": "but don't overwrite an error code",
    "3623": "save low byte of directory entry number",
    "3626": "DE=directory record number",
    "3629": "get DE=absolute logical sector",
    "3633": "dummy FCB address",
    "3636": "get buffer to AHL, and flag changed",
    "3640": "exit if error",
    "3642": "save buffer page",
    "3649": "get address of directory entry",
    "3655": "copy \"direntry\" into directory",
    "3663": "calculate sector checksum",
    "3668": "update checksum vector",
    "3674": "16 entries per sector",
    "3695": "HL=abs logical sector",
    "3704": "DE=#directory records",
    "3713": "test logical sector",
    "3710": "DE=first non-directory sector",
    "3718": "exit if not after directory",
    "3721": "page in bank containing buffer",
    "3729": "A=8-bit checksum of sector",
    "3736": "save checksum",
    "3738": "page back original bank",
    "3744": "HL=address of checksum table",
    "3747": "+abs logical sector",
    "3752": "DE=first non-reserved sector",
    "3756": "HL=address of sector checksum",
    "3761": "restore checksum",
    "3769": "get read-only bit",
    "3770": "move to carry",
    "3773": "carry is inverse of read-only bit",
    "3774": "\"read-only file\" error",
    "3777": "get HL=allocation bitmap, DE=last block #",
    "3787": "zero allocation for 8 blocks",
    "3785": "DE=(last block #)/8+1",
    "3793": "loop back for more",
    "3796": "store directory bitmaps",
    "3811": "DE=block/8",
    "3815": "get HL=address of allocation bitmap",
    "3819": "HL points to correct allocation byte",
    "3824": "B=bit within byte",
    "3831": "B=bitmask",
    "3833": "C=bit if allocating, 0 if deallocating",
    "3838": "update bit in allocation bitmap",
    "3844": "get HL=allocation bitmap & DE=last block",
    "3847": "bit counter & mask",
    "3850": "get byte from allocation bitmap",
    "3852": "move on if found free block",
    "3854": "shift bit mask",
    "3860": "move on if no blocks left",
    "3863": "loop back for more blocks in allocation byte",
    "3866": "back for more allocation bytes",
    "3870": "allocate this block",
    "3880": "calculate DE=allocated block",
    "3887": "signal directory contains valid FCB data",
    "3893": "HL=FCB address",
    "3895": "deallocate",
    "3896": "save BC",
    "3897": "C=allocate/deallocate flag",
    "3901": "exit if not a file entry",
    "3906": "HL points to allocation list",
    "3907": "16 allocation entries to consider",
    "3910": "go to start loop",
    "3912": "E=next allocation entry",
    "3914": "more than 256 blocks on disk?",
    "3918": "DE=block number if 8-bit block numbers",
    "3922": "DE=16-bit block number",
    "3926": "move on if allocation entry null",
    "3936": "test against last block number",
    "3937": "if in range, allocate/deallocate block",
    "3941": "loop back",
    "3946": "Subroutine to calculate extent size in K (to HL)",
    "3949": "test user area",
    "3951": "zero blocks so far",
    "3954": "skip calculation if password entry",
    "3959": "point to allocation list",
    "3960": "D=#bytes to test,E=#blocks found",
    "3966": "more than 255 blocks?",
    "3967": "get block number",
    "3969": "if not move on",
    "3971": "else incorporate 2nd byte",
    "3972": "and move over",
    "3977": "increment #blocks if not null",
    "3979": "loop back for rest of allocation list",
    "3981": "HL=#blocks, to be converted to K next",
    "3983": "get block size",
    "3989": "move on when HL=size in K",
    "3991": "double it",
    "3992": "loop back",
    "3995": "set Z if HL=0",
    "3996": "success",
    "3998": "0 free blocks so far",
    "4001": "stack it",
    "4002": "HL=alloc bitmap, DE=last block number",
    "4005": "bit count & mask",
    "4009": "check if block free",
    "4013": "increment #free if so",
    "4015": "shift bit mask",
    "4019": "move on if no more blocks",
    "4022": "loop back for rest of allocation byte",
    "4025": "loop back",
    "4027": "HL=#free blocks",
    "4028": "convert blocks to K & exit",
    "4033": "HL=address of allocation bitmap",
    "4039": "DE=last block number",
    "4051": "error \"directory full\" if no new entries",
    "4056": "new directory entry needed",
    "4058": "extent now created",
    "4063": "decrement #free directory entries",
    "4079": "BC=last used directory entry number",
    "4082": "set last used=last entry",
    "4088": "find first unused entry",
    "4091": "exit if error",
    "4101": "reset \"new directory entry\" flag",
    "4107": "if no free entry found, cause error",
    "4115": "move on if entry lower than last used",
    "4118": "else last used=this entry",
    "4122": "set last used entry",
    "4125": "success",
    "4128": "re-increment free directory entries",
    "4131": "\"extent missing\" error",
    "4137": "set Z if free",
    "4139": "success",
    "4146": "we don't need a new entry",
    "4149": "success",
    "4150": "increment # free directory entries",
    "4169": "generate HL=address of last entry in record",
    "4174": "check if datestamp entry",
    "4176": "exit if not",
    "4191": "get FCB",
    "4194": "exit if error",
    "4195": "offset for file position",
    "4198": "move on",
    "4200": "get FCB",
    "4203": "exit if error",
    "4204": "offset for EOF",
    "4215": "DEHL=file position/EOF",
    "4217": "success",
    "4219": "get FCB",
    "4222": "exit if error",
    "4225": "DEA=new filepos",
    "4241": "HL=address of filepos in FCB",
    "4230": "move on",
    "4229": "HL=address of filepos in FCB",
    "4242": "add in A",
    "4250": "move HL back to start of filepos",
    "4252": "save registers",
    "4266": "skip next bit if record unchanged",
    "4272": "flag \"record changed\"",
    "4280": "set new filepointer",
    "4281": "success",
    "4289": "DE points to filelength-1",
    "4293": "HL points to filepointer-1",
    "4300": "compare filepointer with filelength",
    "4303": "exit if filepointer within current file",
    "4308": "make filelength=filepointer",
    "4349": "increment filepointer by $80",
    "4358": "DE=address of record",
    "4361": "C=page of buffer",
    "4374": "copy record from buffer",
    "4378": "update address to read to",
    "4387": "subtract $7f from bytes to read",
    "4383": "-#7F",
    "4389": "set Z if done",
    "4390": "subtract further byte",
    "4391": "success",
    "4393": "get FCB & test if open for reading",
    "4396": "exit if error",
    "4401": "DE=filepointer address",
    "4405": "HL=filelength address",
    "4410": "test filepointer (carry must be set",
    "4411": "if pointer within file)",
    "4417": "error \"end of file\"",
    "4419": "get a byte if within file",
    "4422": "exit if error",
    "4423": "C=byte read",
    "4424": "set Z if soft-EOF",
    "4426": "success",
    "4434": "has record been changed?",
    "4438": "if so, get new record details into FCB",
    "4441": "exit if error",
    "4447": "low byte of filepointer",
    "4448": "offset into record",
    "4459": "DE=address of byte in buffer",
    "4461": "A=bank of buffer",
    "4463": "page in buffer bank",
    "4466": "get byte",
    "4467": "page back original bank",
    "4471": "increment filepointer",
    "4474": "A=byte",
    "4475": "success",
    "4480": "store bank & address to write from",
    "4486": "test file B open for writing",
    "4489": "exit if error",
    "4490": "calculate final address",
    "4492": "do the write",
    "4495": "ensure filelength includes filepointer",
    "4499": "exit if successful",
    "4508": "DE=bytes unwritten",
    "4519": "move on if filepointer on record boundary",
    "4521": "write a byte",
    "4537": "exit if error",
    "4524": "exit if error",
    "4525": "exit if finished",
    "4526": "loop back",
    "4532": "move on if don't need to write full record",
    "4534": "write a record",
    "4528": "-#7F",
    "4538": "exit if finished",
    "4539": "loop back",
    "4541": "write a byte",
    "4544": "exit if error",
    "4545": "exit if finished",
    "4546": "loop back",
    "4548": "get bank & address",
    "4554": "page in bank",
    "4557": "get byte",
    "4558": "page back original bank",
    "4562": "write the byte",
    "4565": "exit if error",
    "4570": "update address to write from",
    "4574": "test if finished",
    "4575": "decrement bytes to write",
    "4579": "get record to buffer at AHL",
    "4583": "exit if error",
    "4588": "signal \"current record changed\"",
    "4591": "increment filepointer by $80",
    "4603": "get B=bank, DE=address of buffer",
    "4615": "copy record to buffer",
    "4619": "update address to write from",
    "4627": "subtract $7f from bytes to read",
    "4629": "set Z if finished",
    "4630": "subtract further byte",
    "4634": "check file open for writing",
    "4637": "exit if not",
    "4639": "write byte A at filepointer",
    "4642": "ensure filelength includes filepointer",
    "4648": "save byte in E",
    "4655": "move on if FCB contains valid record details",
    "4659": "get record to buffer",
    "4664": "exit if error",
    "4666": "signal \"record changed\"",
    "4673": "A=offset into current record",
    "4685": "DE=address in file",
    "4687": "A=bank of file",
    "4690": "page in file bank",
    "4693": "store byte at filepointer",
    "4694": "page back original bank",
    "4697": "increment filepointer",
    "4703": "get stored & calculated checksum",
    "4706": "exit if error",
    "4708": "set Z if they match",
    "4709": "success",
    "4711": "get header checksums",
    "4714": "exit if error",
    "4715": "page in bank file bank",
    "4718": "store calculated header checksum",
    "4719": "page back original bank",
    "4722": "increment filepointer past header",
    "4725": "ensure filelength includes filepointer",
    "4732": "set position to file start",
    "4741": "move on if valid record details in FCB",
    "4743": "get record to buffer and update FCB",
    "4746": "exit if error",
    "4753": "DE=address of file start",
    "4755": "A=bank of file",
    "4758": "page in file bank",
    "4762": "zero checksum",
    "4765": "form checksum",
    "4768": "back for more bytes in header",
    "4770": "E=calculated checksum",
    "4771": "D=checksum stored in file header",
    "4773": "page back original bank",
    "4783": "HL points to flags of FCB",
    "4786": "move on if sector already in buffer",
    "4790": "or if current record not changed",
    "4800": "DE=logical sector",
    "4801": "get AHL=buffer address (flag changed)",
    "4806": "move on if error",
    "4809": "reset bits 3,4 & 5",
    "4812": "success",
    "4816": "test for \"drive open as file\"",
    "4818": "routine to use for normal file",
    "4823": "routine to use for drive",
    "4829": "get new extent if required",
    "4833": "get record address & sector number",
    "4836": "exit if error",
    "4840": "get DE=record number from FCB",
    "4843": "check in current extent",
    "4846": "if so, set FCBs extent counter & #records",
    "4854": "find extent HL for file",
    "4858": "if found, get address of record ",
    "4863": "test for \"drive open as file\"",
    "4865": "routine to use for normal file",
    "4870": "routine to use for drive",
    "4873": "DE=record number for filepointer",
    "4876": "exit if file too big",
    "4885": "move on if no sector currently in buffer",
    "4889": "get record number from FCB",
    "4897": "move on if record numbers match",
    "4899": "ensure correct disk logged in",
    "4902": "get sector in FCB to buffer",
    "4905": "exit if error",
    "4915": "DE=record number required",
    "4918": "call routine in HL",
    "4921": "exit if error",
    "4929": "store abs logical sector number",
    "4934": "store address of record",
    "4936": "store bank for buffer",
    "4942": "set bit 3 (valid sector) & bit 5",
    "4944": "(valid filepointer)",
    "4961": "HL points to filepointer",
    "4967": "HLA=filepointer",
    "4969": "double filepointer",
    "4971": "DE=record number",
    "4972": "successful if no carry",
    "4973": "error \"file too big\"",
    "4978": "get block & offset",
    "4984": "move on if not end-of-file",
    "4986": "allocate a new block",
    "4989": "move on if error",
    "4991": "insert block in allocation list",
    "5000": "HL=block number",
    "5007": "if first record in a sector, check in extent",
    "5010": "Z set if record newly created",
    "5013": "get abs logical sector & offset",
    "5017": "get sector to buffer",
    "5020": "exit, getting required record to AHL",
    "5022": "if created, don't read sector",
    "5025": "get sector, reading if necessary",
    "5029": "get block & offset",
    "5035": "check record is in this extent",
    "5039": "calculate sector & offset",
    "5042": "stack offset into sector",
    "5043": "get AHL=address of sector DE",
    "5047": "stack sector, restore offset",
    "5049": "now AHL=address of record",
    "5051": "restore sector",
    "5061": "DE=logical usable record",
    "5064": "DE=abs logical sector of block start",
    "5068": "save high byte of offset",
    "5073": "HL=offset into sector",
    "5075": "A=#sectors offset",
    "5080": "DE=abs logical sector",
    "5085": "HL=FCB",
    "5090": "A=record within block",
    "5096": "BC=byte offset within block",
    "5103": "DE=block number (low byte)",
    "5110": "move on if <256 blocks on disk with A=block",
    "5118": "for 256+ blocks, each uses 2 bytes in list",
    "5119": "D=high byte of actual block number",
    "5120": "HL points to low byte",
    "5128": "for <256 blocks, each uses 1 byte in list",
    "5129": "now, DE=block number on disk",
    "5134": "if 0, exit with \"end of file\" error",
    "5136": "HL=block number",
    "5137": "success",
    "5151": "set number of records in extent",
    "5161": "set extent counter (low 5 bits)",
    "5166": "directory contains valid copy of FCB data",
    "5173": "find last record number in extent",
    "5179": "\"file too big\" error",
    "5182": "check record is in this extent",
    "5184": "\"end of file\" error if not",
    "5226": "A=#records in this extent",
    "5227": "DE=last record in extent+1",
    "5238": "HL=offset of record into sector",
    "5242": "DE=absolute logical sector",
    "5263": "DE=max sector on disk",
    "5267": "no carry (error) if sector > max",
    "5271": "error \"end of file\"",
    "5276": "get the values",
    "5281": "clear current cache",
    "5284": "exit if error",
    "5288": "clear last in-use BCB address",
    "5291": "clear last free BCB address",
    "5295": "set first buffer=D, no buffers yet",
    "5298": "address for first BCB",
    "5302": "max 16 buffers required",
    "5304": "first buffer in bank 7",
    "5309": "move on",
    "5313": "exit if created all required BCBs",
    "5318": "increment # buffers",
    "5320": "increment buffer number",
    "5321": "decrement buffers left to create",
    "5322": "get address & bank of buffer D",
    "5328": "store buffer address",
    "5331": "and bank",
    "5340": "store add of previous BCB",
    "5343": "current BCB is now last",
    "5351": "address of next BCB",
    "5354": "back for more",
    "5356": "success",
    "5358": "last in-use buffer address",
    "5362": "get next in-use BCB",
    "5368": "fail with error \"uncached\" if none",
    "5375": "is buffer from current drive?",
    "5378": "move on if not",
    "5383": "HL=abs logical sector in buffer",
    "5389": "loop back if not required buffer",
    "5391": "success",
    "5393": "get last free BCB",
    "5396": "move on if got one",
    "5398": "address of in-use BCB chain",
    "5402": "get next in-use BCB",
    "5408": "\"uncached\" error if no more inuse BCBs",
    "5409": "is this last BCB in chain?",
    "5412": "loop back if not",
    "5414": "get sector for BCB to memory",
    "5417": "write back data from this buffer if required",
    "5420": "exit if error",
    "5421": "move BCB to the free chain",
    "5430": "no data changed",
    "5434": "no file owner",
    "5439": "drive",
    "5443": "absolute logical sector",
    "5445": "success",
    "5462": "D=drive letter, HL=abs logical sector",
    "5463": "get sector to buffer, updating FCBs",
    "5476": "move on if RAMdisk",
    "5482": "BC=abs logical sector",
    "5483": "check if sector held in a buffer",
    "5486": "move on if so",
    "5488": "get a new buffer for it",
    "5491": "if no error, read the sector to the buffer",
    "5494": "move on",
    "5500": "move on if RAMdisk",
    "5506": "BC=abs logical sector",
    "5507": "check if sector held in a buffer",
    "5510": "get a new buffer if not",
    "5514": "if no error, move BCB to top of in-use chain",
    "5518": "go to return buffer address as AHL",
    "5524": "move on if RAMdisk",
    "5532": "find buffer holding logical sector",
    "5536": "move on if error",
    "5543": "flag \"data changed\"",
    "5548": "store FCB address of file using buffer",
    "5550": "successful so far",
    "5551": "move on if error",
    "5561": "A=buffer bank",
    "5562": "HL=buffer address",
    "5563": "success",
    "5567": "has drive been recently accessed?",
    "5570": "exit if so",
    "5580": "DE=#directory entries",
    "5583": "DE=#directory records (32 bytes per entry)",
    "5589": "DE=last absolute directory sector",
    "5595": "max abs sector number",
    "5599": "BC=absolute sector number",
    "5600": "DE=last inuse buffer address",
    "5604": "get next inuse buffer",
    "5607": "move on if no more in-use buffers",
    "5618": "move on if buffer isn't on same drive",
    "5626": "move on if larger sector than required",
    "5628": "get sector for BCB into memory",
    "5638": "move on if buffer contains changed data",
    "5642": "else move buffer to free chain",
    "5646": "back for more",
    "5649": "back for more",
    "5654": "last in-use BCB address",
    "5658": "get next BCB",
    "5661": "exit if no more",
    "5673": "move on if buffer not for current drive",
    "5676": "move BCB from in-use chain to free chain",
    "5680": "loop back for more",
    "5685": "last in-use BCB address",
    "5689": "get next BCB",
    "5692": "exit if no more",
    "5702": "HL=FCB of file for current buffer",
    "5707": "loop back if not current file",
    "5710": "move BCB from in-use chain to free chain",
    "5714": "loop back",
    "5727": "test flags",
    "5730": "exit if no changed data in buffer",
    "5735": "A=drive letter for buffer",
    "5736": "get IX=XDPB",
    "5739": "write data back for all changed buffers",
    "5742": "on this disk",
    "5748": "last in-use BCB address",
    "5752": "get address of previous in-use BCB",
    "5755": "exit if none",
    "5757": "release cache buffer",
    "5760": "loop back if no error",
    "5771": "max absolute logical sector number",
    "5774": "get a smaller one",
    "5777": "exit if none left",
    "5780": "get a smaller one",
    "5783": "move on if smallest found",
    "5786": "loop back",
    "5789": "write buffer to disk",
    "5792": "loop back if no error",
    "5809": "loop back if no data to write",
    "5802": "exit if none with Z set",
    "5799": "get address of previous BCB",
    "5814": "get drive letter for this buffer",
    "5815": "same as buffer we're freeing?",
    "5818": "back if not",
    "5824": "HL=absolute logical sector",
    "5829": "if same, move on",
    "5831": "if larger, loop back",
    "5833": "BC=smaller absolute logical sector",
    "5836": "exit with Z reset",
    "5839": "get buffer & sector details",
    "5842": "write the sector",
    "5846": "exit if error",
    "5851": "signal \"buffer doesnt contain unwritten data\"",
    "5857": "set null FCB using this buffer",
    "5858": "success",
    "5863": "get buffer & sector details",
    "5866": "read the sector",
    "5877": "B=buffer bank",
    "5882": "stack buffer address",
    "5886": "DE=absolute logical sector number",
    "5887": "get D=logical track, E=logical sector",
    "5890": "HL=buffer address",
    "5892": "address of last free BCB",
    "5897": "DE=BCB address",
    "5900": "set Z if null",
    "5901": "success",
    "5910": "remove current BCB from chain",
    "5916": "go to insert into free chain",
    "5918": "remove current BCB from chain",
    "5921": "address of in-use chain",
    "5924": "store start of chain into current BCB",
    "5931": "store address of current BCB at list address",
    "5943": "\"A\"",
    "5945": "unit 0 is drive A:",
    "5957": "copy extended XDPB info for A:",
    "5951": "xdpb_a+$1b",
    "5962": "set pointer to A:'s XDPB",
    "5968": "xdpb_b+$1b",
    "5974": "copy extended XDPB info for B: ",
    "5982": "B: should be unit 1 or disabled",
    "5995": "exit via DOS_MAP_B",
    "5998": "flags,drive,unit",
    "6001": "last access,filesopen",
    "6005": "#free direntries,lastused",
    "6009": "checksum vector,alloc bitmap",
    "6013": "login disk",
    "6015": "read sector",
    "6017": "write sector",
    "6019": "flags,drive,unit",
    "6022": "last access,filesopen",
    "6026": "#free direntries,lastused",
    "6030": "no checksum;alloc bitmap",
    "6034": "login disk",
    "6036": "read sector",
    "6038": "write sector",
    "6044": "xdpb_m+$1b",
    "6050": "copy extended XDPB info for M:",
    "6059": "setup RAMdisk & exit",
    "6062": "flags,drive,unit",
    "6065": "last access,filesopen",
    "6069": "#free direntries,lastused",
    "6073": "no checksum;alloc bitmap",
    "6077": "login disk",
    "6079": "read sector",
    "6081": "write sector",
    "6083": "success",
    "6085": "ensure drive letter uppercase",
    "6093": "error if <A",
    "6097": "error if >P",
    "6107": "HL=xdpb_ptrs+2*drive",
    "6110": "get address of XDPB for drive (or 0)",
    "6113": "IX points to XDPB",
    "6117": "set carry unless no XDPB (success)",
    "6119": "restore HL",
    "6120": "error 22 - drive not found if error",
    "6123": "error 21 - bad parameter",
    "6127": "get XDPB for drive",
    "6130": "exit if none",
    "6134": "possibly logout disk",
    "6142": "if disk logged out, try to log another in",
    "6149": "get freeze flag",
    "6153": "exit if auto-detect not required",
    "6154": "do a low-level login & exit",
    "6161": "exit if drive not logged in",
    "6166": "exit if files open on drive",
    "6170": "exit if accessed within last 2secs, or fixed",
    "6171": "# files open on drive",
    "6175": "drive in use error if so",
    "6178": "flag drive logged out",
    "6182": "move all BCBs for this drive to free list",
    "6190": "exit if drive is fixed",
    "6194": "get interrupt status",
    "6197": "get HLA=FRAMES",
    "6206": "re-enable interrupts if necessary",
    "6207": "HLB=current FRAMES",
    "6214": "DEA=last access FRAMES",
    "6221": "DEA=last access FRAMES + 2secs",
    "6227": "save carry (set if accessed within last 2s)",
    "6231": "get interrupt status",
    "6235": "update last access time to current FRAMES",
    "6251": "re-enable interrupts if necessary",
    "6256": "done",
    "6272": "exit with success if not floppy drive",
    "6273": "change disk if necessary",
    "6276": "DD_TEST_UNSUITABLE",
    "6279": "exit if error",
    "6280": "DD_DRIVE_STATUS",
    "6286": "exit if not present",
    "6291": "error if disk write-protected",
    "6292": "success",
    "6299": "BC=# reserved tracks",
    "6306": "DE=# records per track",
    "6322": "DE=origHL+#reserved records",
    "6340": "BC=logical track counter",
    "6337": "DE=records per track",
    "6347": "loop until found correct track in BC",
    "6350": "DE=logical sector number on track",
    "6351": "D=logical track, E=logical sector",
    "6359": "HL=routine address to login a disk",
    "6362": "track 0, sector 0",
    "6365": "move on to perform operation",
    "6371": "HL=routine address to read a sector",
    "6380": "HL=routine address to write a sector",
    "6383": "store ready to call",
    "6390": "call routine to write a sector",
    "6396": "exit if no error",
    "6397": "retry message",
    "6400": "loop back to retry",
    "6403": "save HL",
    "6404": "stack routine address",
    "6407": "stack address & restore HL",
    "6408": "return to call routine",
    "6416": "exit if drive not mapped to unit 0",
    "6424": "exit if unit 0 is currently mapped to drive",
    "6427": "change unit 0 mapping to this drive",
    "6432": "ask user to change disk",
    "6443": "generate change disk message",
    "6451": "stack change disk routine address",
    "6452": "exit to routine",
    "6457": "log out from drive B:",
    "6460": "exit, if error",
    "6465": "no change-disk routine if B: is unit 1",
    "6468": "get old routine address",
    "6472": "store new routine address",
    "6479": "set unit number",
    "6482": "DD_INTERFACE",
    "6485": "move on if no interface",
    "6490": "for unit 1 only, test if present",
    "6493": "if not, no drive B:",
    "6501": "exit with HL=old change-disk routine",
    "6495": "set unit number to 0",
    "6524": "check if disk change required",
    "6527": "DD_READ_SECTOR",
    "6530": "check if disk change required",
    "6536": "check if disk change required",
    "6533": "DD_WRITE_SECTOR",
    "6539": "DD_LOGIN",
    "6542": "exit if error",
    "6548": "\"unrecognised disk format\"",
    "6550": "error if sectorsize <> 512",
    "6560": "error if alloc vector size/2 >$2d",
    "6575": "success if chksum size <= $40",
    "6587": "else set chksum size to $40",
    "6593": "save page & address to read to",
    "6599": "test if file B open for reading",
    "6602": "exit if not",
    "6603": "calculate final address",
    "6605": "do the read",
    "6609": "exit if successful",
    "6611": "get current address",
    "6618": "DE=unread bytes",
    "6631": "get BDE=file length",
    "6644": "AHL=filelength available to read",
    "6647": "exit if none",
    "6649": "DE=#bytes to read-1",
    "6655": "if enough bytes in file, move on",
    "6658": "else read what's available",
    "6661": "exit if error",
    "6662": "\"end of file\" error",
    "6847": "get unit number",
    "6851": "go in, if no unit number set",
    "6853": "log out from disk",
    "6856": "exit if error",
    "6867": "copy disk specification",
    "7285": "set up parameter block",
    "7288": "the operation to try",
    "7291": "go to try it",
    "7293": "address of parameter block",
    "7296": "do a DD_L_READ",
    "7121": "flags",
    "7124": "read data command",
    "7126": "set up parameter block",
    "7128": "flags",
    "7131": "mask off deleted address mark bit",
    "7133": "write data command",
    "7135": "setup basic parameter block data",
    "7142": "E=physical sector number",
    "7143": "save physical track & sector numbers",
    "7149": "call encode routine if required",
    "7153": "ddl_parms+$0a, store 1st sector ID",
    "7160": "ddl_parms+$0b, store sector size & last(=1st) sector ID",
    "7166": "ddl_parms+$0d, store gap length",
    "7171": "ddl_parms+8, store track & side numbers",
    "7176": "ddl_parms+5, store # command bytes",
    "7179": "ddl_parms+$0e",
    "7182": "store dummy data length",
    "7186": "ddl_parms+1, store buffer address",
    "7191": "store buffer page",
    "7194": "C=physical side & unit byte",
    "7198": "ddl_parms+6, store command & unit byte",
    "7207": "ddl_parms+3, store sector size as # bytes to transfer",
    "7214": "A=sidedness",
    "7216": "side 0",
    "7218": "exit if single-sided (physical=logical)",
    "7220": "move on if double-sided: successive sides",
    "7223": "for alternate sides, halve track",
    "7226": "with side=remainder",
    "7228": "move on to OR into unit number",
    "7231": "subtract # tracks",
    "7234": "if < # tracks, physical=logical so move on",
    "7236": "on successive side, tracks count back down",
    "7241": "and use side 1",
    "7246": "update unit number with side bit",
    "7249": "move on if routine supplied",
    "7251": "disable",
    "7254": "get old encode routine address",
    "7258": "store new encode routine address",
    "7261": "HL=old routine",
    "7264": "setup parameter block for sector read",
    "7271": "ddl_parms+3, store #bytes required from sector",
    "7274": "the operation to try",
    "7277": "go to try it",
    "7279": "address of parameter block",
    "7282": "read bytes and exit",
    "7299": "test if suitable XDPB",
    "7302": "exit if error",
    "7303": "set up parameter block",
    "7306": "move on",
    "7308": "set up parameter block",
    "7311": "scan the data",
    "7314": "exit if error",
    "7315": "fdc_res+3, get ST2",
    "7318": "set Z if scan was equal",
    "7320": "success",
    "7110": "flags",
    "7113": "scan equal command",
    "7115": "set up parameter block",
    "7118": "store data length 1",
    "7322": "test if suitable XDPB",
    "7325": "exit if not",
    "7326": "setup parameter block",
    "7329": "the operation to try",
    "7332": "go to try it",
    "7334": "address of parameter block",
    "7337": "do a DD_L_WRITE",
    "7081": "A=modulation mode",
    "7083": "format command",
    "7085": "set up parameter block as for read/write etc",
    "7094": "ddl_parms+8, store sector size & #sectors per track",
    "7106": "ddl_parms+5, store # of command bytes",
    "7101": "ddl_parms+$0a, store format gap length & filler byte",
    "7340": "read a sector ID",
    "7343": "get results buffer address",
    "7346": "exit if error",
    "7347": "fdc_res+6, get sector number",
    "7351": "convert logical track to physical",
    "7354": "the operation to try",
    "7357": "go to do it",
    "7359": "get modulation mode",
    "7362": "read sector ID & exit",
    "7365": "turn on motor",
    "7368": "try the operation multiple times",
    "7371": "start motor off timeout & exit",
    "7374": "Type 0 - Spectrum +3 format",
    "7384": "Type 1 - CPC system format",
    "7394": "Type 2 - CPC data format",
    "7404": "Type 3 - PCW format",
    "7415": "get IX=XDPB of +3 format disk",
    "7421": "if no error, read a sector ID on track 0",
    "7425": "exit if error",
    "7428": "CPC system format if IDs ~$40",
    "7434": "CPC data format if IDs ~$c0",
    "7437": "otherwise, +3 or PCW format",
    "7440": "get IX=XDPB of CPC format disks",
    "7443": "move on",
    "7446": "ddl_parms+$0f, buffer for disk spec",
    "7449": "track 0, sector 0",
    "7452": "use page 7",
    "7454": "10 bytes required (disk spec)",
    "7457": "read disk spec from boot sector",
    "7462": "move on if no error",
    "7468": "exit with errors except disk changed",
    "7469": "substitute \"unrecognised disk format\"",
    "7476": "check 10 bytes of specifier",
    "7481": "if any differ, use this as disk spec",
    "7485": "use +3 format if all bytes the same",
    "7490": "test format type",
    "7492": "signal unrecognised disk format",
    "7494": "initialise XDPB if no error",
    "7499": "if no errors, update drive equipment & ",
    "7502": "check suitable for disk",
    "7506": "test format type",
    "7510": "error 6 if not type 0-3",
    "7513": "E=2*type",
    "7516": "A=10*type",
    "7523": "HL=address of info for type",
    "7524": "save info address",
    "7526": "get format type",
    "7527": "first sector number for CPC system",
    "7532": "first sector number for CPC data",
    "7537": "first sector number for +3/PCW",
    "7539": "set first sector number",
    "7544": "set sidedness & single/double track",
    "7549": "set # tracks",
    "7554": "set # sectors",
    "7558": "B=sector size (0..2)",
    "7564": "set gap length (r/w)",
    "7569": "set gap length (format)",
    "7575": "HL=128x2^B",
    "7581": "set sector size (bytes)",
    "7584": "set multitrack,modulation flags",
    "7588": "restore registers",
    "7590": "save registers",
    "7598": "set PSH=log2(sectorsize/128)",
    "7605": "set PHM=(sectorsize/128)-1",
    "7613": "HL=(#sectors)x(records per sector)",
    "7619": "set SPT (records per track)",
    "7627": "set BSH=log2(blocksize/128)",
    "7630": "save it",
    "7635": "set BLM=(blocksize/128)-1",
    "7640": "set OFF (#reserved tracks)",
    "7649": "B=#sectors",
    "7651": "D=#tracks",
    "7653": "A=sidedness",
    "7655": "HL=tracks per side",
    "7657": "DE=reserved tracks",
    "7662": "HL=total tracks on disk",
    "7665": "DE=total tracks-reserved tracks",
    "7670": "HL=total non-reserved sectors",
    "7677": "HL=total non-reserved blocks",
    "7684": "set DSM (last block number)",
    "7693": "B=3, or 4 if >256 blocks",
    "7694": "A=log2(blocksize/128)",
    "7695": "A=log2(bs/2^7)-log2(2^B)=log2(bs/2^(B+7))",
    "7696": "A=(bs/2^(B+7))-1",
    "7699": "set EXM (extent mask)",
    "7703": "save DSM",
    "7710": "HL=Floor(DSM/4)+2=ALS (allocation vector size)",
    "7711": "save ALS and retrieve DSM",
    "7713": "A=#dir blocks",
    "7715": "move on unless need to calculate it",
    "7734": "HL=2^16-2^(16-#dir blocks)",
    "7736": "set AL0 directory bitmap",
    "7739": "set AL1 directory bitmap",
    "7744": "HL=#dirblocks",
    "7745": "B=log2(blocksize/128)",
    "7747": "B=log2(bs/128)+log2(4)=log2(bs/32)",
    "7752": "HL=(#dirblocks*bs/32)-1=DRM",
    "7756": "set DRM (last directory entry number)",
    "7764": "HL=((DRM+1)/4)+1=CKS",
    "7768": "set CKS (checksum vector size)",
    "7773": "HL=4*(DRM+1) (hash table size)",
    "7774": "DE=ALS (2bit allocation vector size)",
    "7776": "A=format type",
    "7777": "signal success",
    "7778": "restore BC",
    "7783": "test drive equipment, updating if necessary",
    "7788": "exit if error",
    "7794": "move on if disk is single-sided",
    "7798": "error 9 if drive single-sided",
    "7806": "exit with success if disk not double-track",
    "7809": "or if drive double-track",
    "7810": "error 9 - unsuitable media for drive",
    "7814": "get equipment address",
    "7818": "check if single/double track drive",
    "7820": "move on if not known",
    "7823": "check if single/double sided drive",
    "7826": "exit with success if known",
    "7830": "check # sides for disk",
    "7833": "exit with success if disk single-sided",
    "7837": "check # sides for disk",
    "7839": "track 2",
    "7841": "move on if single-sided",
    "7844": "track 2 on side 1 if alternating",
    "7846": "move on if alternating sides",
    "7854": "track 2 on side 1 if successive sides",
    "7856": "read a sector ID",
    "7860": "exit if error",
    "7861": "fdc_res+4, get E=track, D=head detected",
    "7870": "move on if single-sided disk",
    "7872": "D should now be zero",
    "7875": "if not, set single-sided drive",
    "7879": "set double-sided drive",
    "7886": "move on if track 2 was detected",
    "7888": "else drive has inverse d-track bit of disk",
    "7889": "get double-track bit",
    "7892": "set double-track",
    "7895": "set single-track",
    "7900": "get equipment address",
    "7903": "test if double-track",
    "7907": "exit with okay if single-track",
    "7911": "set carry (okay) if disk double-track",
    "7912": "error 9 - unsuitable media",
    "7915": "get equipment address",
    "7918": "get flags byte",
    "7919": "mask side & track info",
    "7966": "back for more tries",
    "7968": "exit with error 4 - no data",
    "7973": "reseek to high track every 8 tries",
    "7977": "recalibrate every other 8 tries",
    "7980": "get equipment address",
    "7983": "signal head not positioned",
    "7992": "D=high track number",
    "7993": "seek to it",
    "7997": "exit if error",
    "7998": "seek to track D",
    "8001": "exit if error",
    "8005": "call routine address in HL",
    "8010": "process results buffer",
    "8018": "get status of unit 1",
    "8024": "exit if not ready or write-protected",
    "8025": "signal \"unit 1 present\"",
    "8027": "turn on motor",
    "8030": "get status in A",
    "8033": "start motor off timeout & exit",
    "8037": "exit if zero",
    "8041": "Double A",
    "8044": "decrement",
    "8048": "exit when B=0",
    "8049": "double HL",
    "8050": "loop back",
    "8055": "exit when B=0",
    "8058": "halve HL",
    "8060": "loop back",
    "8063": "motor on time",
    "8064": "motor off time",
    "8065": "write off time",
    "8066": "head settle time",
    "8067": "step rate",
    "8068": "head unload time",
    "8069": "head load time x2+1",
    "8071": "read FD status register ($ff if no i/f)",
    "8078": "carry not set if no i/f",
    "8081": "zero equipment data, timing consts and",
    "8084": "FDC results buffer",
    "8093": "set retry count to $0f",
    "8096": "turn off motor",
    "8099": "enter DD_SETUP with default setup data",
    "8108": "copy first 5 bytes of setup info",
    "8123": "HL=setup info for FDC",
    "8124": "send setup info & exit",
    "8140": "A=2*unit",
    "8147": "HL=equipment+2*unit",
    "8150": "get equipment address",
    "8153": "do the seek",
    "8161": "B=# tries",
    "8164": "move on if head positioned",
    "8167": "set track zero",
    "8170": "seek to track zero",
    "8173": "move on if error",
    "8175": "signal head positioned",
    "8179": "compare required track to current",
    "8182": "exit with carry set if same",
    "8186": "recalibrate if track 0 required",
    "8191": "else seek to track D",
    "8194": "move on if error",
    "8197": "store new track number",
    "8198": "done",
    "8200": "attempt to seek to highest track",
    "8204": "signal head not positioned",
    "8206": "exit if FDC wasn't ready",
    "8207": "wait until ready",
    "8210": "loop back for retries",
    "8212": "exit with carry reset & error 2 - seek fail",
    "8214": "try once",
    "8217": "and again if unsuccessful",
    "8222": "B=max track",
    "8227": "move on unless double-track disk",
    "8231": "move on if single-track drive",
    "8235": "double max track #",
    "8238": "send recalibrate command",
    "8244": "do the seek",
    "8249": "D=high track",
    "8253": "A=#tracks head must move",
    "8258": "ensure A is positive",
    "8262": "send seek command",
    "8266": "send unit number",
    "8269": "A=track number",
    "8274": "move on if double-track disk",
    "8278": "move on unless double-track drive",
    "8282": "double tracks to move",
    "8284": "double track number required",
    "8286": "send unit number",
    "8292": "delay for step rate time",
    "8295": "for max tracks",
    "8300": "delay for head settle time",
    "8306": "sense interrupt status",
    "8309": "wait until seek successfully completed",
    "8324": "unit number",
    "8325": "seek end bit",
    "8328": "mask against ST0",
    "8329": "ignore side information",
    "8332": "return with carry set if seek ended",
    "8334": "test error code",
    "8338": "move on if invalid command",
    "8344": "move on if no error",
    "8354": "test not ready bit",
    "8356": "exit with carry reset if so",
    "8360": "else exit with Z reset",
    "8362": "get ST0",
    "8365": "exit with success if no error bits",
    "8370": "exit with error 0 if not ready",
    "8372": "get ST1",
    "8373": "bit 7 always set on +3",
    "8376": "exit with success if no error",
    "8379": "error 1 if write-protected",
    "8382": "error 3 if CRC data error",
    "8387": "error 4 if no data",
    "8391": "error 5 if missing address mark",
    "8396": "else error 7 (unknown error)",
    "8403": "sense interrupt status",
    "8410": "wait for bit 7=1, bit 6=0",
    "8415": "Sense interrupt status command",
    "8417": "send it",
    "8420": "get results & exit",
    "8422": "get unit status command",
    "8424": "send it",
    "8427": "C=unit number",
    "8428": "send it & follow in to next routine",
    "8431": "HL=buffer for results",
    "8439": "total bytes read",
    "8441": "step past length byte",
    "8443": "get FD status register",
    "8446": "loop back until ready",
    "8448": "move on if no more bytes (bit 6 reset)",
    "8453": "get byte",
    "8457": "store in buffer",
    "8459": "increment count",
    "8460": "short delay",
    "8464": "back for more",
    "8467": "A=first byte of results",
    "8469": "store results length",
    "8472": "exit with HL=address of results",
    "8473": "output command except last byte",
    "8476": "read the bytes",
    "8479": "get results string & exit",
    "8482": "output command except last byte",
    "8485": "write the bytes",
    "8488": "get write off time value",
    "8495": "write off delay",
    "8497": "get results string & exit"
  },
  "PrefixComments": {
    "56": "The maskable interrupt routine",
    "102": "The Non-maskable interrupt",
    "104": "The disk motor timeout subroutine",
    "424": "Initialise +3DOS",
    "476": "Get +3DOS issue and version numbers",
    "492": "Get memory usage in pages 1, 3, 4, 6",
    "498": "Re-allocate memory usage in pages 1, 3, 4, 6",
    "527": "Subroutine to copy BC bytes from HL to DE within page A, then page back original page",
    "539": "Subroutine to page in bank A (gives A=previous bank)",
    "563": "Subroutine to find address of buffer A in 1346 area. On exit, HL=address, A=bank",
    "581": "Subroutine to copy IX bytes from HL in page C to DE in page B",
    "635": "Subroutine to copy $20 bytes from pg_buffer to $bfe0 (or vice-versa if carry set)",
    "656": "Subroutine to copy IX bytes from HL in page C to DE in page B, using a $20-byte buffer at $bfe0",
    "716": "Subroutine to calculate BC=#bytes that can be moved to DE. If DE is in the top segment, no bytes can be moved. IX initially contains total #bytes to move, and on exit contains #bytes that will be left after this move",
    "752": "Enable/disable error messages. A=0: disable A!=0:enable, HL=Alert routine address.",
    "767": "Subroutine to do an ALERT message for error A on drive C",
    "973": "Recoverable error message table",
    "799": "Subroutine to call ALERT subroutine with error message in HL",
    "805": "Subroutine to generate change disk message",
    "813": "Subroutine to generate recoverable error message A, returns address in HL",
    "828": "Subroutine to put recoverable error message address for error A at IX",
    "856": "Subroutine to process a character in the error message generator",
    "945": "Generates a decimal digit from HL, subtracting BC in a loop, counting in A",
    "1259": "Subroutine to shift DE right A times",
    "1269": "Subroutine to shift DE left A times",
    "1278": "Subroutine to call routine address in HL",
    "1279": "Subroutine to convert lowercase drive letters to uppercase",
    "1288": "Sets default drive to first found with XDPB. If none, A: is set as default",
    "1313": "Subroutine to get FCB for file B & test if open for reading",
    "1321": "Subroutine to get FCB for file B & test if open for writing",
    "1340": "Subroutine to clear FCB for closed file B",
    "1368": "Subroutine to get FCB (in BC) of file B. Returns access mode/flags in A.",
    "1398": "Subroutine to check if file in BC is opened by any other FCB",
    "1414": "Subroutine to check if file in BC can be opened in required access mode",
    "1487": "Bring disk up to date",
    "1533": "Subroutine to get sector HL to buffer, ensuring all FCBs on same drive referencing this sector are up to date. On entry, D=drive, HL=abs logical sector of a buffer",
    "1589": "Create and/or open a file",
    "1713": "Subroutine to set up clean directory entry for new file",
    "1740": "Subroutine to find entry for required extent of file",
    "1768": "Subroutine to erase any .BAK file existing for file in current FCB",
    "1806": "Open a drive as a single file",
    "1866": "Close a file",
    "1878": "Subroutine to ensure file's +3DOS header & directory entry are up-to-date",
    "1899": "Abandon a file",
    "1943": "+3DOS file header signature (issue 1)",
    "1953": "Subroutine to update any +3DOS file header with filelength if necessary",
    "1977": "Subroutine to update +3DOS file header with filelength & +3 BASIC header. Leaves filepointer positioned after header.",
    "2012": "Subroutine to copy E bytes from HL into file at current filepointer",
    "2022": "Subroutine to create a header for a newly-created file",
    "2059": "Subroutine to open file & read any header",
    "2199": "Subroutine to update largest rec# with one from current extent if larger",
    "2235": "Point at the header data for this file",
    "2253": "Change open file's access mode",
    "2300": "Free space on disk",
    "2310": "Set/get default user number",
    "2329": "Set/get default drive",
    "2350": "Delete a file",
    "2373": "Subroutine to delete any directory entry matching one in FCB",
    "2403": "Change a file's attributes",
    "2505": "Subroutine to change attributes for directory entries matching filespec",
    "2530": "Subroutine to set/clear attributes. HL points to directory entry, A contains attributes to set/clear & C contains set/clear mask",
    "2558": "Subroutine to rename any directory entry matching filename in SYSFCB1 to name in SYSFCB0",
    "2631": "Subroutine to add directory entry to catalog if suitable",
    "2639": "Subroutine to process a directory entry & add to catalog if suitable",
    "2771": "Subroutine to compare filenames at DE & HL (ignoring attributes) and setting Z if they match. Carry set if filename at HL > one at DE",
    "2793": "Subroutine to parse filespec at HL into FCB at BC, giving error if filespec illegal or contains wildcards",
    "2815": "Subroutine to parse filespecs, allowing wildcards",
    "2818": "Subroutine to set user area & drive letter specified in filename. Should exit with HL pointing to \":\". On exit, carry reset if neither found",
    "2828": "Subroutine to check if chars at HL are a user area. If so, exits with user area set, carry set & HL pointing after user area in filename.",
    "2859": "Subroutine to check if char at HL is a drive letter. If so, exits with drive letter set, carry set & HL pointing after drive letter in filename.",
    "2882": "Subroutine to test if A is a digit ('0'-'9'). If so, exits with carry set & A=value",
    "2889": "Subroutine to parse filename at HL to FCB in BC (preserved). Carry reset & error $14 if illegal filespec.",
    "3014": "Subroutine to fill E+1 chars in filename with \"?\" wildcard chars. Or enter at L0BC8 to fill with char in A.",
    "3023": "Subroutine to skip char in filename & get next one",
    "3027": "Subroutine to get next filename char in A, Z set if end-of-filename",
    "3037": "Subroutine to get next filename char (exits with C reset if already end of filename)",
    "3042": "Subroutine to get current filename char as uppercase in A, checking for end of filename ($ff or space), setting Z if so",
    "3055": "Subroutine to check for illegal chars in filenames. On entry, A=char & on exit carry & Z set if illegal.",
    "3084": "Subroutine to ensure disk for FCB in BC is logged in, if necessary building checksum vector, allocation bitmap & directory entry information for a drive",
    "3149": "Subroutine to process a directory entry, either incrementing the number of free entries, or updating the allocation bitmap for the files blocks.",
    "3168": "Subroutine to copy last directory entry number to extended XDPB info",
    "3181": "Subroutine to find extent HL for current file",
    "3220": "Subroutine to get new extent for file if required",
    "3254": "Subroutine to ensure directory is up-to-date for current file",
    "3307": "Subroutine to update directory with current FCB info",
    "3333": "Subroutine to check if correct extent for record is in FCB. On entry, DE=record number On exit, carry set if record is within this extent",
    "3386": "Subroutine to find directory entry with filename & extent counter in FCB",
    "3408": "Subroutine to check if directory entry found (HL) matches one in FCB. FCB can contain wildcards & $ff for extent bytes (match any extent) Z set if match found",
    "3444": "Subroutine to check if current file (BC) and file HL are the same. Enter at L0D74 if user area flag $20 should be ignored, or at L0D7A if user areas must exactly match. Z set if match.",
    "3463": "Subroutine to check if filename in directory entry at HL matches one in FCB at BC (may contain ? wildcards). Z set if match. On exit, HL points to directory entry after filename & DE points to FCB after filename (or at failed chars).",
    "3486": "Subroutine to call subroutine HL with every directory entry in turn. The subroutine it calls should set Z if it doesn't require any more entries. On exit, this routine leaves address of last-accessed entry in HL.",
    "3549": "Subroutine to call the subroutine whose address is at rt_dirent. It enters with HL=address of directory entry (direntry)",
    "3557": "Subroutine to increment DE (current directory entry). On exit, carry is set if no more entries",
    "3567": "Subroutine to get sector for directory entry DE, and get/set checksum. On exit, AHL=sector buffer address. Error if checksums didn't match",
    "3620": "Subroutine to copy \"direntry\" to directory entry (DE), marking buffer as changed & updating checksum",
    "3674": "Subroutine to calculate an offset into a sector buffer for a directory entry. On entry, A=lowbyte of entry number, HL=buffer address. On exit, DE=direntry, HL=entry address, IX=$20",
    "3693": "Subroutine to find address of sector DE (abs log) within checksum table (returned in HL) returning sector checksum in B On entry, BHL=sector buffer address",
    "3763": "Subroutine to check if file (HL=FCB) is read-only, giving error if so.",
    "3777": "Subroutine to initialise the allocation bitmap of a drive with the directory bitmaps",
    "3806": "Subroutine to allocate/deallocate a block. On entry, DE=block number and C=$00 to remove block from allocation bitmap. or $ff to add block to allocation bitmap",
    "3842": "Subroutine to allocate a new block for a file (returned in DE)",
    "3893": "Subroutine to deallocate all blocks in current FCB",
    "3896": "Subroutine to add/remove all the blocks in a directory entry to the allocation bitmap. On entry, HL=address of directory entry, A=$ff to add or $00 to remove.",
    "3983": "Subroutine to convert HL=blocks to K",
    "3998": "Subroutine to calculate HL=free space (in K) on current drive",
    "4030": "Subroutine to get HL=allocation bitmap & DE=last block number from XDPB",
    "4043": "Subroutine to check if new directory entry available.",
    "4075": "Subroutine to get a new directory entry (DE)",
    "4136": "Subroutine to check if directory entry at HL is free",
    "4141": "Subroutine to clear new entry flag & increment # free entries ",
    "4158": "Subroutine to check for datestamps, and if present to exit with Z set and HL pointing to address to place datestamp for entry DE",
    "4191": "Get file pointer for random access",
    "4200": "Get end of file position for random access",
    "4219": "Set file pointer for random access",
    "4232": "Subroutine to increment filepointer by 1 (L108C), $80 (L1088) or A (L108E). If this caused the filepointer to cross a record boundary, bit 5 of the FCB flags byte is reset.",
    "4283": "Subroutine to ensure filelength is at least as large as current filepointer",
    "4313": "Subroutine to read a byte from the file to correct address. On exit, Z set if finished",
    "4342": "Subroutine to read a record from the file to correct address. On exit, Z set if finished",
    "4393": "Read a byte",
    "4428": "Subroutine to read a byte (A) from the file",
    "4479": "Write bytes from memory",
    "4511": "Subroutine to write DE bytes to file",
    "4548": "Subroutine to write a byte to file",
    "4578": "Subroutine to write a record to file",
    "4633": "Write a byte",
    "4646": "Subroutine to place byte A in file at current filepointer, and increment filepointer",
    "4703": "Subroutine to test if file has valid header checksum (Z set if so)",
    "4711": "Subroutine to update checksum in file header & set filepointer after it",
    "4728": "Subroutine to get stored header checksum (D) & calculated checksum (E)",
    "4779": "Subroutine to get sector in FCB to a buffer",
    "4815": "Subroutine to get abs logical sector (DE) & record address (AHL) for record (DE) in current file, creating new record if required",
    "4828": "Subroutine to find abs log sector (DE) and record address (AHL) for possibly new record DE in current file",
    "4853": "Subroutine to get the abs log sector (DE) and address (AHL) of record DE in the current file",
    "4862": "Subroutine to get the current record into a buffer and update the FCB with its details",
    "4947": "Subroutine to get DE=record number from FCB",
    "4957": "Subroutine to get DE=record number for filepointer",
    "4977": "Subroutine to get record address (AHL) and sector (DE) for record DE, creating new record if required",
    "5022": "Subroutine to get sector DE to a buffer, don't bother reading in if newly created record (Z set)",
    "5028": "Subroutine to find abs log sector (DE) and record address (AHL) for record DE in current file",
    "5053": "Subroutine to calculate abs logical sector (DE) and offset (HL) from block number (HL) offset into block (DE)",
    "5084": "Subroutine to calculate block number (HL) and offset (DE) of record DE in file, assuming correct extent is in FCB",
    "5142": "Subroutine to set extent counter & number of records in extent",
    "5171": "Subroutine to check record number DE is in the current extent",
    "5189": "Subroutine to calculate ADE=last record in extent+1",
    "5230": "Subroutine to find abs log sector (DE) and record address (AHL) for record DE in current file (which is an open drive)",
    "5276": "Subroutine to get D=first buffer for cache, E=number of cache buffers",
    "5281": "Subroutine to set cache to D=first buffer, E=# buffers",
    "5358": "Subroutine to find BCB (address in DE) of buffer holding log sector in BC on current drive",
    "5393": "Subroutine to get a buffer for logical sector BC. On exit, DE=BCB",
    "5447": "Subroutine to get sector for BCB into memory",
    "5472": "Subroutine to return page (A) & address (HL) for absolute logical sector DE reading to a new buffer if necessary",
    "5496": "Subroutine to return page (A) & address (HL) for absolute logical sector DE creating a new buffer if necessary (but not reading sector from disk)",
    "5520": "Subroutine to get page (A) and address (HL) of buffer for files current logical sector, & flag as changed",
    "5567": "Subroutine to free all buffers referencing unchanged sectors on drive. Enter at L15D8, or L15BF to free only buffers referencing directory sectors",
    "5651": "Subroutine to move all in-use BCBs for current drive to the free list",
    "5682": "Subroutine to move all in-use BCBs for current file to the free list",
    "5720": "Subroutine to release in-use cache buffer (address in DE)",
    "5746": "Subroutine to clear current cache",
    "5765": "Subroutine to write data back to disk. On entry, DE=BCB and IX=XDPB. The routine writes all changed sectors for the disk back in order (smallest absolute logical sector first).",
    "5798": "Subroutine to find BCB on same drive with smaller logical sector number than BC. On entry DE contains address of current BCB. On exit, Z set if no BCB with smaller logical sector number found.",
    "5838": "Subroutine to write buffer (DE=BCB) to disk",
    "5860": "Subroutine to read buffer (DE=BCB) from disk",
    "5873": "Subroutine to get buffer bank (B), address (HL), logical track (D) and logical sector (E), given BCB address in DE",
    "5892": "Subroutine to get address of last free/in-use BCB (Z set if none). Enter at L1707 with HL=bcb_inuse for last in-use BCB",
    "5903": "Subroutine to check if current BCB is last in chain. Exits with Z set if so",
    "5910": "Subroutine to move a BCB from the free chain to the in-use chain (L171E) or vice-versa (L1716). If the BCB is already in the chain its being moved to, this has the effect of moving it to the top of the chain. On entry, HL is address of pointer to this BCB and DE holds address of BCB. On exit, HL is address of start of other chain, and DE is unchanged.",
    "5935": "Subroutine to transfer a word value from DE to HL On exit, DE is unchanged, but HL is incremented",
    "5943": "Subroutine to setup extended XDPB info for drives A: and B:",
    "6040": "Subroutine to initialise RAMdisk",
    "6085": "Point at XDPB for low level disk access",
    "6083": "Dummy low-level routines for RAMdisk",
    "6127": "Subroutine to possibly logout drive & low-level login another disk",
    "6149": "Subroutine to low-level login a disk",
    "6157": "Subroutine to log out a disk if no files open & not recently accessed",
    "6171": "Subroutine to low-level log out a disk (IX=XDPB)",
    "6185": "Subroutine to see if drive has been accessed within last 2secs. If so (or if fixed drive), carry is set",
    "6257": "Subroutine to call L187B, preserving BC/DE/HL",
    "6267": "Subroutine to check disk can be written to.",
    "6294": "Subroutine to convert logical usable record number (in DE) to absolute logical sector number by allowing for reserved tracks",
    "6326": "Subroutine to find logical track (D) & sector (E) from absolute logical sector number (DE). IX=XDPB for disk",
    "6355": "Subroutine to login a disk at low-level",
    "6367": "Subroutine to read a sector at BHL on logical track D, logical sector E",
    "6376": "Subroutine to write a sector at BHL on logical track D, logical sector E",
    "6403": "Subroutine to call address at rt_temp",
    "6409": "Calls the subroutine at HL.",
    "6410": "Subroutine to check whether \"change disk\" routine should be called",
    "6441": "Change disk subroutine",
    "6524": "Low-level read sector subroutine for drives A: & B:",
    "6530": "Low-level write sector subroutine for drives A: & B:",
    "6536": "Low-level login disk subroutine for drives A: & B:",
    "6592": "Read bytes into memory",
    "6621": "Subroutine to read DE bytes from file",
    "6813": "Subroutine to do an ALERT message for error A (IX=XDPB)",
    "7121": "Setup parameter block for sector read",
    "7128": "Setup parameter block for sector read",
    "7135": "Subroutine to setup parameter block for low-level read/writes",
    "7186": "Subroutine to setup some of the parameter block for sector read/writes (except # command bytes & additional command bytes)",
    "7211": "Subroutine to return physical side (B) and track (D) given logical track (D). Physical side is also ORed with unit number in C",
    "7248": "Set intercept routine for copy protection",
    "7263": "Subroutine to read A bytes from a sector",
    "7285": "Read a sector",
    "7299": "Write a sector",
    "7308": "Check a sector",
    "7110": "Setup parameter block for sector check",
    "7322": "Format a track",
    "7078": "Subroutine to setup parameter block for format",
    "7340": "Read a sector identifier",
    "7351": "Subroutine to read a sector ID",
    "7365": "Routine to turn on motor, try an operation in HL on track D multiple times & then start the motor off timeout",
    "7374": "Tables of specifications for disk types 0-3. Format as on p215 of +3 Manual.",
    "7414": "Log in disk, initialise XDPB",
    "7505": "Pre-initialise XDPB for DD FORMAT",
    "7524": "Initialise an XDPB from a disk specification. ",
    "7590": "Initialise a DPB from a disk specification. On exit, DE=ALS, HL=HASH and A=format type.",
    "7780": "Subroutine to update drive equipment info & check is suitable for disk",
    "7814": "Subroutine to test drive equipment for sidedness and double/single track",
    "7899": "Test media suitability",
    "7915": "What type of drive?",
    "7922": "Subroutine to try operation in HL on track D multiple times",
    "7970": "Subroutine to position head on track D and call subroutine in HL, processing results buffer afterwards. B contains try number",
    "8015": "Is unit 1 (external drive) present?",
    "8027": "Fetch drive status",
    "8036": "Subroutine to calculate N/128 - 1 given A=log2 (N/128)",
    "8046": "Subroutine to multiply HL by 2^B",
    "8053": "Subroutine to divide HL by 2^B",
    "8063": "Default setup data, used by DD_INIT",
    "8070": "Is the floppy disk driver interface present?",
    "8081": "Initialise disk driver",
    "8102": "Specify drive parameters",
    "8137": "Subroutine to convert unit/head byte (A) to equipment address (in HL)",
    "8158": "Subroutine to seek to track D on equipment HL (XDPB=IX)",
    "8214": "Subroutine to seek to track zero",
    "8246": "Subroutine to seek to the highest track",
    "8285": "Subroutine to complete a seek command. Carry set on exit if successful",
    "8315": "Subroutine to delay for approx A milliseconds",
    "8324": "Subroutine to wait for end of seek command. On exit, carry set if seek completed successfully. If unsuccessful, Z set if FDC was not ready.",
    "8361": "Subroutine to process results buffer, exiting with error or carry set Z is set for success or write-protect/not ready error",
    "8398": "Subroutine to wait until FDC ready for new command",
    "8415": "Subroutine to perform \"sense interrupt status\" command",
    "8422": "Subroutine to perform \"get unit status\" command",
    "8431": "Subroutine to get results string from FDC",
    "8473": "Subroutine to read E bytes only",
    "8482": "uPD765A write driver",
    "8500": "Subroutine to get page (D) and address (HL) of buffer for low-level command, and output all command bytes except last (in A). On entry, HL=address of parameter block."
  },
  "Literals": {
    "23672": [
      "FRAMES"
    ],
    "58880": [
      "timeout"
    ],
    "23388": [
      "BANKM"
    ],
    "23399": [
      "BANK678"
    ],
    "56064": [
      "pg_buffer"
    ],
    "56065": [
      "pg_buffer_p_1"
    ],
    "56096": [
      "rt_alert"
    ],
    "56098": [
      "alert_resp"
    ],
    "56105": [
      "al_mess"
    ],
    "57236": [
      "def_drv"
    ],
    "23417": [
      "LODDRV"
    ],
    "23418": [
      "SAVDRV"
    ],
    "56224": [
      "fcbs"
    ],
    "57120": [
      "sysfcb0"
    ],
    "57232": [
      "filerecs"
    ],
    "57235": [
      "def_user"
    ],
    "57237": [
      "extchg"
    ],
    "57238": [
      "att_clr"
    ],
    "57239": [
      "att_set"
    ],
    "57240": [
      "cat_buff"
    ],
    "57242": [
      "cat_filt"
    ],
    "57244": [
      "cat_ents"
    ],
    "57243": [
      "cat_size"
    ],
    "57248": [
      "rt_dirent"
    ],
    "57250": [
      "direntry"
    ],
    "57296": [
      "rw_page"
    ],
    "57297": [
      "rw_add"
    ],
    "58000": [
      "cachenum"
    ],
    "58002": [
      "bcb_inuse"
    ],
    "58004": [
      "bcb_free"
    ],
    "57312": [
      "bcbs"
    ],
    "57488": [
      "cache7"
    ],
    "58346": [
      "unit0"
    ],
    "58048": [
      "xdpb_a"
    ],
    "58016": [
      "xdpb_ptrs"
    ],
    "23673": [
      "FRAMES_P1"
    ],
    "58349": [
      "rt_temp"
    ],
    "58347": [
      "rt_chgdsk"
    ],
    "58157": [
      "xdpb_b"
    ],
    "58413": [
      "retry_cnt"
    ],
    "58266": [
      "xdpb_m"
    ],
    "58351": [
      "spec_m"
    ],
    "58368": [
      "ddl_parms"
    ],
    "58393": [
      "rt_encode"
    ],
    "58416": [
      "fdc_res"
    ],
    "58400": [
      "equipment"
    ],
    "58408": [
      "tm_mtron"
    ],
    "58412": [
      "tm_step"
    ],
    "58411": [
      "tm_hdset"
    ],
    "58410": [
      "tm_wroff"
    ]
  },
  "LiteralReplacements": {
    "58": "FRAMES",
    "62": "FRAMES",
    "114": "timeout",
    "107": "BANKM",
    "120": "FRAMES",
    "127": "timeout",
    "131": "timeout",
    "139": "BANK678",
    "144": "BANK678",
    "152": "BANKM",
    "428": "pg_buffer",
    "431": "pg_buffer_p_1",
    "542": "BANKM",
    "758": "rt_alert",
    "762": "rt_alert",
    "768": "rt_alert",
    "782": "alert_resp",
    "779": "ERR_MSG_TABLE",
    "800": "rt_alert",
    "807": "ERR_MSG_TABLE",
    "810": "alert_resp",
    "813": "al_mess",
    "830": "alert_resp",
    "1303": "def_drv",
    "1306": "LODDRV",
    "1309": "SAVDRV",
    "1414": "fcbs",
    "1495": "fcbs",
    "1533": "fcbs",
    "1771": "sysfcb0",
    "2024": "DOSH_SIGN",
    "2068": "DOSH_SIGN",
    "2157": "UPD_RECNO",
    "2211": "filerecs",
    "2321": "def_user",
    "2324": "def_user",
    "2342": "def_drv",
    "2345": "def_drv",
    "2350": "sysfcb0",
    "2367": "DEL_MATCH_DIR",
    "2399": "extchg",
    "2403": "att_clr",
    "2407": "sysfcb0",
    "2488": "extchg",
    "2495": "extchg",
    "2510": "att_set",
    "2520": "att_clr",
    "2478": "RENAME_SYSFCB",
    "2591": "extchg",
    "2568": "sysfcb0",
    "2595": "cat_buff",
    "2599": "cat_filt",
    "2605": "cat_ents",
    "2608": "sysfcb0",
    "2626": "cat_size",
    "2643": "cat_filt",
    "2658": "cat_buff",
    "2666": "cat_size",
    "2692": "cat_size",
    "2705": "cat_buff",
    "2743": "cat_size",
    "2750": "cat_ents",
    "2902": "def_drv",
    "2907": "def_user",
    "3124": "PROC_DIRENT",
    "3386": "CHK_DE_IN_FCB",
    "3486": "rt_dirent",
    "3543": "direntry",
    "3549": "rt_dirent",
    "3553": "direntry",
    "3685": "direntry",
    "4085": "TEST_DE_FREE",
    "4319": "rw_page",
    "4322": "rw_add",
    "4333": "rw_add",
    "4362": "rw_page",
    "4366": "rw_add",
    "4378": "rw_add",
    "4480": "rw_page",
    "4483": "rw_add",
    "4501": "rw_add",
    "4548": "rw_page",
    "4551": "rw_add",
    "4566": "rw_add",
    "4570": "rw_add",
    "4604": "rw_page",
    "4608": "rw_add",
    "4619": "rw_add",
    "4818": "FIND_ABS_SECTOR",
    "4865": "GET_FILE_SECT",
    "4870": "GET_DRIVE_SECT",
    "4823": "GET_DRIVE_SECT",
    "5276": "cachenum",
    "5288": "bcb_inuse",
    "5291": "bcb_free",
    "5295": "cachenum",
    "5298": "bcbs",
    "5306": "cache7",
    "5315": "cachenum",
    "5334": "bcb_free",
    "5343": "bcb_free",
    "5358": "bcb_inuse",
    "5398": "bcb_inuse",
    "5600": "bcb_inuse",
    "5654": "bcb_inuse",
    "5685": "bcb_inuse",
    "5748": "bcb_inuse",
    "5768": "bcb_inuse",
    "5892": "bcb_free",
    "5913": "bcb_free",
    "5921": "bcb_inuse",
    "5945": "unit0",
    "5959": "xdpb_a",
    "5962": "xdpb_ptrs",
    "5948": "EXT_XDPB_A",
    "5965": "EXT_XDPB_B",
    "6041": "EXT_XDPB_M",
    "6088": "xdpb_ptrs",
    "6197": "FRAMES",
    "6200": "FRAMES_P1",
    "6383": "rt_temp",
    "6404": "rt_temp",
    "6418": "unit0",
    "6448": "rt_chgdsk",
    "6468": "rt_chgdsk",
    "6453": "xdpb_b",
    "6472": "rt_chgdsk",
    "6475": "xdpb_b",
    "6502": "retry_cnt",
    "6593": "rw_page",
    "6596": "rw_add",
    "6611": "rw_add",
    "6732": "rw_page",
    "16104": "timeout",
    "16107": "BANK678",
    "6808": "rw_add",
    "6843": "xdpb_m",
    "6861": "spec_m",
    "6858": "DISK_M_SPEC",
    "6945": "xdpb_ptrs",
    "7288": "TRY_READ_SECTOR",
    "7293": "ddl_parms",
    "7144": "rt_encode",
    "7191": "ddl_parms",
    "7254": "rt_encode",
    "7258": "rt_encode",
    "7274": "TRY_RSEC_A",
    "7334": "ddl_parms",
    "7329": "TRY_DD_FORMAT",
    "7343": "fdc_res",
    "7485": "SPECT_P3_FORMAT",
    "7922": "retry_cnt",
    "8081": "equipment",
    "8093": "retry_cnt",
    "8099": "DATA_DD_INIT",
    "8102": "tm_mtron",
    "8110": "tm_step",
    "8158": "retry_cnt",
    "8289": "tm_step",
    "8297": "tm_hdset",
    "8303": "fdc_res",
    "8400": "fdc_res",
    "8431": "fdc_res",
    "8488": "tm_wroff"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 7,
      "SectionType": 0,
      "Lenght": 8
    },
    {
      "StartAddress": 8,
      "EndAddress": 15,
      "SectionType": 2,
      "Lenght": 8
    },
    {
      "StartAddress": 16,
      "EndAddress": 55,
      "SectionType": 0,
      "Lenght": 40
    },
    {
      "StartAddress": 56,
      "EndAddress": 85,
      "SectionType": 1,
      "Lenght": 30
    },
    {
      "StartAddress": 86,
      "EndAddress": 101,
      "SectionType": 0,
      "Lenght": 16
    },
    {
      "StartAddress": 102,
      "EndAddress": 972,
      "SectionType": 1,
      "Lenght": 871
    },
    {
      "StartAddress": 973,
      "EndAddress": 984,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 985,
      "EndAddress": 1002,
      "SectionType": 2,
      "Lenght": 18
    },
    {
      "StartAddress": 1003,
      "EndAddress": 1014,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1015,
      "EndAddress": 1027,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1028,
      "EndAddress": 1037,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1038,
      "EndAddress": 1060,
      "SectionType": 2,
      "Lenght": 23
    },
    {
      "StartAddress": 1061,
      "EndAddress": 1073,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1074,
      "EndAddress": 1089,
      "SectionType": 2,
      "Lenght": 16
    },
    {
      "StartAddress": 1090,
      "EndAddress": 1115,
      "SectionType": 2,
      "Lenght": 26
    },
    {
      "StartAddress": 1116,
      "EndAddress": 1128,
      "SectionType": 2,
      "Lenght": 13
    },
    {
      "StartAddress": 1129,
      "EndAddress": 1189,
      "SectionType": 2,
      "Lenght": 61
    },
    {
      "StartAddress": 1190,
      "EndAddress": 1199,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1200,
      "EndAddress": 1206,
      "SectionType": 2,
      "Lenght": 7
    },
    {
      "StartAddress": 1207,
      "EndAddress": 1217,
      "SectionType": 2,
      "Lenght": 11
    },
    {
      "StartAddress": 1218,
      "EndAddress": 1229,
      "SectionType": 2,
      "Lenght": 12
    },
    {
      "StartAddress": 1230,
      "EndAddress": 1258,
      "SectionType": 2,
      "Lenght": 29
    },
    {
      "StartAddress": 1259,
      "EndAddress": 1942,
      "SectionType": 1,
      "Lenght": 684
    },
    {
      "StartAddress": 1943,
      "EndAddress": 1952,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 1953,
      "EndAddress": 3064,
      "SectionType": 1,
      "Lenght": 1112
    },
    {
      "StartAddress": 3065,
      "EndAddress": 3083,
      "SectionType": 2,
      "Lenght": 19
    },
    {
      "StartAddress": 3084,
      "EndAddress": 5997,
      "SectionType": 1,
      "Lenght": 2914
    },
    {
      "StartAddress": 5998,
      "EndAddress": 6000,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 6001,
      "EndAddress": 6004,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6005,
      "EndAddress": 6008,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6009,
      "EndAddress": 6012,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6013,
      "EndAddress": 6014,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6015,
      "EndAddress": 6016,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6017,
      "EndAddress": 6018,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6019,
      "EndAddress": 6021,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 6022,
      "EndAddress": 6025,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6026,
      "EndAddress": 6029,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6030,
      "EndAddress": 6033,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6034,
      "EndAddress": 6035,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6036,
      "EndAddress": 6037,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6038,
      "EndAddress": 6039,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6040,
      "EndAddress": 6061,
      "SectionType": 1,
      "Lenght": 22
    },
    {
      "StartAddress": 6062,
      "EndAddress": 6064,
      "SectionType": 2,
      "Lenght": 3
    },
    {
      "StartAddress": 6065,
      "EndAddress": 6068,
      "SectionType": 2,
      "Lenght": 4
    },
    {
      "StartAddress": 6069,
      "EndAddress": 6072,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6073,
      "EndAddress": 6076,
      "SectionType": 3,
      "Lenght": 4
    },
    {
      "StartAddress": 6077,
      "EndAddress": 6078,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6079,
      "EndAddress": 6080,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6081,
      "EndAddress": 6082,
      "SectionType": 3,
      "Lenght": 2
    },
    {
      "StartAddress": 6083,
      "EndAddress": 6956,
      "SectionType": 1,
      "Lenght": 874
    },
    {
      "StartAddress": 6957,
      "EndAddress": 6964,
      "SectionType": 2,
      "Lenght": 8
    },
    {
      "StartAddress": 6965,
      "EndAddress": 7373,
      "SectionType": 1,
      "Lenght": 409
    },
    {
      "StartAddress": 7374,
      "EndAddress": 7383,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 7384,
      "EndAddress": 7393,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 7394,
      "EndAddress": 7403,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 7404,
      "EndAddress": 7413,
      "SectionType": 2,
      "Lenght": 10
    },
    {
      "StartAddress": 7414,
      "EndAddress": 8062,
      "SectionType": 1,
      "Lenght": 649
    },
    {
      "StartAddress": 8063,
      "EndAddress": 8063,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8064,
      "EndAddress": 8064,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8065,
      "EndAddress": 8065,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8066,
      "EndAddress": 8066,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8067,
      "EndAddress": 8067,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8068,
      "EndAddress": 8068,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8069,
      "EndAddress": 8069,
      "SectionType": 2,
      "Lenght": 1
    },
    {
      "StartAddress": 8070,
      "EndAddress": 16383,
      "SectionType": 1,
      "Lenght": 8314
    }
  ],
  "DisassemblyFlags": 4
}