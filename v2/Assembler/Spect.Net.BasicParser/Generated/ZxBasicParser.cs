//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\dotne\source\repos\spectnetide\v2\Assembler\AntlrZxBasicParserGenerator\AntlrZxBasicParserGenerator\ZxBasic.g4 by ANTLR 4.6.4

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Spect.Net.BasicParser.Generated {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.4")]
[System.CLSCompliant(false)]
public partial class ZxBasicParser : Parser {
	public const int
		WS=1, ASM_SECTION=2, COLON=3, UNDERSCORE=4, SINGLE_QUOTE=5, SLASH=6, DOLLAR=7, 
		SCOLON=8, COMSEP=9, COMMA=10, ASSIGN=11, LPAR=12, RPAR=13, LSBRAC=14, 
		RSBRAC=15, QMARK=16, PLUS=17, MINUS=18, VBAR=19, UPARR=20, AMP=21, EQOP=22, 
		CIEQOP=23, NEQOP=24, CINEQOP=25, LTOP=26, LTEOP=27, GTOP=28, GTEOP=29, 
		LSHOP=30, RSHOP=31, MULOP=32, DIVOP=33, DOT=34, DECNUM=35, REALNUM=36, 
		BLOCK_COMMENT=37, LINE_COMMENT=38, NOTEQ=39, ABS=40, ACS=41, AND=42, ALIGN=43, 
		ASC=44, ASN=45, AT=46, ATN=47, ATTR=48, BAND=49, BNOT=50, BOR=51, BXOR=52, 
		BEEP=53, BOLD=54, BORDER=55, BRIGHT=56, BYREF=57, BYVAL=58, CAST=59, CHR=60, 
		CIRCLE=61, CLS=62, CODE=63, CONST=64, CONTINUE=65, COS=66, CSRLIN=67, 
		DECLARE=68, DIM=69, DO=70, DATA=71, DRAW=72, ELSE=73, ELSEIF=74, END=75, 
		EXIT=76, EXP=77, FASTCALL=78, FLASH=79, FOR=80, FUNCTION=81, GETKEY=82, 
		GETKEYSCANCODE=83, GO=84, GOTO=85, GOSUB=86, HEX=87, HEX16=88, IF=89, 
		IN=90, INK=91, INKEY=92, INPUT=93, INT=94, INVERSE=95, ITALIC=96, LBOUND=97, 
		LCASE=98, LET=99, LEN=100, LN=101, LOAD=102, LOOP=103, MOD=104, MULTIKEYS=105, 
		NEXT=106, NOT=107, OR=108, OVER=109, OUT=110, PAPER=111, PAUSE=112, PEEK=113, 
		PI=114, PLOT=115, POINT=116, POKE=117, POS=118, PRINT=119, PRINT42=120, 
		PRINTAT42=121, PRINT64=122, PRINTAT64=123, RANDOMIZE=124, READ=125, REM=126, 
		RESTORE=127, RETURN=128, RND=129, SAVE=130, SCREEN=131, SGN=132, SHL=133, 
		SHR=134, SIN=135, SQR=136, STDCALL=137, STEP=138, STOP=139, STR=140, SUB=141, 
		TAN=142, THEN=143, TO=144, UBOUND=145, UCASE=146, UNTIL=147, VAL=148, 
		VERIFY=149, WEND=150, WHILE=151, XOR=152, HEXNUM=153, BINNUM=154, IDENTIFIER=155, 
		IDSTART=156, IDCONT=157, STRING=158, LINE_END=159, ErrorCharacter=160;
	public const int
		RULE_compileUnit = 0, RULE_label = 1, RULE_line = 2, RULE_line_item = 3, 
		RULE_asm_section = 4, RULE_keyword = 5, RULE_function = 6, RULE_operator = 7, 
		RULE_special = 8, RULE_number = 9, RULE_identifier = 10, RULE_string = 11, 
		RULE_comment = 12, RULE_block_comment = 13, RULE_line_comment = 14;
	public static readonly string[] ruleNames = {
		"compileUnit", "label", "line", "line_item", "asm_section", "keyword", 
		"function", "operator", "special", "number", "identifier", "string", "comment", 
		"block_comment", "line_comment"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "':'", "'_'", "'''", null, "'$'", "';'", "'//'", "','", 
		"'='", "'('", "')'", "'['", "']'", "'?'", "'+'", "'-'", "'|'", "'^'", 
		"'&'", "'=='", "'==='", "'!='", "'!=='", "'<'", "'<='", "'>'", "'>='", 
		"'<<'", "'>>'", "'*'", null, "'.'", null, null, null, null, "'<>'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WS", "ASM_SECTION", "COLON", "UNDERSCORE", "SINGLE_QUOTE", "SLASH", 
		"DOLLAR", "SCOLON", "COMSEP", "COMMA", "ASSIGN", "LPAR", "RPAR", "LSBRAC", 
		"RSBRAC", "QMARK", "PLUS", "MINUS", "VBAR", "UPARR", "AMP", "EQOP", "CIEQOP", 
		"NEQOP", "CINEQOP", "LTOP", "LTEOP", "GTOP", "GTEOP", "LSHOP", "RSHOP", 
		"MULOP", "DIVOP", "DOT", "DECNUM", "REALNUM", "BLOCK_COMMENT", "LINE_COMMENT", 
		"NOTEQ", "ABS", "ACS", "AND", "ALIGN", "ASC", "ASN", "AT", "ATN", "ATTR", 
		"BAND", "BNOT", "BOR", "BXOR", "BEEP", "BOLD", "BORDER", "BRIGHT", "BYREF", 
		"BYVAL", "CAST", "CHR", "CIRCLE", "CLS", "CODE", "CONST", "CONTINUE", 
		"COS", "CSRLIN", "DECLARE", "DIM", "DO", "DATA", "DRAW", "ELSE", "ELSEIF", 
		"END", "EXIT", "EXP", "FASTCALL", "FLASH", "FOR", "FUNCTION", "GETKEY", 
		"GETKEYSCANCODE", "GO", "GOTO", "GOSUB", "HEX", "HEX16", "IF", "IN", "INK", 
		"INKEY", "INPUT", "INT", "INVERSE", "ITALIC", "LBOUND", "LCASE", "LET", 
		"LEN", "LN", "LOAD", "LOOP", "MOD", "MULTIKEYS", "NEXT", "NOT", "OR", 
		"OVER", "OUT", "PAPER", "PAUSE", "PEEK", "PI", "PLOT", "POINT", "POKE", 
		"POS", "PRINT", "PRINT42", "PRINTAT42", "PRINT64", "PRINTAT64", "RANDOMIZE", 
		"READ", "REM", "RESTORE", "RETURN", "RND", "SAVE", "SCREEN", "SGN", "SHL", 
		"SHR", "SIN", "SQR", "STDCALL", "STEP", "STOP", "STR", "SUB", "TAN", "THEN", 
		"TO", "UBOUND", "UCASE", "UNTIL", "VAL", "VERIFY", "WEND", "WHILE", "XOR", 
		"HEXNUM", "BINNUM", "IDENTIFIER", "IDSTART", "IDCONT", "STRING", "LINE_END", 
		"ErrorCharacter"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ZxBasic.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public ZxBasicParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompileUnitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(ZxBasicParser.Eof, 0); }
		public Asm_sectionContext[] asm_section() {
			return GetRuleContexts<Asm_sectionContext>();
		}
		public Asm_sectionContext asm_section(int i) {
			return GetRuleContext<Asm_sectionContext>(i);
		}
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public LabelContext[] label() {
			return GetRuleContexts<LabelContext>();
		}
		public LabelContext label(int i) {
			return GetRuleContext<LabelContext>(i);
		}
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compileUnit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 37;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASM_SECTION) | (1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << DECNUM) | (1L << REALNUM) | (1L << BLOCK_COMMENT) | (1L << LINE_COMMENT) | (1L << NOTEQ) | (1L << ABS) | (1L << ACS) | (1L << AND) | (1L << ALIGN) | (1L << ASC) | (1L << ASN) | (1L << AT) | (1L << ATN) | (1L << ATTR) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR) | (1L << BEEP) | (1L << BOLD) | (1L << BORDER) | (1L << BRIGHT) | (1L << BYREF) | (1L << BYVAL) | (1L << CAST) | (1L << CHR) | (1L << CIRCLE) | (1L << CLS) | (1L << CODE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONST - 64)) | (1L << (CONTINUE - 64)) | (1L << (COS - 64)) | (1L << (CSRLIN - 64)) | (1L << (DECLARE - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DATA - 64)) | (1L << (DRAW - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (END - 64)) | (1L << (EXIT - 64)) | (1L << (EXP - 64)) | (1L << (FASTCALL - 64)) | (1L << (FLASH - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GETKEY - 64)) | (1L << (GETKEYSCANCODE - 64)) | (1L << (GOTO - 64)) | (1L << (GOSUB - 64)) | (1L << (HEX - 64)) | (1L << (HEX16 - 64)) | (1L << (IF - 64)) | (1L << (IN - 64)) | (1L << (INK - 64)) | (1L << (INKEY - 64)) | (1L << (INPUT - 64)) | (1L << (INT - 64)) | (1L << (INVERSE - 64)) | (1L << (ITALIC - 64)) | (1L << (LBOUND - 64)) | (1L << (LCASE - 64)) | (1L << (LET - 64)) | (1L << (LEN - 64)) | (1L << (LN - 64)) | (1L << (LOAD - 64)) | (1L << (LOOP - 64)) | (1L << (MOD - 64)) | (1L << (MULTIKEYS - 64)) | (1L << (NEXT - 64)) | (1L << (NOT - 64)) | (1L << (OR - 64)) | (1L << (OVER - 64)) | (1L << (OUT - 64)) | (1L << (PAPER - 64)) | (1L << (PAUSE - 64)) | (1L << (PEEK - 64)) | (1L << (PI - 64)) | (1L << (PLOT - 64)) | (1L << (POINT - 64)) | (1L << (POKE - 64)) | (1L << (POS - 64)) | (1L << (PRINT - 64)) | (1L << (PRINT42 - 64)) | (1L << (PRINTAT42 - 64)) | (1L << (PRINT64 - 64)) | (1L << (PRINTAT64 - 64)) | (1L << (RANDOMIZE - 64)) | (1L << (READ - 64)) | (1L << (REM - 64)) | (1L << (RESTORE - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (RETURN - 128)) | (1L << (RND - 128)) | (1L << (SAVE - 128)) | (1L << (SCREEN - 128)) | (1L << (SGN - 128)) | (1L << (SHL - 128)) | (1L << (SHR - 128)) | (1L << (SIN - 128)) | (1L << (SQR - 128)) | (1L << (STDCALL - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STR - 128)) | (1L << (SUB - 128)) | (1L << (TAN - 128)) | (1L << (THEN - 128)) | (1L << (TO - 128)) | (1L << (UBOUND - 128)) | (1L << (UCASE - 128)) | (1L << (UNTIL - 128)) | (1L << (VAL - 128)) | (1L << (VERIFY - 128)) | (1L << (WEND - 128)) | (1L << (WHILE - 128)) | (1L << (XOR - 128)) | (1L << (HEXNUM - 128)) | (1L << (BINNUM - 128)) | (1L << (IDENTIFIER - 128)) | (1L << (STRING - 128)) | (1L << (LINE_END - 128)) | (1L << (ErrorCharacter - 128)))) != 0)) {
				{
				State = 35;
				_errHandler.Sync(this);
				switch (_input.La(1)) {
				case ASM_SECTION:
					{
					State = 30; asm_section();
					}
					break;
				case ASSIGN:
				case PLUS:
				case MINUS:
				case UPARR:
				case AMP:
				case LTOP:
				case LTEOP:
				case GTOP:
				case GTEOP:
				case LSHOP:
				case RSHOP:
				case MULOP:
				case DIVOP:
				case DECNUM:
				case REALNUM:
				case BLOCK_COMMENT:
				case LINE_COMMENT:
				case NOTEQ:
				case ABS:
				case ACS:
				case AND:
				case ALIGN:
				case ASC:
				case ASN:
				case AT:
				case ATN:
				case ATTR:
				case BAND:
				case BNOT:
				case BOR:
				case BXOR:
				case BEEP:
				case BOLD:
				case BORDER:
				case BRIGHT:
				case BYREF:
				case BYVAL:
				case CAST:
				case CHR:
				case CIRCLE:
				case CLS:
				case CODE:
				case CONST:
				case CONTINUE:
				case COS:
				case CSRLIN:
				case DECLARE:
				case DIM:
				case DO:
				case DATA:
				case DRAW:
				case ELSE:
				case ELSEIF:
				case END:
				case EXIT:
				case EXP:
				case FASTCALL:
				case FLASH:
				case FOR:
				case FUNCTION:
				case GETKEY:
				case GETKEYSCANCODE:
				case GOTO:
				case GOSUB:
				case HEX:
				case HEX16:
				case IF:
				case IN:
				case INK:
				case INKEY:
				case INPUT:
				case INT:
				case INVERSE:
				case ITALIC:
				case LBOUND:
				case LCASE:
				case LET:
				case LEN:
				case LN:
				case LOAD:
				case LOOP:
				case MOD:
				case MULTIKEYS:
				case NEXT:
				case NOT:
				case OR:
				case OVER:
				case OUT:
				case PAPER:
				case PAUSE:
				case PEEK:
				case PI:
				case PLOT:
				case POINT:
				case POKE:
				case POS:
				case PRINT:
				case PRINT42:
				case PRINTAT42:
				case PRINT64:
				case PRINTAT64:
				case RANDOMIZE:
				case READ:
				case REM:
				case RESTORE:
				case RETURN:
				case RND:
				case SAVE:
				case SCREEN:
				case SGN:
				case SHL:
				case SHR:
				case SIN:
				case SQR:
				case STDCALL:
				case STEP:
				case STOP:
				case STR:
				case SUB:
				case TAN:
				case THEN:
				case TO:
				case UBOUND:
				case UCASE:
				case UNTIL:
				case VAL:
				case VERIFY:
				case WEND:
				case WHILE:
				case XOR:
				case HEXNUM:
				case BINNUM:
				case IDENTIFIER:
				case STRING:
				case LINE_END:
				case ErrorCharacter:
					{
					State = 32;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
					case 1:
						{
						State = 31; label();
						}
						break;
					}
					State = 34; line();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 39;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 40; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(ZxBasicParser.IDENTIFIER, 0); }
		public ITerminalNode COLON() { return GetToken(ZxBasicParser.COLON, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_label);
		try {
			State = 45;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case DECNUM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 42; Match(DECNUM);
				}
				break;
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 43; Match(IDENTIFIER);
				State = 44; Match(COLON);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext {
		public ITerminalNode LINE_END() { return GetToken(ZxBasicParser.LINE_END, 0); }
		public Line_itemContext[] line_item() {
			return GetRuleContexts<Line_itemContext>();
		}
		public Line_itemContext line_item(int i) {
			return GetRuleContext<Line_itemContext>(i);
		}
		public LineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LineContext line() {
		LineContext _localctx = new LineContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_line);
		int _la;
		try {
			int _alt;
			State = 59;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 50;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << DECNUM) | (1L << REALNUM) | (1L << BLOCK_COMMENT) | (1L << LINE_COMMENT) | (1L << NOTEQ) | (1L << ABS) | (1L << ACS) | (1L << AND) | (1L << ALIGN) | (1L << ASC) | (1L << ASN) | (1L << AT) | (1L << ATN) | (1L << ATTR) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR) | (1L << BEEP) | (1L << BOLD) | (1L << BORDER) | (1L << BRIGHT) | (1L << BYREF) | (1L << BYVAL) | (1L << CAST) | (1L << CHR) | (1L << CIRCLE) | (1L << CLS) | (1L << CODE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONST - 64)) | (1L << (CONTINUE - 64)) | (1L << (COS - 64)) | (1L << (CSRLIN - 64)) | (1L << (DECLARE - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DATA - 64)) | (1L << (DRAW - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (END - 64)) | (1L << (EXIT - 64)) | (1L << (EXP - 64)) | (1L << (FASTCALL - 64)) | (1L << (FLASH - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GETKEY - 64)) | (1L << (GETKEYSCANCODE - 64)) | (1L << (GOTO - 64)) | (1L << (GOSUB - 64)) | (1L << (HEX - 64)) | (1L << (HEX16 - 64)) | (1L << (IF - 64)) | (1L << (IN - 64)) | (1L << (INK - 64)) | (1L << (INKEY - 64)) | (1L << (INPUT - 64)) | (1L << (INT - 64)) | (1L << (INVERSE - 64)) | (1L << (ITALIC - 64)) | (1L << (LBOUND - 64)) | (1L << (LCASE - 64)) | (1L << (LET - 64)) | (1L << (LEN - 64)) | (1L << (LN - 64)) | (1L << (LOAD - 64)) | (1L << (LOOP - 64)) | (1L << (MOD - 64)) | (1L << (MULTIKEYS - 64)) | (1L << (NEXT - 64)) | (1L << (NOT - 64)) | (1L << (OR - 64)) | (1L << (OVER - 64)) | (1L << (OUT - 64)) | (1L << (PAPER - 64)) | (1L << (PAUSE - 64)) | (1L << (PEEK - 64)) | (1L << (PI - 64)) | (1L << (PLOT - 64)) | (1L << (POINT - 64)) | (1L << (POKE - 64)) | (1L << (POS - 64)) | (1L << (PRINT - 64)) | (1L << (PRINT42 - 64)) | (1L << (PRINTAT42 - 64)) | (1L << (PRINT64 - 64)) | (1L << (PRINTAT64 - 64)) | (1L << (RANDOMIZE - 64)) | (1L << (READ - 64)) | (1L << (REM - 64)) | (1L << (RESTORE - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (RETURN - 128)) | (1L << (RND - 128)) | (1L << (SAVE - 128)) | (1L << (SCREEN - 128)) | (1L << (SGN - 128)) | (1L << (SHL - 128)) | (1L << (SHR - 128)) | (1L << (SIN - 128)) | (1L << (SQR - 128)) | (1L << (STDCALL - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STR - 128)) | (1L << (SUB - 128)) | (1L << (TAN - 128)) | (1L << (THEN - 128)) | (1L << (TO - 128)) | (1L << (UBOUND - 128)) | (1L << (UCASE - 128)) | (1L << (UNTIL - 128)) | (1L << (VAL - 128)) | (1L << (VERIFY - 128)) | (1L << (WEND - 128)) | (1L << (WHILE - 128)) | (1L << (XOR - 128)) | (1L << (HEXNUM - 128)) | (1L << (BINNUM - 128)) | (1L << (IDENTIFIER - 128)) | (1L << (STRING - 128)) | (1L << (ErrorCharacter - 128)))) != 0)) {
					{
					{
					State = 47; line_item();
					}
					}
					State = 52;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 53; Match(LINE_END);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 55;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 54; line_item();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 57;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,5,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Line_itemContext : ParserRuleContext {
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		public OperatorContext @operator() {
			return GetRuleContext<OperatorContext>(0);
		}
		public SpecialContext special() {
			return GetRuleContext<SpecialContext>(0);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public ITerminalNode ErrorCharacter() { return GetToken(ZxBasicParser.ErrorCharacter, 0); }
		public Line_itemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line_item; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine_item(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine_item(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine_item(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Line_itemContext line_item() {
		Line_itemContext _localctx = new Line_itemContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_line_item);
		try {
			State = 70;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case AT:
			case BEEP:
			case BOLD:
			case BORDER:
			case BRIGHT:
			case BYREF:
			case BYVAL:
			case CIRCLE:
			case CLS:
			case CONST:
			case CONTINUE:
			case DECLARE:
			case DIM:
			case DO:
			case DATA:
			case DRAW:
			case ELSE:
			case ELSEIF:
			case END:
			case EXIT:
			case FASTCALL:
			case FLASH:
			case FOR:
			case FUNCTION:
			case GOTO:
			case GOSUB:
			case IF:
			case INK:
			case INVERSE:
			case ITALIC:
			case LET:
			case LOAD:
			case LOOP:
			case NEXT:
			case OVER:
			case OUT:
			case PAPER:
			case PAUSE:
			case PI:
			case PLOT:
			case POKE:
			case PRINT:
			case RANDOMIZE:
			case READ:
			case REM:
			case RESTORE:
			case RETURN:
			case SAVE:
			case STDCALL:
			case STEP:
			case STOP:
			case SUB:
			case THEN:
			case TO:
			case UNTIL:
			case VERIFY:
			case WEND:
			case WHILE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 61; keyword();
				}
				break;
			case ABS:
			case ACS:
			case ASC:
			case ASN:
			case ATN:
			case ATTR:
			case CAST:
			case CHR:
			case CODE:
			case COS:
			case CSRLIN:
			case EXP:
			case GETKEY:
			case GETKEYSCANCODE:
			case HEX:
			case HEX16:
			case IN:
			case INKEY:
			case INPUT:
			case INT:
			case LBOUND:
			case LCASE:
			case LEN:
			case LN:
			case MULTIKEYS:
			case PEEK:
			case POINT:
			case POS:
			case PRINT42:
			case PRINTAT42:
			case PRINT64:
			case PRINTAT64:
			case RND:
			case SCREEN:
			case SGN:
			case STR:
			case TAN:
			case UBOUND:
			case UCASE:
			case VAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 62; function();
				}
				break;
			case ASSIGN:
			case PLUS:
			case MINUS:
			case UPARR:
			case AMP:
			case LTOP:
			case LTEOP:
			case GTOP:
			case GTEOP:
			case LSHOP:
			case RSHOP:
			case MULOP:
			case DIVOP:
			case NOTEQ:
			case AND:
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case MOD:
			case NOT:
			case OR:
			case SHL:
			case SHR:
			case SIN:
			case SQR:
			case XOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 63; @operator();
				}
				break;
			case ALIGN:
				EnterOuterAlt(_localctx, 4);
				{
				State = 64; special();
				}
				break;
			case DECNUM:
			case REALNUM:
			case HEXNUM:
			case BINNUM:
				EnterOuterAlt(_localctx, 5);
				{
				State = 65; number();
				}
				break;
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 66; identifier();
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 7);
				{
				State = 67; @string();
				}
				break;
			case BLOCK_COMMENT:
			case LINE_COMMENT:
				EnterOuterAlt(_localctx, 8);
				{
				State = 68; comment();
				}
				break;
			case ErrorCharacter:
				EnterOuterAlt(_localctx, 9);
				{
				State = 69; Match(ErrorCharacter);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_sectionContext : ParserRuleContext {
		public ITerminalNode ASM_SECTION() { return GetToken(ZxBasicParser.ASM_SECTION, 0); }
		public Asm_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterAsm_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitAsm_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsm_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Asm_sectionContext asm_section() {
		Asm_sectionContext _localctx = new Asm_sectionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_asm_section);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 72; Match(ASM_SECTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(ZxBasicParser.AT, 0); }
		public ITerminalNode BEEP() { return GetToken(ZxBasicParser.BEEP, 0); }
		public ITerminalNode BOLD() { return GetToken(ZxBasicParser.BOLD, 0); }
		public ITerminalNode BORDER() { return GetToken(ZxBasicParser.BORDER, 0); }
		public ITerminalNode BRIGHT() { return GetToken(ZxBasicParser.BRIGHT, 0); }
		public ITerminalNode BYREF() { return GetToken(ZxBasicParser.BYREF, 0); }
		public ITerminalNode BYVAL() { return GetToken(ZxBasicParser.BYVAL, 0); }
		public ITerminalNode CIRCLE() { return GetToken(ZxBasicParser.CIRCLE, 0); }
		public ITerminalNode CLS() { return GetToken(ZxBasicParser.CLS, 0); }
		public ITerminalNode CONST() { return GetToken(ZxBasicParser.CONST, 0); }
		public ITerminalNode CONTINUE() { return GetToken(ZxBasicParser.CONTINUE, 0); }
		public ITerminalNode DECLARE() { return GetToken(ZxBasicParser.DECLARE, 0); }
		public ITerminalNode DIM() { return GetToken(ZxBasicParser.DIM, 0); }
		public ITerminalNode DO() { return GetToken(ZxBasicParser.DO, 0); }
		public ITerminalNode DATA() { return GetToken(ZxBasicParser.DATA, 0); }
		public ITerminalNode DRAW() { return GetToken(ZxBasicParser.DRAW, 0); }
		public ITerminalNode ELSE() { return GetToken(ZxBasicParser.ELSE, 0); }
		public ITerminalNode ELSEIF() { return GetToken(ZxBasicParser.ELSEIF, 0); }
		public ITerminalNode END() { return GetToken(ZxBasicParser.END, 0); }
		public ITerminalNode EXIT() { return GetToken(ZxBasicParser.EXIT, 0); }
		public ITerminalNode FASTCALL() { return GetToken(ZxBasicParser.FASTCALL, 0); }
		public ITerminalNode FLASH() { return GetToken(ZxBasicParser.FLASH, 0); }
		public ITerminalNode FOR() { return GetToken(ZxBasicParser.FOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(ZxBasicParser.FUNCTION, 0); }
		public ITerminalNode GOTO() { return GetToken(ZxBasicParser.GOTO, 0); }
		public ITerminalNode GOSUB() { return GetToken(ZxBasicParser.GOSUB, 0); }
		public ITerminalNode IF() { return GetToken(ZxBasicParser.IF, 0); }
		public ITerminalNode INK() { return GetToken(ZxBasicParser.INK, 0); }
		public ITerminalNode INVERSE() { return GetToken(ZxBasicParser.INVERSE, 0); }
		public ITerminalNode ITALIC() { return GetToken(ZxBasicParser.ITALIC, 0); }
		public ITerminalNode LET() { return GetToken(ZxBasicParser.LET, 0); }
		public ITerminalNode LOAD() { return GetToken(ZxBasicParser.LOAD, 0); }
		public ITerminalNode LOOP() { return GetToken(ZxBasicParser.LOOP, 0); }
		public ITerminalNode NEXT() { return GetToken(ZxBasicParser.NEXT, 0); }
		public ITerminalNode OVER() { return GetToken(ZxBasicParser.OVER, 0); }
		public ITerminalNode OUT() { return GetToken(ZxBasicParser.OUT, 0); }
		public ITerminalNode PAPER() { return GetToken(ZxBasicParser.PAPER, 0); }
		public ITerminalNode PAUSE() { return GetToken(ZxBasicParser.PAUSE, 0); }
		public ITerminalNode PI() { return GetToken(ZxBasicParser.PI, 0); }
		public ITerminalNode PLOT() { return GetToken(ZxBasicParser.PLOT, 0); }
		public ITerminalNode POKE() { return GetToken(ZxBasicParser.POKE, 0); }
		public ITerminalNode PRINT() { return GetToken(ZxBasicParser.PRINT, 0); }
		public ITerminalNode RANDOMIZE() { return GetToken(ZxBasicParser.RANDOMIZE, 0); }
		public ITerminalNode READ() { return GetToken(ZxBasicParser.READ, 0); }
		public ITerminalNode REM() { return GetToken(ZxBasicParser.REM, 0); }
		public ITerminalNode RESTORE() { return GetToken(ZxBasicParser.RESTORE, 0); }
		public ITerminalNode RETURN() { return GetToken(ZxBasicParser.RETURN, 0); }
		public ITerminalNode SAVE() { return GetToken(ZxBasicParser.SAVE, 0); }
		public ITerminalNode STDCALL() { return GetToken(ZxBasicParser.STDCALL, 0); }
		public ITerminalNode STEP() { return GetToken(ZxBasicParser.STEP, 0); }
		public ITerminalNode STOP() { return GetToken(ZxBasicParser.STOP, 0); }
		public ITerminalNode SUB() { return GetToken(ZxBasicParser.SUB, 0); }
		public ITerminalNode THEN() { return GetToken(ZxBasicParser.THEN, 0); }
		public ITerminalNode TO() { return GetToken(ZxBasicParser.TO, 0); }
		public ITerminalNode UNTIL() { return GetToken(ZxBasicParser.UNTIL, 0); }
		public ITerminalNode VERIFY() { return GetToken(ZxBasicParser.VERIFY, 0); }
		public ITerminalNode WEND() { return GetToken(ZxBasicParser.WEND, 0); }
		public ITerminalNode WHILE() { return GetToken(ZxBasicParser.WHILE, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 74;
			_la = _input.La(1);
			if ( !(((((_la - 46)) & ~0x3f) == 0 && ((1L << (_la - 46)) & ((1L << (AT - 46)) | (1L << (BEEP - 46)) | (1L << (BOLD - 46)) | (1L << (BORDER - 46)) | (1L << (BRIGHT - 46)) | (1L << (BYREF - 46)) | (1L << (BYVAL - 46)) | (1L << (CIRCLE - 46)) | (1L << (CLS - 46)) | (1L << (CONST - 46)) | (1L << (CONTINUE - 46)) | (1L << (DECLARE - 46)) | (1L << (DIM - 46)) | (1L << (DO - 46)) | (1L << (DATA - 46)) | (1L << (DRAW - 46)) | (1L << (ELSE - 46)) | (1L << (ELSEIF - 46)) | (1L << (END - 46)) | (1L << (EXIT - 46)) | (1L << (FASTCALL - 46)) | (1L << (FLASH - 46)) | (1L << (FOR - 46)) | (1L << (FUNCTION - 46)) | (1L << (GOTO - 46)) | (1L << (GOSUB - 46)) | (1L << (IF - 46)) | (1L << (INK - 46)) | (1L << (INVERSE - 46)) | (1L << (ITALIC - 46)) | (1L << (LET - 46)) | (1L << (LOAD - 46)) | (1L << (LOOP - 46)) | (1L << (NEXT - 46)) | (1L << (OVER - 46)))) != 0) || ((((_la - 110)) & ~0x3f) == 0 && ((1L << (_la - 110)) & ((1L << (OUT - 110)) | (1L << (PAPER - 110)) | (1L << (PAUSE - 110)) | (1L << (PI - 110)) | (1L << (PLOT - 110)) | (1L << (POKE - 110)) | (1L << (PRINT - 110)) | (1L << (RANDOMIZE - 110)) | (1L << (READ - 110)) | (1L << (REM - 110)) | (1L << (RESTORE - 110)) | (1L << (RETURN - 110)) | (1L << (SAVE - 110)) | (1L << (STDCALL - 110)) | (1L << (STEP - 110)) | (1L << (STOP - 110)) | (1L << (SUB - 110)) | (1L << (THEN - 110)) | (1L << (TO - 110)) | (1L << (UNTIL - 110)) | (1L << (VERIFY - 110)) | (1L << (WEND - 110)) | (1L << (WHILE - 110)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		public ITerminalNode ABS() { return GetToken(ZxBasicParser.ABS, 0); }
		public ITerminalNode ACS() { return GetToken(ZxBasicParser.ACS, 0); }
		public ITerminalNode ASC() { return GetToken(ZxBasicParser.ASC, 0); }
		public ITerminalNode ASN() { return GetToken(ZxBasicParser.ASN, 0); }
		public ITerminalNode ATN() { return GetToken(ZxBasicParser.ATN, 0); }
		public ITerminalNode ATTR() { return GetToken(ZxBasicParser.ATTR, 0); }
		public ITerminalNode CAST() { return GetToken(ZxBasicParser.CAST, 0); }
		public ITerminalNode CHR() { return GetToken(ZxBasicParser.CHR, 0); }
		public ITerminalNode CODE() { return GetToken(ZxBasicParser.CODE, 0); }
		public ITerminalNode COS() { return GetToken(ZxBasicParser.COS, 0); }
		public ITerminalNode CSRLIN() { return GetToken(ZxBasicParser.CSRLIN, 0); }
		public ITerminalNode EXP() { return GetToken(ZxBasicParser.EXP, 0); }
		public ITerminalNode GETKEY() { return GetToken(ZxBasicParser.GETKEY, 0); }
		public ITerminalNode GETKEYSCANCODE() { return GetToken(ZxBasicParser.GETKEYSCANCODE, 0); }
		public ITerminalNode HEX() { return GetToken(ZxBasicParser.HEX, 0); }
		public ITerminalNode HEX16() { return GetToken(ZxBasicParser.HEX16, 0); }
		public ITerminalNode IN() { return GetToken(ZxBasicParser.IN, 0); }
		public ITerminalNode INKEY() { return GetToken(ZxBasicParser.INKEY, 0); }
		public ITerminalNode INPUT() { return GetToken(ZxBasicParser.INPUT, 0); }
		public ITerminalNode INT() { return GetToken(ZxBasicParser.INT, 0); }
		public ITerminalNode LBOUND() { return GetToken(ZxBasicParser.LBOUND, 0); }
		public ITerminalNode LCASE() { return GetToken(ZxBasicParser.LCASE, 0); }
		public ITerminalNode LEN() { return GetToken(ZxBasicParser.LEN, 0); }
		public ITerminalNode LN() { return GetToken(ZxBasicParser.LN, 0); }
		public ITerminalNode MULTIKEYS() { return GetToken(ZxBasicParser.MULTIKEYS, 0); }
		public ITerminalNode PEEK() { return GetToken(ZxBasicParser.PEEK, 0); }
		public ITerminalNode POINT() { return GetToken(ZxBasicParser.POINT, 0); }
		public ITerminalNode POS() { return GetToken(ZxBasicParser.POS, 0); }
		public ITerminalNode PRINT42() { return GetToken(ZxBasicParser.PRINT42, 0); }
		public ITerminalNode PRINTAT42() { return GetToken(ZxBasicParser.PRINTAT42, 0); }
		public ITerminalNode PRINT64() { return GetToken(ZxBasicParser.PRINT64, 0); }
		public ITerminalNode PRINTAT64() { return GetToken(ZxBasicParser.PRINTAT64, 0); }
		public ITerminalNode RND() { return GetToken(ZxBasicParser.RND, 0); }
		public ITerminalNode SCREEN() { return GetToken(ZxBasicParser.SCREEN, 0); }
		public ITerminalNode SGN() { return GetToken(ZxBasicParser.SGN, 0); }
		public ITerminalNode STR() { return GetToken(ZxBasicParser.STR, 0); }
		public ITerminalNode TAN() { return GetToken(ZxBasicParser.TAN, 0); }
		public ITerminalNode UBOUND() { return GetToken(ZxBasicParser.UBOUND, 0); }
		public ITerminalNode UCASE() { return GetToken(ZxBasicParser.UCASE, 0); }
		public ITerminalNode VAL() { return GetToken(ZxBasicParser.VAL, 0); }
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_function);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76;
			_la = _input.La(1);
			if ( !(((((_la - 40)) & ~0x3f) == 0 && ((1L << (_la - 40)) & ((1L << (ABS - 40)) | (1L << (ACS - 40)) | (1L << (ASC - 40)) | (1L << (ASN - 40)) | (1L << (ATN - 40)) | (1L << (ATTR - 40)) | (1L << (CAST - 40)) | (1L << (CHR - 40)) | (1L << (CODE - 40)) | (1L << (COS - 40)) | (1L << (CSRLIN - 40)) | (1L << (EXP - 40)) | (1L << (GETKEY - 40)) | (1L << (GETKEYSCANCODE - 40)) | (1L << (HEX - 40)) | (1L << (HEX16 - 40)) | (1L << (IN - 40)) | (1L << (INKEY - 40)) | (1L << (INPUT - 40)) | (1L << (INT - 40)) | (1L << (LBOUND - 40)) | (1L << (LCASE - 40)) | (1L << (LEN - 40)) | (1L << (LN - 40)))) != 0) || ((((_la - 105)) & ~0x3f) == 0 && ((1L << (_la - 105)) & ((1L << (MULTIKEYS - 105)) | (1L << (PEEK - 105)) | (1L << (POINT - 105)) | (1L << (POS - 105)) | (1L << (PRINT42 - 105)) | (1L << (PRINTAT42 - 105)) | (1L << (PRINT64 - 105)) | (1L << (PRINTAT64 - 105)) | (1L << (RND - 105)) | (1L << (SCREEN - 105)) | (1L << (SGN - 105)) | (1L << (STR - 105)) | (1L << (TAN - 105)) | (1L << (UBOUND - 105)) | (1L << (UCASE - 105)) | (1L << (VAL - 105)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(ZxBasicParser.AND, 0); }
		public ITerminalNode BAND() { return GetToken(ZxBasicParser.BAND, 0); }
		public ITerminalNode BNOT() { return GetToken(ZxBasicParser.BNOT, 0); }
		public ITerminalNode BOR() { return GetToken(ZxBasicParser.BOR, 0); }
		public ITerminalNode BXOR() { return GetToken(ZxBasicParser.BXOR, 0); }
		public ITerminalNode MOD() { return GetToken(ZxBasicParser.MOD, 0); }
		public ITerminalNode NOT() { return GetToken(ZxBasicParser.NOT, 0); }
		public ITerminalNode OR() { return GetToken(ZxBasicParser.OR, 0); }
		public ITerminalNode SHL() { return GetToken(ZxBasicParser.SHL, 0); }
		public ITerminalNode SHR() { return GetToken(ZxBasicParser.SHR, 0); }
		public ITerminalNode SIN() { return GetToken(ZxBasicParser.SIN, 0); }
		public ITerminalNode SQR() { return GetToken(ZxBasicParser.SQR, 0); }
		public ITerminalNode XOR() { return GetToken(ZxBasicParser.XOR, 0); }
		public ITerminalNode ASSIGN() { return GetToken(ZxBasicParser.ASSIGN, 0); }
		public ITerminalNode PLUS() { return GetToken(ZxBasicParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(ZxBasicParser.MINUS, 0); }
		public ITerminalNode UPARR() { return GetToken(ZxBasicParser.UPARR, 0); }
		public ITerminalNode AMP() { return GetToken(ZxBasicParser.AMP, 0); }
		public ITerminalNode NOTEQ() { return GetToken(ZxBasicParser.NOTEQ, 0); }
		public ITerminalNode LTOP() { return GetToken(ZxBasicParser.LTOP, 0); }
		public ITerminalNode LTEOP() { return GetToken(ZxBasicParser.LTEOP, 0); }
		public ITerminalNode GTOP() { return GetToken(ZxBasicParser.GTOP, 0); }
		public ITerminalNode GTEOP() { return GetToken(ZxBasicParser.GTEOP, 0); }
		public ITerminalNode MULOP() { return GetToken(ZxBasicParser.MULOP, 0); }
		public ITerminalNode DIVOP() { return GetToken(ZxBasicParser.DIVOP, 0); }
		public ITerminalNode LSHOP() { return GetToken(ZxBasicParser.LSHOP, 0); }
		public ITerminalNode RSHOP() { return GetToken(ZxBasicParser.RSHOP, 0); }
		public OperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorContext @operator() {
		OperatorContext _localctx = new OperatorContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 78;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASSIGN) | (1L << PLUS) | (1L << MINUS) | (1L << UPARR) | (1L << AMP) | (1L << LTOP) | (1L << LTEOP) | (1L << GTOP) | (1L << GTEOP) | (1L << LSHOP) | (1L << RSHOP) | (1L << MULOP) | (1L << DIVOP) | (1L << NOTEQ) | (1L << AND) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR))) != 0) || ((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (MOD - 104)) | (1L << (NOT - 104)) | (1L << (OR - 104)) | (1L << (SHL - 104)) | (1L << (SHR - 104)) | (1L << (SIN - 104)) | (1L << (SQR - 104)) | (1L << (XOR - 104)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialContext : ParserRuleContext {
		public ITerminalNode ALIGN() { return GetToken(ZxBasicParser.ALIGN, 0); }
		public SpecialContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_special; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterSpecial(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitSpecial(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecial(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialContext special() {
		SpecialContext _localctx = new SpecialContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_special);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80; Match(ALIGN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode BINNUM() { return GetToken(ZxBasicParser.BINNUM, 0); }
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode HEXNUM() { return GetToken(ZxBasicParser.HEXNUM, 0); }
		public ITerminalNode REALNUM() { return GetToken(ZxBasicParser.REALNUM, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 82;
			_la = _input.La(1);
			if ( !(_la==DECNUM || _la==REALNUM || _la==HEXNUM || _la==BINNUM) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(ZxBasicParser.IDENTIFIER, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 84; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(ZxBasicParser.STRING, 0); }
		public StringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterString(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitString(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringContext @string() {
		StringContext _localctx = new StringContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 86; Match(STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentContext : ParserRuleContext {
		public Block_commentContext block_comment() {
			return GetRuleContext<Block_commentContext>(0);
		}
		public Line_commentContext line_comment() {
			return GetRuleContext<Line_commentContext>(0);
		}
		public CommentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentContext comment() {
		CommentContext _localctx = new CommentContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_comment);
		try {
			State = 90;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case BLOCK_COMMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 88; block_comment();
				}
				break;
			case LINE_COMMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 89; line_comment();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Block_commentContext : ParserRuleContext {
		public ITerminalNode BLOCK_COMMENT() { return GetToken(ZxBasicParser.BLOCK_COMMENT, 0); }
		public Block_commentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterBlock_comment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitBlock_comment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock_comment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Block_commentContext block_comment() {
		Block_commentContext _localctx = new Block_commentContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_block_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92; Match(BLOCK_COMMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Line_commentContext : ParserRuleContext {
		public ITerminalNode LINE_COMMENT() { return GetToken(ZxBasicParser.LINE_COMMENT, 0); }
		public Line_commentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterLine_comment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitLine_comment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine_comment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Line_commentContext line_comment() {
		Line_commentContext _localctx = new Line_commentContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_line_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 94; Match(LINE_COMMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xA2\x63\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x3\x2\x3\x2\x5\x2#\n\x2\x3\x2\a\x2&\n\x2\f\x2\xE\x2)\v\x2\x3\x2"+
		"\x3\x2\x3\x3\x3\x3\x3\x3\x5\x3\x30\n\x3\x3\x4\a\x4\x33\n\x4\f\x4\xE\x4"+
		"\x36\v\x4\x3\x4\x3\x4\x6\x4:\n\x4\r\x4\xE\x4;\x5\x4>\n\x4\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5I\n\x5\x3\x6\x3\x6\x3"+
		"\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3"+
		"\xE\x3\xE\x5\xE]\n\xE\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x2\x2\x2\x11\x2"+
		"\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2"+
		"\x1A\x2\x1C\x2\x1E\x2\x2\x6\x1A\x2\x30\x30\x37<?@\x42\x43\x46NPSWX[[]"+
		"]\x61\x62\x65\x65hillortuwwyy~\x82\x84\x84\x8B\x8D\x8F\x8F\x91\x92\x95"+
		"\x95\x97\x99\x1A\x2*+./\x31\x32=>\x41\x41\x44\x45OOTUYZ\\\\^`\x63\x64"+
		"\x66gkkssvvxxz}\x83\x83\x85\x86\x8E\x8E\x90\x90\x93\x94\x96\x96\r\x2\r"+
		"\r\x13\x14\x16\x17\x1C#)),,\x33\x36jjmn\x87\x8A\x9A\x9A\x4\x2%&\x9B\x9C"+
		"\x63\x2\'\x3\x2\x2\x2\x4/\x3\x2\x2\x2\x6=\x3\x2\x2\x2\bH\x3\x2\x2\x2\n"+
		"J\x3\x2\x2\x2\fL\x3\x2\x2\x2\xEN\x3\x2\x2\x2\x10P\x3\x2\x2\x2\x12R\x3"+
		"\x2\x2\x2\x14T\x3\x2\x2\x2\x16V\x3\x2\x2\x2\x18X\x3\x2\x2\x2\x1A\\\x3"+
		"\x2\x2\x2\x1C^\x3\x2\x2\x2\x1E`\x3\x2\x2\x2 &\x5\n\x6\x2!#\x5\x4\x3\x2"+
		"\"!\x3\x2\x2\x2\"#\x3\x2\x2\x2#$\x3\x2\x2\x2$&\x5\x6\x4\x2% \x3\x2\x2"+
		"\x2%\"\x3\x2\x2\x2&)\x3\x2\x2\x2\'%\x3\x2\x2\x2\'(\x3\x2\x2\x2(*\x3\x2"+
		"\x2\x2)\'\x3\x2\x2\x2*+\a\x2\x2\x3+\x3\x3\x2\x2\x2,\x30\a%\x2\x2-.\a\x9D"+
		"\x2\x2.\x30\a\x5\x2\x2/,\x3\x2\x2\x2/-\x3\x2\x2\x2\x30\x5\x3\x2\x2\x2"+
		"\x31\x33\x5\b\x5\x2\x32\x31\x3\x2\x2\x2\x33\x36\x3\x2\x2\x2\x34\x32\x3"+
		"\x2\x2\x2\x34\x35\x3\x2\x2\x2\x35\x37\x3\x2\x2\x2\x36\x34\x3\x2\x2\x2"+
		"\x37>\a\xA1\x2\x2\x38:\x5\b\x5\x2\x39\x38\x3\x2\x2\x2:;\x3\x2\x2\x2;\x39"+
		"\x3\x2\x2\x2;<\x3\x2\x2\x2<>\x3\x2\x2\x2=\x34\x3\x2\x2\x2=\x39\x3\x2\x2"+
		"\x2>\a\x3\x2\x2\x2?I\x5\f\a\x2@I\x5\xE\b\x2\x41I\x5\x10\t\x2\x42I\x5\x12"+
		"\n\x2\x43I\x5\x14\v\x2\x44I\x5\x16\f\x2\x45I\x5\x18\r\x2\x46I\x5\x1A\xE"+
		"\x2GI\a\xA2\x2\x2H?\x3\x2\x2\x2H@\x3\x2\x2\x2H\x41\x3\x2\x2\x2H\x42\x3"+
		"\x2\x2\x2H\x43\x3\x2\x2\x2H\x44\x3\x2\x2\x2H\x45\x3\x2\x2\x2H\x46\x3\x2"+
		"\x2\x2HG\x3\x2\x2\x2I\t\x3\x2\x2\x2JK\a\x4\x2\x2K\v\x3\x2\x2\x2LM\t\x2"+
		"\x2\x2M\r\x3\x2\x2\x2NO\t\x3\x2\x2O\xF\x3\x2\x2\x2PQ\t\x4\x2\x2Q\x11\x3"+
		"\x2\x2\x2RS\a-\x2\x2S\x13\x3\x2\x2\x2TU\t\x5\x2\x2U\x15\x3\x2\x2\x2VW"+
		"\a\x9D\x2\x2W\x17\x3\x2\x2\x2XY\a\xA0\x2\x2Y\x19\x3\x2\x2\x2Z]\x5\x1C"+
		"\xF\x2[]\x5\x1E\x10\x2\\Z\x3\x2\x2\x2\\[\x3\x2\x2\x2]\x1B\x3\x2\x2\x2"+
		"^_\a\'\x2\x2_\x1D\x3\x2\x2\x2`\x61\a(\x2\x2\x61\x1F\x3\x2\x2\x2\v\"%\'"+
		"/\x34;=H\\";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Spect.Net.BasicParser.Generated
