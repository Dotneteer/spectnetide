//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\dotne\source\repos\spectnetide\v2\Assembler\AntlrZxBasicParserGenerator\AntlrZxBasicParserGenerator\ZxBasic.g4 by ANTLR 4.6.4

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Spect.Net.BasicParser.Generated {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.4")]
[System.CLSCompliant(false)]
public partial class ZxBasicParser : Parser {
	public const int
		WS=1, NEWLINE=2, COLON=3, UNDERSCORE=4, ZXB_COMMENT=5, ZXB_BLOCK_COMMENT=6, 
		ZXB_LINE_COMMENT=7, ABS=8, ACS=9, AND=10, ALIGN=11, ASC=12, ASM=13, ASN=14, 
		AT=15, ATN=16, ATTR=17, BAND=18, BNOT=19, BOR=20, BXOR=21, BEEP=22, BOLD=23, 
		BORDER=24, BRIGHT=25, BYREF=26, BYVAL=27, CAST=28, CHR=29, CIRCLE=30, 
		CLS=31, CODE=32, CONST=33, CONTINUE=34, COS=35, CSRLIN=36, DECLARE=37, 
		DIM=38, DO=39, DATA=40, DRAW=41, ELSE=42, ELSEIF=43, END=44, EXIT=45, 
		EXP=46, FASTCALL=47, FLASH=48, FOR=49, FUNCTION=50, GETKEY=51, GETKEYSCANCODE=52, 
		GO=53, GOTO=54, GOSUB=55, HEX=56, HEX16=57, IF=58, IN=59, INK=60, INKEY=61, 
		INPUT=62, INT=63, INVERSE=64, ITALIC=65, LBOUND=66, LCASE=67, LET=68, 
		LEN=69, LN=70, LOAD=71, LOOP=72, MOD=73, MULTIKEYS=74, NEXT=75, NOT=76, 
		OR=77, OVER=78, OUT=79, PAPER=80, PAUSE=81, PEEK=82, PI=83, PLOT=84, POINT=85, 
		POKE=86, POS=87, PRINT=88, PRINT42=89, PRINTAT42=90, PRINT64=91, PRINTAT64=92, 
		RANDOMIZE=93, READ=94, REM=95, RESTORE=96, RETURN=97, RND=98, SAVE=99, 
		SCREEN=100, SGN=101, SHL=102, SHR=103, SIN=104, SQR=105, STDCALL=106, 
		STEP=107, STOP=108, STR=109, SUB=110, TAN=111, THEN=112, TO=113, UBOUND=114, 
		UCASE=115, UNTIL=116, VAL=117, VERIFY=118, WEND=119, WHILE=120, XOR=121, 
		DECNUM=122, REALNUM=123, ZXB_HEXNUM=124, ZXB_BINNUM=125, ZXB_IDENTIFIER=126, 
		ZXB_IDSTART=127, ZXB_IDCONT=128, ZXB_STRING=129, ZXB_LINE_END=130;
	public const int
		RULE_compileUnit = 0, RULE_zxb_label = 1, RULE_zxb_line = 2, RULE_zxb_line_item = 3, 
		RULE_zxb_asm_section = 4, RULE_zxb_keyword = 5, RULE_zxb_function = 6, 
		RULE_zxb_operator = 7, RULE_zxb_special = 8, RULE_zxb_number = 9, RULE_asm_section = 10, 
		RULE_asmline = 11;
	public static readonly string[] ruleNames = {
		"compileUnit", "zxb_label", "zxb_line", "zxb_line_item", "zxb_asm_section", 
		"zxb_keyword", "zxb_function", "zxb_operator", "zxb_special", "zxb_number", 
		"asm_section", "asmline"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "':'", "'_'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WS", "NEWLINE", "COLON", "UNDERSCORE", "ZXB_COMMENT", "ZXB_BLOCK_COMMENT", 
		"ZXB_LINE_COMMENT", "ABS", "ACS", "AND", "ALIGN", "ASC", "ASM", "ASN", 
		"AT", "ATN", "ATTR", "BAND", "BNOT", "BOR", "BXOR", "BEEP", "BOLD", "BORDER", 
		"BRIGHT", "BYREF", "BYVAL", "CAST", "CHR", "CIRCLE", "CLS", "CODE", "CONST", 
		"CONTINUE", "COS", "CSRLIN", "DECLARE", "DIM", "DO", "DATA", "DRAW", "ELSE", 
		"ELSEIF", "END", "EXIT", "EXP", "FASTCALL", "FLASH", "FOR", "FUNCTION", 
		"GETKEY", "GETKEYSCANCODE", "GO", "GOTO", "GOSUB", "HEX", "HEX16", "IF", 
		"IN", "INK", "INKEY", "INPUT", "INT", "INVERSE", "ITALIC", "LBOUND", "LCASE", 
		"LET", "LEN", "LN", "LOAD", "LOOP", "MOD", "MULTIKEYS", "NEXT", "NOT", 
		"OR", "OVER", "OUT", "PAPER", "PAUSE", "PEEK", "PI", "PLOT", "POINT", 
		"POKE", "POS", "PRINT", "PRINT42", "PRINTAT42", "PRINT64", "PRINTAT64", 
		"RANDOMIZE", "READ", "REM", "RESTORE", "RETURN", "RND", "SAVE", "SCREEN", 
		"SGN", "SHL", "SHR", "SIN", "SQR", "STDCALL", "STEP", "STOP", "STR", "SUB", 
		"TAN", "THEN", "TO", "UBOUND", "UCASE", "UNTIL", "VAL", "VERIFY", "WEND", 
		"WHILE", "XOR", "DECNUM", "REALNUM", "ZXB_HEXNUM", "ZXB_BINNUM", "ZXB_IDENTIFIER", 
		"ZXB_IDSTART", "ZXB_IDCONT", "ZXB_STRING", "ZXB_LINE_END"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ZxBasic.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public ZxBasicParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompileUnitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(ZxBasicParser.Eof, 0); }
		public Zxb_lineContext[] zxb_line() {
			return GetRuleContexts<Zxb_lineContext>();
		}
		public Zxb_lineContext zxb_line(int i) {
			return GetRuleContext<Zxb_lineContext>(i);
		}
		public Zxb_asm_sectionContext[] zxb_asm_section() {
			return GetRuleContexts<Zxb_asm_sectionContext>();
		}
		public Zxb_asm_sectionContext zxb_asm_section(int i) {
			return GetRuleContext<Zxb_asm_sectionContext>(i);
		}
		public Zxb_labelContext[] zxb_label() {
			return GetRuleContexts<Zxb_labelContext>();
		}
		public Zxb_labelContext zxb_label(int i) {
			return GetRuleContext<Zxb_labelContext>(i);
		}
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compileUnit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 31;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (((((_la - 5)) & ~0x3f) == 0 && ((1L << (_la - 5)) & ((1L << (ZXB_COMMENT - 5)) | (1L << (ABS - 5)) | (1L << (ACS - 5)) | (1L << (AND - 5)) | (1L << (ALIGN - 5)) | (1L << (ASC - 5)) | (1L << (ASM - 5)) | (1L << (ASN - 5)) | (1L << (AT - 5)) | (1L << (ATN - 5)) | (1L << (ATTR - 5)) | (1L << (BAND - 5)) | (1L << (BNOT - 5)) | (1L << (BOR - 5)) | (1L << (BXOR - 5)) | (1L << (BEEP - 5)) | (1L << (BOLD - 5)) | (1L << (BORDER - 5)) | (1L << (BRIGHT - 5)) | (1L << (BYREF - 5)) | (1L << (BYVAL - 5)) | (1L << (CAST - 5)) | (1L << (CHR - 5)) | (1L << (CIRCLE - 5)) | (1L << (CLS - 5)) | (1L << (CODE - 5)) | (1L << (CONST - 5)) | (1L << (CONTINUE - 5)) | (1L << (COS - 5)) | (1L << (CSRLIN - 5)) | (1L << (DECLARE - 5)) | (1L << (DIM - 5)) | (1L << (DO - 5)) | (1L << (DATA - 5)) | (1L << (DRAW - 5)) | (1L << (ELSE - 5)) | (1L << (ELSEIF - 5)) | (1L << (END - 5)) | (1L << (EXIT - 5)) | (1L << (EXP - 5)) | (1L << (FASTCALL - 5)) | (1L << (FLASH - 5)) | (1L << (FOR - 5)) | (1L << (FUNCTION - 5)) | (1L << (GETKEY - 5)) | (1L << (GETKEYSCANCODE - 5)) | (1L << (GOTO - 5)) | (1L << (GOSUB - 5)) | (1L << (HEX - 5)) | (1L << (HEX16 - 5)) | (1L << (IF - 5)) | (1L << (IN - 5)) | (1L << (INK - 5)) | (1L << (INKEY - 5)) | (1L << (INPUT - 5)) | (1L << (INT - 5)) | (1L << (INVERSE - 5)) | (1L << (ITALIC - 5)) | (1L << (LBOUND - 5)) | (1L << (LCASE - 5)) | (1L << (LET - 5)))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (LEN - 69)) | (1L << (LN - 69)) | (1L << (LOAD - 69)) | (1L << (LOOP - 69)) | (1L << (MOD - 69)) | (1L << (MULTIKEYS - 69)) | (1L << (NEXT - 69)) | (1L << (NOT - 69)) | (1L << (OR - 69)) | (1L << (OVER - 69)) | (1L << (OUT - 69)) | (1L << (PAPER - 69)) | (1L << (PAUSE - 69)) | (1L << (PEEK - 69)) | (1L << (PI - 69)) | (1L << (PLOT - 69)) | (1L << (POINT - 69)) | (1L << (POKE - 69)) | (1L << (POS - 69)) | (1L << (PRINT - 69)) | (1L << (PRINT42 - 69)) | (1L << (PRINTAT42 - 69)) | (1L << (PRINT64 - 69)) | (1L << (PRINTAT64 - 69)) | (1L << (RANDOMIZE - 69)) | (1L << (READ - 69)) | (1L << (REM - 69)) | (1L << (RESTORE - 69)) | (1L << (RETURN - 69)) | (1L << (RND - 69)) | (1L << (SAVE - 69)) | (1L << (SCREEN - 69)) | (1L << (SGN - 69)) | (1L << (SHL - 69)) | (1L << (SHR - 69)) | (1L << (SIN - 69)) | (1L << (SQR - 69)) | (1L << (STDCALL - 69)) | (1L << (STEP - 69)) | (1L << (STOP - 69)) | (1L << (STR - 69)) | (1L << (SUB - 69)) | (1L << (TAN - 69)) | (1L << (THEN - 69)) | (1L << (TO - 69)) | (1L << (UBOUND - 69)) | (1L << (UCASE - 69)) | (1L << (UNTIL - 69)) | (1L << (VAL - 69)) | (1L << (VERIFY - 69)) | (1L << (WEND - 69)) | (1L << (WHILE - 69)) | (1L << (XOR - 69)) | (1L << (DECNUM - 69)) | (1L << (REALNUM - 69)) | (1L << (ZXB_HEXNUM - 69)) | (1L << (ZXB_BINNUM - 69)) | (1L << (ZXB_IDENTIFIER - 69)) | (1L << (ZXB_STRING - 69)) | (1L << (ZXB_LINE_END - 69)))) != 0)) {
				{
				State = 29;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
				case 1:
					{
					State = 25;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
					case 1:
						{
						State = 24; zxb_label();
						}
						break;
					}
					State = 27; zxb_line();
					}
					break;

				case 2:
					{
					State = 28; zxb_asm_section();
					}
					break;
				}
				}
				State = 33;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 34; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_labelContext : ParserRuleContext {
		public ITerminalNode COLON() { return GetToken(ZxBasicParser.COLON, 0); }
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode ZXB_IDENTIFIER() { return GetToken(ZxBasicParser.ZXB_IDENTIFIER, 0); }
		public Zxb_labelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_label(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_label(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_label(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_labelContext zxb_label() {
		Zxb_labelContext _localctx = new Zxb_labelContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_zxb_label);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 36;
			_la = _input.La(1);
			if ( !(_la==DECNUM || _la==ZXB_IDENTIFIER) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			State = 37; Match(COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_lineContext : ParserRuleContext {
		public ITerminalNode ZXB_LINE_END() { return GetToken(ZxBasicParser.ZXB_LINE_END, 0); }
		public Zxb_line_itemContext[] zxb_line_item() {
			return GetRuleContexts<Zxb_line_itemContext>();
		}
		public Zxb_line_itemContext zxb_line_item(int i) {
			return GetRuleContext<Zxb_line_itemContext>(i);
		}
		public Zxb_lineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_line; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_line(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_line(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_line(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_lineContext zxb_line() {
		Zxb_lineContext _localctx = new Zxb_lineContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_zxb_line);
		int _la;
		try {
			int _alt;
			State = 51;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 42;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (((((_la - 5)) & ~0x3f) == 0 && ((1L << (_la - 5)) & ((1L << (ZXB_COMMENT - 5)) | (1L << (ABS - 5)) | (1L << (ACS - 5)) | (1L << (AND - 5)) | (1L << (ALIGN - 5)) | (1L << (ASC - 5)) | (1L << (ASM - 5)) | (1L << (ASN - 5)) | (1L << (AT - 5)) | (1L << (ATN - 5)) | (1L << (ATTR - 5)) | (1L << (BAND - 5)) | (1L << (BNOT - 5)) | (1L << (BOR - 5)) | (1L << (BXOR - 5)) | (1L << (BEEP - 5)) | (1L << (BOLD - 5)) | (1L << (BORDER - 5)) | (1L << (BRIGHT - 5)) | (1L << (BYREF - 5)) | (1L << (BYVAL - 5)) | (1L << (CAST - 5)) | (1L << (CHR - 5)) | (1L << (CIRCLE - 5)) | (1L << (CLS - 5)) | (1L << (CODE - 5)) | (1L << (CONST - 5)) | (1L << (CONTINUE - 5)) | (1L << (COS - 5)) | (1L << (CSRLIN - 5)) | (1L << (DECLARE - 5)) | (1L << (DIM - 5)) | (1L << (DO - 5)) | (1L << (DATA - 5)) | (1L << (DRAW - 5)) | (1L << (ELSE - 5)) | (1L << (ELSEIF - 5)) | (1L << (END - 5)) | (1L << (EXIT - 5)) | (1L << (EXP - 5)) | (1L << (FASTCALL - 5)) | (1L << (FLASH - 5)) | (1L << (FOR - 5)) | (1L << (FUNCTION - 5)) | (1L << (GETKEY - 5)) | (1L << (GETKEYSCANCODE - 5)) | (1L << (GOTO - 5)) | (1L << (GOSUB - 5)) | (1L << (HEX - 5)) | (1L << (HEX16 - 5)) | (1L << (IF - 5)) | (1L << (IN - 5)) | (1L << (INK - 5)) | (1L << (INKEY - 5)) | (1L << (INPUT - 5)) | (1L << (INT - 5)) | (1L << (INVERSE - 5)) | (1L << (ITALIC - 5)) | (1L << (LBOUND - 5)) | (1L << (LCASE - 5)) | (1L << (LET - 5)))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (LEN - 69)) | (1L << (LN - 69)) | (1L << (LOAD - 69)) | (1L << (LOOP - 69)) | (1L << (MOD - 69)) | (1L << (MULTIKEYS - 69)) | (1L << (NEXT - 69)) | (1L << (NOT - 69)) | (1L << (OR - 69)) | (1L << (OVER - 69)) | (1L << (OUT - 69)) | (1L << (PAPER - 69)) | (1L << (PAUSE - 69)) | (1L << (PEEK - 69)) | (1L << (PI - 69)) | (1L << (PLOT - 69)) | (1L << (POINT - 69)) | (1L << (POKE - 69)) | (1L << (POS - 69)) | (1L << (PRINT - 69)) | (1L << (PRINT42 - 69)) | (1L << (PRINTAT42 - 69)) | (1L << (PRINT64 - 69)) | (1L << (PRINTAT64 - 69)) | (1L << (RANDOMIZE - 69)) | (1L << (READ - 69)) | (1L << (REM - 69)) | (1L << (RESTORE - 69)) | (1L << (RETURN - 69)) | (1L << (RND - 69)) | (1L << (SAVE - 69)) | (1L << (SCREEN - 69)) | (1L << (SGN - 69)) | (1L << (SHL - 69)) | (1L << (SHR - 69)) | (1L << (SIN - 69)) | (1L << (SQR - 69)) | (1L << (STDCALL - 69)) | (1L << (STEP - 69)) | (1L << (STOP - 69)) | (1L << (STR - 69)) | (1L << (SUB - 69)) | (1L << (TAN - 69)) | (1L << (THEN - 69)) | (1L << (TO - 69)) | (1L << (UBOUND - 69)) | (1L << (UCASE - 69)) | (1L << (UNTIL - 69)) | (1L << (VAL - 69)) | (1L << (VERIFY - 69)) | (1L << (WEND - 69)) | (1L << (WHILE - 69)) | (1L << (XOR - 69)) | (1L << (DECNUM - 69)) | (1L << (REALNUM - 69)) | (1L << (ZXB_HEXNUM - 69)) | (1L << (ZXB_BINNUM - 69)) | (1L << (ZXB_IDENTIFIER - 69)) | (1L << (ZXB_STRING - 69)))) != 0)) {
					{
					{
					State = 39; zxb_line_item();
					}
					}
					State = 44;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 45; Match(ZXB_LINE_END);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 47;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 46; zxb_line_item();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 49;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,4,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_line_itemContext : ParserRuleContext {
		public Zxb_keywordContext zxb_keyword() {
			return GetRuleContext<Zxb_keywordContext>(0);
		}
		public Zxb_functionContext zxb_function() {
			return GetRuleContext<Zxb_functionContext>(0);
		}
		public Zxb_operatorContext zxb_operator() {
			return GetRuleContext<Zxb_operatorContext>(0);
		}
		public Zxb_specialContext zxb_special() {
			return GetRuleContext<Zxb_specialContext>(0);
		}
		public Zxb_numberContext zxb_number() {
			return GetRuleContext<Zxb_numberContext>(0);
		}
		public ITerminalNode ZXB_IDENTIFIER() { return GetToken(ZxBasicParser.ZXB_IDENTIFIER, 0); }
		public ITerminalNode ZXB_STRING() { return GetToken(ZxBasicParser.ZXB_STRING, 0); }
		public ITerminalNode ZXB_COMMENT() { return GetToken(ZxBasicParser.ZXB_COMMENT, 0); }
		public Zxb_line_itemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_line_item; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_line_item(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_line_item(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_line_item(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_line_itemContext zxb_line_item() {
		Zxb_line_itemContext _localctx = new Zxb_line_itemContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_zxb_line_item);
		try {
			State = 61;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case AT:
			case BEEP:
			case BOLD:
			case BORDER:
			case BRIGHT:
			case BYREF:
			case BYVAL:
			case CIRCLE:
			case CLS:
			case CONST:
			case CONTINUE:
			case DECLARE:
			case DIM:
			case DO:
			case DATA:
			case DRAW:
			case ELSE:
			case ELSEIF:
			case END:
			case EXIT:
			case FASTCALL:
			case FLASH:
			case FOR:
			case FUNCTION:
			case GOTO:
			case GOSUB:
			case IF:
			case INK:
			case INVERSE:
			case ITALIC:
			case LET:
			case LOAD:
			case LOOP:
			case NEXT:
			case OVER:
			case OUT:
			case PAPER:
			case PAUSE:
			case PI:
			case PLOT:
			case POKE:
			case PRINT:
			case RANDOMIZE:
			case READ:
			case REM:
			case RESTORE:
			case RETURN:
			case SAVE:
			case STDCALL:
			case STEP:
			case STOP:
			case SUB:
			case THEN:
			case TO:
			case UNTIL:
			case VERIFY:
			case WEND:
			case WHILE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 53; zxb_keyword();
				}
				break;
			case ABS:
			case ACS:
			case ASC:
			case ASN:
			case ATN:
			case ATTR:
			case CAST:
			case CHR:
			case CODE:
			case COS:
			case CSRLIN:
			case EXP:
			case GETKEY:
			case GETKEYSCANCODE:
			case HEX:
			case HEX16:
			case IN:
			case INKEY:
			case INPUT:
			case INT:
			case LBOUND:
			case LCASE:
			case LEN:
			case LN:
			case MULTIKEYS:
			case PEEK:
			case POINT:
			case POS:
			case PRINT42:
			case PRINTAT42:
			case PRINT64:
			case PRINTAT64:
			case RND:
			case SCREEN:
			case SGN:
			case STR:
			case TAN:
			case UBOUND:
			case UCASE:
			case VAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 54; zxb_function();
				}
				break;
			case AND:
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case MOD:
			case NOT:
			case OR:
			case SHL:
			case SHR:
			case SIN:
			case SQR:
			case XOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 55; zxb_operator();
				}
				break;
			case ALIGN:
			case ASM:
				EnterOuterAlt(_localctx, 4);
				{
				State = 56; zxb_special();
				}
				break;
			case DECNUM:
			case REALNUM:
			case ZXB_HEXNUM:
			case ZXB_BINNUM:
				EnterOuterAlt(_localctx, 5);
				{
				State = 57; zxb_number();
				}
				break;
			case ZXB_IDENTIFIER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 58; Match(ZXB_IDENTIFIER);
				}
				break;
			case ZXB_STRING:
				EnterOuterAlt(_localctx, 7);
				{
				State = 59; Match(ZXB_STRING);
				}
				break;
			case ZXB_COMMENT:
				EnterOuterAlt(_localctx, 8);
				{
				State = 60; Match(ZXB_COMMENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_asm_sectionContext : ParserRuleContext {
		public ITerminalNode[] ASM() { return GetTokens(ZxBasicParser.ASM); }
		public ITerminalNode ASM(int i) {
			return GetToken(ZxBasicParser.ASM, i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(ZxBasicParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(ZxBasicParser.NEWLINE, i);
		}
		public Asm_sectionContext asm_section() {
			return GetRuleContext<Asm_sectionContext>(0);
		}
		public ITerminalNode END() { return GetToken(ZxBasicParser.END, 0); }
		public Zxb_asm_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_asm_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_asm_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_asm_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_asm_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_asm_sectionContext zxb_asm_section() {
		Zxb_asm_sectionContext _localctx = new Zxb_asm_sectionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_zxb_asm_section);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 63; Match(ASM);
			State = 64; Match(NEWLINE);
			State = 65; asm_section();
			State = 67;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 66; Match(NEWLINE);
				}
				}
				State = 69;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==NEWLINE );
			State = 71; Match(ASM);
			State = 72; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_keywordContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(ZxBasicParser.AT, 0); }
		public ITerminalNode BEEP() { return GetToken(ZxBasicParser.BEEP, 0); }
		public ITerminalNode BOLD() { return GetToken(ZxBasicParser.BOLD, 0); }
		public ITerminalNode BORDER() { return GetToken(ZxBasicParser.BORDER, 0); }
		public ITerminalNode BRIGHT() { return GetToken(ZxBasicParser.BRIGHT, 0); }
		public ITerminalNode BYREF() { return GetToken(ZxBasicParser.BYREF, 0); }
		public ITerminalNode BYVAL() { return GetToken(ZxBasicParser.BYVAL, 0); }
		public ITerminalNode CIRCLE() { return GetToken(ZxBasicParser.CIRCLE, 0); }
		public ITerminalNode CLS() { return GetToken(ZxBasicParser.CLS, 0); }
		public ITerminalNode CONST() { return GetToken(ZxBasicParser.CONST, 0); }
		public ITerminalNode CONTINUE() { return GetToken(ZxBasicParser.CONTINUE, 0); }
		public ITerminalNode DECLARE() { return GetToken(ZxBasicParser.DECLARE, 0); }
		public ITerminalNode DIM() { return GetToken(ZxBasicParser.DIM, 0); }
		public ITerminalNode DO() { return GetToken(ZxBasicParser.DO, 0); }
		public ITerminalNode DATA() { return GetToken(ZxBasicParser.DATA, 0); }
		public ITerminalNode DRAW() { return GetToken(ZxBasicParser.DRAW, 0); }
		public ITerminalNode ELSE() { return GetToken(ZxBasicParser.ELSE, 0); }
		public ITerminalNode ELSEIF() { return GetToken(ZxBasicParser.ELSEIF, 0); }
		public ITerminalNode END() { return GetToken(ZxBasicParser.END, 0); }
		public ITerminalNode EXIT() { return GetToken(ZxBasicParser.EXIT, 0); }
		public ITerminalNode FASTCALL() { return GetToken(ZxBasicParser.FASTCALL, 0); }
		public ITerminalNode FLASH() { return GetToken(ZxBasicParser.FLASH, 0); }
		public ITerminalNode FOR() { return GetToken(ZxBasicParser.FOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(ZxBasicParser.FUNCTION, 0); }
		public ITerminalNode GOTO() { return GetToken(ZxBasicParser.GOTO, 0); }
		public ITerminalNode GOSUB() { return GetToken(ZxBasicParser.GOSUB, 0); }
		public ITerminalNode IF() { return GetToken(ZxBasicParser.IF, 0); }
		public ITerminalNode INK() { return GetToken(ZxBasicParser.INK, 0); }
		public ITerminalNode INVERSE() { return GetToken(ZxBasicParser.INVERSE, 0); }
		public ITerminalNode ITALIC() { return GetToken(ZxBasicParser.ITALIC, 0); }
		public ITerminalNode LET() { return GetToken(ZxBasicParser.LET, 0); }
		public ITerminalNode LOAD() { return GetToken(ZxBasicParser.LOAD, 0); }
		public ITerminalNode LOOP() { return GetToken(ZxBasicParser.LOOP, 0); }
		public ITerminalNode NEXT() { return GetToken(ZxBasicParser.NEXT, 0); }
		public ITerminalNode OVER() { return GetToken(ZxBasicParser.OVER, 0); }
		public ITerminalNode OUT() { return GetToken(ZxBasicParser.OUT, 0); }
		public ITerminalNode PAPER() { return GetToken(ZxBasicParser.PAPER, 0); }
		public ITerminalNode PAUSE() { return GetToken(ZxBasicParser.PAUSE, 0); }
		public ITerminalNode PI() { return GetToken(ZxBasicParser.PI, 0); }
		public ITerminalNode PLOT() { return GetToken(ZxBasicParser.PLOT, 0); }
		public ITerminalNode POKE() { return GetToken(ZxBasicParser.POKE, 0); }
		public ITerminalNode PRINT() { return GetToken(ZxBasicParser.PRINT, 0); }
		public ITerminalNode RANDOMIZE() { return GetToken(ZxBasicParser.RANDOMIZE, 0); }
		public ITerminalNode READ() { return GetToken(ZxBasicParser.READ, 0); }
		public ITerminalNode REM() { return GetToken(ZxBasicParser.REM, 0); }
		public ITerminalNode RESTORE() { return GetToken(ZxBasicParser.RESTORE, 0); }
		public ITerminalNode RETURN() { return GetToken(ZxBasicParser.RETURN, 0); }
		public ITerminalNode SAVE() { return GetToken(ZxBasicParser.SAVE, 0); }
		public ITerminalNode STDCALL() { return GetToken(ZxBasicParser.STDCALL, 0); }
		public ITerminalNode STEP() { return GetToken(ZxBasicParser.STEP, 0); }
		public ITerminalNode STOP() { return GetToken(ZxBasicParser.STOP, 0); }
		public ITerminalNode SUB() { return GetToken(ZxBasicParser.SUB, 0); }
		public ITerminalNode THEN() { return GetToken(ZxBasicParser.THEN, 0); }
		public ITerminalNode TO() { return GetToken(ZxBasicParser.TO, 0); }
		public ITerminalNode UNTIL() { return GetToken(ZxBasicParser.UNTIL, 0); }
		public ITerminalNode VERIFY() { return GetToken(ZxBasicParser.VERIFY, 0); }
		public ITerminalNode WEND() { return GetToken(ZxBasicParser.WEND, 0); }
		public ITerminalNode WHILE() { return GetToken(ZxBasicParser.WHILE, 0); }
		public Zxb_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_keywordContext zxb_keyword() {
		Zxb_keywordContext _localctx = new Zxb_keywordContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_zxb_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 74;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AT) | (1L << BEEP) | (1L << BOLD) | (1L << BORDER) | (1L << BRIGHT) | (1L << BYREF) | (1L << BYVAL) | (1L << CIRCLE) | (1L << CLS) | (1L << CONST) | (1L << CONTINUE) | (1L << DECLARE) | (1L << DIM) | (1L << DO) | (1L << DATA) | (1L << DRAW) | (1L << ELSE) | (1L << ELSEIF) | (1L << END) | (1L << EXIT) | (1L << FASTCALL) | (1L << FLASH) | (1L << FOR) | (1L << FUNCTION) | (1L << GOTO) | (1L << GOSUB) | (1L << IF) | (1L << INK))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (INVERSE - 64)) | (1L << (ITALIC - 64)) | (1L << (LET - 64)) | (1L << (LOAD - 64)) | (1L << (LOOP - 64)) | (1L << (NEXT - 64)) | (1L << (OVER - 64)) | (1L << (OUT - 64)) | (1L << (PAPER - 64)) | (1L << (PAUSE - 64)) | (1L << (PI - 64)) | (1L << (PLOT - 64)) | (1L << (POKE - 64)) | (1L << (PRINT - 64)) | (1L << (RANDOMIZE - 64)) | (1L << (READ - 64)) | (1L << (REM - 64)) | (1L << (RESTORE - 64)) | (1L << (RETURN - 64)) | (1L << (SAVE - 64)) | (1L << (STDCALL - 64)) | (1L << (STEP - 64)) | (1L << (STOP - 64)) | (1L << (SUB - 64)) | (1L << (THEN - 64)) | (1L << (TO - 64)) | (1L << (UNTIL - 64)) | (1L << (VERIFY - 64)) | (1L << (WEND - 64)) | (1L << (WHILE - 64)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_functionContext : ParserRuleContext {
		public ITerminalNode ABS() { return GetToken(ZxBasicParser.ABS, 0); }
		public ITerminalNode ACS() { return GetToken(ZxBasicParser.ACS, 0); }
		public ITerminalNode ASC() { return GetToken(ZxBasicParser.ASC, 0); }
		public ITerminalNode ASN() { return GetToken(ZxBasicParser.ASN, 0); }
		public ITerminalNode ATN() { return GetToken(ZxBasicParser.ATN, 0); }
		public ITerminalNode ATTR() { return GetToken(ZxBasicParser.ATTR, 0); }
		public ITerminalNode CAST() { return GetToken(ZxBasicParser.CAST, 0); }
		public ITerminalNode CHR() { return GetToken(ZxBasicParser.CHR, 0); }
		public ITerminalNode CODE() { return GetToken(ZxBasicParser.CODE, 0); }
		public ITerminalNode COS() { return GetToken(ZxBasicParser.COS, 0); }
		public ITerminalNode CSRLIN() { return GetToken(ZxBasicParser.CSRLIN, 0); }
		public ITerminalNode EXP() { return GetToken(ZxBasicParser.EXP, 0); }
		public ITerminalNode GETKEY() { return GetToken(ZxBasicParser.GETKEY, 0); }
		public ITerminalNode GETKEYSCANCODE() { return GetToken(ZxBasicParser.GETKEYSCANCODE, 0); }
		public ITerminalNode HEX() { return GetToken(ZxBasicParser.HEX, 0); }
		public ITerminalNode HEX16() { return GetToken(ZxBasicParser.HEX16, 0); }
		public ITerminalNode IN() { return GetToken(ZxBasicParser.IN, 0); }
		public ITerminalNode INKEY() { return GetToken(ZxBasicParser.INKEY, 0); }
		public ITerminalNode INPUT() { return GetToken(ZxBasicParser.INPUT, 0); }
		public ITerminalNode INT() { return GetToken(ZxBasicParser.INT, 0); }
		public ITerminalNode LBOUND() { return GetToken(ZxBasicParser.LBOUND, 0); }
		public ITerminalNode LCASE() { return GetToken(ZxBasicParser.LCASE, 0); }
		public ITerminalNode LEN() { return GetToken(ZxBasicParser.LEN, 0); }
		public ITerminalNode LN() { return GetToken(ZxBasicParser.LN, 0); }
		public ITerminalNode MULTIKEYS() { return GetToken(ZxBasicParser.MULTIKEYS, 0); }
		public ITerminalNode PEEK() { return GetToken(ZxBasicParser.PEEK, 0); }
		public ITerminalNode POINT() { return GetToken(ZxBasicParser.POINT, 0); }
		public ITerminalNode POS() { return GetToken(ZxBasicParser.POS, 0); }
		public ITerminalNode PRINT42() { return GetToken(ZxBasicParser.PRINT42, 0); }
		public ITerminalNode PRINTAT42() { return GetToken(ZxBasicParser.PRINTAT42, 0); }
		public ITerminalNode PRINT64() { return GetToken(ZxBasicParser.PRINT64, 0); }
		public ITerminalNode PRINTAT64() { return GetToken(ZxBasicParser.PRINTAT64, 0); }
		public ITerminalNode RND() { return GetToken(ZxBasicParser.RND, 0); }
		public ITerminalNode SCREEN() { return GetToken(ZxBasicParser.SCREEN, 0); }
		public ITerminalNode SGN() { return GetToken(ZxBasicParser.SGN, 0); }
		public ITerminalNode STR() { return GetToken(ZxBasicParser.STR, 0); }
		public ITerminalNode TAN() { return GetToken(ZxBasicParser.TAN, 0); }
		public ITerminalNode UBOUND() { return GetToken(ZxBasicParser.UBOUND, 0); }
		public ITerminalNode UCASE() { return GetToken(ZxBasicParser.UCASE, 0); }
		public ITerminalNode VAL() { return GetToken(ZxBasicParser.VAL, 0); }
		public Zxb_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_functionContext zxb_function() {
		Zxb_functionContext _localctx = new Zxb_functionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_zxb_function);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ACS) | (1L << ASC) | (1L << ASN) | (1L << ATN) | (1L << ATTR) | (1L << CAST) | (1L << CHR) | (1L << CODE) | (1L << COS) | (1L << CSRLIN) | (1L << EXP) | (1L << GETKEY) | (1L << GETKEYSCANCODE) | (1L << HEX) | (1L << HEX16) | (1L << IN) | (1L << INKEY) | (1L << INPUT) | (1L << INT))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (LBOUND - 66)) | (1L << (LCASE - 66)) | (1L << (LEN - 66)) | (1L << (LN - 66)) | (1L << (MULTIKEYS - 66)) | (1L << (PEEK - 66)) | (1L << (POINT - 66)) | (1L << (POS - 66)) | (1L << (PRINT42 - 66)) | (1L << (PRINTAT42 - 66)) | (1L << (PRINT64 - 66)) | (1L << (PRINTAT64 - 66)) | (1L << (RND - 66)) | (1L << (SCREEN - 66)) | (1L << (SGN - 66)) | (1L << (STR - 66)) | (1L << (TAN - 66)) | (1L << (UBOUND - 66)) | (1L << (UCASE - 66)) | (1L << (VAL - 66)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_operatorContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(ZxBasicParser.AND, 0); }
		public ITerminalNode BAND() { return GetToken(ZxBasicParser.BAND, 0); }
		public ITerminalNode BNOT() { return GetToken(ZxBasicParser.BNOT, 0); }
		public ITerminalNode BOR() { return GetToken(ZxBasicParser.BOR, 0); }
		public ITerminalNode BXOR() { return GetToken(ZxBasicParser.BXOR, 0); }
		public ITerminalNode MOD() { return GetToken(ZxBasicParser.MOD, 0); }
		public ITerminalNode NOT() { return GetToken(ZxBasicParser.NOT, 0); }
		public ITerminalNode OR() { return GetToken(ZxBasicParser.OR, 0); }
		public ITerminalNode SHL() { return GetToken(ZxBasicParser.SHL, 0); }
		public ITerminalNode SHR() { return GetToken(ZxBasicParser.SHR, 0); }
		public ITerminalNode SIN() { return GetToken(ZxBasicParser.SIN, 0); }
		public ITerminalNode SQR() { return GetToken(ZxBasicParser.SQR, 0); }
		public ITerminalNode XOR() { return GetToken(ZxBasicParser.XOR, 0); }
		public Zxb_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_operator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_operator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_operatorContext zxb_operator() {
		Zxb_operatorContext _localctx = new Zxb_operatorContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_zxb_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 78;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AND) | (1L << BAND) | (1L << BNOT) | (1L << BOR) | (1L << BXOR))) != 0) || ((((_la - 73)) & ~0x3f) == 0 && ((1L << (_la - 73)) & ((1L << (MOD - 73)) | (1L << (NOT - 73)) | (1L << (OR - 73)) | (1L << (SHL - 73)) | (1L << (SHR - 73)) | (1L << (SIN - 73)) | (1L << (SQR - 73)) | (1L << (XOR - 73)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_specialContext : ParserRuleContext {
		public ITerminalNode ALIGN() { return GetToken(ZxBasicParser.ALIGN, 0); }
		public ITerminalNode ASM() { return GetToken(ZxBasicParser.ASM, 0); }
		public Zxb_specialContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_special; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_special(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_special(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_special(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_specialContext zxb_special() {
		Zxb_specialContext _localctx = new Zxb_specialContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_zxb_special);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			_la = _input.La(1);
			if ( !(_la==ALIGN || _la==ASM) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zxb_numberContext : ParserRuleContext {
		public ITerminalNode ZXB_BINNUM() { return GetToken(ZxBasicParser.ZXB_BINNUM, 0); }
		public ITerminalNode DECNUM() { return GetToken(ZxBasicParser.DECNUM, 0); }
		public ITerminalNode ZXB_HEXNUM() { return GetToken(ZxBasicParser.ZXB_HEXNUM, 0); }
		public ITerminalNode REALNUM() { return GetToken(ZxBasicParser.REALNUM, 0); }
		public Zxb_numberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zxb_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterZxb_number(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitZxb_number(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZxb_number(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zxb_numberContext zxb_number() {
		Zxb_numberContext _localctx = new Zxb_numberContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_zxb_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 82;
			_la = _input.La(1);
			if ( !(((((_la - 122)) & ~0x3f) == 0 && ((1L << (_la - 122)) & ((1L << (DECNUM - 122)) | (1L << (REALNUM - 122)) | (1L << (ZXB_HEXNUM - 122)) | (1L << (ZXB_BINNUM - 122)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_sectionContext : ParserRuleContext {
		public AsmlineContext[] asmline() {
			return GetRuleContexts<AsmlineContext>();
		}
		public AsmlineContext asmline(int i) {
			return GetRuleContext<AsmlineContext>(i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(ZxBasicParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(ZxBasicParser.NEWLINE, i);
		}
		public Asm_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterAsm_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitAsm_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsm_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Asm_sectionContext asm_section() {
		Asm_sectionContext _localctx = new Asm_sectionContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_asm_section);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 87;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==NEWLINE) {
				{
				{
				State = 84; Match(NEWLINE);
				}
				}
				State = 89;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 90; asmline();
			State = 99;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 92;
					_errHandler.Sync(this);
					_la = _input.La(1);
					do {
						{
						{
						State = 91; Match(NEWLINE);
						}
						}
						State = 94;
						_errHandler.Sync(this);
						_la = _input.La(1);
					} while ( _la==NEWLINE );
					State = 96; asmline();
					}
					} 
				}
				State = 101;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsmlineContext : ParserRuleContext {
		public ITerminalNode[] DECNUM() { return GetTokens(ZxBasicParser.DECNUM); }
		public ITerminalNode DECNUM(int i) {
			return GetToken(ZxBasicParser.DECNUM, i);
		}
		public AsmlineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asmline; } }
		public override void EnterRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.EnterAsmline(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IZxBasicListener typedListener = listener as IZxBasicListener;
			if (typedListener != null) typedListener.ExitAsmline(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IZxBasicVisitor<TResult> typedVisitor = visitor as IZxBasicVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsmline(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AsmlineContext asmline() {
		AsmlineContext _localctx = new AsmlineContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_asmline);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 103;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 102; Match(DECNUM);
				}
				}
				State = 105;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==DECNUM );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x84n\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x3\x2\x5\x2\x1C\n\x2\x3\x2\x3\x2"+
		"\a\x2 \n\x2\f\x2\xE\x2#\v\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x4\a\x4"+
		"+\n\x4\f\x4\xE\x4.\v\x4\x3\x4\x3\x4\x6\x4\x32\n\x4\r\x4\xE\x4\x33\x5\x4"+
		"\x36\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5@\n\x5"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x6\x6\x46\n\x6\r\x6\xE\x6G\x3\x6\x3\x6\x3\x6"+
		"\x3\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\v\x3\v\x3\f\a\fX\n\f\f\f\xE"+
		"\f[\v\f\x3\f\x3\f\x6\f_\n\f\r\f\xE\f`\x3\f\a\f\x64\n\f\f\f\xE\fg\v\f\x3"+
		"\r\x6\rj\n\r\r\r\xE\rk\x3\r\x2\x2\x2\xE\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f"+
		"\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x2\b\x4\x2||\x80\x80\x1A"+
		"\x2\x11\x11\x18\x1D !#$\'/\x31\x34\x38\x39<<>>\x42\x43\x46\x46IJMMPSU"+
		"VXXZZ_\x63\x65\x65lnpprsvvxz\x1B\x2\n\v\xE\xE\x10\x10\x12\x13\x1E\x1F"+
		"\"\"%&\x30\x30\x35\x36:;==?\x41\x44\x45GHLLTTWWYY[^\x64\x64\x66gooqqt"+
		"uww\b\x2\f\f\x14\x17KKNOhk{{\x4\x2\r\r\xF\xF\x3\x2|\x7Fs\x2!\x3\x2\x2"+
		"\x2\x4&\x3\x2\x2\x2\x6\x35\x3\x2\x2\x2\b?\x3\x2\x2\x2\n\x41\x3\x2\x2\x2"+
		"\fL\x3\x2\x2\x2\xEN\x3\x2\x2\x2\x10P\x3\x2\x2\x2\x12R\x3\x2\x2\x2\x14"+
		"T\x3\x2\x2\x2\x16Y\x3\x2\x2\x2\x18i\x3\x2\x2\x2\x1A\x1C\x5\x4\x3\x2\x1B"+
		"\x1A\x3\x2\x2\x2\x1B\x1C\x3\x2\x2\x2\x1C\x1D\x3\x2\x2\x2\x1D \x5\x6\x4"+
		"\x2\x1E \x5\n\x6\x2\x1F\x1B\x3\x2\x2\x2\x1F\x1E\x3\x2\x2\x2 #\x3\x2\x2"+
		"\x2!\x1F\x3\x2\x2\x2!\"\x3\x2\x2\x2\"$\x3\x2\x2\x2#!\x3\x2\x2\x2$%\a\x2"+
		"\x2\x3%\x3\x3\x2\x2\x2&\'\t\x2\x2\x2\'(\a\x5\x2\x2(\x5\x3\x2\x2\x2)+\x5"+
		"\b\x5\x2*)\x3\x2\x2\x2+.\x3\x2\x2\x2,*\x3\x2\x2\x2,-\x3\x2\x2\x2-/\x3"+
		"\x2\x2\x2.,\x3\x2\x2\x2/\x36\a\x84\x2\x2\x30\x32\x5\b\x5\x2\x31\x30\x3"+
		"\x2\x2\x2\x32\x33\x3\x2\x2\x2\x33\x31\x3\x2\x2\x2\x33\x34\x3\x2\x2\x2"+
		"\x34\x36\x3\x2\x2\x2\x35,\x3\x2\x2\x2\x35\x31\x3\x2\x2\x2\x36\a\x3\x2"+
		"\x2\x2\x37@\x5\f\a\x2\x38@\x5\xE\b\x2\x39@\x5\x10\t\x2:@\x5\x12\n\x2;"+
		"@\x5\x14\v\x2<@\a\x80\x2\x2=@\a\x83\x2\x2>@\a\a\x2\x2?\x37\x3\x2\x2\x2"+
		"?\x38\x3\x2\x2\x2?\x39\x3\x2\x2\x2?:\x3\x2\x2\x2?;\x3\x2\x2\x2?<\x3\x2"+
		"\x2\x2?=\x3\x2\x2\x2?>\x3\x2\x2\x2@\t\x3\x2\x2\x2\x41\x42\a\xF\x2\x2\x42"+
		"\x43\a\x4\x2\x2\x43\x45\x5\x16\f\x2\x44\x46\a\x4\x2\x2\x45\x44\x3\x2\x2"+
		"\x2\x46G\x3\x2\x2\x2G\x45\x3\x2\x2\x2GH\x3\x2\x2\x2HI\x3\x2\x2\x2IJ\a"+
		"\xF\x2\x2JK\a.\x2\x2K\v\x3\x2\x2\x2LM\t\x3\x2\x2M\r\x3\x2\x2\x2NO\t\x4"+
		"\x2\x2O\xF\x3\x2\x2\x2PQ\t\x5\x2\x2Q\x11\x3\x2\x2\x2RS\t\x6\x2\x2S\x13"+
		"\x3\x2\x2\x2TU\t\a\x2\x2U\x15\x3\x2\x2\x2VX\a\x4\x2\x2WV\x3\x2\x2\x2X"+
		"[\x3\x2\x2\x2YW\x3\x2\x2\x2YZ\x3\x2\x2\x2Z\\\x3\x2\x2\x2[Y\x3\x2\x2\x2"+
		"\\\x65\x5\x18\r\x2]_\a\x4\x2\x2^]\x3\x2\x2\x2_`\x3\x2\x2\x2`^\x3\x2\x2"+
		"\x2`\x61\x3\x2\x2\x2\x61\x62\x3\x2\x2\x2\x62\x64\x5\x18\r\x2\x63^\x3\x2"+
		"\x2\x2\x64g\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x65\x66\x3\x2\x2\x2\x66\x17"+
		"\x3\x2\x2\x2g\x65\x3\x2\x2\x2hj\a|\x2\x2ih\x3\x2\x2\x2jk\x3\x2\x2\x2k"+
		"i\x3\x2\x2\x2kl\x3\x2\x2\x2l\x19\x3\x2\x2\x2\xE\x1B\x1F!,\x33\x35?GY`"+
		"\x65k";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Spect.Net.BasicParser.Generated
